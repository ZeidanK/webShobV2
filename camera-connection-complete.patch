diff --git a/.gitignore b/.gitignore
index 72ed6e9..3a52a3f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,314 +1,315 @@
-# Event Monitoring MVP - Git Ignore File
-# This file tells Git which files and folders to ignore (not track in version control)
-
-# =============================================================================
-# NODE.JS & NPM DEPENDENCIES
-# =============================================================================
-# Node.js modules are downloaded from npm - we don't need to store them in Git
-# They can be reinstalled using "npm install"
-node_modules/
-npm-debug.log*
-yarn-debug.log*
-yarn-error.log*
-lerna-debug.log*
-
-# Package lock files (only commit one type)
-# We use npm, so we ignore yarn.lock
-yarn.lock
-package-lock.json
-
-# =============================================================================
-# ENVIRONMENT VARIABLES & SECRETS
-# =============================================================================
-# These files contain sensitive information like API keys and passwords
-# NEVER commit these to version control for security reasons
-.env
-.env.local
-.env.development.local
-.env.test.local
-.env.production.local
-.env.staging
-
-# Configuration files with secrets
-config/secrets.json
-config/local.json
-.secrets/
-
-# =============================================================================
-# BUILD OUTPUT & COMPILED FILES
-# =============================================================================
-# These are generated automatically and shouldn't be in version control
-# Frontend build output
-frontend/build/
-frontend/dist/
-
-# Backend compiled TypeScript
-backend/dist/
-backend/build/
-
-# Coverage reports from testing
-coverage/
-*.lcov
-.nyc_output
-
-# =============================================================================
-# DATABASE FILES
-# =============================================================================
-# Local database files - production databases are separate
-*.db
-*.sqlite
-*.sqlite3
-
-# MongoDB local data directory
-data/db/
-mongo-data/
-
-# Database dumps (usually too large for Git)
-*.sql
-*.dump
-
-# =============================================================================
-# LOGS & TEMPORARY FILES
-# =============================================================================
-# Log files can get very large and change constantly
-logs/
-*.log
-npm-debug.log*
-yarn-debug.log*
-yarn-error.log*
-
-# Runtime data
-pids/
-*.pid
-*.seed
-*.pid.lock
-
-# Temporary folders
-.tmp/
-temp/
-tmp/
-
-# =============================================================================
-# PYTHON & AI SERVICE FILES
-# =============================================================================
-# Python compiled files
-__pycache__/
-*.py[cod]
-*$py.class
-*.so
-
-# Python virtual environments (created with "python -m venv")
-venv/
-env/
-ENV/
-.venv/
-
-# Jupyter Notebook checkpoints
-.ipynb_checkpoints/
-
-# AI model files (these are usually large and downloaded separately)
-ai-service/models/*.pt
-ai-service/models/*.pth
-ai-service/models/*.onnx
-ai-service/models/*.h5
-ai-service/models/*.pb
-
-# Python distribution / packaging
-.Python
-build/
-develop-eggs/
-dist/
-downloads/
-eggs/
-.eggs/
-lib/
-lib64/
-parts/
-sdist/
-var/
-wheels/
-*.egg-info/
-.installed.cfg
-*.egg
-
-# =============================================================================
-# DOCKER FILES
-# =============================================================================
-# Docker build context and temporary files
-.docker/
-docker-compose.override.yml
-
-# =============================================================================
-# IDE & EDITOR FILES
-# =============================================================================
-# Visual Studio Code settings (some developers prefer to keep these local)
-.vscode/settings.json
-.vscode/launch.json
-.vscode/tasks.json
-
-# WebStorm/IntelliJ
-.idea/
-*.iml
-*.ipr
-*.iws
-
-# Sublime Text
-*.sublime-project
-*.sublime-workspace
-
-# Vim
-*.swp
-*.swo
-*~
-
-# Emacs
-*~
-\#*\#
-/.emacs.desktop
-/.emacs.desktop.lock
-
-# =============================================================================
-# OPERATING SYSTEM FILES
-# =============================================================================
-# macOS system files
-.DS_Store
-.DS_Store?
-._*
-.Spotlight-V100
-.Trashes
-ehthumbs.db
-Icon?
-
-# Windows system files
-Thumbs.db
-ehthumbs.db
-Desktop.ini
-$RECYCLE.BIN/
-
-# Linux
-*~
-.nfs*
-
-# =============================================================================
-# DEVELOPMENT & TESTING
-# =============================================================================
-# Test coverage reports
-coverage/
-.coverage
-htmlcov/
-.tox/
-.coverage.*
-.cache
-nosetests.xml
-coverage.xml
-*.cover
-.hypothesis/
-.pytest_cache/
-
-# ESLint cache
-.eslintcache
-
-# Optional REPL history
-.node_repl_history
-
-# =============================================================================
-# DEPLOYMENT & PRODUCTION
-# =============================================================================
-# SSL certificates and keys
-*.pem
-*.key
-*.crt
-*.csr
-
-# Deployment scripts with sensitive information
-deploy-config.json
-.deployment/
-
-# =============================================================================
-# BACKUP & ARCHIVE FILES
-# =============================================================================
-# Backup files
-*.bak
-*.backup
-*.old
-
-# Archive files
-*.zip
-*.tar.gz
-*.rar
-
-# =============================================================================
-# PROJECT-SPECIFIC IGNORES
-# =============================================================================
-# Camera stream recordings (these can be very large)
-recordings/
-*.mp4
-*.avi
-*.mov
-
-# Event snapshots and images
-uploads/
-snapshots/
-event-images/
-
-# Performance and monitoring data
-monitoring/
-metrics/
-performance-logs/
-
-# =============================================================================
-# DOCUMENTATION BUILD OUTPUT
-# =============================================================================
-# Generated documentation
-docs/_build/
-docs/.doctrees/
-
-# =============================================================================
-# DEPENDENCY DIRECTORIES
-# =============================================================================
-# Bower (if used for frontend dependencies)
-bower_components/
-
-# TypeScript cache
-*.tsbuildinfo
-
-# Optional npm cache directory
-.npm
-
-# Optional eslint cache
-.eslintcache
-
-# Microbundle cache
-.rpt2_cache/
-.rts2_cache_cjs/
-.rts2_cache_es/
-.rts2_cache_umd/
-
-# Optional REPL history
-.node_repl_history
-
-# Output of 'npm pack'
-*.tgz
-
-# Yarn Integrity file
-.yarn-integrity
-
-# =============================================================================
-# CUSTOM PROJECT IGNORES
-# =============================================================================
-# Add any project-specific ignores here
-# Example: vendor-specific files, custom build outputs, etc.
-
-# Local development notes (developers' personal notes)
-NOTES.md
-TODO.md
-.notes/
-
-# Local development database exports
-dev-data-export.*
-
-# Performance testing results
-load-test-results/
-
-# Security scan results
+# Event Monitoring MVP - Git Ignore File
+# This file tells Git which files and folders to ignore (not track in version control)
+
+# =============================================================================
+# NODE.JS & NPM DEPENDENCIES
+# =============================================================================
+# Node.js modules are downloaded from npm - we don't need to store them in Git
+# They can be reinstalled using "npm install"
+node_modules/
+npm-debug.log*
+yarn-debug.log*
+yarn-error.log*
+lerna-debug.log*
+
+# Package lock files (only commit one type)
+# We use npm, so we ignore yarn.lock
+yarn.lock
+package-lock.json
+
+# =============================================================================
+# ENVIRONMENT VARIABLES & SECRETS
+# =============================================================================
+# These files contain sensitive information like API keys and passwords
+# NEVER commit these to version control for security reasons
+.env
+.env.local
+.env.development.local
+.env.test.local
+.env.production.local
+.env.staging
+
+# Configuration files with secrets
+config/secrets.json
+config/local.json
+.secrets/
+
+# =============================================================================
+# BUILD OUTPUT & COMPILED FILES
+# =============================================================================
+# These are generated automatically and shouldn't be in version control
+# Frontend build output
+frontend/build/
+frontend/dist/
+
+# Backend compiled TypeScript
+backend/dist/
+backend/build/
+
+# Coverage reports from testing
+coverage/
+*.lcov
+.nyc_output
+vms-lab
+
+# =============================================================================
+# DATABASE FILES
+# =============================================================================
+# Local database files - production databases are separate
+*.db
+*.sqlite
+*.sqlite3
+
+# MongoDB local data directory
+data/db/
+mongo-data/
+
+# Database dumps (usually too large for Git)
+*.sql
+*.dump
+
+# =============================================================================
+# LOGS & TEMPORARY FILES
+# =============================================================================
+# Log files can get very large and change constantly
+logs/
+*.log
+npm-debug.log*
+yarn-debug.log*
+yarn-error.log*
+
+# Runtime data
+pids/
+*.pid
+*.seed
+*.pid.lock
+
+# Temporary folders
+.tmp/
+temp/
+tmp/
+
+# =============================================================================
+# PYTHON & AI SERVICE FILES
+# =============================================================================
+# Python compiled files
+__pycache__/
+*.py[cod]
+*$py.class
+*.so
+
+# Python virtual environments (created with "python -m venv")
+venv/
+env/
+ENV/
+.venv/
+
+# Jupyter Notebook checkpoints
+.ipynb_checkpoints/
+
+# AI model files (these are usually large and downloaded separately)
+ai-service/models/*.pt
+ai-service/models/*.pth
+ai-service/models/*.onnx
+ai-service/models/*.h5
+ai-service/models/*.pb
+
+# Python distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+
+# =============================================================================
+# DOCKER FILES
+# =============================================================================
+# Docker build context and temporary files
+.docker/
+docker-compose.override.yml
+
+# =============================================================================
+# IDE & EDITOR FILES
+# =============================================================================
+# Visual Studio Code settings (some developers prefer to keep these local)
+.vscode/settings.json
+.vscode/launch.json
+.vscode/tasks.json
+
+# WebStorm/IntelliJ
+.idea/
+*.iml
+*.ipr
+*.iws
+
+# Sublime Text
+*.sublime-project
+*.sublime-workspace
+
+# Vim
+*.swp
+*.swo
+*~
+
+# Emacs
+*~
+\#*\#
+/.emacs.desktop
+/.emacs.desktop.lock
+
+# =============================================================================
+# OPERATING SYSTEM FILES
+# =============================================================================
+# macOS system files
+.DS_Store
+.DS_Store?
+._*
+.Spotlight-V100
+.Trashes
+ehthumbs.db
+Icon?
+
+# Windows system files
+Thumbs.db
+ehthumbs.db
+Desktop.ini
+$RECYCLE.BIN/
+
+# Linux
+*~
+.nfs*
+
+# =============================================================================
+# DEVELOPMENT & TESTING
+# =============================================================================
+# Test coverage reports
+coverage/
+.coverage
+htmlcov/
+.tox/
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+.hypothesis/
+.pytest_cache/
+
+# ESLint cache
+.eslintcache
+
+# Optional REPL history
+.node_repl_history
+
+# =============================================================================
+# DEPLOYMENT & PRODUCTION
+# =============================================================================
+# SSL certificates and keys
+*.pem
+*.key
+*.crt
+*.csr
+
+# Deployment scripts with sensitive information
+deploy-config.json
+.deployment/
+
+# =============================================================================
+# BACKUP & ARCHIVE FILES
+# =============================================================================
+# Backup files
+*.bak
+*.backup
+*.old
+
+# Archive files
+*.zip
+*.tar.gz
+*.rar
+
+# =============================================================================
+# PROJECT-SPECIFIC IGNORES
+# =============================================================================
+# Camera stream recordings (these can be very large)
+recordings/
+*.mp4
+*.avi
+*.mov
+
+# Event snapshots and images
+uploads/
+snapshots/
+event-images/
+
+# Performance and monitoring data
+monitoring/
+metrics/
+performance-logs/
+
+# =============================================================================
+# DOCUMENTATION BUILD OUTPUT
+# =============================================================================
+# Generated documentation
+docs/_build/
+docs/.doctrees/
+
+# =============================================================================
+# DEPENDENCY DIRECTORIES
+# =============================================================================
+# Bower (if used for frontend dependencies)
+bower_components/
+
+# TypeScript cache
+*.tsbuildinfo
+
+# Optional npm cache directory
+.npm
+
+# Optional eslint cache
+.eslintcache
+
+# Microbundle cache
+.rpt2_cache/
+.rts2_cache_cjs/
+.rts2_cache_es/
+.rts2_cache_umd/
+
+# Optional REPL history
+.node_repl_history
+
+# Output of 'npm pack'
+*.tgz
+
+# Yarn Integrity file
+.yarn-integrity
+
+# =============================================================================
+# CUSTOM PROJECT IGNORES
+# =============================================================================
+# Add any project-specific ignores here
+# Example: vendor-specific files, custom build outputs, etc.
+
+# Local development notes (developers' personal notes)
+NOTES.md
+TODO.md
+.notes/
+
+# Local development database exports
+dev-data-export.*
+
+# Performance testing results
+load-test-results/
+
+# Security scan results
 security-reports/
\ No newline at end of file
diff --git a/README.md b/README.md
index b1ba691..c8b724c 100644
--- a/README.md
+++ b/README.md
@@ -1,369 +1,369 @@
-# ğŸ›¡ï¸ Event Monitoring MVP - Complete Security System
-
-<div align="center">
-  <h3>Modern AI-Powered Security Monitoring Platform</h3>
-  <p><em>A comprehensive security system that combines real-time video monitoring, AI object detection, and intelligent event management</em></p>
-  
-  [![Node.js](https://img.shields.io/badge/Node.js-18+-brightgreen.svg)](https://nodejs.org/)
-  [![React](https://img.shields.io/badge/React-18+-blue.svg)](https://reactjs.org/)
-  [![Python](https://img.shields.io/badge/Python-3.9+-yellow.svg)](https://python.org/)
-  [![TypeScript](https://img.shields.io/badge/TypeScript-5+-blue.svg)](https://typescriptlang.org/)
-  [![Docker](https://img.shields.io/badge/Docker-Ready-blue.svg)](https://docker.com/)
-</div>
-
----
-
-## ğŸ“‹ What This System Does
-
-This Event Monitoring MVP is a **complete security monitoring solution** that automatically watches security cameras using artificial intelligence. Think of it as a smart security guard that never sleeps, never gets distracted, and can watch dozens of cameras simultaneously.
-
-### ğŸ¯ **Core Capabilities**
-- **ğŸ” AI Object Detection** - Automatically detects people, vehicles, and objects in real-time
-- **ğŸ“¹ Multi-Camera Management** - Monitor unlimited security cameras from one dashboard
-- **ğŸš¨ Intelligent Alerts** - Smart notifications that reduce false alarms
-- **ğŸ—ºï¸ Interactive Mapping** - Visual map showing camera locations and live events
-- **ğŸ‘¥ User Management** - Role-based access for administrators, managers, and security guards
-- **ğŸ“Š Analytics Dashboard** - Comprehensive insights and reporting
-- **ğŸ“± Real-time Updates** - Live event streaming via WebSocket connections
-
----
-
-## ğŸ—ï¸ Project Structure (For New Developers)
-
-```
-cityshob/                                    # ğŸ  Main project folder
-â”œâ”€â”€ ğŸ“ event-monitoring-mvp/                 # ğŸš€ The actual application code
-â”‚   â”œâ”€â”€ ğŸ“ frontend/                         # ğŸ¨ User interface (what users see)
-â”‚   â”‚   â”œâ”€â”€ ğŸ“ src/
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ components/               # ğŸ§© Reusable UI components
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Layout/                  # ğŸ“ Main page layout structure
-â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ... (other UI components)
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ pages/                    # ğŸ“„ Main application pages
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx            # ğŸ  Main overview page
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Events.tsx               # ğŸš¨ Security events list
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Cameras.tsx              # ğŸ“¹ Camera management
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MapView.tsx              # ğŸ—ºï¸ Interactive map
-â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ... (other pages)
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/                 # ğŸ”Œ API communication code
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ store/                    # ğŸ—ƒï¸ Application state management
-â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ types/                    # ğŸ“ TypeScript type definitions
-â”‚   â”‚   â”œâ”€â”€ package.json                     # ğŸ“¦ Frontend dependencies list
-â”‚   â”‚   â””â”€â”€ Dockerfile                       # ğŸ³ Frontend container config
-â”‚   â”‚
-â”‚   â”œâ”€â”€ ğŸ“ backend/                          # ğŸ–¥ï¸ Server (business logic & database)
-â”‚   â”‚   â”œâ”€â”€ ğŸ“ src/
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ controllers/              # ğŸ® Request handling logic
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authController.ts        # ğŸ” User authentication
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ cameraController.ts      # ğŸ“¹ Camera management
-â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ eventController.ts       # ğŸš¨ Event handling
-â”‚   â”‚   â”‚   â”‚   â””â”€â”€ userController.ts        # ğŸ‘¥ User management
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ routes/                   # ğŸ›£ï¸ API endpoint definitions
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/                   # ğŸ“Š Database schemas
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ middleware/               # âš™ï¸ Request processing middleware
-â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ services/                 # ğŸ”§ Business logic services
-â”‚   â”‚   â”œâ”€â”€ package.json                     # ğŸ“¦ Backend dependencies list
-â”‚   â”‚   â””â”€â”€ Dockerfile                       # ğŸ³ Backend container config
-â”‚   â”‚
-â”‚   â”œâ”€â”€ ğŸ“ ai-service/                       # ğŸ¤– Artificial Intelligence engine
-â”‚   â”‚   â”œâ”€â”€ ğŸ“ src/
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/                   # ğŸ§  AI model definitions
-â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/                 # âš¡ AI processing services
-â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ utils/                    # ğŸ› ï¸ AI helper functions
-â”‚   â”‚   â”œâ”€â”€ app.py                           # ğŸ Main Python AI server
-â”‚   â”‚   â”œâ”€â”€ requirements.txt                 # ğŸ“‹ Python dependencies list
-â”‚   â”‚   â””â”€â”€ Dockerfile                       # ğŸ³ AI service container config
-â”‚   â”‚
-â”‚   â”œâ”€â”€ ğŸ“ docker/                           # ğŸ³ Docker configuration files
-â”‚   â”‚   â””â”€â”€ mongo-init.js                    # ğŸ—ƒï¸ Database initialization
-â”‚   â”œâ”€â”€ docker-compose.yml                   # ğŸ¼ Multi-container orchestration
-â”‚   â””â”€â”€ README.md                            # ğŸ“– Application-specific documentation
-â”‚
-â”œâ”€â”€ ğŸ“ event-monitoring-mvp-architecture/    # ğŸ“ Project architecture & planning
-â”‚   â”œâ”€â”€ ğŸ“ team-documentation/               # ğŸ“š COMPREHENSIVE TEAM GUIDES
-â”‚   â”‚   â”œâ”€â”€ 01-PROJECT-OVERVIEW.md           # ğŸ¯ What we're building & why
-â”‚   â”‚   â”œâ”€â”€ 02-TECHNOLOGY-STACK.md           # ğŸ› ï¸ Complete tech explanations
-â”‚   â”‚   â”œâ”€â”€ 03-ARCHITECTURE-DIAGRAMS.md      # ğŸ—ï¸ System design & patterns
-â”‚   â”‚   â”œâ”€â”€ 04-DEVELOPMENT-WORKFLOW.md       # ğŸ”„ How to work on the project
-â”‚   â”‚   â”œâ”€â”€ 05-IMPLEMENTATION-ROADMAP.md     # ğŸ—ºï¸ Future development plans
-â”‚   â”‚   â”œâ”€â”€ 06-BEGINNER-GUIDE.md            # ğŸ“ Complete programming intro
-â”‚   â”‚   â””â”€â”€ README.md                        # ğŸ“‹ Documentation index
-â”‚   â”œâ”€â”€ ğŸ“ docs/                             # ğŸ“„ Additional technical docs
-â”‚   â””â”€â”€ ğŸ“ src/                              # ğŸ”§ Architecture planning code
-â”‚
-â”œâ”€â”€ ğŸ“ chatdetails/                          # ğŸ’¬ Development conversation logs
-â”œâ”€â”€ .gitignore                               # ğŸš« Files Git should ignore
-â””â”€â”€ README.md                                # ğŸ“– THIS FILE - Project overview
-```
-
----
-
-## ğŸš€ Quick Start Guide
-
-### **For Complete Beginners**
-If you're new to programming, start here:
-1. ğŸ“š **Read the documentation**: Go to `event-monitoring-mvp-architecture/team-documentation/`
-2. ğŸ“ **Start with**: `06-BEGINNER-GUIDE.md` for programming fundamentals
-3. ğŸ“– **Then read**: `01-PROJECT-OVERVIEW.md` to understand what we're building
-
-### **For Developers**
-If you have some programming experience:
-
-#### **1. Prerequisites Setup**
-```bash
-# Install required software:
-# âœ… Node.js 18+ (for backend & frontend)
-# âœ… Python 3.9+ (for AI service)
-# âœ… Docker Desktop (for easy deployment)
-# âœ… Git (for version control)
-# âœ… VS Code (recommended editor)
-```
-
-#### **2. Get the Code**
-```bash
-# Clone this repository
-git clone <your-repo-url>
-cd cityshob
-
-# Navigate to the main application
-cd event-monitoring-mvp
-```
-
-#### **3. Start Everything with Docker (Easiest)**
-```bash
-# Start all services with one command
-docker-compose up --build
-
-# After containers start, access:
-# ğŸŒ Frontend: http://localhost:3000
-# ğŸ–¥ï¸ Backend API: http://localhost:5000
-# ğŸ¤– AI Service: http://localhost:8000
-# ğŸ—ƒï¸ MongoDB: localhost:27017
-```
-
-#### **4. Manual Setup (For Development)**
-```bash
-# Install backend dependencies
-cd backend
-npm install
-npm run dev
-
-# In a new terminal, install frontend dependencies
-cd frontend
-npm install
-npm start
-
-# In another terminal, setup AI service
-cd ai-service
-python -m venv venv
-source venv/bin/activate  # On Windows: venv\Scripts\activate
-pip install -r requirements.txt
-python app.py
-```
-
----
-
-## ğŸ› ï¸ Technology Stack (What You'll Learn)
-
-### **Frontend (User Interface)**
-- **âš›ï¸ React.js** - For building interactive user interfaces
-- **ğŸ“ TypeScript** - JavaScript with type safety (prevents bugs)
-- **ğŸ¨ Material-UI** - Beautiful, professional UI components
-- **ğŸ—ƒï¸ Redux Toolkit** - Application state management
-- **ğŸ”„ React Query** - Smart data fetching and caching
-
-### **Backend (Server)**
-- **ğŸ’š Node.js + Express** - JavaScript server framework
-- **ğŸ“ TypeScript** - Type-safe server development
-- **ğŸ“¡ Socket.IO** - Real-time communication (live updates)
-- **ğŸ” JWT Authentication** - Secure user login system
-- **âœ… Input Validation** - Data security and validation
-
-### **Database**
-- **ğŸƒ MongoDB** - Flexible document database
-- **ğŸ“Š Mongoose** - Object modeling for Node.js
-
-### **AI & Machine Learning**
-- **ğŸ Python + FastAPI** - AI service backend
-- **ğŸ‘ï¸ YOLOv8** - State-of-the-art object detection
-- **ğŸ“¹ OpenCV** - Computer vision and video processing
-- **ğŸ§  Ultralytics** - Machine learning model management
-
-### **DevOps & Deployment**
-- **ğŸ³ Docker** - Containerization for consistent deployment
-- **ğŸ“ Docker Compose** - Multi-service orchestration
-- **ğŸ“š Git** - Version control and team collaboration
-
----
-
-## ğŸ“š Learning Resources (For Students)
-
-### **Essential Reading (Start Here)**
-1. **`team-documentation/01-PROJECT-OVERVIEW.md`** - Understand the complete project
-2. **`team-documentation/06-BEGINNER-GUIDE.md`** - Programming fundamentals
-3. **`team-documentation/02-TECHNOLOGY-STACK.md`** - All technologies explained
-4. **`team-documentation/04-DEVELOPMENT-WORKFLOW.md`** - How to contribute
-
-### **Development Pathway**
-```
-Week 1-2:  ğŸ“– Read documentation & setup environment
-Week 3-4:  ğŸ¯ Complete small tasks & bug fixes
-Week 5-6:  ğŸš€ Implement new features
-Week 7-8:  ğŸ§  Specialize (frontend, backend, or AI)
-Week 9-12: ğŸ† Lead feature development & mentor others
-```
-
-### **External Learning Resources**
-- **JavaScript**: [MDN JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
-- **React**: [Official React Tutorial](https://react.dev/learn)
-- **Node.js**: [Node.js Getting Started](https://nodejs.org/en/docs/guides/getting-started-guide/)
-- **Python**: [Python Tutorial](https://docs.python.org/3/tutorial/)
-- **Git**: [Git Handbook](https://guides.github.com/introduction/git-handbook/)
-
----
-
-## ğŸ¯ Project Features (What's Already Built)
-
-### âœ… **Completed Features**
-- ğŸ” **User Authentication** - Secure login with JWT tokens
-- ğŸ‘¥ **User Management** - Admin, Manager, and Guard roles
-- ğŸ“¹ **Camera Management** - Add, configure, and monitor cameras
-- ğŸš¨ **Event System** - View and manage security events
-- ğŸ—ºï¸ **Interactive Map** - Mapbox integration with camera/event markers
-- ğŸ“Š **Dashboard** - Real-time statistics and recent activity
-- âš™ï¸ **Settings** - User preferences and system configuration
-- ğŸ“± **Real-time Updates** - Live event notifications via WebSocket
-
-### ğŸš§ **In Development**
-- ğŸ¤– **AI Object Detection** - YOLOv8 integration for automatic detection
-- ğŸ“¹ **Live Video Streams** - Real-time camera feed viewing
-- ğŸ“§ **Email Alerts** - Automatic notifications for critical events
-
-### ğŸ”® **Planned Features**
-- ğŸ“± **Mobile App** - React Native mobile application
-- ğŸ“ˆ **Advanced Analytics** - Detailed reporting and insights
-- ğŸ¢ **Enterprise Features** - Multi-tenant support and advanced AI
-
----
-
-## ğŸ¤ Contributing to the Project
-
-### **For New Developers**
-1. **ğŸ“ Start Learning** - Read the beginner guide and complete tutorials
-2. **ğŸ”§ Setup Environment** - Follow the quick start guide above
-3. **ğŸ‘¶ Pick Small Tasks** - Start with UI improvements or bug fixes
-4. **ğŸ“ Follow Workflow** - Use Git branches and pull requests
-5. **ğŸ¤ Ask Questions** - Use team chat for help and guidance
-
-### **Development Process**
-```bash
-# 1. Create feature branch
-git checkout -b feature/your-feature-name
-
-# 2. Make changes and test locally
-npm test
-docker-compose up --build
-
-# 3. Commit with descriptive message
-git add .
-git commit -m "feat: add camera offline alert feature"
-
-# 4. Push and create pull request
-git push origin feature/your-feature-name
-```
-
-### **Code Quality Standards**
-- âœ… Write tests for new features
-- ğŸ“ Add comments explaining complex logic
-- ğŸ¨ Follow existing code style
-- ğŸ” Test changes thoroughly before submitting
-- ğŸ“– Update documentation when needed
-
----
-
-## ğŸ“Š Project Status
-
-| Component | Status | Description |
-|-----------|--------|-------------|
-| ğŸ¨ Frontend | âœ… **Complete** | Full React app with all pages and components |
-| ğŸ–¥ï¸ Backend | âœ… **Complete** | REST API with authentication and data management |
-| ğŸ—ƒï¸ Database | âœ… **Complete** | MongoDB with proper schemas and indexing |
-| ğŸ¤– AI Service | ğŸš§ **In Progress** | Basic structure ready, AI model integration pending |
-| ğŸ“± Real-time | âœ… **Complete** | WebSocket communication for live updates |
-| ğŸ³ Deployment | âœ… **Complete** | Docker containerization for all services |
-| ğŸ“š Documentation | âœ… **Complete** | Comprehensive guides for team development |
-
----
-
-## ğŸ†˜ Getting Help
-
-### **When You're Stuck**
-1. ğŸ“– **Check Documentation** - Most questions are answered in `team-documentation/`
-2. ğŸ” **Search Issues** - Look for similar problems in GitHub issues
-3. ğŸ’¬ **Ask Team** - Use team communication channels
-4. ğŸ¤ **Pair Programming** - Work with experienced developers
-5. ğŸ“ **Create Issue** - Document bugs or request features
-
-### **Common Issues & Solutions**
-```bash
-# Frontend won't start
-cd frontend && rm -rf node_modules && npm install
-
-# Backend database connection error
-docker-compose up mongo
-
-# AI service dependencies missing
-cd ai-service && pip install -r requirements.txt
-
-# Git merge conflicts
-git status
-# Resolve conflicts in files, then:
-git add . && git commit
-```
-
----
-
-## ğŸ† Success Metrics
-
-### **Technical Goals**
-- ğŸ¯ **Detection Accuracy**: >95% for person detection
-- âš¡ **Response Time**: <200ms API responses
-- ğŸ”„ **Real-time Latency**: <100ms for live updates
-- âœ… **Code Coverage**: >80% test coverage
-- ğŸ”§ **Build Time**: <5 minutes full build
-
-### **Learning Goals**
-- ğŸ“ **Team Skill Growth**: All members contribute meaningfully
-- ğŸ“š **Knowledge Sharing**: Regular code reviews and mentoring
-- ğŸš€ **Project Delivery**: Working MVP in production
-- ğŸ¤ **Collaboration**: Effective teamwork and communication
-
----
-
-## ğŸ“„ License & Usage
-
-This project is designed for educational and learning purposes. It demonstrates modern web development practices, AI integration, and team collaboration workflows.
-
-**Learning Focus Areas:**
-- Full-stack web development
-- AI/ML integration in real applications
-- Modern DevOps practices
-- Team collaboration and Git workflows
-- Security and authentication systems
-
----
-
-## ğŸ‘¥ Team & Contact
-
-**Project Type:** Educational Security Monitoring MVP  
-**Target Audience:** Student developers learning full-stack development  
-**Tech Stack:** React + Node.js + Python + MongoDB + Docker  
-**Learning Level:** Beginner to Intermediate  
-
-**Get Started:** Read `event-monitoring-mvp-architecture/team-documentation/README.md` for complete guidance!
-
----
-
-<div align="center">
-  <h3>ğŸ“ Built for Learning â€¢ ğŸš€ Production Ready â€¢ ğŸ¤ Team Focused</h3>
-  <p><em>A comprehensive platform for students to learn modern software development through real-world application building</em></p>
+# ğŸ›¡ï¸ Event Monitoring MVP - Complete Security System
+
+<div align="center">
+  <h3>Modern AI-Powered Security Monitoring Platform</h3>
+  <p><em>A comprehensive security system that combines real-time video monitoring, AI object detection, and intelligent event management</em></p>
+  
+  [![Node.js](https://img.shields.io/badge/Node.js-18+-brightgreen.svg)](https://nodejs.org/)
+  [![React](https://img.shields.io/badge/React-18+-blue.svg)](https://reactjs.org/)
+  [![Python](https://img.shields.io/badge/Python-3.9+-yellow.svg)](https://python.org/)
+  [![TypeScript](https://img.shields.io/badge/TypeScript-5+-blue.svg)](https://typescriptlang.org/)
+  [![Docker](https://img.shields.io/badge/Docker-Ready-blue.svg)](https://docker.com/)
+</div>
+
+---
+
+## ğŸ“‹ What This System Does
+
+This Event Monitoring MVP is a **complete security monitoring solution** that automatically watches security cameras using artificial intelligence. Think of it as a smart security guard that never sleeps, never gets distracted, and can watch dozens of cameras simultaneously.
+
+### ğŸ¯ **Core Capabilities**
+- **ğŸ” AI Object Detection** - Automatically detects people, vehicles, and objects in real-time
+- **ğŸ“¹ Multi-Camera Management** - Monitor unlimited security cameras from one dashboard
+- **ğŸš¨ Intelligent Alerts** - Smart notifications that reduce false alarms
+- **ğŸ—ºï¸ Interactive Mapping** - Visual map showing camera locations and live events
+- **ğŸ‘¥ User Management** - Role-based access for administrators, managers, and security guards
+- **ğŸ“Š Analytics Dashboard** - Comprehensive insights and reporting
+- **ğŸ“± Real-time Updates** - Live event streaming via WebSocket connections
+
+---
+
+## ğŸ—ï¸ Project Structure (For New Developers)
+
+```
+cityshob/                                    # ğŸ  Main project folder
+â”œâ”€â”€ ğŸ“ event-monitoring-mvp/                 # ğŸš€ The actual application code
+â”‚   â”œâ”€â”€ ğŸ“ frontend/                         # ğŸ¨ User interface (what users see)
+â”‚   â”‚   â”œâ”€â”€ ğŸ“ src/
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ components/               # ğŸ§© Reusable UI components
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Layout/                  # ğŸ“ Main page layout structure
+â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ... (other UI components)
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ pages/                    # ğŸ“„ Main application pages
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx            # ğŸ  Main overview page
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Events.tsx               # ğŸš¨ Security events list
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Cameras.tsx              # ğŸ“¹ Camera management
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MapView.tsx              # ğŸ—ºï¸ Interactive map
+â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ... (other pages)
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/                 # ğŸ”Œ API communication code
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ store/                    # ğŸ—ƒï¸ Application state management
+â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ types/                    # ğŸ“ TypeScript type definitions
+â”‚   â”‚   â”œâ”€â”€ package.json                     # ğŸ“¦ Frontend dependencies list
+â”‚   â”‚   â””â”€â”€ Dockerfile                       # ğŸ³ Frontend container config
+â”‚   â”‚
+â”‚   â”œâ”€â”€ ğŸ“ backend/                          # ğŸ–¥ï¸ Server (business logic & database)
+â”‚   â”‚   â”œâ”€â”€ ğŸ“ src/
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ controllers/              # ğŸ® Request handling logic
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ authController.ts        # ğŸ” User authentication
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ cameraController.ts      # ğŸ“¹ Camera management
+â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ eventController.ts       # ğŸš¨ Event handling
+â”‚   â”‚   â”‚   â”‚   â””â”€â”€ userController.ts        # ğŸ‘¥ User management
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ routes/                   # ğŸ›£ï¸ API endpoint definitions
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/                   # ğŸ“Š Database schemas
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ middleware/               # âš™ï¸ Request processing middleware
+â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ services/                 # ğŸ”§ Business logic services
+â”‚   â”‚   â”œâ”€â”€ package.json                     # ğŸ“¦ Backend dependencies list
+â”‚   â”‚   â””â”€â”€ Dockerfile                       # ğŸ³ Backend container config
+â”‚   â”‚
+â”‚   â”œâ”€â”€ ğŸ“ ai-service/                       # ğŸ¤– Artificial Intelligence engine
+â”‚   â”‚   â”œâ”€â”€ ğŸ“ src/
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/                   # ğŸ§  AI model definitions
+â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ services/                 # âš¡ AI processing services
+â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ utils/                    # ğŸ› ï¸ AI helper functions
+â”‚   â”‚   â”œâ”€â”€ app.py                           # ğŸ Main Python AI server
+â”‚   â”‚   â”œâ”€â”€ requirements.txt                 # ğŸ“‹ Python dependencies list
+â”‚   â”‚   â””â”€â”€ Dockerfile                       # ğŸ³ AI service container config
+â”‚   â”‚
+â”‚   â”œâ”€â”€ ğŸ“ docker/                           # ğŸ³ Docker configuration files
+â”‚   â”‚   â””â”€â”€ mongo-init.js                    # ğŸ—ƒï¸ Database initialization
+â”‚   â”œâ”€â”€ docker-compose.yml                   # ğŸ¼ Multi-container orchestration
+â”‚   â””â”€â”€ README.md                            # ğŸ“– Application-specific documentation
+â”‚
+â”œâ”€â”€ ğŸ“ event-monitoring-mvp-architecture/    # ğŸ“ Project architecture & planning
+â”‚   â”œâ”€â”€ ğŸ“ team-documentation/               # ğŸ“š COMPREHENSIVE TEAM GUIDES
+â”‚   â”‚   â”œâ”€â”€ 01-PROJECT-OVERVIEW.md           # ğŸ¯ What we're building & why
+â”‚   â”‚   â”œâ”€â”€ 02-TECHNOLOGY-STACK.md           # ğŸ› ï¸ Complete tech explanations
+â”‚   â”‚   â”œâ”€â”€ 03-ARCHITECTURE-DIAGRAMS.md      # ğŸ—ï¸ System design & patterns
+â”‚   â”‚   â”œâ”€â”€ 04-DEVELOPMENT-WORKFLOW.md       # ğŸ”„ How to work on the project
+â”‚   â”‚   â”œâ”€â”€ 05-IMPLEMENTATION-ROADMAP.md     # ğŸ—ºï¸ Future development plans
+â”‚   â”‚   â”œâ”€â”€ 06-BEGINNER-GUIDE.md            # ğŸ“ Complete programming intro
+â”‚   â”‚   â””â”€â”€ README.md                        # ğŸ“‹ Documentation index
+â”‚   â”œâ”€â”€ ğŸ“ docs/                             # ğŸ“„ Additional technical docs
+â”‚   â””â”€â”€ ğŸ“ src/                              # ğŸ”§ Architecture planning code
+â”‚
+â”œâ”€â”€ ğŸ“ chatdetails/                          # ğŸ’¬ Development conversation logs
+â”œâ”€â”€ .gitignore                               # ğŸš« Files Git should ignore
+â””â”€â”€ README.md                                # ğŸ“– THIS FILE - Project overview
+```
+
+---
+
+## ğŸš€ Quick Start Guide
+
+### **For Complete Beginners**
+If you're new to programming, start here:
+1. ğŸ“š **Read the documentation**: Go to `event-monitoring-mvp-architecture/team-documentation/`
+2. ğŸ“ **Start with**: `06-BEGINNER-GUIDE.md` for programming fundamentals
+3. ğŸ“– **Then read**: `01-PROJECT-OVERVIEW.md` to understand what we're building
+
+### **For Developers**
+If you have some programming experience:
+
+#### **1. Prerequisites Setup**
+```bash
+# Install required software:
+# âœ… Node.js 18+ (for backend & frontend)
+# âœ… Python 3.9+ (for AI service)
+# âœ… Docker Desktop (for easy deployment)
+# âœ… Git (for version control)
+# âœ… VS Code (recommended editor)
+```
+
+#### **2. Get the Code**
+```bash
+# Clone this repository
+git clone <your-repo-url>
+cd cityshob
+
+# Navigate to the main application
+cd event-monitoring-mvp
+```
+
+#### **3. Start Everything with Docker (Easiest)**
+```bash
+# Start all services with one command
+docker-compose up --build
+
+# After containers start, access:
+# ğŸŒ Frontend: http://localhost:3000
+# ğŸ–¥ï¸ Backend API: http://localhost:5000
+# ğŸ¤– AI Service: http://localhost:8000
+# ğŸ—ƒï¸ MongoDB: localhost:27017
+```
+
+#### **4. Manual Setup (For Development)**
+```bash
+# Install backend dependencies
+cd backend
+npm install
+npm run dev
+
+# In a new terminal, install frontend dependencies
+cd frontend
+npm install
+npm start
+
+# In another terminal, setup AI service
+cd ai-service
+python -m venv venv
+source venv/bin/activate  # On Windows: venv\Scripts\activate
+pip install -r requirements.txt
+python app.py
+```
+
+---
+
+## ğŸ› ï¸ Technology Stack (What You'll Learn)
+
+### **Frontend (User Interface)**
+- **âš›ï¸ React.js** - For building interactive user interfaces
+- **ğŸ“ TypeScript** - JavaScript with type safety (prevents bugs)
+- **ğŸ¨ Material-UI** - Beautiful, professional UI components
+- **ğŸ—ƒï¸ Redux Toolkit** - Application state management
+- **ğŸ”„ React Query** - Smart data fetching and caching
+
+### **Backend (Server)**
+- **ğŸ’š Node.js + Express** - JavaScript server framework
+- **ğŸ“ TypeScript** - Type-safe server development
+- **ğŸ“¡ Socket.IO** - Real-time communication (live updates)
+- **ğŸ” JWT Authentication** - Secure user login system
+- **âœ… Input Validation** - Data security and validation
+
+### **Database**
+- **ğŸƒ MongoDB** - Flexible document database
+- **ğŸ“Š Mongoose** - Object modeling for Node.js
+
+### **AI & Machine Learning**
+- **ğŸ Python + FastAPI** - AI service backend
+- **ğŸ‘ï¸ YOLOv8** - State-of-the-art object detection
+- **ğŸ“¹ OpenCV** - Computer vision and video processing
+- **ğŸ§  Ultralytics** - Machine learning model management
+
+### **DevOps & Deployment**
+- **ğŸ³ Docker** - Containerization for consistent deployment
+- **ğŸ“ Docker Compose** - Multi-service orchestration
+- **ğŸ“š Git** - Version control and team collaboration
+
+---
+
+## ğŸ“š Learning Resources (For Students)
+
+### **Essential Reading (Start Here)**
+1. **`team-documentation/01-PROJECT-OVERVIEW.md`** - Understand the complete project
+2. **`team-documentation/06-BEGINNER-GUIDE.md`** - Programming fundamentals
+3. **`team-documentation/02-TECHNOLOGY-STACK.md`** - All technologies explained
+4. **`team-documentation/04-DEVELOPMENT-WORKFLOW.md`** - How to contribute
+
+### **Development Pathway**
+```
+Week 1-2:  ğŸ“– Read documentation & setup environment
+Week 3-4:  ğŸ¯ Complete small tasks & bug fixes
+Week 5-6:  ğŸš€ Implement new features
+Week 7-8:  ğŸ§  Specialize (frontend, backend, or AI)
+Week 9-12: ğŸ† Lead feature development & mentor others
+```
+
+### **External Learning Resources**
+- **JavaScript**: [MDN JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
+- **React**: [Official React Tutorial](https://react.dev/learn)
+- **Node.js**: [Node.js Getting Started](https://nodejs.org/en/docs/guides/getting-started-guide/)
+- **Python**: [Python Tutorial](https://docs.python.org/3/tutorial/)
+- **Git**: [Git Handbook](https://guides.github.com/introduction/git-handbook/)
+
+---
+
+## ğŸ¯ Project Features (What's Already Built)
+
+### âœ… **Completed Features**
+- ğŸ” **User Authentication** - Secure login with JWT tokens
+- ğŸ‘¥ **User Management** - Admin, Manager, and Guard roles
+- ğŸ“¹ **Camera Management** - Add, configure, and monitor cameras
+- ğŸš¨ **Event System** - View and manage security events
+- ğŸ—ºï¸ **Interactive Map** - Mapbox integration with camera/event markers
+- ğŸ“Š **Dashboard** - Real-time statistics and recent activity
+- âš™ï¸ **Settings** - User preferences and system configuration
+- ğŸ“± **Real-time Updates** - Live event notifications via WebSocket
+
+### ğŸš§ **In Development**
+- ğŸ¤– **AI Object Detection** - YOLOv8 integration for automatic detection
+- ğŸ“¹ **Live Video Streams** - Real-time camera feed viewing
+- ğŸ“§ **Email Alerts** - Automatic notifications for critical events
+
+### ğŸ”® **Planned Features**
+- ğŸ“± **Mobile App** - React Native mobile application
+- ğŸ“ˆ **Advanced Analytics** - Detailed reporting and insights
+- ğŸ¢ **Enterprise Features** - Multi-tenant support and advanced AI
+
+---
+
+## ğŸ¤ Contributing to the Project
+
+### **For New Developers**
+1. **ğŸ“ Start Learning** - Read the beginner guide and complete tutorials
+2. **ğŸ”§ Setup Environment** - Follow the quick start guide above
+3. **ğŸ‘¶ Pick Small Tasks** - Start with UI improvements or bug fixes
+4. **ğŸ“ Follow Workflow** - Use Git branches and pull requests
+5. **ğŸ¤ Ask Questions** - Use team chat for help and guidance
+
+### **Development Process**
+```bash
+# 1. Create feature branch
+git checkout -b feature/your-feature-name
+
+# 2. Make changes and test locally
+npm test
+docker-compose up --build
+
+# 3. Commit with descriptive message
+git add .
+git commit -m "feat: add camera offline alert feature"
+
+# 4. Push and create pull request
+git push origin feature/your-feature-name
+```
+
+### **Code Quality Standards**
+- âœ… Write tests for new features
+- ğŸ“ Add comments explaining complex logic
+- ğŸ¨ Follow existing code style
+- ğŸ” Test changes thoroughly before submitting
+- ğŸ“– Update documentation when needed
+
+---
+
+## ğŸ“Š Project Status
+
+| Component | Status | Description |
+|-----------|--------|-------------|
+| ğŸ¨ Frontend | âœ… **Complete** | Full React app with all pages and components |
+| ğŸ–¥ï¸ Backend | âœ… **Complete** | REST API with authentication and data management |
+| ğŸ—ƒï¸ Database | âœ… **Complete** | MongoDB with proper schemas and indexing |
+| ğŸ¤– AI Service | ğŸš§ **In Progress** | Basic structure ready, AI model integration pending |
+| ğŸ“± Real-time | âœ… **Complete** | WebSocket communication for live updates |
+| ğŸ³ Deployment | âœ… **Complete** | Docker containerization for all services |
+| ğŸ“š Documentation | âœ… **Complete** | Comprehensive guides for team development |
+
+---
+
+## ğŸ†˜ Getting Help
+
+### **When You're Stuck**
+1. ğŸ“– **Check Documentation** - Most questions are answered in `team-documentation/`
+2. ğŸ” **Search Issues** - Look for similar problems in GitHub issues
+3. ğŸ’¬ **Ask Team** - Use team communication channels
+4. ğŸ¤ **Pair Programming** - Work with experienced developers
+5. ğŸ“ **Create Issue** - Document bugs or request features
+
+### **Common Issues & Solutions**
+```bash
+# Frontend won't start
+cd frontend && rm -rf node_modules && npm install
+
+# Backend database connection error
+docker-compose up mongo
+
+# AI service dependencies missing
+cd ai-service && pip install -r requirements.txt
+
+# Git merge conflicts
+git status
+# Resolve conflicts in files, then:
+git add . && git commit
+```
+
+---
+
+## ğŸ† Success Metrics
+
+### **Technical Goals**
+- ğŸ¯ **Detection Accuracy**: >95% for person detection
+- âš¡ **Response Time**: <200ms API responses
+- ğŸ”„ **Real-time Latency**: <100ms for live updates
+- âœ… **Code Coverage**: >80% test coverage
+- ğŸ”§ **Build Time**: <5 minutes full build
+
+### **Learning Goals**
+- ğŸ“ **Team Skill Growth**: All members contribute meaningfully
+- ğŸ“š **Knowledge Sharing**: Regular code reviews and mentoring
+- ğŸš€ **Project Delivery**: Working MVP in production
+- ğŸ¤ **Collaboration**: Effective teamwork and communication
+
+---
+
+## ğŸ“„ License & Usage
+
+This project is designed for educational and learning purposes. It demonstrates modern web development practices, AI integration, and team collaboration workflows.
+
+**Learning Focus Areas:**
+- Full-stack web development
+- AI/ML integration in real applications
+- Modern DevOps practices
+- Team collaboration and Git workflows
+- Security and authentication systems
+
+---
+
+## ğŸ‘¥ Team & Contact
+
+**Project Type:** Educational Security Monitoring MVP  
+**Target Audience:** Student developers learning full-stack development  
+**Tech Stack:** React + Node.js + Python + MongoDB + Docker  
+**Learning Level:** Beginner to Intermediate  
+
+**Get Started:** Read `event-monitoring-mvp-architecture/team-documentation/README.md` for complete guidance!
+
+---
+
+<div align="center">
+  <h3>ğŸ“ Built for Learning â€¢ ğŸš€ Production Ready â€¢ ğŸ¤ Team Focused</h3>
+  <p><em>A comprehensive platform for students to learn modern software development through real-world application building</em></p>
 </div>
\ No newline at end of file
diff --git a/chatdetails/arch.txt b/chatdetails/arch.txt
index e1f50d7..d0e764e 100644
--- a/chatdetails/arch.txt
+++ b/chatdetails/arch.txt
@@ -1,346 +1,346 @@
-Got you ğŸ˜
-Iâ€™ll give you **one big, detailed prompt** you can paste into *another* chat/diagram agent to generate the MVP architecture diagram.
-
-Iâ€™ll also structure it so **you look super organized** in front of the company.
-
----
-
-## âœ… How to use this
-
-* Copy everything under **â€œFULL PROMPT FOR DIAGRAM AGENTâ€**
-* Paste it into a tool/chat that generates diagrams (PlantUML / Mermaid / draw.io assistant / Excalidraw AI / whatever)
-* It should produce a **system architecture diagram** for your MVP.
-
----
-
-## ğŸ§© MVP Scope (Reminder of what the diagram covers)
-
-This architecture is ONLY for the MVP we defined:
-
-* Live video from a few cameras
-* ONE AI model (e.g., people/vehicle detection)
-* Automatic event creation
-* Event table in UI
-* Basic map with camera positions & event highlighting
-* Basic auth (login)
-* Node/Express backend, React frontend, MongoDB, and AI service (probably Python)
-
----
-
-## ğŸ“ FULL PROMPT FOR DIAGRAM AGENT
-
-You can paste this **as-is** to another AI that draws diagrams:
-
----
-
-**PROMPT START**
-
-Create a detailed system architecture diagram for an MVP â€œEvent Monitoring Platformâ€ with live video, AI detection, map, and events.
-The tech stack is:
-
-* Frontend: React (Web)
-* Backend API: Node.js + Express
-* Database: MongoDB
-* AI Service: separate microservice (Python or similar) for video analytics
-* External systems: IP Cameras or VMS, Map Provider (e.g., Mapbox/Google Maps)
-
-The diagram should clearly show **components, data flows, and boundaries**.
-
----
-
-### 1. High-Level Layout
-
-Organize the diagram in layers:
-
-* **Top layer**: Users & client (Web browser)
-* **Middle layer**: Backend (Node/Express API) and AI Service
-* **Bottom layer**: Database (MongoDB), Video Source (Cameras / VMS), Map Provider
-
-Use grouping or boxes to show:
-
-* â€œClient / Frontendâ€
-* â€œBackend APIâ€
-* â€œAI & Video Analyticsâ€
-* â€œData Storageâ€
-* â€œExternal Servicesâ€
-
----
-
-### 2. Actors / Users
-
-Add a user actor:
-
-* **Security Operator / Control Room User**
-
-  * Interacts via the **Web Browser (React app)**
-  * Can:
-
-    * Log in
-    * Watch live video
-    * See events list
-    * See map with cameras & events
-
----
-
-### 3. Frontend (React Web App)
-
-Show a **React Web Application** box with internal logical modules (they can be sub-boxes, compartments, or just labels):
-
-1. **Auth Module**
-
-   * Login form
-   * Sends credentials to `/auth/login`
-   * Receives JWT token
-
-2. **Live Video View**
-
-   * Requests video stream URLs from backend
-   * Embeds video player (e.g., HLS/WebRTC/RTSP via gateway)
-   * Shows one or a few cameras
-
-3. **Events List / Events Panel**
-
-   * Calls backend endpoint `/events` to fetch event list
-   * Displays basic event details: time, camera, type
-
-4. **Map View Module**
-
-   * Loads map from Map Provider SDK (e.g., Mapbox/Google Maps)
-   * Requests camera locations from backend (`/cameras`)
-   * Requests active events from backend (`/events?status=active`)
-   * Shows camera markers and highlights cameras with events
-
-5. **Event Details View**
-
-   * On click of event: fetch `/events/{id}` for details
-   * Displays snapshot/image and metadata
-
-The React app communicates **only** with the Backend API (Node/Express), not directly with AI or DB.
-
----
-
-### 4. Backend API (Node.js + Express)
-
-Draw a **Backend API (Node + Express)** container that exposes REST endpoints.
-
-Inside it, show logical sub-components / services:
-
-1. **Auth Controller / Service**
-
-   * Endpoint: `POST /auth/login`
-   * Validates user credentials against `Users` collection in MongoDB
-   * Issues JWT tokens
-
-2. **Camera Service**
-
-   * Endpoint: `GET /cameras`
-   * Returns a list of cameras with:
-
-     * ID
-     * Name
-     * Location (GPS)
-     * Stream URL or reference ID for VMS
-
-3. **Event Service**
-
-   * Endpoints:
-
-     * `GET /events`
-     * `GET /events/{id}`
-   * Reads event records from MongoDB
-   * Filters by:
-
-     * time
-     * camera
-     * event type
-     * status (active / resolved)
-
-4. **Video Gateway / Stream Info Endpoint (MVP-simple)**
-
-   * Endpoint: `GET /cameras/{id}/stream`
-   * Returns a URL / token to access the live video stream (NOTE: actual streaming can be handled by a VMS or a media server, not implemented fully in MVP)
-
-5. **AI Integration Service**
-
-   * Receives detection results from AI Service via HTTP callback or message queue (for MVP, HTTP is enough)
-   * When AI sends a detection event:
-
-     * Validates data
-     * Creates a new Event document in MongoDB
-     * Optionally links to a snapshot image path
-
-6. **Map / Geolocation Service (simple)**
-
-   * Stores and serves static camera GPS coordinates
-   * No advanced GIS logic in MVP
-
-**Backend to Database Communication:**
-
-* The Backend API connects to **MongoDB** and works with these collections:
-
-  1. `users`
-
-     * username
-     * hashed_password
-     * role (admin/operator)
-
-  2. `cameras`
-
-     * camera_id
-     * name
-     * location (lat, lon)
-     * stream_url or VMS reference
-
-  3. `events`
-
-     * event_id
-     * timestamp
-     * camera_id
-     * event_type (e.g., person_detected, vehicle_detected)
-     * snapshot_url (optional)
-     * status (e.g., new, acknowledged, closed)
-
----
-
-### 5. AI & Video Analytics Service (Separate Microservice)
-
-Draw a separate box labeled **AI Analytics Service**.
-
-Responsibilities:
-
-* Receives **video frames or video stream reference** from Video Ingestion layer or VMS
-* Runs **ONE AI model in MVP** (e.g., object detection: people + vehicles)
-* For each detection:
-
-  * Builds a detection payload with:
-
-    * camera_id
-    * timestamp
-    * detection_type (person/vehicle)
-    * coordinates (optional)
-    * confidence score
-  * Sends HTTP POST to Backend API, e.g. `POST /internal/ai/events`
-
-The AI Service is **not** directly visible to frontend.
-
-Optionally, show:
-
-* A **â€œFrame Extractor / Video Ingestionâ€** small component that:
-
-  * Connects to the RTSP stream
-  * Samples frames (e.g., 1â€“5 FPS)
-  * Sends frames to the AI model
-
----
-
-### 6. Database Layer (MongoDB)
-
-Draw a **MongoDB** container with labeled collections:
-
-* `users`
-* `cameras`
-* `events`
-
-Show arrows:
-
-* From Backend API to MongoDB (CRUD operations)
-* AI Service never speaks directly to DB (only via Backend API)
-
----
-
-### 7. External Systems
-
-Add external systems as separate boxes:
-
-1. **IP Cameras / VMS**
-
-   * Output: Live video stream (RTSP / HLS / VMS proprietary)
-   * Connected to:
-
-     * Video Ingestion / AI Service (for analytics)
-     * Video gateway / streaming server (if applicable)
-
-2. **Map Provider**
-
-   * Example: Mapbox / Google Maps
-   * Provides:
-
-     * Map tiles
-     * Basemap
-   * Used directly by the **React Frontend** via SDK or JS API
-
----
-
-### 8. Data Flows (Label Arrows Clearly)
-
-Please draw and label arrows for these main flows:
-
-1. **User Login Flow**
-
-   * User â†’ React App â†’ Backend `/auth/login` â†’ MongoDB (validate user) â†’ React stores JWT
-
-2. **Live Video Flow (Simplified MVP)**
-
-   * Camera â†’ VMS/Stream Server â†’ React Video Player (using URL fetched from Backend)
-   * React requests `/cameras/{id}/stream` to get stream info
-
-3. **AI Detection Flow**
-
-   * Camera â†’ Video Ingestion/AI Service â†’ AI Model â†’ Detection Event
-   * AI Service â†’ `POST /internal/ai/events` on Backend API
-   * Backend API â†’ MongoDB (`events` collection)
-
-4. **Event List Flow**
-
-   * React App â†’ `GET /events` (Backend API) â†’ MongoDB â†’ React shows table/list
-
-5. **Map View Flow**
-
-   * React Map Module â†’ `GET /cameras` (for camera positions)
-   * React Map Module â†’ `GET /events?status=active` (for active events)
-   * Map Provider â†’ delivers tiles/background map
-   * React places markers and highlights cameras with events
-
----
-
-### 9. Non-Functional Notes (Short Annotations)
-
-Add text annotations or notes mentioning:
-
-* MVP focus:
-
-  * Small number of cameras (e.g., 1â€“5)
-  * One AI model only
-  * Simple RBAC (admin/operator)
-  * No SMS/email alerts yet
-  * No geofencing in MVP
-* All communication between frontend and backend over HTTPS
-* Backendâ€“AI communication using internal HTTP calls (no heavy message bus in MVP)
-
----
-
-### 10. Diagram Style
-
-Use any style you like (C4 Container diagram, layered boxes, or classical system architecture), but:
-
-* Make boundaries clear:
-
-  * Frontend
-  * Backend
-  * AI Service
-  * Database
-  * External Systems
-* Label all arrows with:
-
-  * Protocol (HTTP/HTTPS, RTSP)
-  * Main payload type (video stream, JSON, etc.)
-
-**PROMPT END**
-
----
-
-If you want, I can also:
-
-* Turn this into **PlantUML C4** code
-* Or into **Mermaid** code (for Markdown / docs / GitHub)
-* Or into a **slide layout** you can use in PowerPoint/Canva for Sunday.
+Got you ğŸ˜
+Iâ€™ll give you **one big, detailed prompt** you can paste into *another* chat/diagram agent to generate the MVP architecture diagram.
+
+Iâ€™ll also structure it so **you look super organized** in front of the company.
+
+---
+
+## âœ… How to use this
+
+* Copy everything under **â€œFULL PROMPT FOR DIAGRAM AGENTâ€**
+* Paste it into a tool/chat that generates diagrams (PlantUML / Mermaid / draw.io assistant / Excalidraw AI / whatever)
+* It should produce a **system architecture diagram** for your MVP.
+
+---
+
+## ğŸ§© MVP Scope (Reminder of what the diagram covers)
+
+This architecture is ONLY for the MVP we defined:
+
+* Live video from a few cameras
+* ONE AI model (e.g., people/vehicle detection)
+* Automatic event creation
+* Event table in UI
+* Basic map with camera positions & event highlighting
+* Basic auth (login)
+* Node/Express backend, React frontend, MongoDB, and AI service (probably Python)
+
+---
+
+## ğŸ“ FULL PROMPT FOR DIAGRAM AGENT
+
+You can paste this **as-is** to another AI that draws diagrams:
+
+---
+
+**PROMPT START**
+
+Create a detailed system architecture diagram for an MVP â€œEvent Monitoring Platformâ€ with live video, AI detection, map, and events.
+The tech stack is:
+
+* Frontend: React (Web)
+* Backend API: Node.js + Express
+* Database: MongoDB
+* AI Service: separate microservice (Python or similar) for video analytics
+* External systems: IP Cameras or VMS, Map Provider (e.g., Mapbox/Google Maps)
+
+The diagram should clearly show **components, data flows, and boundaries**.
+
+---
+
+### 1. High-Level Layout
+
+Organize the diagram in layers:
+
+* **Top layer**: Users & client (Web browser)
+* **Middle layer**: Backend (Node/Express API) and AI Service
+* **Bottom layer**: Database (MongoDB), Video Source (Cameras / VMS), Map Provider
+
+Use grouping or boxes to show:
+
+* â€œClient / Frontendâ€
+* â€œBackend APIâ€
+* â€œAI & Video Analyticsâ€
+* â€œData Storageâ€
+* â€œExternal Servicesâ€
+
+---
+
+### 2. Actors / Users
+
+Add a user actor:
+
+* **Security Operator / Control Room User**
+
+  * Interacts via the **Web Browser (React app)**
+  * Can:
+
+    * Log in
+    * Watch live video
+    * See events list
+    * See map with cameras & events
+
+---
+
+### 3. Frontend (React Web App)
+
+Show a **React Web Application** box with internal logical modules (they can be sub-boxes, compartments, or just labels):
+
+1. **Auth Module**
+
+   * Login form
+   * Sends credentials to `/auth/login`
+   * Receives JWT token
+
+2. **Live Video View**
+
+   * Requests video stream URLs from backend
+   * Embeds video player (e.g., HLS/WebRTC/RTSP via gateway)
+   * Shows one or a few cameras
+
+3. **Events List / Events Panel**
+
+   * Calls backend endpoint `/events` to fetch event list
+   * Displays basic event details: time, camera, type
+
+4. **Map View Module**
+
+   * Loads map from Map Provider SDK (e.g., Mapbox/Google Maps)
+   * Requests camera locations from backend (`/cameras`)
+   * Requests active events from backend (`/events?status=active`)
+   * Shows camera markers and highlights cameras with events
+
+5. **Event Details View**
+
+   * On click of event: fetch `/events/{id}` for details
+   * Displays snapshot/image and metadata
+
+The React app communicates **only** with the Backend API (Node/Express), not directly with AI or DB.
+
+---
+
+### 4. Backend API (Node.js + Express)
+
+Draw a **Backend API (Node + Express)** container that exposes REST endpoints.
+
+Inside it, show logical sub-components / services:
+
+1. **Auth Controller / Service**
+
+   * Endpoint: `POST /auth/login`
+   * Validates user credentials against `Users` collection in MongoDB
+   * Issues JWT tokens
+
+2. **Camera Service**
+
+   * Endpoint: `GET /cameras`
+   * Returns a list of cameras with:
+
+     * ID
+     * Name
+     * Location (GPS)
+     * Stream URL or reference ID for VMS
+
+3. **Event Service**
+
+   * Endpoints:
+
+     * `GET /events`
+     * `GET /events/{id}`
+   * Reads event records from MongoDB
+   * Filters by:
+
+     * time
+     * camera
+     * event type
+     * status (active / resolved)
+
+4. **Video Gateway / Stream Info Endpoint (MVP-simple)**
+
+   * Endpoint: `GET /cameras/{id}/stream`
+   * Returns a URL / token to access the live video stream (NOTE: actual streaming can be handled by a VMS or a media server, not implemented fully in MVP)
+
+5. **AI Integration Service**
+
+   * Receives detection results from AI Service via HTTP callback or message queue (for MVP, HTTP is enough)
+   * When AI sends a detection event:
+
+     * Validates data
+     * Creates a new Event document in MongoDB
+     * Optionally links to a snapshot image path
+
+6. **Map / Geolocation Service (simple)**
+
+   * Stores and serves static camera GPS coordinates
+   * No advanced GIS logic in MVP
+
+**Backend to Database Communication:**
+
+* The Backend API connects to **MongoDB** and works with these collections:
+
+  1. `users`
+
+     * username
+     * hashed_password
+     * role (admin/operator)
+
+  2. `cameras`
+
+     * camera_id
+     * name
+     * location (lat, lon)
+     * stream_url or VMS reference
+
+  3. `events`
+
+     * event_id
+     * timestamp
+     * camera_id
+     * event_type (e.g., person_detected, vehicle_detected)
+     * snapshot_url (optional)
+     * status (e.g., new, acknowledged, closed)
+
+---
+
+### 5. AI & Video Analytics Service (Separate Microservice)
+
+Draw a separate box labeled **AI Analytics Service**.
+
+Responsibilities:
+
+* Receives **video frames or video stream reference** from Video Ingestion layer or VMS
+* Runs **ONE AI model in MVP** (e.g., object detection: people + vehicles)
+* For each detection:
+
+  * Builds a detection payload with:
+
+    * camera_id
+    * timestamp
+    * detection_type (person/vehicle)
+    * coordinates (optional)
+    * confidence score
+  * Sends HTTP POST to Backend API, e.g. `POST /internal/ai/events`
+
+The AI Service is **not** directly visible to frontend.
+
+Optionally, show:
+
+* A **â€œFrame Extractor / Video Ingestionâ€** small component that:
+
+  * Connects to the RTSP stream
+  * Samples frames (e.g., 1â€“5 FPS)
+  * Sends frames to the AI model
+
+---
+
+### 6. Database Layer (MongoDB)
+
+Draw a **MongoDB** container with labeled collections:
+
+* `users`
+* `cameras`
+* `events`
+
+Show arrows:
+
+* From Backend API to MongoDB (CRUD operations)
+* AI Service never speaks directly to DB (only via Backend API)
+
+---
+
+### 7. External Systems
+
+Add external systems as separate boxes:
+
+1. **IP Cameras / VMS**
+
+   * Output: Live video stream (RTSP / HLS / VMS proprietary)
+   * Connected to:
+
+     * Video Ingestion / AI Service (for analytics)
+     * Video gateway / streaming server (if applicable)
+
+2. **Map Provider**
+
+   * Example: Mapbox / Google Maps
+   * Provides:
+
+     * Map tiles
+     * Basemap
+   * Used directly by the **React Frontend** via SDK or JS API
+
+---
+
+### 8. Data Flows (Label Arrows Clearly)
+
+Please draw and label arrows for these main flows:
+
+1. **User Login Flow**
+
+   * User â†’ React App â†’ Backend `/auth/login` â†’ MongoDB (validate user) â†’ React stores JWT
+
+2. **Live Video Flow (Simplified MVP)**
+
+   * Camera â†’ VMS/Stream Server â†’ React Video Player (using URL fetched from Backend)
+   * React requests `/cameras/{id}/stream` to get stream info
+
+3. **AI Detection Flow**
+
+   * Camera â†’ Video Ingestion/AI Service â†’ AI Model â†’ Detection Event
+   * AI Service â†’ `POST /internal/ai/events` on Backend API
+   * Backend API â†’ MongoDB (`events` collection)
+
+4. **Event List Flow**
+
+   * React App â†’ `GET /events` (Backend API) â†’ MongoDB â†’ React shows table/list
+
+5. **Map View Flow**
+
+   * React Map Module â†’ `GET /cameras` (for camera positions)
+   * React Map Module â†’ `GET /events?status=active` (for active events)
+   * Map Provider â†’ delivers tiles/background map
+   * React places markers and highlights cameras with events
+
+---
+
+### 9. Non-Functional Notes (Short Annotations)
+
+Add text annotations or notes mentioning:
+
+* MVP focus:
+
+  * Small number of cameras (e.g., 1â€“5)
+  * One AI model only
+  * Simple RBAC (admin/operator)
+  * No SMS/email alerts yet
+  * No geofencing in MVP
+* All communication between frontend and backend over HTTPS
+* Backendâ€“AI communication using internal HTTP calls (no heavy message bus in MVP)
+
+---
+
+### 10. Diagram Style
+
+Use any style you like (C4 Container diagram, layered boxes, or classical system architecture), but:
+
+* Make boundaries clear:
+
+  * Frontend
+  * Backend
+  * AI Service
+  * Database
+  * External Systems
+* Label all arrows with:
+
+  * Protocol (HTTP/HTTPS, RTSP)
+  * Main payload type (video stream, JSON, etc.)
+
+**PROMPT END**
+
+---
+
+If you want, I can also:
+
+* Turn this into **PlantUML C4** code
+* Or into **Mermaid** code (for Markdown / docs / GitHub)
+* Or into a **slide layout** you can use in PowerPoint/Canva for Sunday.
diff --git a/chatdetails/fulldetail.txt b/chatdetails/fulldetail.txt
index aa48c0b..0a2ae8f 100644
--- a/chatdetails/fulldetail.txt
+++ b/chatdetails/fulldetail.txt
@@ -1,664 +1,664 @@
-Hereâ€™s a full, self-contained explanation you can copy into a text file and give to another agent.
-Iâ€™ll write it as if itâ€™s a **project spec + context document**.
-
----
-
-## 1. Project Overview
-
-We are building an **Event Monitoring and Management Platform** that combines:
-
-* **Live video streams** from cameras (IP, VMS, security cameras, etc.)
-* **AI-based video analytics** to detect people, vehicles, suspicious behavior, and other anomalies
-* **A GIS map** that visualizes cameras and events in their geographic context
-* **An event management system** that logs, classifies, prioritizes, and tracks incidents
-* **Dashboards and KPIs** for operators and managers
-* **Integrations** with external systems (VMS, GIS providers, IoT devices, and emergency dispatch/CAD)
-
-The platform is intended for **real-time monitoring of environmental/safety/security events**, for example:
-
-* Smart cities and municipalities
-* Critical infrastructure (ports, industrial sites, campuses)
-* Security operation centers (SOC)
-* Public safety monitoring
-
-The system will eventually support **real-time operations** (live view and alerts) **and offline analysis** (history, trends, reports).
-
----
-
-## 2. High-Level Goals
-
-1. **Real-time situational awareness**
-   Combine video, map, and events in a unified view so operators can quickly understand what is happening, where, and how severe it is.
-
-2. **AI-assisted detection and decision support**
-   Use AI to automatically detect relevant events (e.g., person detected in restricted area, abandoned object, suspicious motion, specific vehicles), create events, and support prioritization.
-
-3. **Efficient event lifecycle management**
-   Allow operators to review, classify, prioritize, and resolve events, and to maintain a full history for investigation and analysis.
-
-4. **Scalable integration with external systems**
-   Integrate with:
-
-   * Existing VMS (Video Management Systems)
-   * IoT sensors
-   * GIS data sources
-   * Emergency response systems (CAD)
-
-5. **Reporting and insights**
-   Provide dashboards and reports for management: trends over time, hotspots, repeated issues, response metrics, etc.
-
----
-
-## 3. Target Users and Primary Use Cases
-
-### Target Users
-
-* **Control room operators / SOC operators**
-  Need to view live events, video, and map, and respond quickly.
-* **Security managers / supervisors**
-  Need higher-level summaries, trends, and reports.
-* **System admins**
-  Manage cameras, users, roles, and integrations.
-
-### Key Use Cases
-
-* Operator monitors live video and map, sees incoming AI-generated events, and decides how to respond.
-* System detects an anomaly on video (e.g., person in restricted zone), automatically creates an event, and visualizes it on the map.
-* Operator filters events by type, time, or area, and reviews history for investigations.
-* Manager exports monthly reports on events by type, location, and severity.
-
----
-
-## 4. System Components (Full Vision)
-
-Below is the full vision of the system, broken down by modules. Later, we will define what the **MVP** includes and what is **phase 2+**.
-
-### 4.1 Video Intelligence
-
-* **Video source connectivity**
-
-  * Connect to IP cameras, VMS systems, or video streams (RTSP, HLS, WebRTC, etc.).
-  * Handle live streams and access historical recordings.
-
-* **Live video viewing**
-
-  * Live video in the web UI from multiple cameras.
-  * Camera selection, switching, possibly grid view (2x2, 3x3).
-
-* **Playback of recorded footage**
-
-  * Timeline-based playback for each camera.
-  * Jump to a specific time (often linked to an event).
-
-* **AI video analytics**
-
-  * Anomaly detection in video streams.
-  * Specific AI tasks:
-
-    * Suspicious motion detection
-    * Abandoned objects
-    * Person detection / people counting
-    * Vehicle detection and classification
-    * License Plate Recognition (LPR)
-    * Face detection and recognition
-  * Generate structured detections (what, when, where, confidence).
-
-* **Event triggering from video**
-
-  * When certain AI detections meet rules/thresholds, an **event** is created automatically, linked to camera & time.
-
-* **Smart video search**
-
-  * Search for relevant segments by:
-
-    * Time range
-    * Object type (person/vehicle)
-    * Event type (e.g., â€œintrusionâ€, â€œabandoned objectâ€)
-  * Use detection metadata to avoid scanning raw video manually.
-
----
-
-### 4.2 GIS and Map Module
-
-* **Interactive base map**
-
-  * Integrate with a GIS provider (Google Maps, Mapbox, ArcGIS, etc.).
-  * Show background map with layers (zones, areas of interest, etc.).
-  * Show camera locations as markers.
-
-* **Events on map**
-
-  * Show active events at their GPS location.
-  * Different icons/colors by event type or severity.
-
-* **Historical locations / tracking**
-
-  * For moving objects (vehicles, persons, assets), show historical paths over time.
-
-* **Search and navigation**
-
-  * Search by address, site name, or GPS coordinates.
-  * Center map on specific camera or event.
-
-* **Geofencing**
-
-  * Define zones (polygons, circles).
-  * Trigger rules when:
-
-    * Something enters a zone
-    * Leaves a zone
-    * Stays too long in a zone
-
----
-
-### 4.3 Event Management
-
-* **Automatic event creation**
-
-  * Events created based on AI detections or sensor triggers.
-  * Each event includes:
-
-    * Time
-    * Camera/source
-    * Location
-    * Type
-    * Possibly snapshot image or video clip.
-
-* **Event classification and categories**
-
-  * Predefined categories: e.g., â€œintrusionâ€, â€œsuspicious behaviorâ€, â€œabandoned objectâ€, â€œvehicle anomalyâ€, etc.
-  * Possibly allow custom categories.
-
-* **Event lifecycle**
-
-  * States like:
-
-    * New
-    * In progress
-    * Resolved
-    * Closed
-  * Optionally assign events to users/teams.
-
-* **Prioritization**
-
-  * Severity or priority levels (e.g., Low/Medium/High, or numeric).
-  * Rules for auto-priority based on type, location, and time.
-
-* **Notifications**
-
-  * Send alerts when new or high-severity events occur:
-
-    * Push notifications
-    * Email
-    * SMS
-    * Possibly integration to other channels later.
-
-* **Logs and audit trail**
-
-  * Store full history of events and all changes.
-  * Who handled which event, when, and what actions they took.
-
----
-
-### 4.4 AI & Analytics
-
-* **Real-time AI**
-
-  * AI models applied on live streams for:
-
-    * Object detection
-    * Intrusion/behavior detection
-    * Face or LPR if required
-  * Output detection events and metadata.
-
-* **Event classification**
-
-  * AI or rule-based classification of events.
-
-* **Trend / pattern analysis**
-
-  * Analyze historical events for:
-
-    * Hotspots on map
-    * Frequent event types
-    * Time-of-day patterns
-
-* **Smart reporting**
-
-  * Generate analytical reports based on repeated patterns and trends.
-
----
-
-### 4.5 Integrations & External Systems
-
-* **VMS integration**
-
-  * Consume streams and/or metadata from an existing video management system.
-
-* **IoT & sensors**
-
-  * Integrate with sensors (e.g., motion sensors, panic buttons, door sensors).
-  * Combine sensor inputs with video-based detections.
-
-* **GIS data integration**
-
-  * Import existing GIS layers (zones, assets, infrastructure).
-
-* **Emergency/CAD systems**
-
-  * Push critical events to emergency dispatch or CAD systems.
-
----
-
-### 4.6 User Interface (Frontend)
-
-* **Dashboard**
-
-  * Overview page:
-
-    * Active events
-    * Live video
-    * Map
-    * Basic KPIs
-
-* **Event view**
-
-  * List of events (filter, sort, search).
-  * Event details page (video snapshot, map location, metadata).
-
-* **Video view**
-
-  * Live video + controls.
-  * Optionally multi-camera views.
-
-* **Map view**
-
-  * Map with cameras and events.
-  * Filters by time, type, severity.
-
-* **Timeline view**
-
-  * Historical navigation of events and video.
-
-* **Responsive design**
-
-  * Desktop first, with support for tablets and possibly mobile.
-
-* **RBAC (Role-Based Access Control)**
-
-  * Different screens and permissions for admins/operators/viewers.
-
----
-
-### 4.7 Security, Infrastructure, and Reporting
-
-* **Security**
-
-  * Authentication (JWT, possibly OAuth2 or SSO).
-  * Authorization (roles/permissions).
-  * Encryption in transit (HTTPS/TLS) and possibly at rest.
-  * Audit logs of user actions.
-
-* **Deployment**
-
-  * Cloud and/or on-premise support.
-  * Potential containers (Docker), orchestration later (Kubernetes).
-
-* **Data retention**
-
-  * Policies for video storage duration.
-  * Policies for event/log retention.
-
-* **Reports & export**
-
-  * Export events and metrics as CSV or PDF.
-  * Configurable periodic reports (monthly, quarterly).
-  * Filtering by user, area, event type, etc.
-
----
-
-## 5. MVP vs Full Project
-
-Below is how the MVP (Minimum Viable Product) differs from the full system.
-
-### 5.1 MVP â€“ What We Include First
-
-**Goal of MVP:**
-A working vertical slice that shows the core value:
-
-* Live video
-* AI detection
-* Automatic event creation
-* Map visualization
-* Basic event management
-* Basic authentication
-
-**MVP Feature Set:**
-
-1. **Video**
-
-   * Connect to a **small number of cameras** (e.g., 1â€“5).
-   * Show **live video** from those cameras in the web UI.
-   * (Optional but nice) Simple playback from either:
-
-     * VMS API, or
-     * Stored short clips.
-
-2. **AI Detection (Single Model)**
-
-   * Focus on **one AI capability** only for MVP, such as:
-
-     * Person/vehicle detection (recommended)
-   * For each detection:
-
-     * Create an event with timestamp, camera, and type.
-
-3. **Basic Event Management**
-
-   * Store events in a database (e.g., MongoDB).
-   * Show event list in the UI with:
-
-     * time
-     * camera
-     * event type
-   * Event details:
-
-     * Basic metadata
-     * Optional snapshot
-   * Simple status:
-
-     * New
-     * (Optionally) Resolved
-
-4. **Map Integration**
-
-   * Use a simple map provider.
-   * Show camera locations.
-   * Highlight cameras with active events.
-
-5. **Dashboard / UI**
-
-   * Main screen with:
-
-     * Live video
-     * Event list
-     * Map tab or section
-   * Simple navigation:
-
-     * Login
-     * Dashboard
-     * Events
-     * Map
-
-6. **Authentication**
-
-   * Basic login with username/password.
-   * Single role or simple distinction (admin vs operator).
-   * JWT-based sessions.
-
-7. **Backend & Architecture**
-
-   * React frontend.
-   * Node.js + Express backend API.
-   * MongoDB for:
-
-     * Users
-     * Cameras
-     * Events
-   * AI service as a separate component/microservice:
-
-     * Receives video frames/stream reference.
-     * Runs the detection model.
-     * Sends detection results to the backend.
-
-8. **Non-functional (MVP)**
-
-   * Not highly optimized.
-   * Work with a limited number of streams.
-   * Focus on **correctness and demonstrability**, not scale.
-
----
-
-### 5.2 Full Project â€“ Later Phases (Beyond MVP)
-
-Later phases can add:
-
-* Multiple AI models:
-
-  * LPR
-  * Face recognition
-  * Abandoned objects
-  * Behavioral anomalies
-* Complex event lifecycle:
-
-  * Assignment
-  * Collaboration
-  * Escalation
-* Full RBAC and SSO integration.
-* Advanced GIS / geofencing / historical tracking.
-* Alert channels (SMS, email, push).
-* CAD integration and IoT/sensor integrations.
-* Sophisticated reports, export, and trend analyses.
-* Performance and scalability enhancements:
-
-  * Distributed processing
-  * High availability
-  * Load balancing
-
----
-
-## 6. Open Questions That Are Still Not Fully Answered
-
-Below is a list of **open-ended questions** that should be clarified with the company. These directly affect architecture and MVP scope.
-
-### 6.1 Video & VMS
-
-1. **Video source details**
-
-   * What protocols are used? (RTSP, HLS, WebRTC, ONVIF, proprietary VMS)
-   * Are we connecting directly to cameras, or to a VMS?
-
-2. **Storage**
-
-   * Who is responsible for storing video?
-
-     * Our platform?
-     * The existing VMS?
-   * Do we need our own archive in MVP, or is it okay to rely on VMS for playback?
-
-3. **Scale**
-
-   * How many cameras must the MVP support?
-   * How many simultaneous live streams will operators view?
-
-4. **Latency**
-
-   * What is the acceptable delay for â€œliveâ€ video?
-
----
-
-### 6.2 AI & Analytics
-
-1. **Model responsibility**
-
-   * Which AI models are provided by the company?
-   * Which AI models are we expected to implement?
-
-2. **MVP AI choice**
-
-   * Which single AI capability should be prioritized for MVP?
-
-     * Person/vehicle detection?
-     * Something else?
-
-3. **Performance and accuracy**
-
-   * Are there target goals for:
-
-     * False positive rate
-     * False negative rate
-   * Is near-real-time acceptable (e.g., analyzing 1â€“5 FPS instead of full 25â€“30 FPS)?
-
-4. **Legal/privacy constraints**
-
-   * Are there limitations on face recognition or LPR in target markets?
-
----
-
-### 6.3 GIS & Location
-
-1. **Map provider**
-
-   * Which provider should we use? (Google Maps, Mapbox, ArcGIS, etc.)
-   * Are there licensing or organizational preferences?
-
-2. **GIS layers**
-
-   * Does the company already have GIS data or layers we should display?
-
-3. **MVP expectations**
-
-   * For MVP, is it enough to:
-
-     * Show cameras and events on the map?
-   * Or do they already expect:
-
-     * Geofencing?
-     * Historical tracks?
-
----
-
-### 6.4 Event Management
-
-1. **Event categories**
-
-   * What are the official categories required?
-   * Is this list fixed or configurable?
-
-2. **Event lifecycle**
-
-   * What statuses are expected?
-
-     * New, acknowledged, in progress, resolved, closed?
-   * What is minimally required in MVP?
-
-3. **Rules**
-
-   * Are there predefined rule sets (e.g., â€œperson in restricted zone after 22:00 = high severityâ€)?
-   * Or is MVP expected to have only simple static rules?
-
-4. **Manual vs automatic events**
-
-   * Can operators manually create events?
-   * Or is MVP purely AI-triggered?
-
----
-
-### 6.5 Alerts and Notifications
-
-1. **Must alerts be included in MVP?**
-
-   * Or is it enough to show events in the UI without external notifications?
-
-2. **Channels**
-
-   * If alerts are required:
-
-     * Do we need SMS? Email? Push? Web UI only?
-
-3. **Urgency**
-
-   * How fast should alerts be delivered?
-
----
-
-### 6.6 UI/UX
-
-1. **Primary users for MVP**
-
-   * Are we targeting:
-
-     * Control room operators?
-     * Field users?
-     * Managers?
-
-2. **Priority views**
-
-   * What is the most important screen they expect to see first?
-
-     * Video-focused?
-     * Event-focused?
-     * Map-focused?
-
-3. **Design**
-
-   * Is there an existing design system or branding?
-   * Do they expect dark mode for MVP?
-
-4. **Languages**
-
-   * Must we support multiple languages (e.g., Hebrew + English) in MVP?
-
----
-
-### 6.7 Security & Deployment
-
-1. **Authentication**
-
-   * Is basic username/password enough for MVP?
-   * Or do they require OAuth2 / SSO already?
-
-2. **Deployment environment**
-
-   * Will MVP be deployed in:
-
-     * Cloud (which provider)?
-     * On-premise at client sites?
-   * Any restrictions on tech choices?
-
-3. **Compliance**
-
-   * Are there specific regulations we must consider from day one? (e.g., GDPR, local privacy laws)
-
----
-
-### 6.8 Reporting and History
-
-1. **Reports in MVP**
-
-   * Do they expect any form of reporting in MVP (e.g., daily/weekly event summary)?
-   * Or is MVP focused purely on real-time operations?
-
-2. **Export**
-
-   * Is CSV/PDF export required in MVP?
-
----
-
-## 7. Summary
-
-* The platform is a **real-time AI-powered event monitoring system** combining video, map, and events.
-* The **MVP** focuses on a **small but complete vertical slice**:
-
-  * Live video from a few cameras
-  * A single AI detection model
-  * Automatic event creation
-  * Basic event list and details
-  * Basic map with cameras and event highlighting
-  * Simple authentication and a dashboard
-* The **full project** includes advanced AI, rich GIS capabilities, deeper event workflows, integrations, security hardening, and complex reporting.
-* Several **critical questions remain open**, especially regarding:
-
-  * Video source & storage
-  * Chosen AI model for MVP
-  * GIS provider
-  * Exact event workflow
-  * MVP expectations for alerts and reports
-  * Deployment and security constraints
-
-This document should give enough context for an agent to:
-
-* Generate architecture diagrams
-* Suggest implementation plans
-* Help refine requirements and identify risks
-* Propose data models and API designs for the MVP and beyond.
+Hereâ€™s a full, self-contained explanation you can copy into a text file and give to another agent.
+Iâ€™ll write it as if itâ€™s a **project spec + context document**.
+
+---
+
+## 1. Project Overview
+
+We are building an **Event Monitoring and Management Platform** that combines:
+
+* **Live video streams** from cameras (IP, VMS, security cameras, etc.)
+* **AI-based video analytics** to detect people, vehicles, suspicious behavior, and other anomalies
+* **A GIS map** that visualizes cameras and events in their geographic context
+* **An event management system** that logs, classifies, prioritizes, and tracks incidents
+* **Dashboards and KPIs** for operators and managers
+* **Integrations** with external systems (VMS, GIS providers, IoT devices, and emergency dispatch/CAD)
+
+The platform is intended for **real-time monitoring of environmental/safety/security events**, for example:
+
+* Smart cities and municipalities
+* Critical infrastructure (ports, industrial sites, campuses)
+* Security operation centers (SOC)
+* Public safety monitoring
+
+The system will eventually support **real-time operations** (live view and alerts) **and offline analysis** (history, trends, reports).
+
+---
+
+## 2. High-Level Goals
+
+1. **Real-time situational awareness**
+   Combine video, map, and events in a unified view so operators can quickly understand what is happening, where, and how severe it is.
+
+2. **AI-assisted detection and decision support**
+   Use AI to automatically detect relevant events (e.g., person detected in restricted area, abandoned object, suspicious motion, specific vehicles), create events, and support prioritization.
+
+3. **Efficient event lifecycle management**
+   Allow operators to review, classify, prioritize, and resolve events, and to maintain a full history for investigation and analysis.
+
+4. **Scalable integration with external systems**
+   Integrate with:
+
+   * Existing VMS (Video Management Systems)
+   * IoT sensors
+   * GIS data sources
+   * Emergency response systems (CAD)
+
+5. **Reporting and insights**
+   Provide dashboards and reports for management: trends over time, hotspots, repeated issues, response metrics, etc.
+
+---
+
+## 3. Target Users and Primary Use Cases
+
+### Target Users
+
+* **Control room operators / SOC operators**
+  Need to view live events, video, and map, and respond quickly.
+* **Security managers / supervisors**
+  Need higher-level summaries, trends, and reports.
+* **System admins**
+  Manage cameras, users, roles, and integrations.
+
+### Key Use Cases
+
+* Operator monitors live video and map, sees incoming AI-generated events, and decides how to respond.
+* System detects an anomaly on video (e.g., person in restricted zone), automatically creates an event, and visualizes it on the map.
+* Operator filters events by type, time, or area, and reviews history for investigations.
+* Manager exports monthly reports on events by type, location, and severity.
+
+---
+
+## 4. System Components (Full Vision)
+
+Below is the full vision of the system, broken down by modules. Later, we will define what the **MVP** includes and what is **phase 2+**.
+
+### 4.1 Video Intelligence
+
+* **Video source connectivity**
+
+  * Connect to IP cameras, VMS systems, or video streams (RTSP, HLS, WebRTC, etc.).
+  * Handle live streams and access historical recordings.
+
+* **Live video viewing**
+
+  * Live video in the web UI from multiple cameras.
+  * Camera selection, switching, possibly grid view (2x2, 3x3).
+
+* **Playback of recorded footage**
+
+  * Timeline-based playback for each camera.
+  * Jump to a specific time (often linked to an event).
+
+* **AI video analytics**
+
+  * Anomaly detection in video streams.
+  * Specific AI tasks:
+
+    * Suspicious motion detection
+    * Abandoned objects
+    * Person detection / people counting
+    * Vehicle detection and classification
+    * License Plate Recognition (LPR)
+    * Face detection and recognition
+  * Generate structured detections (what, when, where, confidence).
+
+* **Event triggering from video**
+
+  * When certain AI detections meet rules/thresholds, an **event** is created automatically, linked to camera & time.
+
+* **Smart video search**
+
+  * Search for relevant segments by:
+
+    * Time range
+    * Object type (person/vehicle)
+    * Event type (e.g., â€œintrusionâ€, â€œabandoned objectâ€)
+  * Use detection metadata to avoid scanning raw video manually.
+
+---
+
+### 4.2 GIS and Map Module
+
+* **Interactive base map**
+
+  * Integrate with a GIS provider (Google Maps, Mapbox, ArcGIS, etc.).
+  * Show background map with layers (zones, areas of interest, etc.).
+  * Show camera locations as markers.
+
+* **Events on map**
+
+  * Show active events at their GPS location.
+  * Different icons/colors by event type or severity.
+
+* **Historical locations / tracking**
+
+  * For moving objects (vehicles, persons, assets), show historical paths over time.
+
+* **Search and navigation**
+
+  * Search by address, site name, or GPS coordinates.
+  * Center map on specific camera or event.
+
+* **Geofencing**
+
+  * Define zones (polygons, circles).
+  * Trigger rules when:
+
+    * Something enters a zone
+    * Leaves a zone
+    * Stays too long in a zone
+
+---
+
+### 4.3 Event Management
+
+* **Automatic event creation**
+
+  * Events created based on AI detections or sensor triggers.
+  * Each event includes:
+
+    * Time
+    * Camera/source
+    * Location
+    * Type
+    * Possibly snapshot image or video clip.
+
+* **Event classification and categories**
+
+  * Predefined categories: e.g., â€œintrusionâ€, â€œsuspicious behaviorâ€, â€œabandoned objectâ€, â€œvehicle anomalyâ€, etc.
+  * Possibly allow custom categories.
+
+* **Event lifecycle**
+
+  * States like:
+
+    * New
+    * In progress
+    * Resolved
+    * Closed
+  * Optionally assign events to users/teams.
+
+* **Prioritization**
+
+  * Severity or priority levels (e.g., Low/Medium/High, or numeric).
+  * Rules for auto-priority based on type, location, and time.
+
+* **Notifications**
+
+  * Send alerts when new or high-severity events occur:
+
+    * Push notifications
+    * Email
+    * SMS
+    * Possibly integration to other channels later.
+
+* **Logs and audit trail**
+
+  * Store full history of events and all changes.
+  * Who handled which event, when, and what actions they took.
+
+---
+
+### 4.4 AI & Analytics
+
+* **Real-time AI**
+
+  * AI models applied on live streams for:
+
+    * Object detection
+    * Intrusion/behavior detection
+    * Face or LPR if required
+  * Output detection events and metadata.
+
+* **Event classification**
+
+  * AI or rule-based classification of events.
+
+* **Trend / pattern analysis**
+
+  * Analyze historical events for:
+
+    * Hotspots on map
+    * Frequent event types
+    * Time-of-day patterns
+
+* **Smart reporting**
+
+  * Generate analytical reports based on repeated patterns and trends.
+
+---
+
+### 4.5 Integrations & External Systems
+
+* **VMS integration**
+
+  * Consume streams and/or metadata from an existing video management system.
+
+* **IoT & sensors**
+
+  * Integrate with sensors (e.g., motion sensors, panic buttons, door sensors).
+  * Combine sensor inputs with video-based detections.
+
+* **GIS data integration**
+
+  * Import existing GIS layers (zones, assets, infrastructure).
+
+* **Emergency/CAD systems**
+
+  * Push critical events to emergency dispatch or CAD systems.
+
+---
+
+### 4.6 User Interface (Frontend)
+
+* **Dashboard**
+
+  * Overview page:
+
+    * Active events
+    * Live video
+    * Map
+    * Basic KPIs
+
+* **Event view**
+
+  * List of events (filter, sort, search).
+  * Event details page (video snapshot, map location, metadata).
+
+* **Video view**
+
+  * Live video + controls.
+  * Optionally multi-camera views.
+
+* **Map view**
+
+  * Map with cameras and events.
+  * Filters by time, type, severity.
+
+* **Timeline view**
+
+  * Historical navigation of events and video.
+
+* **Responsive design**
+
+  * Desktop first, with support for tablets and possibly mobile.
+
+* **RBAC (Role-Based Access Control)**
+
+  * Different screens and permissions for admins/operators/viewers.
+
+---
+
+### 4.7 Security, Infrastructure, and Reporting
+
+* **Security**
+
+  * Authentication (JWT, possibly OAuth2 or SSO).
+  * Authorization (roles/permissions).
+  * Encryption in transit (HTTPS/TLS) and possibly at rest.
+  * Audit logs of user actions.
+
+* **Deployment**
+
+  * Cloud and/or on-premise support.
+  * Potential containers (Docker), orchestration later (Kubernetes).
+
+* **Data retention**
+
+  * Policies for video storage duration.
+  * Policies for event/log retention.
+
+* **Reports & export**
+
+  * Export events and metrics as CSV or PDF.
+  * Configurable periodic reports (monthly, quarterly).
+  * Filtering by user, area, event type, etc.
+
+---
+
+## 5. MVP vs Full Project
+
+Below is how the MVP (Minimum Viable Product) differs from the full system.
+
+### 5.1 MVP â€“ What We Include First
+
+**Goal of MVP:**
+A working vertical slice that shows the core value:
+
+* Live video
+* AI detection
+* Automatic event creation
+* Map visualization
+* Basic event management
+* Basic authentication
+
+**MVP Feature Set:**
+
+1. **Video**
+
+   * Connect to a **small number of cameras** (e.g., 1â€“5).
+   * Show **live video** from those cameras in the web UI.
+   * (Optional but nice) Simple playback from either:
+
+     * VMS API, or
+     * Stored short clips.
+
+2. **AI Detection (Single Model)**
+
+   * Focus on **one AI capability** only for MVP, such as:
+
+     * Person/vehicle detection (recommended)
+   * For each detection:
+
+     * Create an event with timestamp, camera, and type.
+
+3. **Basic Event Management**
+
+   * Store events in a database (e.g., MongoDB).
+   * Show event list in the UI with:
+
+     * time
+     * camera
+     * event type
+   * Event details:
+
+     * Basic metadata
+     * Optional snapshot
+   * Simple status:
+
+     * New
+     * (Optionally) Resolved
+
+4. **Map Integration**
+
+   * Use a simple map provider.
+   * Show camera locations.
+   * Highlight cameras with active events.
+
+5. **Dashboard / UI**
+
+   * Main screen with:
+
+     * Live video
+     * Event list
+     * Map tab or section
+   * Simple navigation:
+
+     * Login
+     * Dashboard
+     * Events
+     * Map
+
+6. **Authentication**
+
+   * Basic login with username/password.
+   * Single role or simple distinction (admin vs operator).
+   * JWT-based sessions.
+
+7. **Backend & Architecture**
+
+   * React frontend.
+   * Node.js + Express backend API.
+   * MongoDB for:
+
+     * Users
+     * Cameras
+     * Events
+   * AI service as a separate component/microservice:
+
+     * Receives video frames/stream reference.
+     * Runs the detection model.
+     * Sends detection results to the backend.
+
+8. **Non-functional (MVP)**
+
+   * Not highly optimized.
+   * Work with a limited number of streams.
+   * Focus on **correctness and demonstrability**, not scale.
+
+---
+
+### 5.2 Full Project â€“ Later Phases (Beyond MVP)
+
+Later phases can add:
+
+* Multiple AI models:
+
+  * LPR
+  * Face recognition
+  * Abandoned objects
+  * Behavioral anomalies
+* Complex event lifecycle:
+
+  * Assignment
+  * Collaboration
+  * Escalation
+* Full RBAC and SSO integration.
+* Advanced GIS / geofencing / historical tracking.
+* Alert channels (SMS, email, push).
+* CAD integration and IoT/sensor integrations.
+* Sophisticated reports, export, and trend analyses.
+* Performance and scalability enhancements:
+
+  * Distributed processing
+  * High availability
+  * Load balancing
+
+---
+
+## 6. Open Questions That Are Still Not Fully Answered
+
+Below is a list of **open-ended questions** that should be clarified with the company. These directly affect architecture and MVP scope.
+
+### 6.1 Video & VMS
+
+1. **Video source details**
+
+   * What protocols are used? (RTSP, HLS, WebRTC, ONVIF, proprietary VMS)
+   * Are we connecting directly to cameras, or to a VMS?
+
+2. **Storage**
+
+   * Who is responsible for storing video?
+
+     * Our platform?
+     * The existing VMS?
+   * Do we need our own archive in MVP, or is it okay to rely on VMS for playback?
+
+3. **Scale**
+
+   * How many cameras must the MVP support?
+   * How many simultaneous live streams will operators view?
+
+4. **Latency**
+
+   * What is the acceptable delay for â€œliveâ€ video?
+
+---
+
+### 6.2 AI & Analytics
+
+1. **Model responsibility**
+
+   * Which AI models are provided by the company?
+   * Which AI models are we expected to implement?
+
+2. **MVP AI choice**
+
+   * Which single AI capability should be prioritized for MVP?
+
+     * Person/vehicle detection?
+     * Something else?
+
+3. **Performance and accuracy**
+
+   * Are there target goals for:
+
+     * False positive rate
+     * False negative rate
+   * Is near-real-time acceptable (e.g., analyzing 1â€“5 FPS instead of full 25â€“30 FPS)?
+
+4. **Legal/privacy constraints**
+
+   * Are there limitations on face recognition or LPR in target markets?
+
+---
+
+### 6.3 GIS & Location
+
+1. **Map provider**
+
+   * Which provider should we use? (Google Maps, Mapbox, ArcGIS, etc.)
+   * Are there licensing or organizational preferences?
+
+2. **GIS layers**
+
+   * Does the company already have GIS data or layers we should display?
+
+3. **MVP expectations**
+
+   * For MVP, is it enough to:
+
+     * Show cameras and events on the map?
+   * Or do they already expect:
+
+     * Geofencing?
+     * Historical tracks?
+
+---
+
+### 6.4 Event Management
+
+1. **Event categories**
+
+   * What are the official categories required?
+   * Is this list fixed or configurable?
+
+2. **Event lifecycle**
+
+   * What statuses are expected?
+
+     * New, acknowledged, in progress, resolved, closed?
+   * What is minimally required in MVP?
+
+3. **Rules**
+
+   * Are there predefined rule sets (e.g., â€œperson in restricted zone after 22:00 = high severityâ€)?
+   * Or is MVP expected to have only simple static rules?
+
+4. **Manual vs automatic events**
+
+   * Can operators manually create events?
+   * Or is MVP purely AI-triggered?
+
+---
+
+### 6.5 Alerts and Notifications
+
+1. **Must alerts be included in MVP?**
+
+   * Or is it enough to show events in the UI without external notifications?
+
+2. **Channels**
+
+   * If alerts are required:
+
+     * Do we need SMS? Email? Push? Web UI only?
+
+3. **Urgency**
+
+   * How fast should alerts be delivered?
+
+---
+
+### 6.6 UI/UX
+
+1. **Primary users for MVP**
+
+   * Are we targeting:
+
+     * Control room operators?
+     * Field users?
+     * Managers?
+
+2. **Priority views**
+
+   * What is the most important screen they expect to see first?
+
+     * Video-focused?
+     * Event-focused?
+     * Map-focused?
+
+3. **Design**
+
+   * Is there an existing design system or branding?
+   * Do they expect dark mode for MVP?
+
+4. **Languages**
+
+   * Must we support multiple languages (e.g., Hebrew + English) in MVP?
+
+---
+
+### 6.7 Security & Deployment
+
+1. **Authentication**
+
+   * Is basic username/password enough for MVP?
+   * Or do they require OAuth2 / SSO already?
+
+2. **Deployment environment**
+
+   * Will MVP be deployed in:
+
+     * Cloud (which provider)?
+     * On-premise at client sites?
+   * Any restrictions on tech choices?
+
+3. **Compliance**
+
+   * Are there specific regulations we must consider from day one? (e.g., GDPR, local privacy laws)
+
+---
+
+### 6.8 Reporting and History
+
+1. **Reports in MVP**
+
+   * Do they expect any form of reporting in MVP (e.g., daily/weekly event summary)?
+   * Or is MVP focused purely on real-time operations?
+
+2. **Export**
+
+   * Is CSV/PDF export required in MVP?
+
+---
+
+## 7. Summary
+
+* The platform is a **real-time AI-powered event monitoring system** combining video, map, and events.
+* The **MVP** focuses on a **small but complete vertical slice**:
+
+  * Live video from a few cameras
+  * A single AI detection model
+  * Automatic event creation
+  * Basic event list and details
+  * Basic map with cameras and event highlighting
+  * Simple authentication and a dashboard
+* The **full project** includes advanced AI, rich GIS capabilities, deeper event workflows, integrations, security hardening, and complex reporting.
+* Several **critical questions remain open**, especially regarding:
+
+  * Video source & storage
+  * Chosen AI model for MVP
+  * GIS provider
+  * Exact event workflow
+  * MVP expectations for alerts and reports
+  * Deployment and security constraints
+
+This document should give enough context for an agent to:
+
+* Generate architecture diagrams
+* Suggest implementation plans
+* Help refine requirements and identify risks
+* Propose data models and API designs for the MVP and beyond.
diff --git "a/chatdetails/\327\252\327\231\327\247 \327\220\327\244\327\231\327\225\327\237 \327\246\327\225\327\225\327\252 A(1).txt" "b/chatdetails/\327\252\327\231\327\247 \327\220\327\244\327\231\327\225\327\237 \327\246\327\225\327\225\327\252 A(1).txt"
new file mode 100644
index 0000000..c20e2ca
--- /dev/null
+++ "b/chatdetails/\327\252\327\231\327\247 \327\220\327\244\327\231\327\225\327\237 \327\246\327\225\327\225\327\252 A(1).txt"	
@@ -0,0 +1,1202 @@
+ï»¿×¦×•×•×ª: karim zeidan ,boaz rosiner, mor korem, shahar lankry, yotam shpilman 
+×¨××© ×¦×•×•×ª: karim zeidan
+    ×¤×¨×§ 1: ×™×–×•×
+×ª×™××•×¨ ×›×œ×œ×™
+×ª×™××•×¨ ×›×œ×œ×™ ×©×œ ×”×¤×¨×•×™×§×˜ shob web:
+×›×œ×™ ×©×× ×˜×¨ ××™×¨×•×¢×™× ××”×©×˜×— ×‘×××¦×¢×•×ª ×©×™×œ×•×‘ ×©×œ ×•×™×“××• ×—×™, ××¤×•×ª GIS ×•×™×›×•×œ×•×ª AI, ×›×“×™ ×œ×–×”×•×ª ×—×¨×™×’×•×ª ×‘×–××Ÿ ×××ª, ×œ×”×¦×™×’ ××•×ª×Ÿ ×‘×¦×•×¨×” ×•×™×–×•××œ×™×ª ×•×‘×¨×•×¨×”, ×•×œ××¤×©×¨ ×œ×× ×”×œ×™× ×œ×§×‘×œ ×”×—×œ×˜×•×ª ××”×™×¨×•×ª ×•××‘×•×¡×¡×•×ª × ×ª×•× ×™×.
+	××˜×¨×ª ×”×¤×¨×•×™×§×˜
+×›×ª×‘×• ×¤×¡×§×” ×§×¦×¨×” ×”××ª××¨×ª ××ª ××˜×¨×ª ×”×¤×¨×•×™×§×˜ shob web:
+ ×”×¤×¨×•×™×§×˜ SHOB Web × ×•×¢×“ ×œ×™×¦×•×¨ ×¤×œ×˜×¤×•×¨××” ×—×›××” ×œ× ×™×˜×•×¨ ×•× ×™×”×•×œ ××™×¨×•×¢×™× ×‘×–××Ÿ ×××ª, ×”××‘×•×¡×¡×ª ×¢×œ ×©×™×œ×•×‘ ×©×œ ×•×™×“××• ×—×™, × ×ª×•× ×™ ××™×§×•× ×•×™×›×•×œ×•×ª AI. ×”××¢×¨×›×ª ×××¤×©×¨×ª ×œ×–×”×•×ª ×—×¨×™×’×•×ª ×‘××•×¤×Ÿ ××•×˜×•××˜×™, ×œ×”×¦×™×’ ××•×ª×Ÿ ×¢×œ ××¤×” ××™× ×˜×¨××§×˜×™×‘×™×ª, ×•×œ×¡×¤×§ ×œ××©×ª××©×™× ×ª××•× ×ª ××¦×‘ ××™×™×“×™×ª ×©×ª×•××›×ª ×‘×§×‘×œ×ª ×”×—×œ×˜×•×ª ××”×™×¨×” ×•×™×¢×™×œ×”.
+	×§×”×œ ×”×™×¢×“ 
+×ª××¨×• ××ª ×§×”×œ ×”×™×¢×“ ×•×¡×•×’ ×”××©×ª××©×™× ×©×¦×¤×•×™ ×œ×”×©×ª××© ×‘shob web:
+×§×”×œ ×”×™×¢×“ ×”×¢×™×§×¨×™ ×©×œ SHOB Web ×”×•× ×’×•×¨××™ ×‘×™×˜×—×•×Ÿ, ××•×§×“×™ ×©×œ×™×˜×” ×•××¨×’×•× ×™× ×ª×¤×¢×•×œ×™×™×, ×‘×¢×œ×™ ×™×“×¢ ×‘×¡×™×¡×™ ×¢×“ ×‘×™× ×•× ×™ ×‘×”×¤×¢×œ×ª ××¢×¨×›×•×ª × ×™×˜×•×¨, ××¤×•×ª ×•×™×™×©×•××™ ×•×™×“××•. ×”××©×ª××©×™× ×”×¢×™×§×¨×™×™× ×¦×¤×•×™×™× ×œ×”×™×•×ª ××¤×¢×™×œ×™ ×—×“×¨×™ ×‘×§×¨×”, ×× ×”×œ×™ ××‘×˜×—×” ×•×’×•×¨××™ ×©×˜×— ×”×–×§×•×§×™× ×œ×ª××•× ×ª ××¦×‘ ×‘×–××Ÿ ×××ª. ×§×”×œ ×”×™×¢×“ ×”××©× ×™ ×›×•×œ×œ ×× ×”×œ×™× ×‘×›×™×¨×™×, ×× ×©×™ × ×™×ª×•×— × ×ª×•× ×™× ×•×¦×•×•×ª×™ IT, ××©×¨ ×™×¢×–×¨×• ×‘××¢×¨×›×ª ×œ×¦×•×¨×š ×‘×§×¨×”, ×”×¤×§×ª ×“×•×—×•×ª, ×ª×—×§×•×¨ ××™×¨×•×¢×™× ×•×§×‘×œ×ª ×”×—×œ×˜×•×ª ××¡×˜×¨×˜×’×™×•×ª. ×‘××¢×¨×›×ª ×§×™×™××™× ×¡×•×’×™ ××©×ª××©×™× ×©×•× ×™×, ×›××• ××¤×¢×™×œ×™×, ×× ×”×œ×™× ×•×× ×œ×™×¡×˜×™×, ×©×œ×›×œ ××—×“ ××”× ×××©×§×™ ×¢×‘×•×“×” ×•×”×¨×©××•×ª ×”××ª××™××™× ×œ×ª×¤×§×™×“×•.
+	×œ×™×‘×” ×˜×›× ×•×œ×•×’×™×ª
+×”×œ×™×‘×” ×”×˜×›× ×•×œ×•×’×™×ª ×”×™× ×¤×™×¦'×¨ ××• ×™×›×•×œ×ª ××©××¢×•×ª×™×ª ×‘shob web. ×ª××¨×• ××ª ×”×œ×™×‘×” ×”×˜×›× ×•×œ×•×’×™×ª ×©×œ shob web:
+×”×œ×™×‘×” ×”×˜×›× ×•×œ×•×’×™×ª ×©×œ SHOB Web ×”×™× ×”×™×›×•×œ×ª ×œ×—×‘×¨ ×‘×™×Ÿ ××™×“×¢ ×•×™×“××• ×—×™ ×œ×‘×™×Ÿ ××™×§×•× ×’×™××•×’×¨×¤×™ ×‘×–××Ÿ ×××ª, ×œ×–×”×•×ª ××•×˜×•××˜×™×ª ×—×¨×™×’×•×ª ×‘×××¦×¢×•×ª ××•×“×œ×™ AI, ×•×œ×”××™×¨ ××•×ª×Ÿ ×œ××™×¨×•×¢×™× ×‘×¨×•×¨×™× ×©××•×¦×’×™× ×¢×œ ××¤×” ××™× ×˜×¨××§×˜×™×‘×™×ª ×‘××˜×¨×” ×œ××¤×©×¨ ×ª×’×•×‘×” ××”×™×¨×”, ××“×•×™×§×ª ×•××‘×•×¡×¡×ª × ×ª×•× ×™×.
+	×˜×›× ×•×œ×•×’×™×•×ª ×¢×™×§×¨×™×•×ª
+×ª××¨×• ××ª ×”×˜×›× ×•×œ×•×’×™×•×ª ×”×¢×™×§×¨×™×•×ª ×‘×”×Ÿ ×ª×©×ª××©×• ×œ×˜×•×‘×ª ×¤×™×ª×•×— ×”×œ×™×‘×” ×”×˜×›× ×•×œ×•×’×™×ª (×©×¤×•×ª ×ª×›× ×•×ª, ×¡×¤×¨×™×•×ª ×§×•×“, × ×•×©××™ ×ª×•×›×Ÿ), ×•××ª ×”×©×™×§×•×œ×™× ×œ×‘×—×™×¨×” ×‘×”×Ÿ:
+React
+ ×˜×›× ×•×œ×•×’×™×” ×œ×‘× ×™×™×ª ×××©×§×™ ××©×ª××© ××™× ×˜×¨××§×˜×™×‘×™×™×. ×ª××¤×©×¨ ×œ×™×¦×•×¨ Dashboard ×“×™× ×××™, ××¤×” ××™× ×˜×¨××§×˜×™×‘×™×ª ×•×ª×¦×•×’×ª ×•×™×“××• ×‘×–××Ÿ ×××ª. ×‘×—×¨× ×• ×‘×” ×‘×’×œ×œ ×¤×™×ª×•×— ××”×™×¨ ×©×œ ×¨×›×™×‘×™×, ×§×”×™×œ×” ×¨×—×‘×” ×•×ª××™×›×” ××¦×•×™× ×ª ×‘×›×œ×™× ×’×¨×¤×™×™× ×•×¡×¤×¨×™×•×ª GIS.
+Node.js
+ ×¡×‘×™×‘×ª ×¨×™×¦×” ×œ-JavaScript ×‘×¦×“ ×”×©×¨×ª ×©×ª× ×”×œ ××ª ×”×–×¨×™××” ×‘×™×Ÿ ××§×•×¨×•×ª ×”×•×•×™×“××•, ×”-API, ×”×œ×•×’×™×§×•×ª ×©×œ ×”××¢×¨×›×ª ×•×”××™×¨×•×¢×™× ×‘×–××Ÿ ×××ª. ×‘×—×¨× ×• ×‘×” ×‘×’×œ×œ ×”×¢×‘×•×“×” ×”××—×™×“×” ×‘-JavaScript, ×”×‘×™×¦×•×¢×™× ×”×’×‘×•×”×™× ×•×™×›×•×œ×ª ×˜×•×‘×” ×œ×˜×¤×œ ×‘×ª×§×©×•×¨×ª Real Time.
+MongoDB
+ ××¡×“ × ×ª×•× ×™× NoSQL ×©×‘×• ×™××•×—×¡× ×• ××™×¨×•×¢×™×, ×œ×•×’×™×, ××©×ª××©×™×, × ×ª×•× ×™ ××™×§×•× ×•××™×“×¢ ×”×™×¡×˜×•×¨×™. ×‘×—×¨× ×• ×‘×• ×‘×’×œ×œ ×”×’××™×©×•×ª ×©×œ ××‘× ×” ×”××¡××›×™× ×•×”×ª×××” ××¦×•×™× ×ª ×œ× ×ª×•× ×™× ×œ× ××—×™×“×™× ×›××• ×•×™×“××• ×•××˜×-×“××˜×”.
+Passport.js
+ ×¡×¤×¨×™×™×ª ××•×ª× ×˜×™×§×¦×™×” ×œ-Node.js ×”×××¤×©×¨×ª ×©×™×œ×•×‘ ×§×œ ×©×œ JWT, ×¡×™×¡××” ×‘×¡×™×¡×™×ª ××• OAuth2. ×‘×—×¨× ×• ×‘×” ×›×™ ×”×™× ×¤×©×•×˜×” ×œ×©×™××•×©, ××©×ª×œ×‘×ª ×‘×§×œ×•×ª ×¢× Express ×•××¡×¤×§×ª ×©×›×‘×ª ××‘×˜×—×” ××•×›× ×” ×•×™×¦×™×‘×” ×‘×œ×™ ×©× ×¦×˜×¨×š ×œ×›×ª×•×‘ ××ª ×›×œ ×”×× ×’× ×•×Ÿ ×××¤×¡.
+________________
+
+
+×× ×—× ×• ××ª×œ×‘×˜×™× ×× ×œ×”×©×ª××© ×‘:
+×¡×¤×¨×™×•×ª GIS ×›××• Mapbox ××• Leaflet
+ ×©××¦×™×’×•×ª ××¤×•×ª ××™× ×˜×¨××§×˜×™×‘×™×•×ª ×•×©×›×‘×•×ª ××™×“×¢. ×”×”×ª×œ×‘×˜×•×ª × ×•×‘×¢×ª ××”×‘×“×œ×™× ×‘×™×Ÿ ×¢×œ×•×ª, ×‘×™×¦×•×¢×™×, ×§×œ×•×ª ××™× ×˜×’×¨×¦×™×” ×œ-React, ×•×”×× × ×“×¨×© ×××™×ª× ×• ×’×™××•×¤× ×¡×™× ×’ ××ª×§×“× ×‘×¦×“ ×”×œ×§×•×—.
+×¡×¤×¨×™×•×ª ×•×™×“××• ×›××• FFmpeg ××• WebRTC
+ ×©×××¤×©×¨×•×ª ×¡×˜×¨×™××™× ×’ ×•×¢×™×‘×•×“ ×•×™×“××• ×—×™. ×”×”×ª×œ×‘×˜×•×ª ×”×™× ×”×× × ×¦×˜×¨×š ×©×œ×™×˜×” ××œ××” ×‘×–×¨××™× ××• ×©× ×§×‘×œ API ××•×›×Ÿ ××”××¢×¨×›×ª ×”×—×™×¦×•× ×™×ª, ××” ×©×™×©×¤×™×¢ ×¢×œ ×¨××ª ×”××•×¨×›×‘×•×ª ×•×”×¢×•××¡ ×‘×¦×“ ×”×©×¨×ª.
+	
+
+________________
+  
+
+  ×¤×¨×§ 2: ××¤×™×•×Ÿ
+×¤×™×¦'×¨×™× ×•×ª×”×œ×™×›×™× ×¢×™×§×¨×™×™×
+×›×ª×‘×• ×¨×©×™××” ×©×œ ×›×œ ×”×¤×™×¦'×¨×™× ×‘×¤×¨×•×™×§×˜ shob web. ×¢×‘×•×¨ ×›×œ ×¤×™×¦'×¨ ×‘×¨×©×™××” ×”×¡×‘×™×¨×• ××” ×”×¤×™×¦'×¨ ×•×ª××¨×• ××ª ×”×ª×”×œ×™×š ×”×˜×›× ×™ ×©××ª×¨×—×© ×××—×•×¨×™×•. ×¢×‘×•×¨ ×›×œ ×¤×™×¦'×¨ ××œ××• ××ª ×”×¡×¢×™×¤×™× ×”×‘××™×:
+* ××” ×”×§×œ×˜?
+* ××” ×”×¤×œ×˜?
+* ××” ×”×•× ×¢×•×©×”? (×¡×“×¨ ×¤×¢×•×œ×•×ª)
+* ××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? (×¤×™×–×™×ª ××™×š × ×××©)
+×•×™×“××• ×—×›×:
+1. ×—×™×‘×•×¨ ×œ××§×•×¨×•×ª ×•×™×“××• ×—×™×¦×•× ×™×™× (××¦×œ××•×ª IP, VMS ×•×›×•'):
+××” ×”×§×œ×˜? ×¤×™×“×™× ×××¦×œ××•×ª ×¨×—×•×‘ ×•××¦×œ××•×ª ××‘×˜×—×”, ×¤×¨×˜×™ ××™×§×•× ×•×–××Ÿ ×¦×™×œ×•×.
+××” ×”×¤×œ×˜? ×©×™×“×•×¨ ×—×™ ××”××¦×œ××•×ª ×”×©×•× ×•×ª
+××” ×”×•× ×¢×•×©×”? ×¤×¤×•× ×” ×œ×©×¨×ª ×”×××—×¡×Ÿ ×¤×™×“×™× ×××¦×œ××•×ª ×›×“×™ ×œ×§×¨×•×, ×œ× ×ª×— ×•×œ××—×¡×Ÿ ××™×“×¢ (××™×–×” ××¦×œ××”, ××™×§×•×, ×–××Ÿ).
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×œ×™×—×ª ×‘×§×©×•×ª ×œ×©×¨×ª ×”××—×¡×•×Ÿ ×‘××™× ×˜×¨×•×•×œ×™× ×§×¦×¨×™× ×›×“×™ ×œ× ×œ×”×¢××™×¡ ×¢×œ ×”××¢×¨×›×ª, ×”×¢×©×¨×ª ×”× ×ª×•× ×™× ×•×”×¢×‘×¨×ª× ×œ×”××©×š ×¢×™×‘×•×“ ×•×©××™×¨×” ×‘××¡×“ ×”× ×ª×•× ×™×.
+
+2. ×¦×¤×™×™×” ×‘×©×™×“×•×¨ ×—×™:
+××” ×”×§×œ×˜? ×¤×™×“×™× ×—×™×™× ×××¦×œ××•×ª ×”××—×•×‘×¨×•×ª ×œ××¢×¨×›×ª.
+××” ×”×¤×œ×˜? ×•×™×“××• ×‘×–××Ÿ ×××ª ×‘××¡×š ×”××©×ª××© (Dashboard).
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×œ××©×ª××© ×œ×¦×¤×•×ª ×‘××ª×¨×—×© ×‘×©×˜×— ×‘×–××Ÿ ×××ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘-WebRTC ××• ×¡×˜×¨×™××™× ×’ ××‘×•×¡×¡ HTTP ×œ×œ×§×•×—, ×—×™×‘×•×¨ ×œ×©×¨×ª ×”×•×™×“××• ×•×”×ª×××” ×œ×¤×œ×˜×¤×•×¨××•×ª ×©×•× ×•×ª.
+
+3. ×¤×œ×™×™×‘×§ ×©×œ ×”×§×œ×˜×•×ª ×”×™×¡×˜×•×¨×™×•×ª:
+××” ×”×§×œ×˜? ×”×§×œ×˜×•×ª ×™×©× ×•×ª ×”×××•×—×¡× ×•×ª ×‘×××’×¨ ×”×•×™×“××•.
+××” ×”×¤×œ×˜? × ×™×’×•×Ÿ ×•×™×“××• ×”×™×¡×˜×•×¨×™ ×œ××©×ª××©.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×¦×¤×™×™×” ×—×•×–×¨×ª ×‘××™×¨×•×¢×™× ×©×”×ª×¨×—×©×• ×‘×¢×‘×¨.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×§×¨×™××” ××”×××’×¨, ×¡× ×›×¨×•×Ÿ ×œ×¤×™ ×ª××¨×™×š ×•×©×¢×”, ×”×¤×§×” ×©×œ ×¡×˜×¨×™××™× ×’ ×œ×××©×§ ×”×œ×§×•×—.
+
+4. ×× ×œ×™×˜×™×§×” ××‘×•×¡×¡×ª AI (×–×™×”×•×™ ×ª× ×•×¢×” ×—×©×•×“×”, ×–×™×”×•×™ ×—×¤×¦×™× × ×˜×•×©×™×, ×–×™×”×•×™ ×œ×•×—×™×•×ª ×¨×™×©×•×™ (LPR), ×–×™×”×•×™ ×¤× ×™×):
+××” ×”×§×œ×˜? ×¤×™×“×™× ×—×™×™× ×•×”×™×¡×˜×•×¨×™×™× ×××¦×œ××•×ª, × ×ª×•× ×™ ××™×§×•×, ×¤×¨××˜×¨×™× ××”××©×ª××©.
+××” ×”×¤×œ×˜? ××™×¨×•×¢×™× ××¡×•×•×’×™×, ×”×ª×¨××•×ª, ×ª×•×‘× ×•×ª.
+××” ×”×•× ×¢×•×©×”? ××–×”×” ×—×¨×™×’×•×ª, ×”×ª× ×”×’×•×™×•×ª ×—×¨×™×’×•×ª ×•×—×¤×¦×™× ×¨×œ×•×•× ×˜×™×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×”×¤×¢×œ×ª ××•×“×œ×™ AI ×œ×–×™×”×•×™ ××•×‘×™×™×§×˜×™×, ×ª× ×•×¢×” ×•×¤×¢×•×œ×•×ª ×—×¨×™×’×•×ª, ×©×™×œ×•×‘ ×¢× ××¡×“ ×”× ×ª×•× ×™×.
+
+5. ×™×¦×™×¨×ª ××™×¨×•×¢×™× ××•×˜×•××˜×™×ª ×›×©×”××¢×¨×›×ª ××–×”×” ×—×¨×™×’×” ×‘×•×™×“××•:
+××” ×”×§×œ×˜? ×–×¨× ×•×™×“××• ×—×™ ××• ××•×§×œ×˜.
+××” ×”×¤×œ×˜? ××™×¨×•×¢ ×¢× ×”×ª×¨××” ×¢×œ ×ª× ×•×¢×” ×—×¨×™×’×”.
+××” ×”×•× ×¢×•×©×”? ××–×”×” ×ª× ×•×¢×•×ª ×©××™× ×Ÿ ×¨×’×™×œ×•×ª ×‘××–×•×¨ ××•×’×“×¨.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×”×©×•×•××ª ×ª× ×•×¢×•×ª ×œ××•×“×œ × ×•×¨××œ×™ ×©×œ ×”××–×•×¨, ×©×™××•×© ×‘××œ×’×•×¨×™×ª××™× ×œ×–×™×”×•×™ ×—×¨×™×’×•×ª.
+
+6. ×—×™×¤×•×© ×—×›× ×‘×ª×•×›×Ÿ ×•×™×“××• ×œ×¤×™ ×–××Ÿ/××•×‘×™×™×§×˜/××™×¨×•×¢:
+××” ×”×§×œ×˜? ×–×¨× ×•×™×“××•.
+××” ×”×¤×œ×˜? ××™×¨×•×¢ ×¢× ××™×§×•× ×”×—×¤×¥.
+××” ×”×•× ×¢×•×©×”? ××–×”×” ×—×¤×¦×™× ×©× ×©××¨×• ×œ×œ× ×ª×–×•×–×” ×œ×–××Ÿ ××•×’×“×¨.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×–×™×”×•×™ ××•×‘×™×™×§×˜×™×, ××¢×§×‘ ××—×¨ ××™×§×•× ×œ××•×¨×š ×–××Ÿ ×•×”×©×•×•××” ×œ×–××Ÿ ×¡×£.
+××¤×” ×’×™××•×’×¨×¤×™×ª (GIS):
+   7. ××¤×ª ×¨×§×¢ ××™× ×˜×¨××§×˜×™×‘×™×ª ×¢× ×©×›×‘×•×ª ××™×“×¢:
+××” ×”×§×œ×˜? × ×ª×•× ×™ GIS, ××¦×œ××•×ª, ××–×•×¨×™× ××•×’×“×¨×™×.
+××” ×”×¤×œ×˜? ××¤×” ××™× ×˜×¨××§×˜×™×‘×™×ª ×œ××©×ª××© ×¢× ×©×›×‘×•×ª ××™×“×¢ ×©×•× ×•×ª.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ × ×™×•×•×˜ ×•×”×¦×’×ª ××™×“×¢ ×’×™××•×’×¨×¤×™ ×‘×¦×•×¨×” ×•×™×–×•××œ×™×ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™×œ×•×‘ ×¡×¤×¨×™×•×ª GIS (Leaflet/Mapbox) ×¢× React, ×˜×¢×™× ×ª ×©×›×‘×•×ª ×‘×–××Ÿ ×××ª.
+
+   8. ×”×¦×’×ª ××™×¨×•×¢×™× ×‘×–××Ÿ ×××ª ×¢×œ ×”××¤×”:
+××” ×”×§×œ×˜? ××™×¨×•×¢×™× ×©××’×™×¢×™× ××”××¢×¨×›×ª ×‘×–××Ÿ ×××ª.
+××” ×”×¤×œ×˜? ×¡×™××•×Ÿ ×”××™×¨×•×¢×™× ×¢×œ ×”××¤×”.
+××” ×”×•× ×¢×•×©×”? ××¦×™×’ ×œ××©×ª××© ××™×¤×” ×”×ª×¨×—×© ×›×œ ××™×¨×•×¢.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×¢×“×›×•×Ÿ Map Layer ×¢× × ×ª×•× ×™ ×”××™×¨×•×¢×™× ×“×¨×š WebSocket ××• API.
+
+   9. ×”×¦×’×ª ×”×™×¡×˜×•×¨×™×™×ª ×ª× ×•×¢×”/××™×§×•× ×‘×¦×™×¨ ×–××Ÿ:
+××” ×”×§×œ×˜? × ×ª×•× ×™ ××™×§×•× ××”×¢×‘×¨.
+××” ×”×¤×œ×˜? ×ª×¦×•×’×” ×©×œ ××¡×œ×•×œ×™ ×ª× ×•×¢×” ×¢×œ ×”××¤×” ×œ×¤×™ ×¦×™×¨ ×–××Ÿ.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ × ×™×ª×•×— ××™×¨×•×¢×™× ×•×”×‘× ×ª ×“×¤×•×¡×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×§×¨×™××ª × ×ª×•× ×™ ×”×™×¡×˜×•×¨×™×” ×××¡×“, ×¨×™× ×“×•×¨ ××¡×œ×•×œ×™× ×¢× Timeline ××™× ×˜×¨××§×˜×™×‘×™.
+
+   10. ×—×™×¤×•×© ××™×§×•× ×œ×¤×™ ×›×ª×•×‘×ª/×©× ××ª×¨/GPS:
+××” ×”×§×œ×˜? ×›×ª×•×‘×ª, ×©× ××ª×¨ ××• × ×§×•×“×ª GPS.
+××” ×”×¤×œ×˜? ××™×§×•× ×‘××¤×”.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ × ×™×•×•×˜ ××”×™×¨ ×œ××–×•×¨ ××¡×•×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘-API ×©×œ ××¤×•×ª ×œ-Geocoding ×•×”×¦×’×ª ×”××™×§×•× ×¢×œ ×”××¤×”.
+
+   11. ×’×™××• ×¤× ×¡×™× ×’: ×™×¦×™×¨×ª ××–×•×¨×™× ×©××¤×¢×™×œ×™× ×”×ª×¨××•×ª ×‘×›× ×™×¡×”/×™×¦×™××”:
+××” ×”×§×œ×˜? ×”×’×“×¨×ª ××–×•×¨×™× ×¢×œ ×”××¤×”.
+××” ×”×¤×œ×˜? ×”×ª×¨××•×ª ×›××©×¨ × ×›× ×¡×™× ××• ×™×•×¦××™× ××”××–×•×¨.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ × ×™×˜×•×¨ ××•×˜×•××˜×™ ×©×œ ×ª× ×•×¢×•×ª ×‘××§×•××•×ª ×§×¨×™×˜×™×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×‘×“×™×§×” ××ª××“×ª ×©×œ ××™×§×•××™ ××™×¨×•×¢×™× ××•×œ ×’×‘×•×œ×•×ª ×”××–×•×¨×™×, ×”×¤×¢×œ×ª ×˜×¨×™×’×¨×™×.
+× ×™×”×•×œ ××™×¨×•×¢×™×:
+      12. ×™×¦×™×¨×ª ××™×¨×•×¢ ×™×“× ×™ ×¢×œ ×™×“×™ ××©×ª××©×™ ×”××¢×¨×›×ª ×” WEB ×•××¤×œ×™×§×¦×™×™×ª ×”××•×‘×™×™×œ:
+××” ×”×§×œ×˜? × ×ª×•× ×™ event ×œ×¤×™ ×˜×•×¤×¡ ×™×¦×™×¨×”.
+××” ×”×¤×œ×˜? ×¨×©×•××ª ××™×¨×•×¢ ×—×“×©×” ×‘××¢×¨×›×ª.
+××” ×”×•× ×¢×•×©×”? ×™×•×¦×¨ ××™×¨×•×¢ ×—×“×© ×‘××¢×¨×›×ª ×œ×¤×™ ×§×¨×™×˜×¨×™×•× ×™× ×©×”×•×’×“×¨×• ××¨××©.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×”×§××ª ×¨×©×•××” ×—×“×©×” ××¡×•×’ event ×¢×œ ×‘×¡×™×¡ ××™×“×¢ ×©×”×’×™×¢ ××˜×•×¤×¡ ×‘×¦×“ ×”×œ×§×•×—, ×©××™×¨×” ×‘××¡×“ ×•×”×¤×¢×œ×” ×©×œ ×”×ª×¨××•×ª.
+
+      13. ×™×¦×™×¨×ª ××™×¨×•×¢ ××•×˜×•××˜×™ ×œ×¤×™ ×›×œ×œ×™× ××•×’×“×¨×™× ××¨××©:
+××” ×”×§×œ×˜? ×–×™×”×•×™ ×—×¨×™×’×” (×•×™×“××•, IoT, GIS).
+××” ×”×¤×œ×˜? ×¨×©×•××ª ××™×¨×•×¢ ×—×“×©×” ×‘××¢×¨×›×ª.
+××” ×”×•× ×¢×•×©×”? ×™×•×¦×¨ ××™×¨×•×¢ ×—×“×© ×‘××¢×¨×›×ª ×œ×¤×™ ×§×¨×™×˜×¨×™×•× ×™× ×©×”×•×’×“×¨×• ××¨××©.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×˜×¨×™×’×¨ ××•×˜×•××˜×™ ×©××‘×¦×¢ ×‘×“×™×§×” ××•×œ ×›×œ×œ×™×, ×©××™×¨×” ×‘××¡×“ ×•×”×¤×¢×œ×” ×©×œ ×”×ª×¨××•×ª.
+
+      14.  ×¡×™×•×•×’ ××™×¨×•×¢×™× ×œ×¤×™ ×§×˜×’×•×¨×™×•×ª:
+××” ×”×§×œ×˜? ××™×¨×•×¢ ×©× ×•×¦×¨.
+××” ×”×¤×œ×˜? ××™×¨×•×¢ ××¡×•×•×’ ×œ×¤×™ ×¡×•×’ (×ª× ×•×¢×” ×—×¨×™×’×”, ×¤×¨×™×¦×”, ×—×¤×¥ ×—×©×•×“ ×•×›×•').
+××” ×”×•× ×¢×•×©×”? ××¡×•×•×’ ××™×¨×•×¢×™× ×œ×¤×™ ×¡×•×’ ×•×§×˜×’×•×¨×™×” ×œ×¦×•×¨×š × ×™×ª×•×— × ×•×—.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘×œ×•×’×™×§×” ××• ××•×“×œ AI ×œ×¡×™×•×•×’ ××•×˜×•××˜×™, ×©××™×¨×ª ×”×¡×™×•×•×’ ×‘××¡×“ ×”× ×ª×•× ×™×.
+
+      15. ×ª×™×¢×•×“ ××œ× (×•×™×“××•, ×ª×™××•×¨, ×–××Ÿ, ××™×§×•×, ×—×•××¨×”):
+××” ×”×§×œ×˜? ××™×¨×•×¢.
+××” ×”×¤×œ×˜? ×¨×©×•××” ××œ××” ×‘××¢×¨×›×ª ×¢× ×›×œ ×”×¤×¨×˜×™×.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ××¢×§×‘ ×•×‘×“×™×§×” ××œ××” ×©×œ ×›×œ ××™×¨×•×¢.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ××™×¡×•×£ ××™×“×¢ ××›×œ ×”××§×•×¨×•×ª (×•×™×“××•, GIS, ×—×™×™×©× ×™×), ×©×™×œ×•×‘ ×‘××¡×“ ×”× ×ª×•× ×™×.
+
+      16. ×× ×’× ×•×Ÿ ×¢×“×™×¤×•×ª ×•×“×™×¨×•×’ ×—×•××¨×”:
+××” ×”×§×œ×˜? ××™×¨×•×¢ ×¢× ×¤×¨×˜×™ ×—×¨×™×’×”.
+××” ×”×¤×œ×˜? ×“×™×¨×•×’ ×—×•××¨×” (×’×‘×•×”/×‘×™× ×•× ×™/× ××•×š).
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×œ××©×ª××©×™× ×œ×”×ª×¨×›×– ×‘××™×¨×•×¢×™× ×§×¨×™×˜×™×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×—×™×©×•×‘ ×¢×œ ×‘×¡×™×¡ ×¡×•×’ ×”××™×¨×•×¢, ××™×§×•×, ××¡×¤×¨ ×× ×©×™×/×¨×›×‘×™× ×•×›×•', ×©××™×¨×” ×‘×“××˜×” ×•×‘×××©×§.
+
+      17. ×”×ª×¨××•×ª Push/Email/SMS:
+××” ×”×§×œ×˜? ××™×¨×•×¢ ×—×“×© ××• ×—×¨×™×’.
+××” ×”×¤×œ×˜? ×”×ª×¨××” ×œ××©×ª××©×™× ×‘××¢×¨×›×ª ××• ××—×•×¦×” ×œ×”.
+××” ×”×•× ×¢×•×©×”? ×©×•×œ×— ×”×•×“×¢×•×ª ××™×™×“×™×•×ª ×¢×œ ××™×¨×•×¢×™× ×§×¨×™×˜×™×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘-API ×©×œ Push Notifications, SMTP ××• SMS, ×—×™×‘×•×¨ ×œ××©×ª××©×™× ×œ×¤×™ ×”×¨×©××•×ª.
+
+      18. ××¢×¨×›×ª ×œ×•×’×™× ××œ××” ×œ××™×¨×•×¢×™× ×•×”×™×¡×˜×•×¨×™×”:
+××” ×”×§×œ×˜? ×›×œ ××™×¨×•×¢ ××• ×¤×¢×•×œ×” ×‘××¢×¨×›×ª.
+××” ×”×¤×œ×˜? ×¨×©×•××•×ª ×œ×•×’ ×‘×××’×¨.
+××” ×”×•× ×¢×•×©×”? ×©×•××¨ ××ª ×›×œ ×”××™×“×¢ ×œ×¦×¨×›×™ × ×™×ª×•×— ×¢×ª×™×“×™ ×•××•×“×™×˜.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×›×ª×™×‘×” ×œ××¡×“ LTS ××• ××¢×¨×›×ª ×œ×•×’×™× ×™×™×¢×•×“×™×ª, ×—×™×¤×•×© ×•×”×¦×’×” ×œ×¤×™ ×¤×¨××˜×¨×™×.
+× ×™×ª×•×— ×•-AI:
+         19. ×–×™×”×•×™ ×•× ×™×ª×•×— ×—×¨×™×’×•×ª ×‘×–××Ÿ ×××ª:
+××” ×”×§×œ×˜? ×¤×™×“×™× ×—×™×™× ×××¦×œ××•×ª ××• ×—×™×™×©× ×™×, × ×ª×•× ×™ ××™×§×•×.
+××” ×”×¤×œ×˜? ××™×¨×•×¢×™× ×‘×–××Ÿ ×××ª ×¢× ×¡×•×’ ×”×—×¨×™×’×”.
+××” ×”×•× ×¢×•×©×”? ××–×”×” ×—×¨×™×’×•×ª ××™×™×“×™×•×ª ×›×“×™ ×œ××¤×©×¨ ×ª×’×•×‘×” ××”×™×¨×”.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×”×¤×¢×œ×ª ××•×“×œ×™ AI ×œ×–×™×”×•×™ ×—×¨×™×’×•×ª ×•×”×ª×¨××•×ª ××•×˜×•××˜×™×•×ª.
+
+         20. ×¡×™×•×•×’ ××•×˜×•××˜×™ ×©×œ ××™×¨×•×¢×™×:
+××” ×”×§×œ×˜? ××™×¨×•×¢×™× ××–×•×”×™×.
+××” ×”×¤×œ×˜? ×¡×™×•×•×’ ××•×˜×•××˜×™ ×œ×¤×™ ×§×˜×’×•×¨×™×” ×•×—×•××¨×”.
+××” ×”×•× ×¢×•×©×”? ××¤×©×˜ × ×™×ª×•×— ×¢×‘×•×¨ ×”××©×ª××©×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘××•×“×œ×™× ××‘×•×¡×¡×™ ML ××• ×›×œ×œ×™ ×¡×™×•×•×’ ××‘×•×¡×¡×™ ×—×•×§×™×.
+
+         21. ×–×™×”×•×™ ××’××•×ª ×•×˜×¨× ×“×™× ×œ××•×¨×š ×–××Ÿ:
+××” ×”×§×œ×˜? × ×ª×•× ×™ ××™×¨×•×¢×™× ×”×™×¡×˜×•×¨×™×™×.
+××” ×”×¤×œ×˜? ×’×¨×¤×™× ×•×“×•×—×•×ª ×¢×œ ××’××•×ª.
+××” ×”×•× ×¢×•×©×”?  ××¡×¤×§ × ×™×ª×•×— ×—×›× ×©×œ ×“×¤×•×¡×™ ××™×¨×•×¢×™× ×œ××•×¨×š ×–××Ÿ.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? × ×™×ª×•×— ×¡×˜×˜×™×¡×˜×™, ××œ×’×•×¨×™×ª××™× ×œ×–×™×”×•×™ ×˜×¨× ×“×™×, ×”×¤×§×ª ×•×™×–×•××œ×™×–×¦×™×•×ª.
+
+         22. ×“×•×—×•×ª ×—×›××™× ×©××‘×•×¡×¡×™× ×¢×œ ×ª×‘× ×™×•×ª ×—×•×–×¨×•×ª ×‘×”×ª× ×”×’×•×ª:
+××” ×”×§×œ×˜?  ×”×™×¡×˜×•×¨×™×™×ª ××™×¨×•×¢×™×.
+××” ×”×¤×œ×˜? ×“×•×—×•×ª ××¡×›××™× ×•×”××œ×¦×•×ª.
+××” ×”×•× ×¢×•×©×”? ××–×”×” ×“×¤×•×¡×™× ×©×—×•×–×¨×™× ×¢×œ ×¢×¦×× ×•××¤×™×§ ××™×“×¢ ×©×™××•×©×™.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×”×¤×¢×œ×ª ××œ×’×•×¨×™×ª××™× ×œ×–×™×”×•×™ ×ª×‘× ×™×•×ª, ×©×™×œ×•×‘ ×¢× ×××©×§ ×“×•×—×•×ª.
+××™× ×˜×’×¨×¦×™×•×ª:
+            23. ×—×™×‘×•×¨ ×œ××¢×¨×›×•×ª × ×™×”×•×œ ×•×™×“××• (VMS):
+××” ×”×§×œ×˜?  ×¤×™×“×™× ×××¢×¨×›×•×ª ×—×™×¦×•× ×™×•×ª.
+××” ×”×¤×œ×˜? ×–×¨× ×•×™×“××• ×‘××¢×¨×›×ª SHOB Web.
+××” ×”×•× ×¢×•×©×”?  ×××¤×©×¨ ×©×™××•×© ×‘××¢×¨×›×•×ª ×§×™×™××•×ª ×‘×œ×™ ×œ×”×—×œ×™×£ ××¦×œ××•×ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”?  ×©×™××•×© ×‘-API ×©×œ ×”-VMS ×•××™× ×˜×’×¨×¦×™×” ×¢× ×”-Backend.
+
+            24. ×ª××™×›×” ×‘××¦×œ××•×ª IoT ×•×—×™×™×©× ×™× ×©×•× ×™×:
+××” ×”×§×œ×˜?  × ×ª×•× ×™ ×—×™×™×©× ×™×/××¦×œ××•×ª ×—×›××•×ª.
+××” ×”×¤×œ×˜? ××™×¨×•×¢×™× ×•×ª×¦×•×’×•×ª ×¢×œ ×”××¤×”.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×”×¨×—×‘×ª × ×™×˜×•×¨ ××¢×‘×¨ ×œ×•×•×™×“××• ×¨×’×™×œ.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×§×¨×™××” ×œ-API ×©×œ ×”××›×©×™×¨×™× ×•×”××¨×ª ×”× ×ª×•× ×™× ×œ×¤×•×¨××˜ ××—×™×“.
+
+            25. ××™× ×˜×’×¨×¦×™×” ×œ× ×ª×•× ×™ GIS ×§×™×™××™×:
+××” ×”×§×œ×˜?  ×©×›×‘×•×ª GIS ×§×™×™××•×ª.
+××” ×”×¤×œ×˜?  ××¤×ª ×¨×§×¢ ×¢×©×™×¨×” ×¢× ×©×›×‘×•×ª ××™×“×¢.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×¢×‘×•×“×” ×¢× ××™×“×¢ ×’×™××•×’×¨×¤×™ ××•×›×Ÿ.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”?  ×˜×¢×™× ×ª ×©×›×‘×•×ª GIS ×‘×××©×§ ×‘×××¦×¢×•×ª ×¡×¤×¨×™×•×ª ××™×¤×•×™.
+
+            26. ×—×™×‘×•×¨ ×œ××¢×¨×›×•×ª ×—×™×¨×•×/×“×™×•×•×— (CAD):
+××” ×”×§×œ×˜? ××™×¨×•×¢×™× ×§×¨×™×˜×™×™×.
+××” ×”×¤×œ×˜?  ×“×™×•×•×— ××•×˜×•××˜×™ ×œ××•×§×“×™ ×—×™×¨×•×.
+××” ×”×•× ×¢×•×©×”?  ×××¤×©×¨ ×”×ª×¨××” ××™×™×“×™×ª ×œ××•×§×“×™ ×ª×’×•×‘×”.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”?  ×©×™××•×© ×‘-API ×—×™×‘×•×¨ ×œ××¢×¨×›×•×ª CAD ×§×™×™××•×ª.
+×××©×§ ××©×ª××© (Frontend):
+               27. Dashboard ×¢× ×ª××•× ×ª ××¦×‘ ×‘×–××Ÿ ×××ª:
+××” ×”×§×œ×˜? ××™×¨×•×¢×™× ×—×™×™×, ×•×™×“××•, ××™×§×•×.
+××” ×”×¤×œ×˜? ×œ×•×— ×‘×§×¨×” ××™× ×˜×¨××§×˜×™×‘×™.
+××” ×”×•× ×¢×•×©×”?  ×××¤×©×¨ ×œ××©×ª××© ×œ×¨××•×ª ××ª ×›×œ ×”××™×“×¢ ×”×—×©×•×‘ ×‘××‘×˜ ××—×“.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™×œ×•×‘ React, WebSocket ×•×¢×“×›×•×Ÿ ×‘×–××Ÿ ×××ª.
+
+               28. ×ª×¦×•×’×ª ×•×™×“××•, ××¤×” ×•××™×¨×•×¢×™× ×™×—×“:
+××” ×”×§×œ×˜? ×¤×™×“×™× ×—×™×™×, ××™×¨×•×¢×™×, ××™×§×•×.
+××” ×”×¤×œ×˜?  ×××©×§ ×›×•×œ×œ ×œ×›×œ ×”× ×ª×•× ×™×.
+××” ×”×•× ×¢×•×©×”?  ××™×—×•×“ ×›×œ ×”××™×“×¢ ×‘××§×•× ××—×“ ×œ× ×•×—×•×ª ×”××©×ª××©.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”?  ×©×™××•×© ×‘-React components ××™× ×˜×¨××§×˜×™×‘×™×™× ×•×©×›×‘×•×ª GIS.
+
+               29. ×›×œ×™× ×œ×¡×™× ×•×Ÿ ××™×¨×•×¢×™× (×œ×¤×™ ×¡×•×’/××™×§×•×/×–××Ÿ):
+××” ×”×§×œ×˜? ×§×¨×™×˜×¨×™×•× ×™× ××”××©×ª××©.
+××” ×”×¤×œ×˜? ×¨×©×™××ª ××™×¨×•×¢×™× ××¡×•× × ×ª.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ××¦×™××ª ××™×¨×•×¢×™× ×¨×œ×•×•× ×˜×™×™× ×‘××”×™×¨×•×ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©××™×œ×ª×•×ª ×œ××¡×“ ×”× ×ª×•× ×™× ×œ×¤×™ ×”×¤×¨××˜×¨×™× ×©×”×•×–× ×•.
+
+               30. KPI ×•×™×–×•××œ×™×™×: ××¡×¤×¨ ××™×¨×•×¢×™×, ××’××•×ª, ××™×¨×•×¢×™× ×—×¨×™×’×™×:
+××” ×”×§×œ×˜?  × ×ª×•× ×™ ××™×¨×•×¢×™×.
+××” ×”×¤×œ×˜?  ×’×¨×¤×™× ×•×ª×¨×©×™××™×.
+××” ×”×•× ×¢×•×©×”?  ×××¤×©×¨ ××¢×§×‘ ××”×™×¨ ××—×¨×™ ×‘×™×¦×•×¢×™ ×”××¢×¨×›×ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? × ×™×ª×•×— × ×ª×•× ×™× ×‘×¦×“ ×”×©×¨×ª ×•×”×¦×’×” ×‘×××¦×¢×•×ª ×¨×›×™×‘×™ React ×’×¨×¤×™×™×.
+
+               31. Timeline ××™× ×˜×¨××§×˜×™×‘×™ ×œ×—×™×¤×•×© ×”×™×¡×˜×•×¨×™:
+××” ×”×§×œ×˜? ×˜×•×•×—×™ ×–××Ÿ ×•××™×§×•××™×.
+××” ×”×¤×œ×˜? ×§×˜×¢×™ ××™×¨×•×¢×™×/×•×™×“××• ×¨×œ×•×•× ×˜×™×™×.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×¡×§×™×¨×” ×©×œ ×”×™×¡×˜×•×¨×™×™×ª ××™×¨×•×¢×™× ×‘×¦×•×¨×” ×§×œ×”.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘-Frontend Timeline ×¢× ×©××™×œ×ª×•×ª ×œ××¡×“ ×”× ×ª×•× ×™×.
+
+               32. ×ª××™×›×” ××œ××” ×‘×“×¡×§×˜×•×¤/××•×‘×™×™×œ/×˜××‘×œ×˜:
+××” ×”×§×œ×˜? ×›× ×™×¡×” ×œ××¢×¨×›×ª ××›×œ ××›×©×™×¨.
+××” ×”×¤×œ×˜? ×××©×§ ××•×ª×× ×œ××¡×š.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×©×™××•×© ×‘××¢×¨×›×ª ××›×œ ×¤×œ×˜×¤×•×¨××”.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×××©×§ ×¨×¡×¤×•× ×¡×™×‘×™ ×‘-React, ×”×ª×××ª CSS ×•×©×›×‘×•×ª UI.
+
+               33. ××¢×¨×›×ª ×”×¨×©××•×ª ×œ×¤×™ ×ª×¤×§×™×“×™× (RBAC):
+××” ×”×§×œ×˜? ×¤×¨×˜×™ ××©×ª××©, ×ª×¤×§×™×“.
+××” ×”×¤×œ×˜? ×”×¨×©××•×ª ×’×™×©×” ××•×ª×××•×ª.
+××” ×”×•× ×¢×•×©×”?  ××•× ×¢ ×’×™×©×” ×œ××™×“×¢ ×œ× ××•×¨×©×”.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ××™××•×ª ×‘×××¦×¢×•×ª Passport.js, ×©××™×¨×” ×‘×××’×¨ ×”××©×ª××©×™× ×•×”×’×“×¨×ª ×”×¨×©××•×ª ×‘×”×ª×× ×œ×ª×¤×§×™×“.
+×ª×©×ª×™×•×ª ×•××‘×˜×—×”:
+                  34.  ×”×¦×¤× ×ª × ×ª×•× ×™× ×‘×ª×¢×‘×•×¨×” ×•×‘××—×¡×•×Ÿ:
+××” ×”×§×œ×˜? ×›×œ ×”× ×ª×•× ×™× ×‘××¢×¨×›×ª.
+××” ×”×¤×œ×˜? × ×ª×•× ×™× ××•×¦×¤× ×™×.
+××” ×”×•× ×¢×•×©×”? ××’×Ÿ ×¢×œ ×¤×¨×˜×™×•×ª ×•××‘×˜×—×ª ×”××™×“×¢.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘-SSL/TLS ×œ× ×ª×•× ×™× ×‘×ª×¢×‘×•×¨×”, ×”×¦×¤× ×ª AES ×œ× ×ª×•× ×™× ×”×××•×—×¡× ×™×.
+
+                  35. ×”×ª×—×‘×¨×•×ª ×××•×‘×˜×—×ª ×¢× SSO/OAuth2:
+××” ×”×§×œ×˜?  ×¤×¨×˜×™ ×”×ª×—×‘×¨×•×ª ×©×œ ×”××©×ª××©.
+××” ×”×¤×œ×˜? ×”×ª×—×‘×¨×•×ª ×××•××ª×ª.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×›× ×™×¡×” ×××•×‘×˜×—×ª ×•× ×™×”×•×œ ×’×™×©×”.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™×œ×•×‘ Passport.js ××• ×¤×ª×¨×•×Ÿ Auth0, ××™××•×ª ××•×œ ×¡×¤×§ ×—×™×¦×•× ×™.
+
+                  36. ×œ×•×’×™ ××•×“×™×˜ ×•×¤×¢×•×œ×•×ª ××©×ª××©:
+××” ×”×§×œ×˜? ×¤×¢×•×œ×•×ª ××©×ª××©.
+××” ×”×¤×œ×˜? ×¨×©×•××•×ª ×œ×•×’.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ××¢×§×‘ ×•×‘×§×¨×” ××—×¨×™ ×¤×¢×•×œ×•×ª ×‘××¢×¨×›×ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©××™×¨×ª × ×ª×•× ×™ ×¤×¢×•×œ×•×ª ×‘××¡×“ ×œ×•×’×™×.
+
+                  37. ×¤×¨×™×¡×” ×‘×¢× ×Ÿ ××• On-Premise:
+××” ×”×§×œ×˜? ×§×•× ×¤×™×’×•×¨×¦×™×” ×©×œ ××¢×¨×›×ª ×•×”×¢×“×¤×•×ª ×¤×¨×™×¡×”.
+××” ×”×¤×œ×˜? ××¢×¨×›×ª ×¤×¢×™×œ×” ×‘×¡×‘×™×‘×” × ×‘×—×¨×ª.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×’××™×©×•×ª ×‘×‘×—×™×¨×ª ×ª×©×ª×™×ª.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©×™××•×© ×‘-Docker/Kubernetes ×œ×¤×¨×™×¡×” ××•×“×•×œ×¨×™×ª, ×§×•× ×¤×™×’×•×¨×¦×™×” ×œ×¤×™ ×”×¦×•×¨×š.
+
+
+                     38. ×××’×¨ ×•×™×“××• ××¨×›×™×•× ×™ ×œ×¤×™ ××“×™× ×™×•×ª ×©××™×¨×”:
+××” ×”×§×œ×˜? ×”×§×œ×˜×•×ª ×•×™×“××•.
+××” ×”×¤×œ×˜?  ×•×™×“××• ×©××•×¨ ×œ××•×¨×š ×–××Ÿ ×‘×”×ª×× ×œ××“×™× ×™×•×ª.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ××—×¡×•×Ÿ ×•×™×“××• ×œ×–××Ÿ ××•×’×“×¨, ×’×™×©×” × ×•×—×” ×œ××™×¨×•×¢×™× ×™×©× ×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×›×ª×™×‘×” ×œ××¡×“ × ×ª×•× ×™× ××• S3 Bucket, × ×™×”×•×œ ××—×–×•×¨ ×—×™×™× ×©×œ ×”×§×‘×¦×™×.
+
+
+                        39.  ×××©×§ ××“××™×Ÿ ×œ× ×™×”×•×œ ×”×’×“×¨×•×ª ××¢×¨×›×ª:
+××” ×”×§×œ×˜? ×¤×¢×•×œ×•×ª ××©×ª××©.
+××” ×”×¤×œ×˜?  ×©××™×¨×” ×‘××¡×“ ×”× ×ª×•× ×™×.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×”×’×“×¨×•×ª ×‘×¨×™×¨×ª ××—×“×œ ×•×§×•× ×¤×™×’×•×¨×¦×™×” ×‘×××¦×¢×•×ª ×××©×§ ×™×“×™×“×•×ª×™.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×›×ª×™×‘×” ×œ××¡×“ × ×ª×•× ×™×.
+
+
+×“×•×—×•×ª ×•×™×™×¦×•×:
+                           40. ×™×¦×•× CSV/PDF ×©×œ ××™×¨×•×¢×™× ×•× ×ª×•× ×™×:
+××” ×”×§×œ×˜? ××™×¨×•×¢×™× ×©× ×‘×—×¨×• ××• ××¡×•× × ×™×.
+××” ×”×¤×œ×˜? ×§×•×‘×¥ CSV ××• PDF.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ ×©×™×ª×•×£ ×•×“×™×•×•×— ×—×™×¦×•× ×™.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×”×¤×§×ª ×”×§×•×‘×¥ ×‘×¦×“ ×”×©×¨×ª ×¢× Node.js ×•×™×¦×•× ×œ××©×ª××©.
+
+                           41. ×“×•×—×•×ª ×—×•×“×©×™×™×/×¨×‘×¢×•× ×™×™× ×¢×œ ×˜×¨× ×“×™×:
+××” ×”×§×œ×˜? × ×ª×•× ×™ ××™×¨×•×¢×™× ×”×™×¡×˜×•×¨×™×™×.
+××” ×”×¤×œ×˜?  ×“×•×— ××¡×›× ×¢× ×’×¨×¤×™× ×•×¡×˜×˜×™×¡×˜×™×§×•×ª.
+××” ×”×•× ×¢×•×©×”?  ×××¤×©×¨ ××¢×§×‘ ××¨×•×š ×˜×•×•×— ××—×¨ ××™×¨×•×¢×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”?  × ×™×ª×•×— ×¡×˜×˜×™×¡×˜×™ ×‘×¦×“ ×”×©×¨×ª, ×”×¤×§×ª ×“×•×—×•×ª PDF/HTML.
+
+                           42. ×¤×™×œ×•×—×™× ××ª×§×“××™× ×œ×¤×™ ××©×ª××©/ ××–×•×¨/ ×¡×•×’ ××™×¨×•×¢:
+××” ×”×§×œ×˜? ×§×¨×™×˜×¨×™×•× ×™× ×©× ×‘×—×¨×• ×¢×œ ×™×“×™ ×”××©×ª××©.
+××” ×”×¤×œ×˜? ×¨×©×™××ª ××™×¨×•×¢×™× ××• ×“×•×—×•×ª ××•×ª×××™×.
+××” ×”×•× ×¢×•×©×”? ×××¤×©×¨ × ×™×ª×•×— ×××•×§×“ ×œ×¤×™ ×¤×¨××˜×¨×™× ×©×•× ×™×.
+××™×š ×”×•× ×¢×•×©×” ××ª ×–×”? ×©××™×œ×ª×•×ª ×œ××¡×“ ×”× ×ª×•× ×™×, ×¡×™× ×•×Ÿ ×œ×¤×™ ×§×¨×™×˜×¨×™×•× ×™×, ×”×¦×’×ª ×ª×•×¦××•×ª ×‘×××©×§.
+	×˜×›× ×•×œ×•×’×™×•×ª
+×¤×¨×˜×• ××ª ××¨×›×™×‘×™ ×”××™××•×© ×©×œ ×›×œ ××—×“ ××”×¤×™×¦'×¨×™× ×©×ª×™××¨×ª× ×§×•×“× ×‘×˜×‘×œ×ª ×”×¤×™×¦'×¨×™×.
+
+
+×¤×™×¦'×¨
+	×˜×›× ×•×œ×•×’×™×•×ª ×•×©×¤×•×ª ×ª×›× ×•×ª
+	××©××‘×™× × ×“×¨×©×™× ×•×©×™×¨×•×ª×™× ×—×™×¦×•× ×™×™×
+	×—×™×‘×•×¨ ×œ××§×•×¨×•×ª ×•×™×“××• (IP, VMS)
+	Node.js, JavaScript, REST API
+	×©×¨×ª VMS ×—×™×¦×•× ×™, ××¦×œ××•×ª IP, ×¨×©×ª ×ª×§×©×•×¨×ª
+	×¦×¤×™×™×” ×‘×©×™×“×•×¨ ×—×™
+	React, WebRTC / HTTP Streaming
+	×©×¨×ª ×¡×˜×¨×™××™× ×’, ×¨×•×—×‘ ×¤×¡ ×’×‘×•×”
+	×¤×œ×™×™×‘×§ ×©×œ ×”×§×œ×˜×•×ª ×”×™×¡×˜×•×¨×™×•×ª
+	React, Node.js
+	×××’×¨ ×•×™×“××•, ××—×¡×•×Ÿ ×‘×¢× ×Ÿ ××• ××§×•××™
+	×× ×œ×™×˜×™×§×” ××‘×•×¡×¡×ª AI
+	Python, OpenCV, TensorFlow / PyTorch
+	××•×“×œ×™× ×××•×× ×™×, GPU (××•×¤×¦×™×•× ×œ×™)
+	×–×™×”×•×™ ×ª× ×•×¢×” ×—×©×•×“×”
+	Python, OpenCV
+	××•×“×œ ×–×™×”×•×™ ×ª× ×•×¢×”, ×¤×™×“×™ ×•×™×“××•
+	×–×™×”×•×™ ×—×¤×¦×™× × ×˜×•×©×™×
+	Python, Computer Vision
+	××•×“×œ Object Detection
+	×–×™×”×•×™ ×œ×•×—×™×•×ª ×¨×™×©×•×™ (LPR)
+	Python, OCR, OpenALPR / EasyOCR
+	××•×“×œ OCR, ×××’×¨ ×œ×•×—×™×•×ª
+	×–×™×”×•×™ ×¤× ×™×
+	Python, Face Recognition
+	××•×“×œ ×–×™×”×•×™ ×¤× ×™×, ×××’×¨ ×¤× ×™×
+	×™×¦×™×¨×ª ××™×¨×•×¢ ×™×“× ×™
+	Node.js, MongoDB
+	×©×¨×ª backend, ×××©×§ UI, ×©×¨×ª VMS
+	×™×¦×™×¨×ª ××™×¨×•×¢×™× ××•×˜×•××˜×™×ª
+	Node.js, MongoDB
+	×× ×•×¢ ×—×•×§×™×, ××¡×“ × ×ª×•× ×™×
+	×—×™×¤×•×© ×—×›× ×‘×•×™×“××•
+	Node.js, MongoDB
+	××™× ×“×§×¡×™×, ××˜×-×“××˜×” ×-AI
+	××¤×ª ×¨×§×¢ ××™× ×˜×¨××§×˜×™×‘×™×ª (GIS)
+	React, Leaflet / Mapbox
+	×©×™×¨×•×ª ××¤×•×ª ×—×™×¦×•× ×™
+	×”×¦×’×ª ××™×¨×•×¢×™× ×‘×–××Ÿ ×××ª ×¢×œ ×”××¤×”
+	React, WebSocket
+	×©×¨×ª Real Time
+	×”×™×¡×˜×•×¨×™×™×ª ×ª× ×•×¢×” ×‘×¦×™×¨ ×–××Ÿ
+	React, MongoDB
+	× ×ª×•× ×™ ××™×§×•× ×”×™×¡×˜×•×¨×™×™×
+	×—×™×¤×•×© ××™×§×•× (×›×ª×•×‘×ª/GPS)
+	JavaScript, GIS API
+	×©×™×¨×•×ª Geocoding
+	×’×™××• ×¤× ×¡×™× ×’
+	Node.js, GIS Libraries
+	×—×™×©×•×‘×™ ×¤×•×œ×™×’×•× ×™×, × ×ª×•× ×™ GPS
+	×™×¦×™×¨×ª ××™×¨×•×¢ ×œ×¤×™ ×›×œ×œ×™×
+	Node.js
+	×× ×•×¢ ×—×•×§×™×, ××¡×“ × ×ª×•× ×™×
+	×¡×™×•×•×’ ××™×¨×•×¢×™×
+	Node.js / Python
+	×œ×•×’×™×§×” ×¢×¡×§×™×ª ××• ××•×“×œ AI
+	×ª×™×¢×•×“ ××œ× ×©×œ ××™×¨×•×¢
+	MongoDB, Node.js
+	××—×¡×•×Ÿ ×•×™×“××• ×•××™×“×¢
+	×× ×’× ×•×Ÿ ×¢×“×™×¤×•×ª ×•×—×•××¨×”
+	Node.js
+	××œ×’×•×¨×™×ª× ×“×™×¨×•×’
+	×”×ª×¨××•×ª Push / Email / SMS
+	Node.js
+	Firebase, SMTP, SMS Gateway
+	××¢×¨×›×ª ×œ×•×’×™×
+	MongoDB
+	××—×¡×•×Ÿ ×œ×•×’×™×
+	×–×™×”×•×™ ×—×¨×™×’×•×ª ×‘×–××Ÿ ×××ª
+	Python, AI Models
+	×—×™×©×•×‘ ×‘×–××Ÿ ×××ª
+	×–×™×”×•×™ ××’××•×ª ×•×˜×¨× ×“×™×
+	Python, Data Analysis
+	× ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™×
+	×“×•×—×•×ª ×—×›××™×
+	Node.js, PDF Generator
+	×× ×•×¢ ×“×•×—×•×ª
+	×—×™×‘×•×¨ ×œ-VMS
+	Node.js, REST API
+	××¢×¨×›×ª VMS ×—×™×¦×•× ×™×ª
+	×—×™×‘×•×¨ ×œ××¦×œ××•×ª IoT ×•×—×™×™×©× ×™×
+	Node.js, MQTT / HTTP
+	×—×™×™×©× ×™×, Gateway
+	××™× ×˜×’×¨×¦×™×™×ª GIS ×§×™×™××ª
+	React, GIS Libraries
+	×©×›×‘×•×ª GIS ×—×™×¦×•× ×™×•×ª
+	×—×™×‘×•×¨ ×œ××¢×¨×›×•×ª CAD
+	Node.js, API
+	××¢×¨×›×•×ª ×—×™×¨×•×
+	Dashboard ×‘×–××Ÿ ×××ª
+	React
+	WebSocket, Backend
+	×ª×¦×•×’×ª ×•×™×“××• + ××¤×” + ××™×¨×•×¢×™×
+	React
+	×©×¨×ª Backend
+	×¡×™× ×•×Ÿ ××™×¨×•×¢×™×
+	React, MongoDB
+	×©××™×œ×ª×•×ª ×œ××¡×“
+	KPI ×•×™×–×•××œ×™×™×
+	React, Chart Libraries
+	× ×ª×•× ×™ ××¢×¨×›×ª
+	Timeline ×”×™×¡×˜×•×¨×™
+	React
+	× ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™×
+	×ª××™×›×” ×‘×“×¡×§×˜×•×¤/××•×‘×™×™×œ
+	React, CSS
+	×“×¤×“×¤× ×™×
+	××¢×¨×›×ª ×”×¨×©××•×ª (RBAC)
+	Node.js, Passport.js
+	××¡×“ ××©×ª××©×™×
+	×”×¦×¤× ×ª × ×ª×•× ×™×
+	Node.js, TLS
+	×ª×¢×•×“×•×ª SSL
+	×”×ª×—×‘×¨×•×ª SSO/OAuth2
+	Passport.js / Auth0
+	×¡×¤×§ ×–×”×•×™×•×ª
+	×œ×•×’×™ ××•×“×™×˜
+	Node.js
+	××¡×“ × ×ª×•× ×™×
+	×¤×¨×™×¡×” ×‘×¢× ×Ÿ / On-Prem
+	Docker
+	×©×¨×ª×™ ×¢× ×Ÿ / ×©×¨×ª ××§×•××™
+	×××’×¨ ×•×™×“××• ××¨×›×™×•× ×™
+	S3 / File System
+	××—×¡×•×Ÿ ××¨×•×š ×˜×•×•×—
+	× ×™×”×•×œ ×”×’×“×¨×•×ª ××¢×¨×›×ª
+	Node.js
+	××¡×“ × ×ª×•× ×™×
+	×™×¦×•× CSV / PDF
+	Node.js
+	×¡×¤×¨×™×•×ª ×™×™×¦×•×
+	×“×•×—×•×ª ×—×•×“×©×™×™× / ×¨×‘×¢×•× ×™×™×
+	Node.js, Python
+	× ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™×
+	×¤×™×œ×•×—×™× ××ª×§×“××™×
+	MongoDB
+	××™× ×“×§×¡×™× ××ª×§×“××™×
+	
+
+	×ª×¨×©×™× ×–×¨×™××”
+×–×” ×”××§×•× ×œ×‘× ×•×ª ××ª ×”-Flow ×©×œ ×”×¤×™×¦'×¨×™× ×©×¨×©××ª× ×‘×˜×‘×œ×ª ×”×¤×™×¦'×¨×™×, ×‘×©×‘×™×œ ×œ×§×‘×œ ×”×¨×’×©×” ×›×œ×œ×™×ª ×©×œ ××™×š ×”×¤×¨×•×™×§×˜ ×™×¢×‘×•×“. × ×™×ª×Ÿ ×œ×¢×©×•×ª ×–××ª ×¢×œ ×™×“×™ ×ª×¨×©×™× ×–×¨×™××” ××• ×¦×™×•×¨ ×¡×§×™×¦×” ×œ××¡×›×™ ×”×¤×¨×•×™×§×˜ ×•×”××¢×‘×¨×™× ×‘×™×Ÿ ××¡×š ×œ××¡×š. ×¢×œ×™×›× ×œ×”×ª×™×™×—×¡ ×›××Ÿ ×œ×›×œ ×”×¤×™×¦'×¨×™× ×©×œ×›×. ×¢×œ ×ª×¨×©×™× ×”×–×¨×™××” ×œ×”×™×•×ª ×§×¨×™× ×•×‘×”×™×¨.
+×›×œ×™× ×©×‘×”× × ×™×ª×Ÿ ×œ×”×©×ª××©: 
+                              * Draw.io
+                              * lucidchart
+                              * gliffy-diagrams
+                              * visio
+×ª×¨×©×™× ×©××ª××¨ ××ª ×”-Flow ×‘×¤×¨×•×™×§×˜ shob web:
+ ×§×•×‘×¥
+
+
+ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ×”××˜×¨×” ×”×¢×™×§×¨×™×ª ×©×œ ×”××¢×¨×›×ª? ××”×Ÿ ×”××©×™××•×ª ×”×¢×™×§×¨×™×•×ª ×”× ×•×¡×¤×•×ª? ×”×× ×™×© ×ª× ××™× ×©×¦×¨×™×š ×œ×”×ª×—×©×‘ ×‘×”× ×œ×¦×•×¨×š ×§×‘×œ×ª ×”×—×œ×˜×•×ª? ×”×× ×™×© ×¤×¢×•×œ×•×ª ×©×—×•×–×¨×•×ª ×¢×œ ×¢×¦××Ÿ? ×”×× ×™×© ×—×œ×§×™× ×©×•× ×™× ×‘×ª×•×›× ×™×ª ×©××ª×§×©×¨×™× ××—×“ ×¢× ×”×©× ×™?
+×œ×“×•×’××”:
+  
+ğŸ—‘ï¸
+	××‘× ×” ×‘×¡×™×¡ × ×ª×•× ×™×
+×›××¢×˜ ×›×œ ×¤×¨×•×™×§×˜ ×”×™×•× ××©×ª××© ×‘×‘×¡×™×¡ × ×ª×•× ×™× ×•××ª× ×›×‘×¨ ×”×—×œ×˜×ª× ×‘××™×–×” ×˜×›× ×•×œ×•×’×™×” ×ª×©×ª××©×• ×‘×‘×¡×™×¡ ×”× ×ª×•× ×™× ×©×œ×›×. ×–×” ×”××§×•× ×œ×ª×›× ×Ÿ ×•×œ×¤×¨×˜ ×¢×œ ×”×˜×‘×œ××•×ª ××• ×”×¡×›××•×ª ×©×œ ×‘×¡×™×¡ ×”× ×ª×•× ×™× ×©×œ×›×. 
+×¢×œ×™×›× ×œ×›×ª×•×‘ ×›××Ÿ ××ª ×›×œ ×”×˜×‘×œ××•×ª ×©×™×¨×›×™×‘×• ××ª ×”×¤×¨×•×™×§×˜ ×©×œ×›×:
+×‘×¤×¨×•×™×§×˜ × ×××© ××ª ××¡×“ ×”× ×ª×•× ×™× ×‘×××¦×¢×•×ª MongoDB ××¡×•×’ NoSQL (Document-Oriented Database).
+×”×‘×—×™×¨×” ×‘-MongoDB ×××¤×©×¨×ª ×’××™×©×•×ª ×‘×¡×›××•×ª, ×¢×‘×•×“×” × ×•×—×” ×¢× JSON, ×”×ª×××” ×’×‘×•×”×” ×œ-Node.js ×•×™×›×•×œ×ª ×¡×§×™×™×œ×™× ×’ ×¢×ª×™×“×™×ª.
+Collection: Users
+×˜×‘×œ×ª ××©×ª××©×™× ×‘××¢×¨×›×ª:
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	email
+	String
+	Unique, Required
+	passwordHash
+	String
+	Required
+	fullName
+	String
+	Required
+	role
+	String
+	Enum: admin, operator, viewer
+	isActive
+	Boolean
+	Default: true
+	createdAt
+	Date
+	Auto-generated
+	lastLogin
+	Date
+	Nullable
+	Collection: Cameras
+××™×“×¢ ×¢×œ ××¦×œ××•×ª ×•××§×•×¨×•×ª ×•×™×“××•
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	name
+	String
+	Required
+	type
+	String
+	Enum: IP, VMS, IoT
+	streamUrl
+	String
+	Required
+	location
+	Object
+	lat, lng
+	address
+	String
+	Optional
+	status
+	String
+	Enum: active, inactive
+	createdAt
+	Date
+	Auto-generated
+	Collection: VideoStreams
+××™×“×¢ ×¢×œ ×–×¨××™ ×•×™×“××• ×—×™×™× ×•×”×§×œ×˜×•×ª
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	cameraId
+	ObjectId
+	Reference: Cameras
+	startTime
+	Date
+	Required
+	endTime
+	Date
+	Nullable
+	streamType
+	String
+	live / recorded
+	filePath
+	String
+	Optional
+	metadata
+	Object
+	JSON
+	Collection: Events
+××™×¨×•×¢×™× ×©× ×•×¦×¨×• ××•×˜×•××˜×™×ª ××• ×™×“× ×™×ª
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	type
+	Enum
+	motion, face, lpr, object
+	subType
+	Enum
+	
+
+	severity
+	Number
+	1-5
+	cameraId
+	ObjectId - List?
+	Reference: Cameras
+	videoId
+	ObjectId - List?
+	Reference: VideoStreams
+	description
+	String
+	Optional
+	timestamp
+	Date
+	Required
+	location
+	Object
+	lat, lng
+	status
+	String
+	open / closed
+	address
+	String
+	
+
+	attachment
+	Object - List
+	FilePath
+	Collection: AIAnalysis
+×ª×•×¦××•×ª × ×™×ª×•×— ××‘×•×¡×¡ AI
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	eventId
+	ObjectId
+	Reference: Events
+	modelType
+	String
+	face, lpr, anomaly
+	confidence
+	Number
+	0-1
+	detectedObjects
+	Array
+	JSON
+	processedAt
+	Date
+	Auto-generated
+	Collection: Notifications
+×”×ª×¨××•×ª ×œ××©×ª××©×™×
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	userId
+	ObjectId
+	Reference: Users
+	eventId
+	ObjectId
+	Reference: Events
+	channel
+	String
+	email, sms, push
+	sentAt
+	Date
+	Auto-generated
+	status
+	String
+	sent / failed
+	message
+	String
+	Required
+	Collection: AuditLogs
+×œ×•×’×™× ×•×¤×¢×•×œ×•×ª ××©×ª××©×™×
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	userId
+	ObjectId
+	Reference: Users
+	action
+	String
+	Required
+	targetId
+	ObjectId
+	Optional
+	timestamp
+	Date
+	Auto-generated
+	ipAddress
+	String
+	Optional
+	Collection: GeoZones
+××–×•×¨×™ Geofencing
+×©×“×”
+	×¡×•×’
+	××’×‘×œ×•×ª
+	_id
+	ObjectId
+	Primary Key
+	name
+	String
+	Required
+	polygon
+	Array
+	Coordinates
+	alertOnEnter
+	Boolean
+	Default: false
+	alertOnExit
+	Boolean
+	Default: false
+	
+
+Collection: PermissionRoles
+×¤×¨×•×¤×™×œ×™ ×”×¨×©××•×ª
+
+
+
+
+	________________
+
+
+
+
+    ×¤×¨×§ 3: ××¨×›×™×˜×§×˜×•×¨×”
+××‘×˜ ×¢×œ
+×›×©×¢×‘×“× ×• ×¢×œ ×ª×•×›× ×•×ª, ×—×™×œ×§× ×• ××•×ª×Ÿ ×œ×¤×•× ×§×¦×™×•×ª â€“ ×œ×›×œ ×¤×•× ×§×¦×™×” ×ª×¤×§×™×“ ×•×ª×—×•× ××—×¨×™×•×ª ××©×œ×”. ×›×©×¢×‘×“× ×• ×¢×œ ×ª×•×›× ×•×ª ×’×“×•×œ×•×ª, ×—×™×œ×§× ×• ××•×ª×Ÿ ×œ××—×œ×§×•×ª â€“ ×œ×›×œ ××—×œ×§×” ×ª×¤×§×™×“ ×•××—×¨×™×•×ª ××©×œ×”. ×•×¢×›×©×™×• â€“ × ×—×œ×§ ××ª ×”×¤×¨×•×™×§×˜ ×©×œ× ×• ×œ×¨×›×™×‘×™× â€“ ×œ×›×œ ×¨×›×™×‘ ×ª×¤×§×™×“ ×•××—×¨×™×•×ª ××©×œ×•. ×“×•×’×××•×ª ×œ×¨×›×™×‘×™×: ×©×¨×ª, ×œ×§×•×— ×•××¡×“ × ×ª×•× ×™×.
+×›××Ÿ ×™×© ×œ×¤×¨×˜ ××ª ×”×¨×›×™×‘×™× ×”×¢×™×§×¨×™×™× ×©××¨×›×™×‘×™× ××ª ××™××•×© ×”×¤×¨×•×™×§×˜. ××™×Ÿ ×¦×•×¨×š ×œ×”×™×›× ×¡ ×œ×“×§×•×™×•×ª ××• ×œ××§×¨×™ ×§×¦×”, ××œ× ×œ×ª×ª ×ª××•× ×” ×›×•×œ×œ×ª ×©×œ ×”×—×œ×§×™× ×”×¢×™×§×¨×™×™× ×‘××¢×¨×›×ª.
+×¨××©×™×ª ×›×œ ×™×© ×œ×©×™× ×›××Ÿ ×“×™××’×¨××” ×”××ª××¨×ª ××ª ×”×¨×›×™×‘×™× ×”×¢×™×§×¨×™×™× ×•×”×§×©×¨×™× ×‘×™× ×™×”×. ××ª ×”×“×™××’×¨××” × ×™×ª×Ÿ ×œ×™×¦×•×¨ ×‘××’×•×•×Ÿ ×“×¨×›×™× - ×”×—×œ ××¡×¨×™×§×” ×©×œ ×©×¨×˜×•×˜ ×©×¦×™×™×¨×ª× ×‘×¢×¦××›×, ×“×¨×š Powerpoint ×•×¢×“ ×œ×©×™×¨×•×ª×™ ×¨×©×ª ×—×™× ××™×™× ×›××• moqups.com ××• Draw.io.
+×œ××—×¨ ××›×Ÿ ×™×© ×œ×”×¡×‘×™×¨ ×‘×§×¦×¨×” ×¢×‘×•×¨ ×›×œ ×¨×›×™×‘ ×œ×’×‘×™ ×ª×¤×§×™×“×• ×•×ª×—×•× ×”××—×¨×™×•×ª ×©×œ×• ×•×œ××™×œ×• ×¨×›×™×‘×™× ××—×¨×™× ×”×•× ××ª×××©×§. 
+ğŸ’– ×©×™××• ×œ×‘: ×™×ª×›×Ÿ ×©×”×¤×¨×•×™×§×˜ ×©×œ×›× ×™×—×•×œ×§ ×œ××¡×¤×¨ ×ª×•×›× ×•×ª/××¤×œ×™×§×¦×™×•×ª ×©×•× ×•×ª, ×›××©×¨ ×œ×›×œ ××—×ª ××”×Ÿ ×§×™×™××™× ×¨×›×™×‘×™× ××©×œ×”. ×¢×œ×™×›× ×œ×¤×¨×˜ ×¢×œ ×›×œ ×”×¨×›×™×‘×™× ×‘×¤×¨×•×™×™×§×˜ ×©×œ×›×. 
+
+
+×“×™××’×¨××ª ×¨×›×™×‘×™× â€“ ×ª×™××•×¨ ×›×œ×œ×™
+×”××¢×¨×›×ª SHOB Web ×‘× ×•×™×” ×××¨×›×™×˜×§×˜×•×¨×ª Client Server ××•×“×•×œ×¨×™×ª, ×¢× ×”×¤×¨×“×” ×‘×¨×•×¨×” ×‘×™×Ÿ ×××©×§ ××©×ª××©, ×©×¨×ª ×œ×•×’×™×§×”, ×¨×›×™×‘×™ AI, ××™× ×˜×’×¨×¦×™×•×ª ×—×™×¦×•× ×™×•×ª ×•××¡×“ × ×ª×•× ×™×.
+×”××©×ª××© ×¢×•×‘×“ ××•×œ ×××©×§ ×”-Web.
+×××©×§ ×”-Web ××ª×§×©×¨ ×¢× ×©×¨×ª ×”-Backend ×‘×××¦×¢×•×ª API.
+×©×¨×ª ×”-Backend ×¢×•×‘×“ ××•×œ ××¡×“ ×”× ×ª×•× ×™×, ×× ×•×¢×™ ×”-AI ×•××¢×¨×›×•×ª ×—×™×¦×•× ×™×•×ª.
+×× ×•×¢×™ ×”-AI ××§×‘×œ×™× ×•×™×“××• ×•× ×ª×•× ×™×, ×× ×ª×—×™× ××•×ª× ×•××—×–×™×¨×™× ×ª×•×¦××•×ª ×œ×©×¨×ª.
+________________
+
+
+×¨×›×™×‘×™× ×¢×™×§×¨×™×™× ×‘××¢×¨×›×ª
+×¨×›×™×‘: Web Client (Frontend)
+×¨×›×™×‘ ×–×” ××—×¨××™ ×¢×œ ×××©×§ ×”××©×ª××© ×•×”××™× ×˜×¨××§×¦×™×” ×¢× ×”××¢×¨×›×ª.
+×ª×¤×§×™×“ ×•××—×¨×™×•×ª:
+                              * ×”×¦×’×ª Dashboard ×‘×–××Ÿ ×××ª
+                              * ×”×¦×’×ª ×•×™×“××• ×—×™ ×•×”×§×œ×˜×•×ª ×”×™×¡×˜×•×¨×™×•×ª
+                              * ×”×¦×’×ª ××™×¨×•×¢×™× ×¢×œ ×’×‘×™ ××¤×” ××™× ×˜×¨××§×˜×™×‘×™×ª
+                              * ×¡×™× ×•×Ÿ, ×—×™×¤×•×© ×•×™×™×¦×•× × ×ª×•× ×™×
+                              * ×§×‘×œ×ª ×”×ª×¨××•×ª ×‘×–××Ÿ ×××ª
+×˜×›× ×•×œ×•×’×™×•×ª:
+                              * React
+                              * ×¡×¤×¨×™×™×ª ××¤×•×ª Mapbox ××• Leaflet
+                              * ×ª×§×©×•×¨×ª HTTP ×• WebSocket
+××ª×××©×§ ×¢×:
+                              * Backend Server
+×ª×ª ×¨×›×™×‘×™×:
+                              * Video Viewer ×œ×”×¦×’×ª ×©×™×“×•×¨ ×—×™ ×•×¤×œ×™×™×‘×§
+                              * Map View ×œ×”×¦×’×ª ××¦×œ××•×ª ×•××™×¨×•×¢×™×
+                              * Events Panel ×œ×¨×©×™××ª ××™×¨×•×¢×™× ×•×¡×™× ×•×Ÿ
+                              * Authentication UI ×œ×”×ª×—×‘×¨×•×ª ×•× ×™×”×•×œ ××©×ª××©
+________________
+
+
+×¨×›×™×‘: Backend Server
+×”×¨×›×™×‘ ×”××¨×›×–×™ ×©×× ×”×œ ××ª ×”×œ×•×’×™×§×” ×”×¢×¡×§×™×ª ×©×œ ×”××¢×¨×›×ª.
+×ª×¤×§×™×“ ×•××—×¨×™×•×ª:
+                              * × ×™×”×•×œ ××©×ª××©×™× ×•×”×¨×©××•×ª ×œ×¤×™ ×ª×¤×§×™×“
+                              * ×™×¦×™×¨×”, ×¢×“×›×•×Ÿ ×•×¡×’×™×¨×” ×©×œ ××™×¨×•×¢×™×
+                              * ×§×™×©×•×¨ ×‘×™×Ÿ ×•×™×“××•, ××™×§×•× ×•× ×™×ª×•×— AI
+                              * ×©×œ×™×—×ª ×”×ª×¨××•×ª ×œ××©×ª××©×™×
+                              * ××¡×¤×§×ª API ×œ×××©×§ ×”××©×ª××©
+×˜×›× ×•×œ×•×’×™×•×ª:
+                              * Node.js
+                              * Express.js
+                              * Passport.js ×¢× JWT
+××ª×××©×§ ×¢×:
+                              * Web Client
+                              * Database
+                              * AI Engine
+                              * ××¢×¨×›×•×ª ×—×™×¦×•× ×™×•×ª
+×ª×ª ×¨×›×™×‘×™×:
+                              * Auth Service ×œ××™××•×ª ××©×ª××©×™×
+                              * Events Service ×œ× ×™×”×•×œ ××™×¨×•×¢×™×
+                              * Video Service ×œ× ×™×”×•×œ ××˜× ×“××˜×” ×©×œ ×•×™×“××•
+                              * Notification Service ×œ×©×œ×™×—×ª ×”×ª×¨××•×ª
+                              * Audit Service ×œ×ª×™×¢×•×“ ×¤×¢×•×œ×•×ª
+________________
+
+
+×¨×›×™×‘: AI and Video Analysis Engine
+×¨×›×™×‘ ×¢×¦×××™ ×œ× ×™×ª×•×— ×—×›× ×©×œ ×•×™×“××• ×•× ×ª×•× ×™×.
+×ª×¤×§×™×“ ×•××—×¨×™×•×ª:
+                              * ×–×™×”×•×™ ×—×¨×™×’×•×ª ×‘×–××Ÿ ×××ª
+                              * ×–×™×”×•×™ ×ª× ×•×¢×”, ×¤× ×™× ×•×œ×•×—×™×•×ª ×¨×™×©×•×™
+                              * ×—×™×©×•×‘ ×¨××ª ×—×•××¨×” ×•×××™× ×•×ª
+                              * ×”×—×–×¨×ª ×ª×•×¦××•×ª × ×™×ª×•×— ×œ×©×¨×ª
+×˜×›× ×•×œ×•×’×™×•×ª:
+                              * Python
+                              * OpenCV
+                              * ××•×“×œ×™× ×©×œ Deep Learning
+××ª×××©×§ ×¢×:
+                              * Backend Server
+                              * ××§×•×¨×•×ª ×•×™×“××•
+________________
+
+
+×¨×›×™×‘: Video Sources and VMS
+××§×•×¨×•×ª ×”×•×•×™×“××• ×©×œ ×”××¢×¨×›×ª.
+×ª×¤×§×™×“ ×•××—×¨×™×•×ª:
+                              * ××¡×¤×§×ª ×©×™×“×•×¨ ×—×™
+                              * ×’×™×©×” ×œ×”×§×œ×˜×•×ª ×”×™×¡×˜×•×¨×™×•×ª
+×›×•×œ×œ:
+                              * ××¦×œ××•×ª IP
+                              * ××¢×¨×›×•×ª VMS ×§×™×™××•×ª
+××ª×××©×§ ×¢×:
+                              * Backend Server
+                              * AI Engine
+________________
+
+
+×¨×›×™×‘: Database
+××—×¨××™ ×¢×œ ××—×¡×•×Ÿ ×›×œ ×”××™×“×¢ ×©×œ ×”××¢×¨×›×ª.
+×ª×¤×§×™×“ ×•××—×¨×™×•×ª:
+                              * ××—×¡×•×Ÿ ××©×ª××©×™× ×•×”×¨×©××•×ª
+                              * ××—×¡×•×Ÿ ××™×¨×•×¢×™× ×•×œ×•×’×™×
+                              * ××—×¡×•×Ÿ ××˜× ×“××˜×” ×©×œ ×•×™×“××•
+                              * ××—×¡×•×Ÿ ×ª×•×¦××•×ª × ×™×ª×•×— AI
+×˜×›× ×•×œ×•×’×™×”:
+                              * MongoDB
+××ª×××©×§ ×¢×:
+                              * Backend Server
+________________
+
+
+×¨×›×™×‘: External Integrations
+×¨×›×™×‘×™× ×—×™×¦×•× ×™×™× ×©×”××¢×¨×›×ª ××ª×§×©×¨×ª ××™×ª×.
+×›×•×œ×œ:
+                              * ××¢×¨×›×•×ª GIS
+                              * ××¢×¨×›×•×ª ×—×™×¨×•× ×•×“×™×•×•×— CAD
+                              * ×¡×¤×§×™ Email, SMS ×• Push
+××ª×××©×§ ×¢×:
+                              * Backend Server
+ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ×ª×¤×§×™×“ ×”×¨×›×™×‘/×ª×ª ×¨×›×™×‘? ×¢×œ ××” ×”×•× ××—×¨××™? ×œ××™ ×”×•× ××ª×××©×§ ×•×‘××™×–×” ××•×¤×Ÿ?
+×œ×“×•×’××”:
+  
+
+                              1. Scanning device - ×¨×›×™×‘ ×”×¡×¨×™×§×•×ª ××©×¨ ×™××¦× ×‘×¨×©×ª ×•×™×§×œ×•×˜ ××ª ×”×ª×¢×‘×•×¨×” ×©×¢×•×‘×¨×ª ×‘×”. ×œ××—×¨ ××›×Ÿ ×™×¢×‘×“ ××ª ×”××™×“×¢ ×•×™×–×”×” ××ª×§×¤×•×ª ×”××ª×¨×—×©×•×ª ×‘×¨×©×ª ×•××ª ×”×ª×•×§×¤×™×. ×™×¤×•×ª×— ×‘-Python ×•×‘×¢×–×¨×ª ×¡×¤×¨×™×™×ª Scapy.
+                              1. Communication with server - ××—×¨××™ ×¢×œ ×‘×™×¦×•×¢ ×”×ª×§×©×•×¨×ª ××•×œ ×”×©×¨×ª, ×›×•×œ×œ ×˜×™×¤×•×œ ×‘×ª×§×œ×•×ª ×ª×§×©×•×¨×ª.
+                              2. Logic ×¨×›×™×‘ ×œ×•×’×™×§×” - ×”×—×œ×§ ×”××—×¨××™ ×œ×¢×™×‘×•×“ ×”××™×“×¢ ×”××ª×§×‘×œ ××¡×¨×™×§×ª ×”×¨×©×ª ×•×–×™×”×•×™ ×”××ª×§×¤×•×ª ×•×”×ª×•×§×¤×™×. 
+                              3. Scans - ×”×¨×›×™×‘ ×”××—×¨××™ ×œ×˜×™×¤×•×œ ×‘× ×•×©× ×”×¡×¨×™×§×•×ª ×‘×¨××” ×”×œ×•×§××œ×™×ª ×›×œ×•××¨ ×™×¢×‘×“ ××ª ×”××™×“×¢ ×©×”-Logic ×–×™×”×” ×œ×›×“×™ ××™×“×¢ ×©×”-Client ×™×‘×™×Ÿ, ×™×©××•×¨ ××ª ×”-Log ×”×¢×“×›× ×™ ×‘× ×•×’×¢ ×œ××¦×‘ ×ª×§×™×¤×ª ×”×¨×©×ª.
+                              4. Communication with client - ××—×¨××™ ×¢×œ ×‘×™×¦×•×¢ ×”×ª×§×©×•×¨×ª ××•×œ ×”×œ×§×•×— (WEB).
+                              5. Communication with router - ××—×¨××™ ×¢×œ ×‘×™×¦×•×¢ ×•×™×“×•× ××•×ª× ×˜×™×§×¦×™×” ××•×œ ×”×¨××•×˜×¨ ×•×× ×”×œ ×”×¨×©×ª. 
+                              2. Server - 
+                              1. Communication with device - ××—×¨××™ ×¢×œ ×‘×™×¦×•×¢ ×”×ª×§×©×•×¨×ª ××•×œ ×”×¨×›×™×‘, ×›×•×œ×œ ×˜×™×¤×•×œ ×‘×ª×§×œ×•×ª ×ª×§×©×•×¨×ª. ×¨×›×™×‘ ×–×” ×™×›×ª×‘ ×‘-#C ×•×™×ª××•×š ×‘×—×™×‘×•×¨ ×¨×‘ ××©×ª××©×™× (Multi threaded).
+                              2. Logic - ××—×¨××™ ×¢×œ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×•×”×‘×§×©×•×ª ×”××ª×§×‘×œ×™× ×‘×ª×§×©×•×¨×ª, ××™××•×ª ××• ×¢×“×›×•×Ÿ ×©×œ×”× ××•×œ ×¨×›×™×‘ ×‘×¡×™×¡ ×”× ×ª×•× ×™×, ×•×”×¢×‘×¨×ª ×‘×§×©×•×ª ×œ××¢× ×” ×”××ª××™×.
+                              3. Communication with google's SMTP server - ××—×¨××™ ×¢×œ ×©×œ×™×—×ª ×”×œ×•×’ ×‘××™×™×œ ×œ××©×ª××©×™× ×‘×××¦×¢×•×ª ×”×©×™×¨×•×ª SMTP ×©×œ ×’×•×’×œ.
+                              4. DB Wrapper ×¨×›×™×‘ ×‘×¡×™×¡ × ×ª×•× ×™× - ××—×¨××™ ×œ×©×œ×•×£, ×œ×”×•×¡×™×£ ×•×œ×¢×“×›×Ÿ × ×ª×•× ×™× ××•×œ ×‘×¡×™×¡ ×”× ×ª×•× ×™× (× ×™×ª×Ÿ ×œ×”× ×™×— ×©×”×˜×‘×œ××•×ª ×›×‘×¨ ×§×™×™××•×ª ×‘×• ×•× ×•×¦×¨×• ××¨××©). ×¨×›×™×‘×™× ××—×¨×™× (×›××• ×œ×•×’×™×§×”) ××ª×§×©×¨×™× ××•×œ×• ×¢×œ ×× ×ª ×œ×¢×‘×•×“ ×‘××•×¤×Ÿ ××¡×•×“×¨, ×‘×˜×•×— ×•×™×¢×™×œ ××•×œ ×‘×¡×™×¡ ×”× ×ª×•× ×™× ×©×œ ×”×ª×•×›× ×”. ğŸ—‘ï¸
+	×”×ª×××” ×œ××¤×™×•×Ÿ
+×¢×‘×•×¨ ×›×œ ×“×¨×™×©×” ××¤×¨×§ ×”××¤×™×•×Ÿ, ×¦×™×™× ×• ××”× ×”×¨×›×™×‘×™× ××©×¨ ××¡×¤×§×™× ××¢× ×” ×¢×‘×•×¨×”. ×‘××™×“×” ×•×™×©× × ××¡×¤×¨ ×¨×›×™×‘×™× ×”× ×•×‘×¢×™× ××“×¨×™×©×” ××—×ª, ×™×© ×œ×¦×™×™×Ÿ ××ª ×¡×“×¨ ×”×¤×¢×•×œ×” ×‘×™× ×™×”×:
+
+
+×¤×™×¦'×¨
+	×¨×›×™×‘×™× ×¨×œ×•×•× ×˜×™×™×
+	×—×™×‘×•×¨ ×œ××§×•×¨×•×ª ×•×™×“××• ×—×™×¦×•× ×™×™×
+	Backend Server, Video Management Service, Video Sources and VMS, Database
+	×¦×¤×™×™×” ×‘×©×™×“×•×¨ ×—×™
+	Web Client, Backend Server, Video Management Service, Video Sources
+	×¤×œ×™×™×‘×§ ×©×œ ×”×§×œ×˜×•×ª ×”×™×¡×˜×•×¨×™×•×ª
+	Web Client, Backend Server, Database
+	×× ×œ×™×˜×™×§×” ××‘×•×¡×¡×ª AI
+	Backend Server, AI and Video Analysis Engine, Video Sources
+	×–×™×”×•×™ ×ª× ×•×¢×” ×—×©×•×“×”
+	AI and Video Analysis Engine, Backend Server, Database
+	×–×™×”×•×™ ×—×¤×¦×™× × ×˜×•×©×™×
+	AI and Video Analysis Engine, Backend Server, Database
+	×–×™×”×•×™ ×œ×•×—×™×•×ª ×¨×™×©×•×™ (LPR)
+	AI and Video Analysis Engine, Backend Server, Database
+	×–×™×”×•×™ ×¤× ×™×
+	AI and Video Analysis Engine, Backend Server, Database
+	×™×¦×™×¨×ª ××™×¨×•×¢×™× ××•×˜×•××˜×™×ª
+	Backend Server, Events Service, AI Engine, Database
+	×—×™×¤×•×© ×—×›× ×‘×ª×•×›×Ÿ ×•×™×“××•
+	Web Client, Backend Server, Database
+	××¤×ª ×¨×§×¢ ××™× ×˜×¨××§×˜×™×‘×™×ª
+	Web Client, GIS Services
+	×”×¦×’×ª ××™×¨×•×¢×™× ×‘×–××Ÿ ×××ª ×¢×œ ×”××¤×”
+	Web Client, Backend Server, GIS Services
+	×”×¦×’×ª ×”×™×¡×˜×•×¨×™×™×ª ××™×§×•× ×‘×¦×™×¨ ×–××Ÿ
+	Web Client, Backend Server, Database
+	×—×™×¤×•×© ××™×§×•× ×œ×¤×™ ×›×ª×•×‘×ª ××• GPS
+	Web Client, GIS Services
+	×’×™××•×¤× ×¡×™× ×’
+	Backend Server, GIS Services, Database
+	×¡×™×•×•×’ ××™×¨×•×¢×™×
+	Backend Server, Events Service, AI Engine
+	×ª×™×¢×•×“ ××œ× ×©×œ ××™×¨×•×¢×™×
+	Backend Server, Database
+	×× ×’× ×•×Ÿ ×¢×“×™×¤×•×ª ×•×—×•××¨×”
+	Backend Server, Events Service
+	×”×ª×¨××•×ª Push Email SMS
+	Backend Server, Notification Service, External Providers
+	××¢×¨×›×ª ×œ×•×’×™× ×•××•×“×™×˜
+	Backend Server, Audit Service, Database
+	×–×™×”×•×™ ×—×¨×™×’×•×ª ×‘×–××Ÿ ×××ª
+	AI Engine, Backend Server
+	×–×™×”×•×™ ××’××•×ª ×•×˜×¨× ×“×™×
+	Backend Server, Database
+	×“×•×—×•×ª ×—×›××™×
+	Backend Server, Database
+	×—×™×‘×•×¨ ×œ VMS
+	Backend Server, Video Management Service
+	×ª××™×›×” ×‘××¦×œ××•×ª IoT
+	Backend Server, Video Sources
+	××™× ×˜×’×¨×¦×™×” ×œ GIS
+	Backend Server, GIS Services
+	×—×™×‘×•×¨ ×œ××¢×¨×›×•×ª ×—×™×¨×•× CAD
+	Backend Server, External CAD Systems
+	Dashboard ×‘×–××Ÿ ×××ª
+	Web Client, Backend Server
+	×ª×¦×•×’×ª ×•×™×“××• ××¤×” ×•××™×¨×•×¢×™×
+	Web Client, Backend Server
+	×¡×™× ×•×Ÿ ××™×¨×•×¢×™×
+	Web Client, Backend Server
+	KPI ×•×™×–×•××œ×™×™×
+	Web Client, Backend Server
+	Timeline ××™× ×˜×¨××§×˜×™×‘×™
+	Web Client, Backend Server
+	×ª××™×›×” ×‘×“×¡×§×˜×•×¤ ××•×‘×™×™×œ ×˜××‘×œ×˜
+	Web Client
+	× ×™×”×•×œ ×”×¨×©××•×ª RBAC
+	Backend Server, Authentication Service
+	×”×¦×¤× ×ª × ×ª×•× ×™×
+	Backend Server, Database
+	×”×ª×—×‘×¨×•×ª ×¢× OAuth2
+	Web Client, Backend Server, Authentication Service
+	×œ×•×’×™ ×¤×¢×•×œ×•×ª ××©×ª××©
+	Backend Server, Audit Service, Database
+	×¤×¨×™×¡×” ×‘×¢× ×Ÿ ××• On Premise
+	Backend Server, Database
+	×××’×¨ ×•×™×“××• ××¨×›×™×•× ×™
+	Backend Server, Database
+	×™×¦×•× CSV PDF
+	Backend Server, Web Client
+	×“×•×—×•×ª ×—×•×“×©×™×™× ×•×¨×‘×¢×•× ×™×™×
+	Backend Server, Database
+	×¤×™×œ×•×—×™× ××ª×§×“××™×
+	Backend Server, Database
+	
+
+ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××™×œ×• ×¨×›×™×‘×™× ××©×ª×ª×¤×™×/×‘××™× ×œ×™×“×™ ×‘×™×˜×•×™ ×‘×›×œ ×¤×™×¦'×¨?
+×œ×“×•×’××”:
+×”×ª×—×‘×¨×•×ª ×”×¨×›×™×‘ ×œ×¨××•×˜×¨
+	×¨×›×™×‘ (×œ×•×’×™×§ > ×ª×§×©×•×¨×ª ×¢× ×”×¨××•×˜×¨)
+	×‘×™×¦×•×¢ ×¡×¨×™×§×•×ª
+	×œ×§×•×— (WEB GUI ->×œ×•×’×™×§ -> ×ª×§×©×•×¨×ª ×¢× ×”×¨×›×™×‘) >
+×¨×›×™×‘ (×ª×§×©×•×¨×ª ×¢× ×”×œ×§×•×— > ×œ×•×’×™×§ > scans)
+	×©×œ×™×—×ª ×“×•×— ×œ××—×¨ ×¡×¨×™×§×”
+	×¨×›×™×‘ (scans > ×œ×•×’×™×§ > ×ª×§×©×•×¨×ª ×¢× ×”×œ×§×•×—)
+×œ×§×•×— (×ª×§×©×•×¨×ª ×¢× ×”×¨×›×™×‘ > ×œ×•×’×™×§ > ×××©×§ WEB
++
+×¨×›×™×‘ (scans > ×œ×•×’×™×§ > ×ª×§×©×•×¨×ª ×¢× ×”×©×¨×ª) >
+×©×¨×ª (×ª×§×©×•×¨×ª ×¢× ×”×¨×›×™×‘ > ×œ×•×’×™×§ > ×ª×§×©×•×¨×ª ×¢× ×©×¨×ª SMTP)
+	ğŸ—‘ï¸
+	×¢×™×¦×•×‘ × ×ª×•× ×™× ×•×™×©×•×™×•×ª ××™×“×¢
+×“×¨×š ×˜×•×‘×” ×œ×”×‘×™×Ÿ ××ª ×”××¢×¨×›×ª ×”×™× ×“×¨×š ×”× ×ª×•× ×™× ×•×™×™×©×•×™×•×ª ×”××™×“×¢ ×©×¢×•×‘×¨×™× ×•× ×©××¨×™× ×‘×”. 
+×”×›×•×•× ×” ×”×™× ×œ××™×“×¢ ×©××•×¢×‘×¨ ×‘×ª×•×š ×”××¢×¨×›×ª (×œ××©×œ ×‘×™×Ÿ ××•×“×•×œ×™× / ×¨×›×™×‘×™× ×©×•× ×™×, ××• ×‘×™×Ÿ ×œ×§×•×— ×œ×©×¨×ª ×¢×œ ×’×‘×™ ×”×¨×©×ª) ×•×’× ×œ××™×“×¢ ×©× ×©××¨ ×¢×œ ×™×“×™ ×”××¢×¨×›×ª (×œ××©×œ ×‘-DB, ×§×‘×¦×™ ×˜×§×¡×˜ ××• ×‘×™× ××¨×™×™×). ×©×™××• ×œ×‘ ×›×™ ×™×™×©×•×™×•×ª ×™×›×•×œ×•×ª ×œ×”×›×™×œ ×™×™×©×•×™×•×ª ××—×¨×•×ª:
+×¢×™×¦×•×‘ × ×ª×•× ×™× ×•×™×©×•×™×•×ª ××™×“×¢
+×”××™×“×¢ ×”××•×¢×‘×¨ ×‘×ª×•×š ××¢×¨×›×ª SHOB Web ××ª×—×œ×§ ×œ×©× ×™ ×¡×•×’×™× ×¢×™×§×¨×™×™×:
+×‘×§×©×•×ª ×•××¢× ×™×, ×©××™× × × ×©××¨×™× ×œ×˜×•×•×— ××¨×•×š, ×•××™×“×¢ ×ª×¤×¢×•×œ×™ ×•×¢×¡×§×™, ××©×¨ × ×©××¨ ×‘××¡×“ ×”× ×ª×•× ×™× ×œ×¦×•×¨×š ×ª×™×¢×•×“, × ×™×ª×•×— ×•×”×¦×’×” ×¢×ª×™×“×™×ª.
+________________
+
+
+×‘×§×©×•×ª ×•××¢× ×™× ×‘×™×Ÿ Web Client ×œ Backend Server
+××™×“×¢ ×–×” ××™× ×• × ×©××¨ ×‘××¡×“ ×”× ×ª×•× ×™×, ××œ× ××©××© ×œ×ª×§×©×•×¨×ª ×‘×–××Ÿ ×××ª.
+                              * ×‘×§×©×ª ×”×ª×—×‘×¨×•×ª ××©×ª××©
+                              * ××¢× ×” ×¢×œ ×‘×§×©×ª ×”×ª×—×‘×¨×•×ª ×•×”×—×–×¨×ª Authentication Token
+                              * ×‘×§×©×ª ×¦×¤×™×™×” ×‘×©×™×“×•×¨ ×—×™ ×××¦×œ××”
+                              * ××¢× ×” ×¢× ×¤×¨×˜×™ ×–×¨× ×”×•×•×™×“××•
+                              * ×‘×§×©×ª ×¤×œ×™×™×‘×§ ×©×œ ×”×§×œ×˜×” ×œ×¤×™ ×–××Ÿ
+                              * ××¢× ×” ×¢× × ×ª×•× ×™ ×”×”×§×œ×˜×”
+                              * ×‘×§×©×ª ×¡×™× ×•×Ÿ ×•×—×™×¤×•×© ××™×¨×•×¢×™×
+                              * ××¢× ×” ×¢× ×¨×©×™××ª ××™×¨×•×¢×™× ×ª×•×××ª
+                              * ×‘×§×©×ª ×™×¦×•× ×“×•×—×•×ª
+                              * ××¢× ×” ×¢× ×§×•×‘×¥ CSV ××• PDF
+________________
+
+
+×‘×§×©×•×ª ×•××¢× ×™× ×‘×™×Ÿ Backend Server ×œ AI and Video Analysis Engine
+××™×“×¢ ×–×” ××©××© ×œ×¢×™×‘×•×“ ×•× ×™×ª×•×— ×•××™× ×• × ×©××¨ ×‘×©×œ××•×ª×•.
+                              * ×‘×§×©×ª × ×™×ª×•×— ×•×™×“××• ××• ×¤×¨×™×™××™×
+                              * ××¢× ×” ×¢× ×ª×•×¦××•×ª ×–×™×”×•×™ ×—×¨×™×’×•×ª
+                              * ××¢× ×” ×¢× ×¨××ª ×××™× ×•×ª ×•×¡×•×’ ×–×™×”×•×™
+________________
+
+
+×‘×§×©×•×ª ×•××¢× ×™× ×‘×™×Ÿ Backend Server ×œ××§×•×¨×•×ª ×•×™×“××•
+××™×“×¢ ×–×” ××©××© ×œ××©×™×›×ª × ×ª×•× ×™× ×‘×–××Ÿ ×××ª.
+                              * ×‘×§×©×ª ×©×™×“×•×¨ ×—×™
+                              * ×‘×§×©×ª ×’×™×©×” ×œ×”×§×œ×˜×•×ª ×”×™×¡×˜×•×¨×™×•×ª
+                              * ××¢× ×” ×¢× ×–×¨× ×•×™×“××• ×•××˜× ×“××˜×”
+________________
+
+
+××™×“×¢ ×”×¢×•×‘×¨ ×•× ×©××¨ ×‘××¢×¨×›×ª
+××™×“×¢ ××¡×•×’ User Data
+×›×•×œ×œ ×¤×¨×˜×™ ××©×ª××©×™× ×•×”×¨×©××•×ª.
+×”××™×“×¢ × ×©××¨ ×‘ Database ×•× ×’×™×© ×¨×§ ×œ Backend Server.
+                              * ×©× ××©×ª××©
+                              * ×›×ª×•×‘×ª ××™××™×™×œ
+                              * ×¡×™×¡××” ××•×¦×¤× ×ª
+                              * ×ª×¤×§×™×“ ×•×”×¨×©××•×ª
+________________
+
+
+××™×“×¢ ××¡×•×’ Camera Data
+×›×•×œ×œ × ×ª×•× ×™× ×¢×œ ××¦×œ××•×ª ×•××§×•×¨×•×ª ×•×™×“××•.
+×”××™×“×¢ × ×©××¨ ×‘ Database.
+                              * ××–×”×” ××¦×œ××”
+                              * ××™×§×•× ×’×™××•×’×¨×¤×™
+                              * ×›×ª×•×‘×ª ××§×•×¨ ×”×•×•×™×“××•
+                              * ×¡×˜×˜×•×¡
+________________
+
+
+××™×“×¢ ××¡×•×’ Event Data
+×›×•×œ×œ ××™×¨×•×¢×™× ×©× ×•×¦×¨×• ××•×˜×•××˜×™×ª ××• ×™×“× ×™×ª.
+×”××™×“×¢ × ×©××¨ ×‘ Database.
+                              * ×¡×•×’ ××™×¨×•×¢
+                              * ×–××Ÿ
+                              * ××™×§×•×
+                              * ×¨××ª ×—×•××¨×”
+                              * ×§×™×©×•×¨ ×œ×•×™×“××•
+________________
+
+
+××™×“×¢ ××¡×•×’ AI Analysis Results
+×›×•×œ×œ ×ª×•×¦××•×ª × ×™×ª×•×— ×—×›×.
+×”××™×“×¢ × ×©××¨ ×‘ Database ×œ×¦×•×¨×š × ×™×ª×•×— ×¢×ª×™×“×™ ×•×“×•×—×•×ª.
+                              * ×¡×•×’ ×”×–×™×”×•×™
+                              * ×¨××ª ×××™× ×•×ª
+                              * ××•×‘×™×™×§×˜×™× ×©×–×•×”×•
+________________
+
+
+××™×“×¢ ××¡×•×’ Video Archive Metadata
+×›×•×œ×œ ××˜× ×“××˜×” ×¢×œ ×”×§×œ×˜×•×ª ×•×™×“××•.
+×”××™×“×¢ × ×©××¨ ×‘ Database, ×‘×¢×•×“ ×©×§×‘×¦×™ ×”×•×•×™×“××• ×¢×¦×× × ×©××¨×™× ×‘××—×¡×•×Ÿ ×™×™×¢×•×“×™.
+                              * ×–××Ÿ ×”×ª×—×œ×” ×•×¡×™×•×
+                              * ××¦×œ××”
+                              * ××™×§×•× ××—×¡×•×Ÿ
+________________
+
+
+××™×“×¢ ××¡×•×’ Logs and Audit Data
+×›×•×œ×œ ×ª×™×¢×•×“ ×¤×¢×•×œ×•×ª ××©×ª××©×™× ×•×¤×¢×•×œ×•×ª ××¢×¨×›×ª.
+×”××™×“×¢ × ×©××¨ ×‘ Database.
+                              * ××–×”×” ××©×ª××©
+                              * ×¤×¢×•×œ×”
+                              * ×–××Ÿ
+                              * ×›×ª×•×‘×ª IP
+________________
+
+
+××™×“×¢ ×”××•×¢×‘×¨ ×œ××¢×¨×›×•×ª ×—×™×¦×•× ×™×•×ª
+                              * × ×ª×•× ×™ ×”×ª×¨××•×ª ×”× ×©×œ×—×™× ×œ×©×™×¨×•×ª×™ Email, SMS ×• Push
+                              * × ×ª×•× ×™ ××™×§×•× ×•××™×¨×•×¢×™× ×”××•×¢×‘×¨×™× ×œ××¢×¨×›×•×ª GIS
+                              * × ×ª×•× ×™ ××™×¨×•×¢×™× ×§×¨×™×˜×™×™× ×”××•×¢×‘×¨×™× ×œ××¢×¨×›×•×ª ×—×™×¨×•× CAD
+ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ×¡×•×’ ×”××™×“×¢ ×©×¢×•×‘×¨ ×‘××¢×¨×›×ª? ×”×× ×”×•× × ×©××¨ ××• ×œ×? ×× ×”×•× × ×©××¨, ×”×™×›×Ÿ ×”×•× × ×©××¨? ×‘×™×Ÿ ××™×œ×• ×¨×›×™×‘×™× ×”×•× ×¢×•×‘×¨?
+×œ×“×•×’××”:
+×”××™×“×¢ ×”××•×¢×‘×¨ ×‘×ª×•×š ×”××¢×¨×›×ª ×©×œ× ×• ×”×•× ×‘×§×©×•×ª (×œ× × ×©××¨×•×ª) ×•××™×“×¢ (× ×©××¨):
+                              1. ×‘×§×©×•×ª ×•××¢× ×•×ª ×‘×™×Ÿ ×”×©×¨×ª ×œ×¨×›×™×‘ ×”×¡×¨×™×§×•×ª:
+                              1. ×‘×§×©×ª ××™×©×•×¨ ×”×¨×©××” / ×”×ª×—×‘×¨×•×ª
+                              2. ××¢× ×” ×¢×œ ××™×©×•×¨ ×”×¨×©××” / ×”×ª×—×‘×¨×•×ª
+                              3. ×‘×§×©×ª ××™×©×•×¨ ×”×¨×©××” ×©×œ ××©×ª××© ×œ×¨×›×™×‘ 
+                              4. ××¢× ×” ×¢×œ ××™×©×•×¨ ×”×¨×©××” ×©×œ ××©×ª××© ×œ×¨×›×™×‘
+                              5. ×‘×§×©×ª ×©×œ×™×—×ª ×§×•×‘×¥ LOG ×œ××™×™×œ.
+                              6. ××¢× ×” ×¢×œ ×©×œ×™×—×ª ×§×•×‘×¥ LOG ×œ××™×™×œ.
+                              2. ×‘×§×©×•×ª ×•××¢× ×•×ª ×‘×™×Ÿ ×”×œ×§×•×— ×œ×¨×›×™×‘:
+                              1. ×‘×§×©×ª ×”×ª×—×‘×¨×•×ª / ×”×¨×©××” 
+                              2. ××¢× ×” ×¢×œ ×‘×§×©×ª ×”×ª×—×‘×¨×•×ª / ×”×¨×©××”
+                              3. ×‘×§×©×ª ×”×¤×¢×œ×ª ×¡×¨×™×§×”.
+                              4. ×§×‘×œ×ª × ×ª×•× ×™ ×”×¡×¨×™×§×”.
+                              5. ×‘×§×©×ª ×©×œ×™×—×ª ×”×¡×¨×™×§×” ×œ××™×™×œ.
+                              3. ××™×“×¢ ×”×¢×•×‘×¨ ×‘××¢×¨×›×ª:
+                              1. × ×ª×•× ×™ ××©×ª××©×™× (×©× ××©×ª××©, ×¡×™×¡×× ×•×›×•')
+                              2. ×ª×•×¦××•×ª ×¡×¨×™×§×•×ª ğŸ—‘ï¸
+	________________
+
+
+
+
+    ×¤×¨×§ 4: ×ª×•×›× ×™×ª ×¢×‘×•×“×”
+××©×™××•×ª ×•×ª×œ×•×™×•×ª
+××ª ×¡×¢×™×£ ×–×” ×™×© ×œ××œ× ×¢×œ ×‘×¡×™×¡ ×¤×™×¨×•×˜ ×”×“×¨×™×©×•×ª ×©×›×ª×‘×ª× ×‘×¤×¨×§ ×”××¤×™×•×Ÿ, ×•×‘×”×ª×× ×œ×¨×›×™×‘×™× ×©×œ ××¡××š ×”××¨×›×™×˜×§×˜×•×¨×”.
+××›×™×•×•×Ÿ ×©×›×œ ×“×¨×™×©×” ××•×¨×›×‘×ª ×××¡×¤×¨ ×©×œ×‘×™× (×©×›×œ ××—×“ ××”× ×”×•× ×¤×™×¦'×¨ ×‘×¤× ×™ ×¢×¦××•), ×™×© ×œ×”×ª×™×™×—×¡ ×œ×›×œ ×©×œ×‘/×¤×™×¦'×¨ ×›×–×” ×‘×”×ª×× ×•×‘× ×¤×¨×“ ××”×™×ª×¨. ×‘×©×œ×‘ ×”×¨××©×•×Ÿ ×ª××¡×¤×¨×• ××ª ×”×¤×™×¦'×¨×™× ×©×œ×›× ×•×œ××—×¨ ××›×Ÿ ×ª×¤×¨×˜×• ××•×ª×Ÿ ×œ××©×™××•×ª ×‘×˜×‘×œ×”. ×©×™××• ×œ×‘ ×©××©×™××” ×¦×¨×™×›×” ×œ×”×™×•×ª ×ª×—×ª ×¨×›×™×‘ ××—×“. ×‘××™×“×” ×•×”×™× × ××¦××ª ×ª×—×ª ××¡×¤×¨ ×¨×›×™×‘×™×, ×™×© ×œ×¤×¨×•×˜ ××ª ×”××©×™××” ×¢×•×“ ×™×•×ª×¨. ×‘× ×•×¡×£, ×—×©×‘×• ×”×™×˜×‘ ×¢×œ ×¡×“×¨ ×”××©×™××•×ª ×‘×¨×¦×£ ×”×¤×™×ª×•×—. ×¡×¤×¦×™×¤×™×ª, ×”×× ×™×© ××©×™××•×ª ×©×ª×œ×•×™×•×ª ×‘×”×©×œ××” ×©×œ ××©×™××•×ª ××—×¨×•×ª ×§×•×“× ×œ×›×Ÿ.
+
+
+×¨×©×™××ª ×”×¤×™×¦'×¨×™×:
+                              1. ×¤×™×¦'×¨ â€¦
+                              2. ××¡' ×¤×™×¦'×¨
+	××©×™××”
+	××•×¤×¦×™×•× ×œ×™: ×ª×œ×•×™×•×ª
+(×”×× ×”××©×™××” ×ª×œ×•×™×” ×‘××©×™××” ××—×¨×ª? ××”×™?)
+	××•×¤×¦×™×•× ×œ×™: ×”×¢×¨×•×ª ×œ××©×™××”
+	×¨×›×™×‘ ×¨×œ×•×•× ×˜×™
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+	
+
+ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ×”××©×™××”? ×”×× ×”×™× ×ª×œ×•×™×” ×‘××©×™××” ××—×¨×ª? ×œ××™×–×” ×¨×›×™×‘/×™× ×”×™× ××ª×§×©×¨×ª?
+×œ×“×•×’××”:
+×¨×©×™××ª ×¤×™×¦'×¨×™×:
+                              1. ×”×¦×’×ª ×¨×©×ª×•×ª WiFi ×–××™× ×•×ª ×•×”×ª×—×‘×¨×•×ª ×œ××—×ª ××”×Ÿ
+                              2. ×œ×›×™×“×ª ×”×ª×¢×‘×•×¨×” ×©×¢×•×‘×¨×ª ×‘×¨×©×ª
+                              3. ×–×™×”×•×™ ×”×ª×§×¤×•×ª ×•×”×’× ×” ××¤× ×™×”×Ÿ
+                              4. ×–×™×”×•×™ ×”×ª×§×¤×ª Man In The Middle
+                              5. ×–×™×”×•×™ ×”×ª×§×¤×ª Evil twin
+1
+	×”×¦×’×ª ×¨×©×ª×•×ª WiFi ×–××™× ×•×ª ×œ××©×ª××©
+	×”×¤×™×¦'×¨ ×ª×œ×•×™ ×‘×›×š ×©×”×›×¨×˜×™×¡ ×¨×©×ª ×ª×•××š ×‘××¦×‘ MONITOR ×•××£ ×”×•×¢×‘×¨ ×œ××¦×‘ ×–×”
+	××ª ×”×¨×©×ª×•×ª × ×™×§×— ×‘×××¦×¢×•×ª ×¡×¨×™×§×ª BEACON-×™×
+	×¨×›×™×‘ ×”××•×ª× ×˜×™×§×¦×™×”
+	1
+	×”×ª×—×‘×¨×•×ª ×œ×¨×©×ª ××•×ª×” ×‘×—×¨ ×”××©×ª××©
+	×”×¤×™×¦'×¨ ×ª×œ×•×™ ×‘×›×š ×©×”×•×¦×’×” ×¨×©×™××ª ×¨×©×ª×•×ª ×œ××©×ª××© ×•×‘×—×™×¨×ª×• ×”×ª×§×‘×œ×”
+	×”××©×ª××© ×™×‘×—×¨ ××ª ×”×¨×©×ª ×”×¨×¦×•×™×” ×‘×¤×œ×˜×¤×•×¨××ª WEB
+	×¨×›×™×‘ ×”××•×ª× ×˜×™×§×¦×™×”
+	ğŸ—‘ï¸
+	××™×˜×¨×¦×™×•×ª (×¡×¤×¨×™× ×˜×™×)
+×–×”×• ×”×—×œ×§ ×”××—×¨×•×Ÿ ×©×œ ××¡××š ×ª×›× ×•×ª ×”×¢×‘×•×“×”, ×•×ª×‘×¦×¢×• ××•×ª×• ×¨×§ ×œ××—×¨ ×©×§×™×‘×œ×ª× ×œ×›×š ××™×©×•×¨ ××¨××© ×”×¦×•×•×ª ×©×œ×›×.
+×›××•×‘×Ÿ ×©×™×© ×œ×”×¢×–×¨ ×‘×× ×˜×•×¨ ×‘××™×“×” ×•×™×© ×œ×›× ××—×“, ×¢×œ ×× ×ª ×œ×ª×›× ×Ÿ × ×›×•×Ÿ ××ª ××•×¤×Ÿ ×”×¢×‘×•×“×”.
+×™×© ×œ×–×›×•×¨ ×›×™ ×›×œ ××™×˜×¨×¦×™×” ×“×•×¨×©×ª ×—×œ×•×§×ª ××—×¨×™×•×ª ×‘×™×Ÿ ×›×œ ×—×‘×¨×™ ×”×¦×•×•×ª - ×”×™× ××ª×—×™×œ×” ×‘×ª×›× ×•×Ÿ ××¤×•×¨×˜ ×©×œ ×”×¨×›×™×‘×™× ×”××¤×•×ª×—×™× (×‘×”×ª×× ×œ××¡××›×™× ×©×›×ª×‘×ª× ×¢×“ ×›×”) ×•××¡×ª×™×™××ª ×‘×”×¦×’×ª ×¤×¨×•×™×§×˜ ×¨×¥.
+×¢×œ×™×›× ×œ×ª×¢×“×£ ××ª ×”××©×™××•×ª ×œ×¤×™ ×¡×“×¨ ×¤×™×ª×•×—. ×—×œ×§×• ××•×ª× ×œ××™×˜×¨×¦×™×•×ª ×©×•× ×•×ª ×¢×œ ×¤×™ ×©×™×§×•×œ×™× ×©×œ ×ª×œ×•×™×•×ª ×•×¡×“×¨ ×—×©×™×‘×•×ª.
+                              1. ××™×˜×¨×¦×™×” 1:
+                              1. ××©×™××” â€¦ (×¤×™×¦'×¨ â€¦ )
+                              2.                               2. ××™×˜×¨×¦×™×” 2:
+                              1. ××©×™××” â€¦ (×¤×™×¦'×¨ â€¦)
+                              2. ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ×”×“×‘×¨ ×”×›×™ ×‘×¡×™×¡×™ ×©×—×™×™×‘ ×œ×”×™×›× ×¡ ×‘××™×˜×¨×¦×™×”? ××™×–×” ×™×›×•×œ×ª ×—×“×©×” ×ª×¨×¦×• ×œ×”×•×¡×™×£ ×œ××¢×¨×›×ª ×©×œ×›× ×‘×¡×•×£ ×”××™×˜×¨×¦×™×”? ×”×× ×™×© ×“×‘×¨×™× ×¤×—×•×ª ×—×©×•×‘×™× ×©×ª×¨×¦×• ×œ×ª×¢×“×£ ×œ××™×˜×¨×¦×™×•×ª ×××•×—×¨×•×ª ×™×•×ª×¨? ×”×¤×¢×™×œ×• ×©×™×§×•×œ×™× ×©×œ ×ª×œ×•×™×•×ª: ×›××” ×–××Ÿ ×”××©×™××•×ª ×‘××™×˜×¨×¦×™×” ×™×™×§×—×•? ×”×× ×”×˜×›× ×•×œ×•×’×™×” ×”×‘×©×™×œ×”? ×”×× ×™×© ×ª×œ×•×™×•×ª ×‘×™×Ÿ ××©×™××•×ª?
+×œ×“×•×’××”:
+                              1. ××™×˜×¨×¦×™×” 1:
+                              1. ×”×¢×‘×¨×ª ×›×¨×˜×™×¡ ×”×¨×©×ª ×œ××¦×‘ MONITOR  (×¤×™×¦'×¨ 2)
+                              2. ×”×’×“×¨×ª ×¡×§××¤×™ ×•×”×ª×—×œ×ª ×œ×›×™×“×ª ×”×ª×¢×‘×•×¨×” ×©×¢×•×‘×¨×ª ×‘×¨×©×ª (×¤×™×¦'×¨ 2) 
+                              3. ×”×¦×’×ª ×¨×©×ª×•×ª WiFi ×–××™× ×•×ª ×œ××©×ª××© (×¤×™×¦'×¨ 1)
+                              4. ×”×ª×—×‘×¨×•×ª ×œ×¨×©×ª ××•×ª×” ×‘×—×¨ ×”××©×ª××© (×¤×™×¦'×¨ 1)
+                              5. ×”×›× ×ª ×ª×•×›× ×ª ×œ×§×•×— ×œ×× ×’× ×•×Ÿ ××•×ª× ×˜×™×§×¦×™×” (×¤×™×¦'×¨ 9) 
+                              6. ×”×›× ×ª ×ª×•×›× ×ª ×©×¨×ª ×œ×¨×›×™×‘ ×”××•×ª× ×˜×™×§×¦×™×” (×¤×™×¦'×¨ 9)
+                              2. ××™×˜×¨×¦×™×” 2:
+                              1. ×¡×¨×™×§×ª ×‘×§×©×•×ª ×•×ª×©×•×‘×•×ª ARP ×•×©××™×¨×ª× (×¤×™×¦'×¨ 4)
+                              2. ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×©× ×©××¨×• ×•×‘×“×™×§×” ×©×œ ×”×× ×”×ª×¨×—×©×” ××ª×§×¤×ª MITM (×¤×™×¦'×¨ 4) ğŸ—‘ï¸
+	
+
+________________
+
+
+    ×¤×¨×§ 5: ×¢×™×¦×•×‘
+ğŸ‘‚ ×©×™××• ×œ×‘: ×™×© 5 ××™×˜×¨×¦×™×•×ª ×•×¢×‘×•×¨ ×›×œ ××—×ª ××”×Ÿ ×ª×¦×˜×¨×›×• ×œ×©×›×¤×œ ××ª ×”×—×œ×§ ×©××•×¤×™×¢ ×œ××˜×” ×•×œ××œ× ××•×ª×• ×‘×”×ª××.
+
+××™×˜×¨×¦×™×” 1
+×—×–×•×Ÿ:
+××˜×¨×•×ª ×”××™×˜×¨×¦×™×” ×”×Ÿ â€¦
+×‘×¡×™×•× ×”××™×˜×¨×¦×™×” ×™×”×™×” ×ª×•×¦×¨ ×©×¢×•×©×” â€¦
+ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ××ª× ××¦×¤×™× ×œ×”×©×™×’ ×‘×¡×•×£ ×”××™×˜×¨×¦×™×”?
+×œ×“×•×’××”:
+                              * ×‘×¡×™×•× ×”××™×˜×¨×¦×™×” ×”× "×œ, ×ª×•×¦×’ ×œ××©×ª××© ×¨×©×™××” ×©×œ ×¨×©×ª×•×ª WIFI ××”×Ÿ ×™×¦×˜×¨×š ×œ×‘×—×•×¨ ××—×ª. ×× ×§×™×™××ª ××‘×˜×—×”, ×™×“×¨×© ×”××©×ª××© ×œ×”×§×™×© ×¡×™×¡×× ×•×œ××—×¨ ××›×Ÿ ×”×¨×›×™×‘ ×™×—×•×‘×¨ ×œ×¨×©×ª ×‘××•×¤×Ÿ ××•×˜×•××˜×™.
+                              * ×‘×¡×™×•× ×”××™×˜×¨×¦×™×” ×× ×• ××¦×¤×™× ×©× ×¦×œ×™×— ×œ×”×¡× ×™×£ ××ª ×›×œ ×ª×¢×‘×•×¨×ª ×”×¨×©×ª.ğŸ—‘ï¸
+	
+
+××©×™××•×ª ×¢×™×§×¨×™×•×ª
+×”××©×™××•×ª ×”×¢×™×§×¨×™×•×ª ×©×œ ×”××™×˜×¨×¦×™×” ×”×–×•:
+                              1. ××©×™××” â€¦ ×©×¢×•×©×” â€¦
+                              2. ğŸ—‘ï¸ ×©××œ×• ××ª ×¢×¦××›×: ××” ×”××©×™××•×ª ×”×¢×™×§×¨×™×•×ª ×©××ª× ××¦×¤×™× ×œ×”×©×œ×™× ×•/××• ×œ×”×ª×§×“× ×‘×”× ×¢×“ ×¡×•×£ ×”××™×˜×¨×¦×™×”? ×¢×œ ××” ××ª× ×©××™× ××ª ×”×¤×•×§×•×¡ ×‘×ª×¢×“×•×£? ×”×•×¡×™×¤×• ×¦×™×œ×•×/×ª××•× ×” ×× ×¦×¨×™×š.
+×œ×“×•×’××”:
+                              * ×”×”×ª×—×‘×¨×•×ª ×œ×¨×©×ª ×ª×¢×©×” ×‘×¢×™×§×¨ ×¢×œ ×™×“×™ ×¤×§×•×“×•×ª ××¢×¨×›×ª (System calls) ×•×œ×›×Ÿ ×©×œ×•×©×ª ×”×™××™× ×”×¨××©×•× ×™× ×™×•×§×“×© ×”×–××Ÿ ×œ××—×§×¨ ×¢×œ ×§×¨×™××•×ª ××¢×¨×›×ª ×‘× ×•×©×. ××ª ××¦×™××ª ×”×¨×©×ª×•×ª ×”×–××™× ×•×ª × ×××© ×‘×××¦×¢×•×ª ×”×¡× ×¤×ª ×—×‘×™×œ×•×ª ×‘×™×§×•×Ÿ (×—×‘×™×œ×•×ª ××™×“×¢ ×©ACCESS POINT×™× ×©×•×œ×—×™× ×¢×œ ×× ×ª ×œ×™×“×¢ ×¢×œ ×§×™×•××) ×œ×¦×•×¨×š ×›×š ×™×•×§×“×© ×©×‘×•×¢. ×œ××—×¨ ××›×Ÿ, × ×¢×‘×•×¨ ×œ××™××•×© ×‘×§×•×“ ×‘×• × ×©×œ×‘ ××ª ×”×¤×§×•×“×•×ª ×”×©×•× ×•×ª ×¢×œ ×× ×ª ×œ×”×’×™×¢ ×œ×—×–×•×Ÿ ×©×”×’×“×¨× ×• ×œ×¢×¦×× ×•.
+                              * ××™×©×•×¨ ×”×”×¡× ×¤×•×ª ×™×ª×¤×•×¡ ×—×œ×§ ×§×˜×Ÿ ×™×•×ª×¨ ××”×¡×¤×¨×™× ×˜ ××š ×™×”×•×•×” ×—×œ×§ ××©××¢×•×ª×™ ×™×•×ª×¨ ×‘×”××©×š ×”×¤×¨×•×™×™×§×˜ ×•×œ×›×Ÿ ×¢×œ×™× ×• ×œ×”×©×§×™×¢ ×™×•×ª×¨ ×‘××—×§×¨. ×›××• ×›×Ÿ, ×œ×¦×•×¨×š ×”×¡× ×¤×ª ×”×¨×©×ª ×™×© ×¦×•×¨×š ×œ×”×¢×‘×™×¨ ××ª ×›×¨×˜×™×¡ ×”×¨×©×ª ×œ××¦×‘ monitor mode. ×œ××—×§×¨ ×¢×œ ×”×¢×‘×¨ ×”×›×¨×˜×™×¡ ×œ××¦×‘ ××•× ×™×˜×•×¨ ×•×”×‘× ×” ×©×œ ×”××©××¢×•×™×•×ª ×”×›×¨×•×›×•×ª ×‘×–×” ×™×•×§×“×© ×©×‘×•×¢ ×•×—×¦×™ ×©×‘×¡×•×¤×• ×× ×• ×¨×•×¦×™× ×œ×”×¦×œ×™×— ×œ×”×¢×‘×™×¨ ××ª ×›×¨×˜×™×¡ ×”×¨×©×ª ×œ××¦×‘ ×–×” ×•×œ×“×¢×ª ×œ×”×©×ª××© ×‘×•. ×©× ×¦×œ×™×—, ×× ×• ×¨×•×¦×™× ×’× ×œ×§× ×¤×’ ××ª Scapy ×›×š ×©×™×©×ª××© ×‘×›×¨×˜×™×¡ ×”×¨×©×ª ×©×”×•×¢×‘×¨ ×œ××¦×‘ ××•× ×™×˜×•×¨ ×•×œ×”×¤×™×¡ ××ª ×›×œ ×”×ª×¢×‘×•×¨×” ×‘×¨×©×ª ×œ×ª×•×š ×§×•×‘×¥. ×œ×¦×•×¨×š ×›×š ×× ×• ××§×“×™×©×™× ×©×œ×•×©×” ×™××™×.ğŸ—‘ï¸
+	
+
+×©×¨×˜×•×˜ ×©×œ ×¨×›×™×‘ ×©××ª× ×”×•×œ×›×™× ×œ×××© ×‘×¡×¤×¨×™× ×˜:
+×©×¨×˜×•×˜ (××¢×•×œ× ×”× ×“×¡×ª ×”×ª×•×›× ×”) ×©×œ ×¨×›×™×‘ ×œ×‘×—×™×¨×ª×›× ×©××ª× ×”×•×œ×›×™× ×œ×××© ×‘×¡×¤×¨×™× ×˜:
+ ×§×•×‘×¥ ğŸ—‘ï¸
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/README.md b/event-monitoring-mvp-architecture/README.md
index a57774f..0778701 100644
--- a/event-monitoring-mvp-architecture/README.md
+++ b/event-monitoring-mvp-architecture/README.md
@@ -1,58 +1,58 @@
-# Event Monitoring and Management Platform
-
-## Overview
-
-The Event Monitoring and Management Platform is designed to provide real-time monitoring and management of environmental, safety, and security events. This platform integrates live video streams, AI-based video analytics, a GIS map for visualization, and an event management system to log and track incidents.
-
-## Project Structure
-
-The project is organized into several key directories and files:
-
-- **docs/**: Contains documentation related to prompts, architecture, API specifications, data models, non-functional requirements, and the project roadmap.
-- **src/**: Contains the source code for the application, including the entry point and type definitions.
-- **package.json**: Configuration file for npm, listing dependencies and scripts.
-- **tsconfig.json**: Configuration file for TypeScript, specifying compiler options.
-
-## Getting Started
-
-To set up the project locally, follow these steps:
-
-1. **Clone the repository**:
-   ```
-   git clone <repository-url>
-   cd event-monitoring-mvp-architecture
-   ```
-
-2. **Install dependencies**:
-   ```
-   npm install
-   ```
-
-3. **Run the application**:
-   ```
-   npm start
-   ```
-
-## Features
-
-- **Live Video Streaming**: Connect to IP cameras and view live feeds.
-- **AI Detection**: Utilize AI models for detecting people, vehicles, and suspicious behavior.
-- **Event Management**: Log, classify, and track incidents in real-time.
-- **GIS Mapping**: Visualize camera locations and events on an interactive map.
-- **User Authentication**: Secure access with role-based authentication.
-
-## Future Enhancements
-
-The project roadmap includes plans for additional features and improvements in future phases, such as:
-
-- Integration of multiple AI models for enhanced detection capabilities.
-- Advanced event lifecycle management and reporting features.
-- Scalability improvements to support a larger number of cameras and users.
-
-## Contributing
-
-Contributions are welcome! Please submit a pull request or open an issue for any enhancements or bug fixes.
-
-## License
-
+# Event Monitoring and Management Platform
+
+## Overview
+
+The Event Monitoring and Management Platform is designed to provide real-time monitoring and management of environmental, safety, and security events. This platform integrates live video streams, AI-based video analytics, a GIS map for visualization, and an event management system to log and track incidents.
+
+## Project Structure
+
+The project is organized into several key directories and files:
+
+- **docs/**: Contains documentation related to prompts, architecture, API specifications, data models, non-functional requirements, and the project roadmap.
+- **src/**: Contains the source code for the application, including the entry point and type definitions.
+- **package.json**: Configuration file for npm, listing dependencies and scripts.
+- **tsconfig.json**: Configuration file for TypeScript, specifying compiler options.
+
+## Getting Started
+
+To set up the project locally, follow these steps:
+
+1. **Clone the repository**:
+   ```
+   git clone <repository-url>
+   cd event-monitoring-mvp-architecture
+   ```
+
+2. **Install dependencies**:
+   ```
+   npm install
+   ```
+
+3. **Run the application**:
+   ```
+   npm start
+   ```
+
+## Features
+
+- **Live Video Streaming**: Connect to IP cameras and view live feeds.
+- **AI Detection**: Utilize AI models for detecting people, vehicles, and suspicious behavior.
+- **Event Management**: Log, classify, and track incidents in real-time.
+- **GIS Mapping**: Visualize camera locations and events on an interactive map.
+- **User Authentication**: Secure access with role-based authentication.
+
+## Future Enhancements
+
+The project roadmap includes plans for additional features and improvements in future phases, such as:
+
+- Integration of multiple AI models for enhanced detection capabilities.
+- Advanced event lifecycle management and reporting features.
+- Scalability improvements to support a larger number of cameras and users.
+
+## Contributing
+
+Contributions are welcome! Please submit a pull request or open an issue for any enhancements or bug fixes.
+
+## License
+
 This project is licensed under the MIT License. See the LICENSE file for more details.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/api/ai_callbacks.md b/event-monitoring-mvp-architecture/docs/api/ai_callbacks.md
index 31fc5b3..035f2c2 100644
--- a/event-monitoring-mvp-architecture/docs/api/ai_callbacks.md
+++ b/event-monitoring-mvp-architecture/docs/api/ai_callbacks.md
@@ -1,71 +1,71 @@
-# AI Callbacks Documentation for Event Monitoring and Management Platform
-
-## Overview
-
-This document outlines the AI service callbacks for the Event Monitoring and Management Platform. It details how the AI service communicates with the backend API, including the expected payloads and response formats. This ensures a clear understanding of the integration points between the AI service and the backend, facilitating future modifications and expansions.
-
-## AI Service Callbacks
-
-### 1. Detection Event Callback
-
-**Endpoint:** `POST /internal/ai/events`
-
-**Description:** This endpoint is used by the AI service to send detection events to the backend API. Each detection event includes relevant information about the detected object, such as its type and location.
-
-**Request Payload:**
-
-```json
-{
-  "camera_id": "string",
-  "timestamp": "ISO 8601 timestamp",
-  "detection_type": "string", // e.g., "person", "vehicle"
-  "coordinates": {
-    "latitude": "float",
-    "longitude": "float"
-  },
-  "confidence_score": "float"
-}
-```
-
-**Response:**
-
-- **Status Code:** `201 Created` if the event is successfully recorded.
-- **Body:**
-
-```json
-{
-  "event_id": "string",
-  "message": "Event recorded successfully."
-}
-```
-
-### 2. Error Handling Callback
-
-**Endpoint:** `POST /internal/ai/errors`
-
-**Description:** This endpoint is used to report any errors encountered by the AI service during processing. This helps in monitoring and debugging the AI service's performance.
-
-**Request Payload:**
-
-```json
-{
-  "error_type": "string", // e.g., "processing_error", "network_error"
-  "timestamp": "ISO 8601 timestamp",
-  "details": "string" // Detailed error message
-}
-```
-
-**Response:**
-
-- **Status Code:** `200 OK` if the error report is successfully received.
-- **Body:**
-
-```json
-{
-  "message": "Error reported successfully."
-}
-```
-
-## Future Considerations
-
+# AI Callbacks Documentation for Event Monitoring and Management Platform
+
+## Overview
+
+This document outlines the AI service callbacks for the Event Monitoring and Management Platform. It details how the AI service communicates with the backend API, including the expected payloads and response formats. This ensures a clear understanding of the integration points between the AI service and the backend, facilitating future modifications and expansions.
+
+## AI Service Callbacks
+
+### 1. Detection Event Callback
+
+**Endpoint:** `POST /internal/ai/events`
+
+**Description:** This endpoint is used by the AI service to send detection events to the backend API. Each detection event includes relevant information about the detected object, such as its type and location.
+
+**Request Payload:**
+
+```json
+{
+  "camera_id": "string",
+  "timestamp": "ISO 8601 timestamp",
+  "detection_type": "string", // e.g., "person", "vehicle"
+  "coordinates": {
+    "latitude": "float",
+    "longitude": "float"
+  },
+  "confidence_score": "float"
+}
+```
+
+**Response:**
+
+- **Status Code:** `201 Created` if the event is successfully recorded.
+- **Body:**
+
+```json
+{
+  "event_id": "string",
+  "message": "Event recorded successfully."
+}
+```
+
+### 2. Error Handling Callback
+
+**Endpoint:** `POST /internal/ai/errors`
+
+**Description:** This endpoint is used to report any errors encountered by the AI service during processing. This helps in monitoring and debugging the AI service's performance.
+
+**Request Payload:**
+
+```json
+{
+  "error_type": "string", // e.g., "processing_error", "network_error"
+  "timestamp": "ISO 8601 timestamp",
+  "details": "string" // Detailed error message
+}
+```
+
+**Response:**
+
+- **Status Code:** `200 OK` if the error report is successfully received.
+- **Body:**
+
+```json
+{
+  "message": "Error reported successfully."
+}
+```
+
+## Future Considerations
+
 As the platform evolves, additional callbacks may be introduced to handle more complex interactions between the AI service and the backend API. This may include callbacks for batch processing results, status updates, or other relevant events that enhance the functionality and responsiveness of the system.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/api/backend_endpoints.md b/event-monitoring-mvp-architecture/docs/api/backend_endpoints.md
index 271f1c3..2030e7b 100644
--- a/event-monitoring-mvp-architecture/docs/api/backend_endpoints.md
+++ b/event-monitoring-mvp-architecture/docs/api/backend_endpoints.md
@@ -1,105 +1,496 @@
-# Backend API Endpoints for Event Monitoring and Management Platform
-
-This document outlines the backend API endpoints for the Event Monitoring and Management Platform MVP. Each endpoint includes the route, HTTP method, description, and expected responses.
-
-## Authentication
-
-### POST /auth/login
-- **Description**: Authenticates a user and returns a JWT token.
-- **Request Body**:
-  - `username`: string
-  - `password`: string
-- **Responses**:
-  - **200 OK**: Returns a JWT token.
-  - **401 Unauthorized**: Invalid credentials.
-
-## Cameras
-
-### GET /cameras
-- **Description**: Retrieves a list of all cameras.
-- **Responses**:
-  - **200 OK**: Returns an array of camera objects.
-    - Example:
-      ```json
-      [
-        {
-          "camera_id": "1",
-          "name": "Main Entrance",
-          "location": {
-            "lat": 34.0522,
-            "lon": -118.2437
-          },
-          "stream_url": "rtsp://example.com/stream1"
-        }
-      ]
-      ```
-
-### GET /cameras/{id}
-- **Description**: Retrieves details of a specific camera by ID.
-- **Responses**:
-  - **200 OK**: Returns the camera object.
-  - **404 Not Found**: Camera not found.
-
-## Events
-
-### GET /events
-- **Description**: Retrieves a list of events, with optional filtering.
-- **Query Parameters**:
-  - `status`: string (optional, e.g., "active", "resolved")
-  - `camera_id`: string (optional)
-  - `start_time`: string (optional, ISO format)
-  - `end_time`: string (optional, ISO format)
-- **Responses**:
-  - **200 OK**: Returns an array of event objects.
-    - Example:
-      ```json
-      [
-        {
-          "event_id": "1",
-          "timestamp": "2023-10-01T12:00:00Z",
-          "camera_id": "1",
-          "event_type": "person_detected",
-          "snapshot_url": "http://example.com/snapshot1.jpg",
-          "status": "new"
-        }
-      ]
-      ```
-
-### GET /events/{id}
-- **Description**: Retrieves details of a specific event by ID.
-- **Responses**:
-  - **200 OK**: Returns the event object.
-  - **404 Not Found**: Event not found.
-
-### POST /events
-- **Description**: Creates a new event (for internal use by AI service).
-- **Request Body**:
-  - `camera_id`: string
-  - `event_type`: string
-  - `snapshot_url`: string (optional)
-- **Responses**:
-  - **201 Created**: Returns the created event object.
-  - **400 Bad Request**: Invalid input data.
-
-## Video Stream
-
-### GET /cameras/{id}/stream
-- **Description**: Retrieves the stream URL for a specific camera.
-- **Responses**:
-  - **200 OK**: Returns the stream URL.
-  - **404 Not Found**: Camera not found.
-
-## AI Integration
-
-### POST /internal/ai/events
-- **Description**: Receives detection results from the AI service.
-- **Request Body**:
-  - `camera_id`: string
-  - `timestamp`: string (ISO format)
-  - `detection_type`: string (e.g., "person", "vehicle")
-  - `confidence`: number
-- **Responses**:
-  - **200 OK**: Event created successfully.
-  - **400 Bad Request**: Invalid input data.
-
-This document serves as a reference for developers to implement and utilize the backend API endpoints effectively.
\ No newline at end of file
+# Backend API Endpoints for Event Monitoring and Management Platform
+
+This document outlines the backend API endpoints for the Event Monitoring and Management Platform. The API supports multi-tenant operation with company isolation, mobile citizen reporting, first responder tracking, and dynamic event types.
+
+**Authentication Overview**:
+- **Web Dashboard**: JWT-based authentication for operators, admins, and company admins
+- **Mobile Apps**: API key validation for company access, separate mobile authentication
+- **First Responders**: Phone/password authentication with API key validation
+- **Multi-Tenant**: All endpoints are company-scoped via API keys or user company association
+
+## Authentication Endpoints
+
+### POST /api/auth/register
+- **Description**: Register a new web dashboard user (operators, admins, company_admins).
+- **Headers**: X-API-Key: {company_api_key} (required for company-scoped registration)
+- **Request Body**:
+  ```json
+  {
+    "email": "string (required)",
+    "password": "string (required)",
+    "username": "string (optional)",
+    "firstName": "string (required)",
+    "lastName": "string (required)",
+    "role": "string (optional, default: 'operator')"
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns user object and JWT token
+  - **400 Bad Request**: Invalid input or missing required fields
+  - **409 Conflict**: User already exists
+  - **403 Forbidden**: Invalid API key or insufficient permissions
+
+### POST /api/auth/login
+- **Description**: Authenticate web dashboard user with email/password.
+- **Request Body**:
+  ```json
+  {
+    "email": "string",
+    "password": "string"
+  }
+  ```
+- **Responses**:
+  - **200 OK**: Returns JWT token and user profile
+  - **401 Unauthorized**: Invalid credentials
+
+### POST /api/auth/first-responder/login
+- **Description**: Authenticate first responder with phone/password.
+- **Headers**: X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "phone": "string",
+    "password": "string"
+  }
+  ```
+- **Responses**:
+  - **200 OK**: Returns JWT token and user profile with location tracking enabled
+  - **401 Unauthorized**: Invalid credentials or API key
+
+### POST /api/auth/validate-api-key
+- **Description**: Validate company API key for mobile app access.
+- **Headers**: X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: API key is valid, returns company info
+  - **401 Unauthorized**: Invalid API key
+
+## Company Management Endpoints
+
+### GET /api/companies
+- **Description**: List companies (super_admin only).
+- **Headers**: Authorization: Bearer {token}
+- **Query Parameters**:
+  - `status`: string (optional: "active", "suspended")
+  - `plan`: string (optional: "basic", "professional", "enterprise")
+- **Responses**:
+  - **200 OK**: Returns paginated array of company objects
+  - **403 Forbidden**: Insufficient permissions
+
+### POST /api/companies
+- **Description**: Create new company (super_admin only).
+- **Headers**: Authorization: Bearer {token}
+- **Request Body**:
+  ```json
+  {
+    "name": "string (required)",
+    "description": "string (optional)",
+    "contact": {
+      "email": "string",
+      "phone": "string",
+      "address": "object"
+    },
+    "subscription": {
+      "plan": "string",
+      "maxUsers": "number",
+      "maxCameras": "number"
+    }
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns company object with generated API key
+  - **403 Forbidden**: Insufficient permissions
+
+### GET /api/companies/{id}
+- **Description**: Get company details (company_admin or super_admin).
+- **Headers**: Authorization: Bearer {token}
+- **Responses**:
+  - **200 OK**: Returns company object
+  - **403 Forbidden**: Access denied
+  - **404 Not Found**: Company not found
+
+### PUT /api/companies/{id}
+- **Description**: Update company settings (company_admin or super_admin).
+- **Headers**: Authorization: Bearer {token}
+- **Request Body**: Partial company object
+- **Responses**:
+  - **200 OK**: Company updated
+  - **403 Forbidden**: Insufficient permissions
+
+### POST /api/companies/{id}/rotate-api-key
+- **Description**: Generate new API key for company (company_admin or super_admin).
+- **Headers**: Authorization: Bearer {token}
+- **Responses**:
+  - **200 OK**: Returns new API key
+  - **403 Forbidden**: Insufficient permissions
+
+## User Management Endpoints
+
+### GET /api/users
+- **Description**: List users in company (admin, company_admin, super_admin).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Query Parameters**:
+  - `role`: string (optional filter)
+  - `status`: string (optional: "active", "inactive")
+  - `page`: number, `limit`: number
+- **Responses**:
+  - **200 OK**: Returns paginated array of user objects
+  - **403 Forbidden**: Insufficient permissions
+
+### POST /api/users
+- **Description**: Create new user in company (admin, company_admin, super_admin).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "email": "string (optional for mobile-only)",
+    "phone": "string (optional)",
+    "username": "string (required)",
+    "password": "string (required)",
+    "firstName": "string (required)",
+    "lastName": "string (required)",
+    "role": "string (required)"
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns user object
+  - **403 Forbidden**: Insufficient permissions
+
+### GET /api/users/{id}
+- **Description**: Get user details.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns user object
+  - **403 Forbidden**: Access denied
+  - **404 Not Found**: User not found
+
+### PUT /api/users/{id}
+- **Description**: Update user (admin, company_admin, super_admin, or self).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**: Partial user object
+- **Responses**:
+  - **200 OK**: User updated
+  - **403 Forbidden**: Insufficient permissions
+
+## Event Endpoints
+
+### GET /api/events
+- **Description**: List events with filtering and pagination.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Query Parameters**:
+  - `status`: string (optional: "active", "resolved", "closed")
+  - `priority`: string (optional: "low", "medium", "high", "critical")
+  - `eventTypeId`: ObjectId (optional)
+  - `assignedTo`: ObjectId (optional)
+  - `startDate`: ISO string (optional)
+  - `endDate`: ISO string (optional)
+  - `page`: number, `limit`: number
+- **Responses**:
+  - **200 OK**: Returns paginated array of event objects with report counts
+  - **403 Forbidden**: Invalid API key
+
+### GET /api/events/{id}
+- **Description**: Get detailed event information.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns event object with related reports and event type details
+  - **403 Forbidden**: Access denied
+  - **404 Not Found**: Event not found
+
+### POST /api/events
+- **Description**: Create new event (operators and above).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "eventTypeId": "ObjectId (required)",
+    "title": "string (required)",
+    "description": "string (optional)",
+    "priority": "string (optional)",
+    "location": {
+      "type": "Point",
+      "coordinates": [longitude, latitude]
+    },
+    "address": "string (optional)",
+    "assignedTo": "ObjectId (optional)",
+    "tags": ["string"] (optional)
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns created event object
+  - **400 Bad Request**: Invalid data
+  - **403 Forbidden**: Insufficient permissions
+
+### PUT /api/events/{id}
+- **Description**: Update event (assigned user or admin).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**: Partial event object
+- **Responses**:
+  - **200 OK**: Event updated
+  - **403 Forbidden**: Insufficient permissions
+
+### GET /api/events/{id}/reports
+- **Description**: Get all reports linked to an event.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns array of report objects
+  - **403 Forbidden**: Access denied
+
+## Report Endpoints
+
+### GET /api/reports
+- **Description**: List reports with filtering.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Query Parameters**:
+  - `status`: string (optional: "submitted", "reviewed", "verified", "rejected")
+  - `reportType`: string (optional)
+  - `eventId`: ObjectId (optional)
+  - `startDate`: ISO string (optional)
+  - `endDate`: ISO string (optional)
+  - `page`: number, `limit`: number
+- **Responses**:
+  - **200 OK**: Returns paginated array of report objects
+  - **403 Forbidden**: Invalid API key
+
+### GET /api/reports/{id}
+- **Description**: Get detailed report information.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns report object with attachments
+  - **403 Forbidden**: Access denied
+  - **404 Not Found**: Report not found
+
+### POST /api/mobile/reports
+- **Description**: Submit report from mobile app (citizen or first responder).
+- **Headers**: X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "reportType": "string (required: 'citizen', 'first_responder')",
+    "title": "string (required)",
+    "description": "string (required)",
+    "eventTypeId": "ObjectId (required)",
+    "location": {
+      "type": "Point",
+      "coordinates": [longitude, latitude]
+    },
+    "address": "string (optional)",
+    "attachments": [{
+      "type": "string ('image', 'video', 'audio')",
+      "data": "string (base64)",
+      "filename": "string"
+    }] (optional),
+    "metadata": {
+      "deviceInfo": "object",
+      "appVersion": "string"
+    } (optional)
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns created report object, may link to existing or new event
+  - **400 Bad Request**: Invalid data
+  - **403 Forbidden**: Invalid API key
+
+### PUT /api/reports/{id}/status
+- **Description**: Update report status (operators and above).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "status": "string",
+    "reviewedBy": "ObjectId (auto-filled)"
+  }
+  ```
+- **Responses**:
+  - **200 OK**: Report status updated
+  - **403 Forbidden**: Insufficient permissions
+
+### POST /api/reports/{id}/link-event
+- **Description**: Link report to an existing event or create new event from report.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "eventId": "ObjectId (optional - if null, creates new event)",
+    "createEvent": "boolean (default: true)"
+  }
+  ```
+- **Responses**:
+  - **200 OK**: Report linked to event
+  - **201 Created**: New event created and report linked
+  - **403 Forbidden**: Insufficient permissions
+
+## Camera Endpoints
+
+### GET /api/cameras
+- **Description**: List cameras in company.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Query Parameters**:
+  - `status`: string (optional)
+  - `page`: number, `limit`: number
+- **Responses**:
+  - **200 OK**: Returns paginated array of camera objects
+  - **403 Forbidden**: Invalid API key
+
+### GET /api/cameras/{id}
+- **Description**: Get camera details.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns camera object with configuration
+  - **403 Forbidden**: Access denied
+  - **404 Not Found**: Camera not found
+
+### POST /api/cameras
+- **Description**: Register new camera (admin, company_admin).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "name": "string (required)",
+    "serialNumber": "string (required)",
+    "model": "string (required)",
+    "location": {
+      "type": "Point",
+      "coordinates": [longitude, latitude]
+    },
+    "address": "string (optional)",
+    "streamUrl": "string (required)",
+    "config": "object (optional)"
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns camera object
+  - **403 Forbidden**: Insufficient permissions
+
+### PUT /api/cameras/{id}
+- **Description**: Update camera configuration.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**: Partial camera object
+- **Responses**:
+  - **200 OK**: Camera updated
+  - **403 Forbidden**: Insufficient permissions
+
+### GET /api/cameras/{id}/stream
+- **Description**: Get secure stream URL for camera.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns signed stream URL
+  - **403 Forbidden**: Access denied
+
+## Event Type Endpoints
+
+### GET /api/event-types
+- **Description**: List available event types (public and company-specific).
+- **Headers**: Authorization: Bearer {token} (optional), X-API-Key: {company_api_key}
+- **Query Parameters**:
+  - `isPublic`: boolean (optional)
+  - `category`: string (optional)
+  - `parentId`: ObjectId (optional)
+- **Responses**:
+  - **200 OK**: Returns array of event type objects
+  - **403 Forbidden**: Invalid API key
+
+### POST /api/event-types
+- **Description**: Create new event type (admin, company_admin, super_admin).
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "name": "string (required)",
+    "description": "string (optional)",
+    "category": "string (required)",
+    "parentId": "ObjectId (optional)",
+    "isPublic": "boolean (default: true)",
+    "priority": "string (default: 'medium')",
+    "autoCreateEvent": "boolean (default: false)"
+  }
+  ```
+- **Responses**:
+  - **201 Created**: Returns event type object
+  - **403 Forbidden**: Insufficient permissions
+
+### PUT /api/event-types/{id}
+- **Description**: Update event type.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Request Body**: Partial event type object
+- **Responses**:
+  - **200 OK**: Event type updated
+  - **403 Forbidden**: Insufficient permissions
+
+## Real-time Endpoints (WebSocket)
+
+### WS /api/realtime/events
+- **Description**: Real-time event updates and notifications.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Events**:
+  - `event_created`: New event notification
+  - `event_updated`: Event status/location changes
+  - `report_submitted`: New report notification
+
+### WS /api/realtime/location
+- **Description**: First responder location tracking.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Events**:
+  - `location_update`: Send current location
+  - `responder_available`: Status updates
+
+## AI Service Integration
+
+### POST /internal/ai/detections
+- **Description**: Receive AI detection results from camera service.
+- **Headers**: X-API-Key: {company_api_key}
+- **Request Body**:
+  ```json
+  {
+    "cameraId": "ObjectId",
+    "timestamp": "ISO string",
+    "detections": [{
+      "type": "string",
+      "confidence": "number",
+      "boundingBox": "object (optional)"
+    }],
+    "snapshotUrl": "string (optional)"
+  }
+  ```
+- **Responses**:
+  - **200 OK**: Detection processed, report/event created if threshold met
+  - **400 Bad Request**: Invalid data
+
+## Analytics Endpoints
+
+### GET /api/analytics/events
+- **Description**: Event analytics and reporting.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Query Parameters**:
+  - `startDate`: ISO string
+  - `endDate`: ISO string
+  - `groupBy`: string ("day", "week", "month", "type")
+- **Responses**:
+  - **200 OK**: Returns analytics data
+  - **403 Forbidden**: Insufficient permissions
+
+### GET /api/analytics/performance
+- **Description**: System performance metrics.
+- **Headers**: Authorization: Bearer {token}, X-API-Key: {company_api_key}
+- **Responses**:
+  - **200 OK**: Returns performance metrics
+  - **403 Forbidden**: Insufficient permissions
+
+## Error Responses
+
+All endpoints may return the following error responses:
+- **400 Bad Request**: Invalid request data or parameters
+- **401 Unauthorized**: Missing or invalid authentication
+- **403 Forbidden**: Insufficient permissions or invalid API key
+- **404 Not Found**: Resource not found
+- **409 Conflict**: Resource already exists
+- **429 Too Many Requests**: Rate limit exceeded
+- **500 Internal Server Error**: Server error
+
+## Rate Limiting
+
+- **Mobile Reports**: 100 requests per hour per API key
+- **Web Dashboard**: 1000 requests per hour per user
+- **Real-time**: Unlimited for active connections
+- **AI Integration**: 1000 requests per minute per camera
+
+This API documentation reflects the multi-tenant architecture with company isolation, flexible event types, and comprehensive mobile integration.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/api/mobile_endpoints.md b/event-monitoring-mvp-architecture/docs/api/mobile_endpoints.md
new file mode 100644
index 0000000..3e8ae3e
--- /dev/null
+++ b/event-monitoring-mvp-architecture/docs/api/mobile_endpoints.md
@@ -0,0 +1,448 @@
+# DEV-13: Mobile API Implementation
+**Implementation Summary for Approval**  
+Mobile App Integration Project
+
+## Overview
+DEV-13 creates mobile-optimized APIs that integrate with our existing multi-tenant, permission-based architecture. These APIs enable the Mobile team to authenticate users, submit events, and retrieve dynamic event types while maintaining consistency with our current system design.
+
+## APIs to Build
+
+| API | Purpose | Request | Response |
+|-----|---------|---------|----------|
+| `POST /api/mobile/auth/company-validate` | Validate company API credentials | Headers: `X-API-Key`, `X-Company-ID` | `{ valid, company: { id, name, settings } }` |
+| `POST /api/mobile/auth/first-responder` | Authenticate First Responder via existing JWT system | `{ username, password }` + Header: `X-API-Key` | `{ success, token, user: { id, username, role } }` |
+| `POST /api/mobile/auth/anonymous-session` | Create anonymous session for civilians | `{ deviceInfo: { platform, version, deviceId } }` + Header: `X-API-Key` | `{ success, sessionToken, deviceId }` |
+| `GET /api/mobile/event-types` | Retrieve dynamic event types for company | Headers: `X-API-Key`, `Authorization: Bearer <token>` | `{ eventTypes: [{ id, name, severity }] }` |
+| `POST /api/mobile/reports` | Submit incident reports using Report model | `{ type, subType, severity, description, location, media? }` + Headers: `X-API-Key`, `Authorization` | `{ success, reportId, status }` |
+| `GET /api/mobile/reports/my` | Retrieve user's own submitted reports only | Headers: `X-API-Key`, `Authorization` + Query: `?date=2024-12-26&status=new&limit=50` | `{ reports: [{ id, type, severity, status, timestamp }] }` |
+| `GET /api/mobile/reports/{id}` | Get specific report details (own reports only) | Headers: `X-API-Key`, `Authorization` | `{ report: { id, type, description, location, media, status } }` |
+
+## Files to Modify (Leveraging Existing Architecture)
+
+| File | Purpose |
+|------|---------|
+| `src/routes/auth.ts` | Add mobile authentication endpoints |
+| `src/controllers/authController.ts` | Add mobile-specific auth handlers |
+| `src/routes/reports.ts` | Add mobile report submission and retrieval endpoints |
+| `src/controllers/reportController.ts` | Add mobile report handlers |
+| `src/routes/events.ts` | Add mobile event retrieval endpoints |
+| `src/controllers/eventController.ts` | Add mobile event retrieval handlers |
+| `src/middleware/auth.ts` | Add mobile API key validation |
+| `src/types/index.ts` | Extend existing interfaces for mobile responses |
+
+## Technical Sync Document Coverage
+
+This implementation addresses the WEB-App technical sync requirements while maintaining architectural consistency:
+
+| Section | Requirement | Covered By |
+|---------|-------------|------------|
+| 1 | Check if user is First Responder | `POST /auth/first-responder` |
+| 3 | Receive reports with dynamic event types | `POST /reports` + `GET /event-types` |
+| 4 | Identify reporter type | Authentication middleware logic |
+| 5 | Validate API Key per company | Company-scoped API key middleware |
+| 5 | Multi-tenancy support | Company-based API key validation |
+| - | View user's own reports only | `GET /reports/my` with user-scoped access |
+
+## API Details
+
+### 1. POST /api/mobile/auth/company-validate
+**Purpose:** Validate company API credentials and retrieve company settings
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+X-Company-ID: <company_id>
+```
+
+**Response:**
+```json
+{
+  "valid": true,
+  "company": {
+    "id": "comp_001",
+    "name": "City Emergency Services",
+    "settings": {
+      "allowAnonymousReports": true,
+      "requiredEventFields": ["location", "eventType"]
+    }
+  }
+}
+```
+
+### 2. POST /api/mobile/auth/first-responder
+**Purpose:** Authenticate First Responder using existing JWT system
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+```
+
+**Request Body:**
+```json
+{
+  "username": "john.doe",
+  "password": "securepassword"
+}
+```
+
+**Response:**
+```json
+{
+  "success": true,
+  "token": "eyJhbGciOiJIUzI1NiIs...",
+  "user": {
+    "id": "user_001",
+    "username": "john.doe",
+    "role": "operator"
+  }
+}
+```
+
+### 3. POST /api/mobile/auth/anonymous-session
+**Purpose:** Create anonymous session for civilian reporters
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+```
+
+**Request Body:**
+```json
+{
+  "deviceInfo": {
+    "platform": "iOS",
+    "version": "1.0.0",
+    "deviceId": "unique_device_identifier"
+  }
+}
+```
+
+**Response:**
+```json
+{
+  "success": true,
+  "sessionToken": "temp_session_token",
+  "deviceId": "device_001",
+  "expiresIn": 3600
+}
+```
+
+### 4. GET /api/mobile/event-types
+**Purpose:** Retrieve dynamic event types configured for the company
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+Authorization: Bearer <token_or_session_token>
+```
+
+**Response:**
+```json
+{
+  "eventTypes": [
+    {
+      "id": "person_detected",
+      "name": "Person Detected",
+      "severity": "low"
+    },
+    {
+      "id": "suspicious_behavior", 
+      "name": "Suspicious Behavior",
+      "severity": "medium"
+    },
+    {
+      "id": "abandoned_object",
+      "name": "Abandoned Object", 
+      "severity": "high"
+    }
+  ]
+}
+```
+
+### 5. POST /api/mobile/reports
+**Purpose:** Submit incident reports using Report model structure
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+Authorization: Bearer <token_or_session_token>
+```
+
+**Request Body:**
+```json
+{
+  "type": "FIRE",
+  "subType": "FOREST",
+  "severity": "HIGH",
+  "description": "Large forest fire spreading rapidly",
+  "location": {
+    "latitude": 32.0853,
+    "longitude": 34.7818
+  },
+  "media": {
+    "images": ["base64_encoded_image_1", "base64_encoded_image_2"],
+    "videos": ["base64_encoded_video"]
+  }
+}
+```
+
+**Response:**
+```json
+{
+  "success": true,
+  "reportId": "rpt_abc123",
+  "status": "new",
+  "reporterType": "FR"
+}
+```
+
+### 6. GET /api/mobile/reports/my
+**Purpose:** Retrieve user's own submitted reports only (security: user can only see their own data)
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+Authorization: Bearer <token_or_session_token>
+```
+
+**Query Parameters:**
+```
+?date=2024-12-26&dateFrom=2024-12-01&dateTo=2024-12-31&status=new&type=FIRE&severity=HIGH&limit=50&offset=0&sortBy=timestamp&sortOrder=desc
+```
+
+**Available Filters:**
+- `date`: Specific date (YYYY-MM-DD)
+- `dateFrom` / `dateTo`: Date range filter
+- `status`: Filter by status (`new`, `acknowledged`, `resolved`, `closed`)
+- `type`: Filter by report type (`FIRE`, `MEDICAL`, `POLICE`, etc.)
+- `severity`: Filter by severity (`LOW`, `MEDIUM`, `HIGH`, `CRITICAL`)
+- `limit`: Number of results to return (default: 20, max: 100)
+- `offset`: Pagination offset
+- `sortBy`: Sort field (`timestamp`, `severity`, `status`)
+- `sortOrder`: Sort direction (`asc`, `desc`)
+
+**Response:**
+```json
+{
+  "reports": [
+    {
+      "id": "rpt_abc123",
+      "type": "FIRE",
+      "subType": "FOREST",
+      "severity": "HIGH",
+      "status": "acknowledged",
+      "timestamp": "2024-12-26T10:30:00Z",
+      "location": {
+        "latitude": 32.0853,
+        "longitude": 34.7818
+      },
+      "lastUpdated": "2024-12-26T10:45:00Z"
+    }
+  ],
+  "pagination": {
+    "total": 15,
+    "limit": 50,
+    "offset": 0,
+    "hasMore": false
+  },
+  "summary": {
+    "totalByStatus": {
+      "new": 3,
+      "acknowledged": 8,
+      "resolved": 4,
+      "closed": 0
+    },
+    "totalBySeverity": {
+      "LOW": 2,
+      "MEDIUM": 5,
+      "HIGH": 7,
+      "CRITICAL": 1
+    }
+  }
+}
+```
+
+### 7. GET /api/mobile/reports/{id}
+**Purpose:** Get detailed information for a specific report (security: only own reports or reports assigned to user)
+
+**Request Headers:**
+```
+X-API-Key: <company_api_key>
+Authorization: Bearer <token_or_session_token>
+```
+
+**Security Rules:**
+- First Responders: Can view reports they submitted or reports assigned to them
+- Anonymous users: Can only view reports they submitted during their session
+- Returns 404 if report doesn't belong to user
+
+**Response:**
+```json
+{
+  "report": {
+    "id": "rpt_abc123",
+    "type": "FIRE",
+    "subType": "FOREST",
+    "severity": "HIGH",
+    "description": "Large forest fire spreading rapidly",
+    "location": {
+      "latitude": 32.0853,
+      "longitude": 34.7818
+    },
+    "media": {
+      "images": ["base64_encoded_image_1"],
+      "videos": ["base64_encoded_video"]
+    },
+    "status": "acknowledged",
+    "timestamp": "2024-12-26T10:30:00Z",
+    "submittedBy": "user_001",
+    "assignedTo": "user_002",
+    "lastUpdated": "2024-12-26T10:45:00Z",
+    "statusHistory": [
+      {
+        "status": "new",
+        "timestamp": "2024-12-26T10:30:00Z",
+        "changedBy": "system"
+      },
+      {
+        "status": "acknowledged",
+        "timestamp": "2024-12-26T10:45:00Z", 
+        "changedBy": "user_002",
+        "comment": "Emergency crews dispatched"
+      }
+    ]
+  }
+}
+```
+
+## Authentication Middleware Integration
+
+### Company API Key Validation
+Extends existing `src/middleware/auth.ts` to validate company-specific API keys:
+```typescript
+export const validateMobileApiKey = (req, res, next) => {
+  // Validate X-API-Key against Company.apiKey
+  // Set req.company for downstream use
+  // Ensure company is active
+}
+
+export const validateMobileUserAccess = (req, res, next) => {
+  // Ensure user can only access their own reports
+  // For FR: reports they submitted OR reports assigned to them
+  // For Anonymous: reports from their session only
+}
+```
+
+### Role-Based Access
+Leverages existing User model roles with mobile-specific restrictions:
+- `admin`: Can view reports they submitted (mobile access is limited even for admins)
+- `operator`: Can view reports they submitted or assigned to them
+- `anonymous`: Can only view reports from their current session
+- **Security**: NO access to camera-detected events (that's web dashboard only)
+- **Scope**: Users only see their own data, never company-wide data
+
+## Integration with Existing Models
+
+This implementation extends our current type definitions in `src/types/index.ts`:
+
+```typescript
+// Mobile-specific response interfaces
+export interface MobileAuthResponse {
+  success: boolean;
+  token?: string;
+  sessionToken?: string;
+  user?: Pick<User, 'id' | 'username' | 'role'>;
+}
+
+export interface MobileReportRequest {
+  type: string;
+  subType: string;
+  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
+  description: string;
+  location: Camera['location'];
+  media?: {
+    images?: string[];
+    videos?: string[];
+  };
+}
+
+export interface MobileEventResponse {
+  events: Array<Pick<Event, 'id' | 'eventType' | 'cameraId' | 'timestamp' | 'status'> & {
+    cameraName: string;
+    location: Camera['location'];
+  }>;
+  pagination: {
+    total: number;
+    limit: number;
+    offset: number;
+    hasMore: boolean;
+  };
+}
+```
+
+## Implementation Steps for Web Backend
+
+### Phase 1: Core Infrastructure
+1. **Extend Type Definitions**
+   - Add mobile-specific interfaces to `src/types/index.ts`
+   - Add Company model with `apiKey` field
+   - Add anonymous session types
+
+2. **Update Authentication Middleware**
+   - Modify `src/middleware/auth.ts` to support company API key validation
+   - Add mobile-specific authentication handlers
+   - Implement session management for anonymous users
+
+3. **Database Schema Updates**
+   - Add `apiKey` field to Company model
+   - Add anonymous session storage
+   - Update User model for mobile authentication
+
+### Phase 2: API Implementation
+4. **Authentication Endpoints**
+   - Implement `POST /api/mobile/auth/company-validate` in `src/routes/auth.ts`
+   - Implement `POST /api/mobile/auth/first-responder` in `src/controllers/authController.ts`
+   - Implement `POST /api/mobile/auth/anonymous-session` for civilian access
+
+5. **Report Management Endpoints**
+   - Implement `GET /api/mobile/event-types` in `src/routes/events.ts`
+   - Implement `POST /api/mobile/reports` in `src/controllers/reportController.ts`
+   - Implement `GET /api/mobile/reports/my` with user-scoped filtering
+   - Implement `GET /api/mobile/reports/{id}` with ownership validation
+   - Add comprehensive filtering (date ranges, status, type, severity)
+   - Add pagination and sorting capabilities
+
+### Phase 3: Testing & Documentation
+6. **API Testing**
+   - Create unit tests for all mobile endpoints
+   - Test company isolation and API key validation
+   - Verify existing web functionality remains intact
+
+7. **API Documentation**
+   - Update OpenAPI/Swagger documentation
+   - Create mobile integration guide
+   - Document authentication flows
+
+## Benefits of This Approach
+
+- âœ… Leverages existing authentication system
+- âœ… Maintains multi-tenant company isolation  
+- âœ… Uses current Event and User models
+- âœ… Consistent with existing API patterns
+- âœ… No parallel systems or data duplication
+- âœ… Mobile team gets clear API specification for development
+
+## Mobile Team Integration
+
+Once the web backend implementation is complete, the mobile team can:
+
+1. **Use the API specification above** to build their integration
+2. **Test against fake responses** during development (DEV-15 will provide real data)
+3. **Follow the authentication flows** outlined in this document
+4. **Submit incident reports using the Report model** structure  
+5. **Retrieve only their own submitted reports** (with comprehensive filtering)
+6. **Implement pagination and date filtering** for report history
+7. **Handle different user types** (First Responders vs Anonymous sessions)
+8. **Respect security boundaries** (no access to camera events or other users' data)
+
+This implementation ensures the mobile APIs integrate seamlessly with our existing architecture while providing clear specifications for the mobile development team.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/architecture/c4_component.md b/event-monitoring-mvp-architecture/docs/architecture/c4_component.md
index 0155176..171505c 100644
--- a/event-monitoring-mvp-architecture/docs/architecture/c4_component.md
+++ b/event-monitoring-mvp-architecture/docs/architecture/c4_component.md
@@ -1,97 +1,97 @@
-# C4 Component Diagram for Event Monitoring and Management Platform
-
-## Overview
-
-This document provides a detailed breakdown of the C4 component diagram for the Event Monitoring and Management Platform MVP. It outlines the internal components of each container and their interactions, ensuring a clear understanding of the system's architecture for future expansion and modification.
-
-## Components
-
-### 1. Frontend (React Web Application)
-
-- **Auth Module**
-  - Handles user authentication.
-  - Interacts with the backend API to validate credentials and manage JWT tokens.
-
-- **Live Video View**
-  - Requests video stream URLs from the backend.
-  - Displays live video feeds from connected cameras.
-
-- **Events List / Events Panel**
-  - Fetches and displays a list of events from the backend.
-  - Allows users to view event details.
-
-- **Map View Module**
-  - Integrates with a map provider to display camera locations and active events.
-  - Requests camera and event data from the backend.
-
-- **Event Details View**
-  - Displays detailed information about a selected event, including snapshots and metadata.
-
-### 2. Backend API (Node.js + Express)
-
-- **Auth Controller**
-  - Manages user login and token issuance.
-  - Validates user credentials against the database.
-
-- **Camera Service**
-  - Provides endpoints to retrieve camera information.
-  - Returns camera details including stream URLs.
-
-- **Event Service**
-  - Manages event data, including creation, retrieval, and filtering of events.
-  - Interacts with the database to store and retrieve event records.
-
-- **Video Gateway**
-  - Facilitates access to live video streams.
-  - Provides endpoints to fetch stream URLs for frontend consumption.
-
-- **AI Integration Service**
-  - Receives detection results from the AI service.
-  - Creates event records in the database based on AI detections.
-
-### 3. AI & Video Analytics Service
-
-- **AI Model**
-  - Processes video streams to detect objects (e.g., people, vehicles).
-  - Sends detection results to the backend API for event creation.
-
-### 4. Database (MongoDB)
-
-- **Users Collection**
-  - Stores user data, including usernames, hashed passwords, and roles.
-
-- **Cameras Collection**
-  - Contains camera metadata, including IDs, names, locations, and stream URLs.
-
-- **Events Collection**
-  - Records event data, including timestamps, camera IDs, event types, and statuses.
-
-### 5. External Systems
-
-- **IP Cameras / VMS**
-  - Provides live video streams to the system.
-  - Interfaces with the AI service for video analytics.
-
-- **Map Provider**
-  - Supplies map tiles and geolocation services for the frontend application.
-
-## Interactions
-
-- **User Login Flow**
-  - User interacts with the Auth Module â†’ Sends credentials to the Auth Controller â†’ Validates against Users Collection â†’ Issues JWT token.
-
-- **Live Video Flow**
-  - Camera streams video â†’ Video Gateway provides stream URL â†’ Live Video View displays the stream.
-
-- **AI Detection Flow**
-  - Video stream processed by AI Model â†’ Detection results sent to AI Integration Service â†’ Event Service creates event in Events Collection.
-
-- **Event List Flow**
-  - Events Panel requests event data from Event Service â†’ Displays events fetched from Events Collection.
-
-- **Map View Flow**
-  - Map View Module requests camera and event data â†’ Displays camera locations and active events on the map.
-
-## Conclusion
-
+# C4 Component Diagram for Event Monitoring and Management Platform
+
+## Overview
+
+This document provides a detailed breakdown of the C4 component diagram for the Event Monitoring and Management Platform MVP. It outlines the internal components of each container and their interactions, ensuring a clear understanding of the system's architecture for future expansion and modification.
+
+## Components
+
+### 1. Frontend (React Web Application)
+
+- **Auth Module**
+  - Handles user authentication.
+  - Interacts with the backend API to validate credentials and manage JWT tokens.
+
+- **Live Video View**
+  - Requests video stream URLs from the backend.
+  - Displays live video feeds from connected cameras.
+
+- **Events List / Events Panel**
+  - Fetches and displays a list of events from the backend.
+  - Allows users to view event details.
+
+- **Map View Module**
+  - Integrates with a map provider to display camera locations and active events.
+  - Requests camera and event data from the backend.
+
+- **Event Details View**
+  - Displays detailed information about a selected event, including snapshots and metadata.
+
+### 2. Backend API (Node.js + Express)
+
+- **Auth Controller**
+  - Manages user login and token issuance.
+  - Validates user credentials against the database.
+
+- **Camera Service**
+  - Provides endpoints to retrieve camera information.
+  - Returns camera details including stream URLs.
+
+- **Event Service**
+  - Manages event data, including creation, retrieval, and filtering of events.
+  - Interacts with the database to store and retrieve event records.
+
+- **Video Gateway**
+  - Facilitates access to live video streams.
+  - Provides endpoints to fetch stream URLs for frontend consumption.
+
+- **AI Integration Service**
+  - Receives detection results from the AI service.
+  - Creates event records in the database based on AI detections.
+
+### 3. AI & Video Analytics Service
+
+- **AI Model**
+  - Processes video streams to detect objects (e.g., people, vehicles).
+  - Sends detection results to the backend API for event creation.
+
+### 4. Database (MongoDB)
+
+- **Users Collection**
+  - Stores user data, including usernames, hashed passwords, and roles.
+
+- **Cameras Collection**
+  - Contains camera metadata, including IDs, names, locations, and stream URLs.
+
+- **Events Collection**
+  - Records event data, including timestamps, camera IDs, event types, and statuses.
+
+### 5. External Systems
+
+- **IP Cameras / VMS**
+  - Provides live video streams to the system.
+  - Interfaces with the AI service for video analytics.
+
+- **Map Provider**
+  - Supplies map tiles and geolocation services for the frontend application.
+
+## Interactions
+
+- **User Login Flow**
+  - User interacts with the Auth Module â†’ Sends credentials to the Auth Controller â†’ Validates against Users Collection â†’ Issues JWT token.
+
+- **Live Video Flow**
+  - Camera streams video â†’ Video Gateway provides stream URL â†’ Live Video View displays the stream.
+
+- **AI Detection Flow**
+  - Video stream processed by AI Model â†’ Detection results sent to AI Integration Service â†’ Event Service creates event in Events Collection.
+
+- **Event List Flow**
+  - Events Panel requests event data from Event Service â†’ Displays events fetched from Events Collection.
+
+- **Map View Flow**
+  - Map View Module requests camera and event data â†’ Displays camera locations and active events on the map.
+
+## Conclusion
+
 This C4 component diagram serves as a foundational reference for the development of the Event Monitoring and Management Platform MVP. It is designed to facilitate future enhancements and modifications, ensuring the architecture remains adaptable to evolving requirements.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/architecture/c4_container.md b/event-monitoring-mvp-architecture/docs/architecture/c4_container.md
index d8de5d8..fff564f 100644
--- a/event-monitoring-mvp-architecture/docs/architecture/c4_container.md
+++ b/event-monitoring-mvp-architecture/docs/architecture/c4_container.md
@@ -1,70 +1,70 @@
-# C4 Container Diagram for Event Monitoring and Management Platform
-
-## Overview
-
-This document outlines the C4 container diagram for the Event Monitoring and Management Platform MVP. It provides a high-level view of the system's containers, their responsibilities, and interactions. The architecture is designed to be modular and scalable, allowing for future enhancements and modifications.
-
-## Containers
-
-### 1. React Web Application
-- **Description**: The frontend of the application that users interact with.
-- **Responsibilities**:
-  - User authentication and session management.
-  - Display live video streams from cameras.
-  - Show a list of events and their details.
-  - Provide a map view with camera locations and active events.
-
-### 2. Node.js Backend API
-- **Description**: The server-side application that handles business logic and data management.
-- **Responsibilities**:
-  - Authenticate users and issue JWT tokens.
-  - Serve camera data and event information to the frontend.
-  - Handle incoming detection events from the AI service.
-  - Interact with the MongoDB database for data storage and retrieval.
-
-### 3. AI Analytics Service
-- **Description**: A separate microservice responsible for processing video streams and detecting events.
-- **Responsibilities**:
-  - Analyze video feeds using AI models to detect people and vehicles.
-  - Send detection results back to the Node.js backend API for event creation.
-
-### 4. MongoDB Database
-- **Description**: The database used for storing application data.
-- **Responsibilities**:
-  - Store user information, camera details, and event records.
-  - Provide data persistence for the application.
-
-### 5. External Systems
-- **Description**: Systems that interact with the Event Monitoring Platform.
-- **Responsibilities**:
-  - IP Cameras or VMS: Provide live video streams to the application.
-  - Map Provider: Supply map tiles and geolocation services for the frontend.
-
-## Data Flows
-
-1. **User Authentication Flow**:
-   - User logs in via the React app.
-   - Credentials are sent to the Node.js backend API.
-   - The backend validates the credentials and returns a JWT token.
-
-2. **Live Video Stream Flow**:
-   - The React app requests video stream URLs from the Node.js backend API.
-   - The backend retrieves stream information and sends it back to the frontend.
-   - The frontend displays the live video using the provided URLs.
-
-3. **AI Detection Flow**:
-   - The AI Analytics Service processes video streams and detects events.
-   - Upon detection, it sends an HTTP POST request to the Node.js backend API with event details.
-   - The backend creates a new event record in the MongoDB database.
-
-4. **Event List Flow**:
-   - The React app requests the list of events from the Node.js backend API.
-   - The backend retrieves event data from MongoDB and returns it to the frontend for display.
-
-5. **Map View Flow**:
-   - The React app requests camera locations and active events from the Node.js backend API.
-   - The backend provides the necessary data, which the frontend uses to render the map with camera markers and event highlights.
-
-## Conclusion
-
+# C4 Container Diagram for Event Monitoring and Management Platform
+
+## Overview
+
+This document outlines the C4 container diagram for the Event Monitoring and Management Platform MVP. It provides a high-level view of the system's containers, their responsibilities, and interactions. The architecture is designed to be modular and scalable, allowing for future enhancements and modifications.
+
+## Containers
+
+### 1. React Web Application
+- **Description**: The frontend of the application that users interact with.
+- **Responsibilities**:
+  - User authentication and session management.
+  - Display live video streams from cameras.
+  - Show a list of events and their details.
+  - Provide a map view with camera locations and active events.
+
+### 2. Node.js Backend API
+- **Description**: The server-side application that handles business logic and data management.
+- **Responsibilities**:
+  - Authenticate users and issue JWT tokens.
+  - Serve camera data and event information to the frontend.
+  - Handle incoming detection events from the AI service.
+  - Interact with the MongoDB database for data storage and retrieval.
+
+### 3. AI Analytics Service
+- **Description**: A separate microservice responsible for processing video streams and detecting events.
+- **Responsibilities**:
+  - Analyze video feeds using AI models to detect people and vehicles.
+  - Send detection results back to the Node.js backend API for event creation.
+
+### 4. MongoDB Database
+- **Description**: The database used for storing application data.
+- **Responsibilities**:
+  - Store user information, camera details, and event records.
+  - Provide data persistence for the application.
+
+### 5. External Systems
+- **Description**: Systems that interact with the Event Monitoring Platform.
+- **Responsibilities**:
+  - IP Cameras or VMS: Provide live video streams to the application.
+  - Map Provider: Supply map tiles and geolocation services for the frontend.
+
+## Data Flows
+
+1. **User Authentication Flow**:
+   - User logs in via the React app.
+   - Credentials are sent to the Node.js backend API.
+   - The backend validates the credentials and returns a JWT token.
+
+2. **Live Video Stream Flow**:
+   - The React app requests video stream URLs from the Node.js backend API.
+   - The backend retrieves stream information and sends it back to the frontend.
+   - The frontend displays the live video using the provided URLs.
+
+3. **AI Detection Flow**:
+   - The AI Analytics Service processes video streams and detects events.
+   - Upon detection, it sends an HTTP POST request to the Node.js backend API with event details.
+   - The backend creates a new event record in the MongoDB database.
+
+4. **Event List Flow**:
+   - The React app requests the list of events from the Node.js backend API.
+   - The backend retrieves event data from MongoDB and returns it to the frontend for display.
+
+5. **Map View Flow**:
+   - The React app requests camera locations and active events from the Node.js backend API.
+   - The backend provides the necessary data, which the frontend uses to render the map with camera markers and event highlights.
+
+## Conclusion
+
 This C4 container diagram serves as a foundational blueprint for the Event Monitoring and Management Platform MVP. It emphasizes modularity and clear separation of concerns, facilitating future enhancements and scalability.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/architecture/c4_context.md b/event-monitoring-mvp-architecture/docs/architecture/c4_context.md
index 12a70ac..7d399f8 100644
--- a/event-monitoring-mvp-architecture/docs/architecture/c4_context.md
+++ b/event-monitoring-mvp-architecture/docs/architecture/c4_context.md
@@ -1,69 +1,69 @@
-# C4 Context Diagram for Event Monitoring and Management Platform
-
-## Overview
-
-This document describes the C4 model context diagram for the Event Monitoring and Management Platform. It illustrates the system's interactions with external entities and stakeholders, providing a high-level view of how the system fits into its environment.
-
-## System Context
-
-The Event Monitoring and Management Platform is designed to provide real-time monitoring and management of environmental, safety, and security events. It integrates various components to deliver a comprehensive solution for users in smart cities, critical infrastructure, and public safety monitoring.
-
-### External Entities
-
-1. **Control Room Operators**
-   - Users who monitor live video feeds, receive alerts, and manage events through the platform.
-
-2. **Security Managers**
-   - Users who analyze trends, generate reports, and oversee the overall security operations.
-
-3. **System Administrators**
-   - Users responsible for managing system configurations, user roles, and integrations with external systems.
-
-4. **IP Cameras / VMS**
-   - External video sources that provide live video streams for analysis and monitoring.
-
-5. **GIS Providers**
-   - External services that supply geographic information and mapping capabilities.
-
-6. **Emergency Response Systems (CAD)**
-   - External systems that receive critical event notifications for immediate action.
-
-### System Boundaries
-
-The Event Monitoring and Management Platform encompasses the following key components:
-
-- **Frontend (React Web Application)**
-  - User interface for operators, managers, and administrators to interact with the system.
-
-- **Backend API (Node.js + Express)**
-  - Handles requests from the frontend, processes data, and communicates with the database and external services.
-
-- **AI Service**
-  - A separate microservice responsible for video analytics, detecting anomalies, and generating events based on AI models.
-
-- **Database (MongoDB)**
-  - Stores user data, camera configurations, and event records.
-
-### Data Flows
-
-- **User Interactions**
-  - Control room operators and security managers interact with the frontend to view live video, manage events, and generate reports.
-
-- **Video Streams**
-  - IP cameras or VMS provide live video streams to the backend for processing and analysis.
-
-- **AI Detection**
-  - The AI service receives video frames, processes them for detection, and sends detection events to the backend.
-
-- **Event Management**
-  - The backend API manages event creation, updates, and retrieval, storing data in the MongoDB database.
-
-- **GIS Integration**
-  - The system integrates with GIS providers to visualize camera locations and events on a map.
-
-- **Emergency Notifications**
-  - Critical events are communicated to emergency response systems for immediate action.
-
-## Conclusion
-
+# C4 Context Diagram for Event Monitoring and Management Platform
+
+## Overview
+
+This document describes the C4 model context diagram for the Event Monitoring and Management Platform. It illustrates the system's interactions with external entities and stakeholders, providing a high-level view of how the system fits into its environment.
+
+## System Context
+
+The Event Monitoring and Management Platform is designed to provide real-time monitoring and management of environmental, safety, and security events. It integrates various components to deliver a comprehensive solution for users in smart cities, critical infrastructure, and public safety monitoring.
+
+### External Entities
+
+1. **Control Room Operators**
+   - Users who monitor live video feeds, receive alerts, and manage events through the platform.
+
+2. **Security Managers**
+   - Users who analyze trends, generate reports, and oversee the overall security operations.
+
+3. **System Administrators**
+   - Users responsible for managing system configurations, user roles, and integrations with external systems.
+
+4. **IP Cameras / VMS**
+   - External video sources that provide live video streams for analysis and monitoring.
+
+5. **GIS Providers**
+   - External services that supply geographic information and mapping capabilities.
+
+6. **Emergency Response Systems (CAD)**
+   - External systems that receive critical event notifications for immediate action.
+
+### System Boundaries
+
+The Event Monitoring and Management Platform encompasses the following key components:
+
+- **Frontend (React Web Application)**
+  - User interface for operators, managers, and administrators to interact with the system.
+
+- **Backend API (Node.js + Express)**
+  - Handles requests from the frontend, processes data, and communicates with the database and external services.
+
+- **AI Service**
+  - A separate microservice responsible for video analytics, detecting anomalies, and generating events based on AI models.
+
+- **Database (MongoDB)**
+  - Stores user data, camera configurations, and event records.
+
+### Data Flows
+
+- **User Interactions**
+  - Control room operators and security managers interact with the frontend to view live video, manage events, and generate reports.
+
+- **Video Streams**
+  - IP cameras or VMS provide live video streams to the backend for processing and analysis.
+
+- **AI Detection**
+  - The AI service receives video frames, processes them for detection, and sends detection events to the backend.
+
+- **Event Management**
+  - The backend API manages event creation, updates, and retrieval, storing data in the MongoDB database.
+
+- **GIS Integration**
+  - The system integrates with GIS providers to visualize camera locations and events on a map.
+
+- **Emergency Notifications**
+  - Critical events are communicated to emergency response systems for immediate action.
+
+## Conclusion
+
 This C4 context diagram provides a clear understanding of the Event Monitoring and Management Platform's interactions with external entities and its internal components. It serves as a foundation for further architectural development and ensures that the system is structured for easy expansion and modification in the future.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/architecture/data_flows.md b/event-monitoring-mvp-architecture/docs/architecture/data_flows.md
index 216af83..dbfcef4 100644
--- a/event-monitoring-mvp-architecture/docs/architecture/data_flows.md
+++ b/event-monitoring-mvp-architecture/docs/architecture/data_flows.md
@@ -1,49 +1,49 @@
-# Data Flows for Event Monitoring and Management Platform
-
-This document outlines the data flows within the Event Monitoring and Management Platform MVP, illustrating how data moves between components and external systems. Understanding these flows is crucial for ensuring the architecture is structured for easy expansion and modification in the future.
-
-## 1. User Login Flow
-
-- **User** interacts with the **React App** to log in.
-- The **React App** sends a request to the **Backend API** at `/auth/login` with user credentials.
-- The **Backend API** validates the credentials against the **MongoDB** `users` collection.
-- Upon successful validation, the **Backend API** issues a JWT token, which the **React App** stores for subsequent requests.
-
-## 2. Live Video Flow
-
-- **IP Cameras / VMS** provide live video streams.
-- The **React App** requests video stream URLs from the **Backend API** at `/cameras/{id}/stream`.
-- The **Backend API** retrieves the stream URL from the **MongoDB** `cameras` collection and returns it to the **React App**.
-- The **React App** embeds the video player using the provided stream URL.
-
-## 3. AI Detection Flow
-
-- **IP Cameras / VMS** send video frames to the **AI Analytics Service** for processing.
-- The **AI Analytics Service** runs the detection model (e.g., people/vehicle detection).
-- For each detection, the **AI Analytics Service** constructs a detection payload containing:
-  - `camera_id`
-  - `timestamp`
-  - `detection_type`
-  - `coordinates` (optional)
-  - `confidence score`
-- The **AI Analytics Service** sends an HTTP POST request to the **Backend API** at `/internal/ai/events` with the detection payload.
-- The **Backend API** validates the data and creates a new event document in the **MongoDB** `events` collection.
-
-## 4. Event List Flow
-
-- The **React App** requests the list of events from the **Backend API** at `/events`.
-- The **Backend API** queries the **MongoDB** `events` collection and returns the event data.
-- The **React App** displays the event list, including details such as time, camera, and event type.
-
-## 5. Map View Flow
-
-- The **React Map Module** requests camera positions from the **Backend API** at `/cameras`.
-- The **Backend API** retrieves camera data from the **MongoDB** `cameras` collection and returns it.
-- The **React Map Module** also requests active events from the **Backend API** at `/events?status=active`.
-- The **Backend API** retrieves active events from the **MongoDB** `events` collection and returns them.
-- The **Map Provider** delivers map tiles and background maps to the **React App**.
-- The **React App** places markers on the map for camera locations and highlights cameras with active events.
-
-## 6. Data Flow Summary
-
+# Data Flows for Event Monitoring and Management Platform
+
+This document outlines the data flows within the Event Monitoring and Management Platform MVP, illustrating how data moves between components and external systems. Understanding these flows is crucial for ensuring the architecture is structured for easy expansion and modification in the future.
+
+## 1. User Login Flow
+
+- **User** interacts with the **React App** to log in.
+- The **React App** sends a request to the **Backend API** at `/auth/login` with user credentials.
+- The **Backend API** validates the credentials against the **MongoDB** `users` collection.
+- Upon successful validation, the **Backend API** issues a JWT token, which the **React App** stores for subsequent requests.
+
+## 2. Live Video Flow
+
+- **IP Cameras / VMS** provide live video streams.
+- The **React App** requests video stream URLs from the **Backend API** at `/cameras/{id}/stream`.
+- The **Backend API** retrieves the stream URL from the **MongoDB** `cameras` collection and returns it to the **React App**.
+- The **React App** embeds the video player using the provided stream URL.
+
+## 3. AI Detection Flow
+
+- **IP Cameras / VMS** send video frames to the **AI Analytics Service** for processing.
+- The **AI Analytics Service** runs the detection model (e.g., people/vehicle detection).
+- For each detection, the **AI Analytics Service** constructs a detection payload containing:
+  - `camera_id`
+  - `timestamp`
+  - `detection_type`
+  - `coordinates` (optional)
+  - `confidence score`
+- The **AI Analytics Service** sends an HTTP POST request to the **Backend API** at `/internal/ai/events` with the detection payload.
+- The **Backend API** validates the data and creates a new event document in the **MongoDB** `events` collection.
+
+## 4. Event List Flow
+
+- The **React App** requests the list of events from the **Backend API** at `/events`.
+- The **Backend API** queries the **MongoDB** `events` collection and returns the event data.
+- The **React App** displays the event list, including details such as time, camera, and event type.
+
+## 5. Map View Flow
+
+- The **React Map Module** requests camera positions from the **Backend API** at `/cameras`.
+- The **Backend API** retrieves camera data from the **MongoDB** `cameras` collection and returns it.
+- The **React Map Module** also requests active events from the **Backend API** at `/events?status=active`.
+- The **Backend API** retrieves active events from the **MongoDB** `events` collection and returns them.
+- The **Map Provider** delivers map tiles and background maps to the **React App**.
+- The **React App** places markers on the map for camera locations and highlights cameras with active events.
+
+## 6. Data Flow Summary
+
 This document serves as a guide for understanding the interactions and data exchanges within the Event Monitoring and Management Platform MVP. By clearly defining these flows, we can ensure that the architecture remains adaptable for future enhancements and modifications.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/architecture/mvp_system_overview.md b/event-monitoring-mvp-architecture/docs/architecture/mvp_system_overview.md
index 3263241..5d99075 100644
--- a/event-monitoring-mvp-architecture/docs/architecture/mvp_system_overview.md
+++ b/event-monitoring-mvp-architecture/docs/architecture/mvp_system_overview.md
@@ -1,52 +1,52 @@
-# MVP System Overview
-
-## Introduction
-
-The Event Monitoring and Management Platform is designed to provide real-time monitoring and management of environmental, safety, and security events. This document outlines the architecture of the Minimum Viable Product (MVP), detailing the key components, their interactions, and the overall system structure to ensure easy expansion and modification in the future.
-
-## Key Components
-
-1. **Frontend (React Web Application)**
-   - The user interface for security operators and control room users.
-   - Modules include:
-     - Authentication Module for user login.
-     - Live Video View for streaming video from cameras.
-     - Events List for displaying detected events.
-     - Map View for visualizing camera locations and active events.
-     - Event Details View for detailed information on specific events.
-
-2. **Backend API (Node.js + Express)**
-   - Serves as the intermediary between the frontend and the database.
-   - Key services include:
-     - Authentication Service for user validation and JWT issuance.
-     - Camera Service for managing camera data and streams.
-     - Event Service for handling event data and interactions.
-     - Video Gateway for providing access to live video streams.
-     - AI Integration Service for processing AI detection results.
-
-3. **AI & Video Analytics Service**
-   - A separate microservice responsible for running AI models on video streams.
-   - Processes video frames to detect objects (e.g., people, vehicles) and sends detection events to the backend.
-
-4. **Database (MongoDB)**
-   - Stores user, camera, and event data.
-   - Collections include:
-     - Users: Information about system users and their roles.
-     - Cameras: Details about camera configurations and locations.
-     - Events: Records of detected events, including timestamps and statuses.
-
-5. **External Systems**
-   - **IP Cameras / VMS**: Provide live video streams for monitoring.
-   - **Map Provider**: Supplies map tiles and geolocation services for the frontend.
-
-## Data Flows
-
-- **User Login Flow**: Users authenticate via the frontend, which communicates with the backend to validate credentials and retrieve a JWT token.
-- **Live Video Flow**: The frontend requests video stream URLs from the backend, which in turn fetches the necessary information from the camera service.
-- **AI Detection Flow**: The AI service processes video streams, detects events, and sends the results to the backend for storage and further action.
-- **Event List Flow**: The frontend retrieves a list of events from the backend, displaying them to the user.
-- **Map View Flow**: The frontend loads camera locations and active events from the backend and integrates with the map provider for visualization.
-
-## Conclusion
-
+# MVP System Overview
+
+## Introduction
+
+The Event Monitoring and Management Platform is designed to provide real-time monitoring and management of environmental, safety, and security events. This document outlines the architecture of the Minimum Viable Product (MVP), detailing the key components, their interactions, and the overall system structure to ensure easy expansion and modification in the future.
+
+## Key Components
+
+1. **Frontend (React Web Application)**
+   - The user interface for security operators and control room users.
+   - Modules include:
+     - Authentication Module for user login.
+     - Live Video View for streaming video from cameras.
+     - Events List for displaying detected events.
+     - Map View for visualizing camera locations and active events.
+     - Event Details View for detailed information on specific events.
+
+2. **Backend API (Node.js + Express)**
+   - Serves as the intermediary between the frontend and the database.
+   - Key services include:
+     - Authentication Service for user validation and JWT issuance.
+     - Camera Service for managing camera data and streams.
+     - Event Service for handling event data and interactions.
+     - Video Gateway for providing access to live video streams.
+     - AI Integration Service for processing AI detection results.
+
+3. **AI & Video Analytics Service**
+   - A separate microservice responsible for running AI models on video streams.
+   - Processes video frames to detect objects (e.g., people, vehicles) and sends detection events to the backend.
+
+4. **Database (MongoDB)**
+   - Stores user, camera, and event data.
+   - Collections include:
+     - Users: Information about system users and their roles.
+     - Cameras: Details about camera configurations and locations.
+     - Events: Records of detected events, including timestamps and statuses.
+
+5. **External Systems**
+   - **IP Cameras / VMS**: Provide live video streams for monitoring.
+   - **Map Provider**: Supplies map tiles and geolocation services for the frontend.
+
+## Data Flows
+
+- **User Login Flow**: Users authenticate via the frontend, which communicates with the backend to validate credentials and retrieve a JWT token.
+- **Live Video Flow**: The frontend requests video stream URLs from the backend, which in turn fetches the necessary information from the camera service.
+- **AI Detection Flow**: The AI service processes video streams, detects events, and sends the results to the backend for storage and further action.
+- **Event List Flow**: The frontend retrieves a list of events from the backend, displaying them to the user.
+- **Map View Flow**: The frontend loads camera locations and active events from the backend and integrates with the map provider for visualization.
+
+## Conclusion
+
 This MVP architecture provides a solid foundation for the Event Monitoring and Management Platform, ensuring that the system is modular and scalable. Future enhancements can be easily integrated, such as additional AI models, advanced event management features, and expanded reporting capabilities. The architecture is designed to accommodate growth while maintaining performance and usability.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/data-models/cameras.md b/event-monitoring-mvp-architecture/docs/data-models/cameras.md
index 1bf16ce..b18b159 100644
--- a/event-monitoring-mvp-architecture/docs/data-models/cameras.md
+++ b/event-monitoring-mvp-architecture/docs/data-models/cameras.md
@@ -1,48 +1,115 @@
-# Camera Data Model
-
-The camera data model defines the structure and properties of camera data within the Event Monitoring and Management Platform. This model is essential for managing the cameras that provide live video streams and for integrating with the AI analytics service.
-
-## Camera Model Structure
-
-- **camera_id**: 
-  - Type: String
-  - Description: Unique identifier for the camera.
-
-- **name**: 
-  - Type: String
-  - Description: Human-readable name for the camera.
-
-- **location**: 
-  - Type: Object
-  - Description: Geographic coordinates of the camera.
-    - **latitude**: 
-      - Type: Number
-      - Description: Latitude of the camera's location.
-    - **longitude**: 
-      - Type: Number
-      - Description: Longitude of the camera's location.
-
-- **stream_url**: 
-  - Type: String
-  - Description: URL for accessing the live video stream (e.g., RTSP, HLS).
-
-- **vms_reference**: 
-  - Type: String (optional)
-  - Description: Reference ID for the camera in the Video Management System (if applicable).
-
-## Example Camera Object
-
-```json
-{
-  "camera_id": "cam_001",
-  "name": "Main Entrance",
-  "location": {
-    "latitude": 34.0522,
-    "longitude": -118.2437
-  },
-  "stream_url": "rtsp://example.com/stream/cam_001",
-  "vms_reference": "vms_cam_001"
-}
-```
-
-This data model allows for easy expansion in the future, such as adding additional properties for camera settings, status, or integration with other systems.
\ No newline at end of file
+# Camera Data Model
+
+The camera data model defines the structure and properties of camera devices within the Event Monitoring and Management Platform. Cameras provide live video streams for AI analytics and event detection, with multi-tenant isolation and comprehensive configuration management.
+
+## Camera Model Structure
+
+```json
+{
+  "_id": "ObjectId",             // MongoDB ObjectId
+  "companyId": "ObjectId",       // Reference to Company collection (multi-tenant isolation)
+  "name": "string",              // Human-readable camera name
+  "description": "string",       // Optional detailed description
+  "serialNumber": "string",      // Manufacturer serial number (unique within company)
+  "model": "string",             // Camera model/manufacturer
+  "location": {
+    "type": "Point",
+    "coordinates": [number, number]  // [longitude, latitude] GeoJSON format
+  },
+  "address": "string",           // Human-readable installation address
+  "streamUrl": "string",         // RTSP/HLS stream URL for video feed
+  "snapshotUrl": "string",       // HTTP URL for snapshot images
+  "status": "string",            // Current status: "online", "offline", "maintenance", "error"
+  "config": {
+    "resolution": "string",      // Video resolution (e.g., "1920x1080")
+    "frameRate": "number",       // Frames per second
+    "nightVision": "boolean",    // Night vision capability
+    "ptz": "boolean",            // Pan-tilt-zoom capability
+    "audio": "boolean"           // Audio recording capability
+  },
+  "aiConfig": {
+    "enabled": "boolean",        // AI detection enabled
+    "detectionTypes": ["string"], // Array of detection types to monitor
+    "confidenceThreshold": "number", // Minimum confidence for alerts (0-1)
+    "roi": [{                    // Regions of interest (polygons)
+      "name": "string",
+      "coordinates": [[number, number]]  // Array of [lng, lat] points
+    }]
+  },
+  "vmsReference": "string",      // Reference ID in Video Management System
+  "installationDate": "Date",    // Camera installation date
+  "lastMaintenance": "Date",     // Last maintenance date
+  "lastOnline": "Date",          // Last time camera was online
+  "createdAt": "Date",           // Creation timestamp
+  "updatedAt": "Date",           // Last update timestamp
+  "tags": ["string"]             // Array of tags for categorization
+}
+```
+
+## Properties Description
+
+- **_id**: MongoDB ObjectId serving as the unique identifier for each camera.
+- **companyId**: Reference to the Company collection, ensuring multi-tenant data isolation.
+- **name**: Human-readable name for the camera (e.g., "Main Entrance North").
+- **description**: Optional detailed description of the camera's purpose and coverage area.
+- **serialNumber**: Manufacturer-provided serial number, unique within each company.
+- **model**: Camera model and manufacturer information for support and compatibility.
+- **location**: GeoJSON Point with longitude/latitude coordinates for mapping and location-based queries.
+- **address**: Human-readable address where the camera is installed.
+- **streamUrl**: URL for accessing the live video stream (RTSP, RTMP, HLS, etc.).
+- **snapshotUrl**: HTTP URL for retrieving still images from the camera.
+- **status**: Current operational status of the camera:
+  - `"online"`: Camera is operational and streaming
+  - `"offline"`: Camera is unreachable or powered off
+  - `"maintenance"`: Camera is under maintenance
+  - `"error"`: Camera has configuration or hardware issues
+- **config**: Technical configuration settings for video streaming and capabilities.
+- **aiConfig**: AI detection configuration including enabled detection types, confidence thresholds, and regions of interest.
+- **vmsReference**: Reference identifier for integration with Video Management Systems.
+- **installationDate**: Date when the camera was installed at its current location.
+- **lastMaintenance**: Date of the most recent maintenance or inspection.
+- **lastOnline**: Timestamp of the last successful communication with the camera.
+- **createdAt** / **updatedAt**: Automatic timestamps for lifecycle tracking.
+- **tags**: Array of strings for flexible categorization and filtering.
+
+## AI Integration
+
+Cameras integrate with the AI service for automated event detection:
+
+- **Detection Types**: Configurable array of objects to detect (person, vehicle, animal, etc.)
+- **Confidence Threshold**: Minimum AI confidence score required to generate alerts
+- **Regions of Interest**: Polygonal areas within the camera view that require special attention
+- **Real-time Processing**: Live video streams are processed by the AI service for immediate alerts
+
+## Multi-Tenant Considerations
+
+- All cameras are scoped to a specific company via `companyId`
+- Serial numbers must be unique within each company but can repeat across companies
+- Stream URLs and configurations are company-specific
+- Location data enables company-specific geographic camera management
+
+## Status Monitoring
+
+Camera status is actively monitored:
+
+- **Heartbeat Monitoring**: Regular pings to verify camera connectivity
+- **Stream Validation**: Periodic checks of video stream availability
+- **Alert Generation**: Automatic alerts for status changes
+- **Maintenance Tracking**: Scheduled maintenance and issue tracking
+
+## Security Considerations
+
+- Stream URLs should use secure protocols (HTTPS, RTSP over TLS)
+- Access to camera feeds is restricted by company and user permissions
+- Configuration changes are logged for audit purposes
+- Sensitive configuration data is encrypted at rest
+
+## Future Considerations
+
+As the platform evolves, additional properties may be added:
+
+- **powerSource**: Battery, PoE, wired power source tracking
+- **connectivity**: WiFi, Ethernet, cellular connectivity options
+- **storage**: On-device or cloud storage configuration
+- **analytics**: Historical analytics and performance metrics
+- **integration**: Third-party VMS and security system integrations
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/data-models/companies.md b/event-monitoring-mvp-architecture/docs/data-models/companies.md
new file mode 100644
index 0000000..9881bdf
--- /dev/null
+++ b/event-monitoring-mvp-architecture/docs/data-models/companies.md
@@ -0,0 +1,134 @@
+# Company Data Model
+
+The company data model defines the structure and properties of companies within the Event Monitoring and Management Platform. Companies represent separate tenants with isolated data, users, and configurations, enabling multi-tenant operation with API key-based access control.
+
+## Company Model Structure
+
+```json
+{
+  "_id": "ObjectId",             // MongoDB ObjectId
+  "name": "string",              // Company name
+  "description": "string",       // Optional company description
+  "apiKey": "string",            // Unique API key for mobile app access
+  "subscription": {
+    "plan": "string",            // Subscription plan: "basic", "professional", "enterprise"
+    "status": "string",          // Status: "active", "suspended", "cancelled"
+    "startDate": "Date",         // Subscription start date
+    "endDate": "Date",           // Subscription end date (optional)
+    "maxUsers": "number",        // Maximum number of users allowed
+    "maxCameras": "number",      // Maximum number of cameras allowed
+    "features": ["string"]       // Array of enabled features
+  },
+  "settings": {
+    "timezone": "string",        // Default timezone (e.g., "America/New_York")
+    "currency": "string",        // Currency for billing (e.g., "USD")
+    "language": "string",        // Default language (e.g., "en")
+    "allowAnonymousReports": "boolean", // Allow anonymous citizen reports
+    "autoCreateEvents": "boolean", // Auto-create events from high-priority reports
+    "notificationSettings": {
+      "emailEnabled": "boolean", // Enable email notifications
+      "smsEnabled": "boolean",   // Enable SMS notifications
+      "pushEnabled": "boolean"   // Enable push notifications
+    }
+  },
+  "contact": {
+    "email": "string",           // Primary contact email
+    "phone": "string",           // Primary contact phone
+    "address": {
+      "street": "string",
+      "city": "string",
+      "state": "string",
+      "zipCode": "string",
+      "country": "string"
+    }
+  },
+  "usage": {
+    "eventsThisMonth": "number", // Event count for current month
+    "reportsThisMonth": "number", // Report count for current month
+    "storageUsed": "number",     // Storage used in bytes
+    "apiCallsThisMonth": "number" // API calls for current month
+  },
+  "createdAt": "Date",           // Company creation timestamp
+  "updatedAt": "Date",           // Last update timestamp
+  "isActive": "boolean"          // Company account status
+}
+```
+
+## Properties Description
+
+- **_id**: MongoDB ObjectId serving as the unique identifier for each company.
+- **name**: Human-readable company name for display and identification.
+- **description**: Optional detailed description of the company's purpose or operations.
+- **apiKey**: Unique API key used for mobile app authentication and API access validation.
+- **subscription**: Subscription and billing information including plan details and limits.
+- **settings**: Company-wide configuration settings that affect all users and operations.
+- **contact**: Primary contact information for billing, support, and administrative purposes.
+- **usage**: Current usage statistics for billing and limit enforcement.
+- **createdAt** / **updatedAt**: Automatic timestamps for lifecycle tracking.
+- **isActive**: Boolean flag indicating if the company account is active and can access the system.
+
+## Subscription Plans
+
+### Basic Plan
+- Max 10 users
+- Max 5 cameras
+- Core features only
+- Community support
+
+### Professional Plan
+- Max 50 users
+- Max 25 cameras
+- Advanced analytics
+- Priority support
+- Custom integrations
+
+### Enterprise Plan
+- Unlimited users
+- Unlimited cameras
+- All features
+- Dedicated support
+- SLA guarantees
+- Custom development
+
+## API Key Management
+
+- **Generation**: API keys are generated using cryptographically secure random generation
+- **Rotation**: Keys can be rotated for security without service interruption
+- **Validation**: All mobile app requests include API key validation
+- **Scope**: Keys are company-specific and cannot access other companies' data
+
+## Multi-Tenant Isolation
+
+Companies provide complete data isolation:
+
+- **Data Separation**: All collections (users, events, cameras, reports) are filtered by companyId
+- **Access Control**: Users can only access data within their company
+- **Resource Limits**: Usage is tracked and enforced per company
+- **Configuration**: Settings are company-specific and inherited by all users
+
+## Usage Tracking and Limits
+
+The platform tracks and enforces usage limits:
+
+- **Monthly Reset**: Usage counters reset monthly for billing cycles
+- **Real-time Monitoring**: API calls check limits before processing
+- **Graceful Degradation**: Soft limits with warnings, hard limits with rejection
+- **Analytics**: Usage data powers billing and feature optimization
+
+## Security Considerations
+
+- API keys are hashed in logs and never stored in plain text
+- Company data is physically segregated in multi-tenant databases
+- Access logs track all API key usage for audit purposes
+- Failed authentication attempts are rate-limited per API key
+
+## Future Considerations
+
+As the platform evolves, additional properties may be added:
+
+- **billingHistory**: Detailed billing and payment history
+- **integrations**: Third-party service integrations (Slack, PagerDuty, etc.)
+- **customFields**: Company-specific additional data fields
+- **branding**: Custom branding options for white-label deployments
+- **auditLogs**: Comprehensive audit trails for compliance
+- **dataRetention**: Configurable data retention policies
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/data-models/event-types.md b/event-monitoring-mvp-architecture/docs/data-models/event-types.md
new file mode 100644
index 0000000..423d078
--- /dev/null
+++ b/event-monitoring-mvp-architecture/docs/data-models/event-types.md
@@ -0,0 +1,109 @@
+# Event Type Data Model
+
+The event type data model defines the structure and properties of event types within the Event Monitoring and Management Platform. Event types replace fixed enums with a dynamic, hierarchical system that can be configured per company or shared globally, enabling flexible categorization of incidents.
+
+## EventType Model Structure
+
+```json
+{
+  "_id": "ObjectId",             // MongoDB ObjectId
+  "companyId": "ObjectId",       // Reference to Company (null for global types)
+  "name": "string",              // Human-readable type name
+  "description": "string",       // Optional detailed description
+  "category": "string",          // High-level category (e.g., "security", "safety", "maintenance")
+  "parentId": "ObjectId",        // Reference to parent EventType (for hierarchical types)
+  "icon": "string",              // Icon identifier for UI display
+  "color": "string",             // Hex color code for UI theming
+  "priority": "string",          // Default priority: "low", "medium", "high", "critical"
+  "isPublic": "boolean",         // Whether citizens can select this type
+  "isActive": "boolean",         // Whether this type is available for use
+  "autoCreateEvent": "boolean",  // Whether reports of this type auto-create events
+  "escalationRules": [{
+    "condition": "string",       // Condition to trigger escalation
+    "delayMinutes": "number",    // Delay before escalation
+    "newPriority": "string",     // Priority to escalate to
+    "notifyRoles": ["string"]    // Roles to notify
+  }],
+  "metadata": {
+    "requiresLocation": "boolean", // Location required for this type
+    "allowsAttachments": "boolean", // Attachments allowed
+    "responseTimeSLA": "number",   // Expected response time in minutes
+    "autoAssign": "boolean"        // Auto-assign to available responders
+  },
+  "createdBy": "ObjectId",       // Reference to User who created this type
+  "createdAt": "Date",           // Creation timestamp
+  "updatedAt": "Date"            // Last update timestamp
+}
+```
+
+## Properties Description
+
+- **_id**: MongoDB ObjectId serving as the unique identifier for each event type.
+- **companyId**: Reference to Company collection. If null, this is a global type available to all companies.
+- **name**: Human-readable name for the event type (e.g., "Suspicious Activity", "Medical Emergency").
+- **description**: Optional detailed description of when and how to use this event type.
+- **category**: High-level grouping for organization and filtering (security, safety, maintenance, etc.).
+- **parentId**: Reference to parent EventType for hierarchical relationships (e.g., "Vehicle Accident" â†’ "Traffic Incident").
+- **icon**: Icon identifier or URL for visual representation in the UI.
+- **color**: Hex color code for consistent theming across the application.
+- **priority**: Default priority level assigned to events of this type.
+- **isPublic**: Whether citizen users can select this type when submitting reports.
+- **isActive**: Whether this type is currently available for selection and use.
+- **autoCreateEvent**: Whether reports with this type should automatically create new events.
+- **escalationRules**: Array of automatic escalation rules based on time and conditions.
+- **metadata**: Additional configuration options for type-specific behavior.
+- **createdBy**: Reference to the User who created this event type.
+- **createdAt** / **updatedAt**: Automatic timestamps for lifecycle tracking.
+
+## Hierarchical Structure
+
+Event types support parent-child relationships:
+
+- **Parent Types**: Broad categories (e.g., "Security Incident", "Medical Emergency")
+- **Child Types**: Specific subtypes (e.g., "Burglary", "Heart Attack")
+- **Multiple Levels**: Support for multi-level hierarchies
+- **Inheritance**: Child types can inherit properties from parents
+
+## Global vs Company Types
+
+- **Global Types**: CompanyId is null, available to all companies, managed by super admins
+- **Company Types**: Scoped to specific company, can extend or override global types
+- **Type Resolution**: Company-specific types take precedence over global types with same name
+
+## Auto-Creation and Escalation
+
+- **Auto-Creation**: Certain types (high-priority) automatically create events when reports are submitted
+- **Escalation Rules**: Time-based priority increases and notifications
+- **SLA Tracking**: Response time expectations and monitoring
+- **Auto-Assignment**: Automatic assignment to available first responders
+
+## Usage in Reports and Events
+
+- **Report Submission**: Types guide users in categorizing their reports
+- **Event Classification**: Events inherit type information from contributing reports
+- **Filtering and Search**: Types enable powerful filtering and analytics
+- **Workflow Triggers**: Types determine which workflows and notifications are triggered
+
+## Multi-Tenant Considerations
+
+- Global types are shared across all companies
+- Company-specific types are isolated to their company
+- Type management permissions are role-based
+- Migration between global and company types is supported
+
+## Security and Access Control
+
+- Type creation and modification is restricted by role
+- Public types are visible to citizens, private types are internal-only
+- Audit logging tracks all type changes
+- Type deletion is soft-delete to preserve historical data
+
+## Future Considerations
+
+As the platform evolves, additional properties may be added:
+
+- **customFields**: Type-specific additional data fields
+- **workflows**: Custom workflow definitions per type
+- **integrations**: Third-party system triggers per type
+- **analytics**: Type-specific reporting and metrics
+- **translations**: Multi-language support for international deployments
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/data-models/events.md b/event-monitoring-mvp-architecture/docs/data-models/events.md
index fef02ab..6e688d6 100644
--- a/event-monitoring-mvp-architecture/docs/data-models/events.md
+++ b/event-monitoring-mvp-architecture/docs/data-models/events.md
@@ -1,35 +1,84 @@
-# Event Data Model
-
-The event data model defines the structure and properties of event data within the Event Monitoring and Management Platform. Each event represents a significant occurrence detected by the system, such as the detection of a person or vehicle, and includes relevant metadata for tracking and analysis.
-
-## Event Model Structure
-
-```json
-{
-  "event_id": "string",          // Unique identifier for the event
-  "timestamp": "string",         // ISO 8601 formatted timestamp of when the event occurred
-  "camera_id": "string",         // Identifier for the camera that detected the event
-  "event_type": "string",        // Type of event (e.g., "person_detected", "vehicle_detected")
-  "snapshot_url": "string",      // Optional URL to a snapshot image related to the event
-  "status": "string"             // Current status of the event (e.g., "new", "acknowledged", "closed")
-}
-```
-
-## Properties Description
-
-- **event_id**: A unique identifier for each event, typically generated by the database.
-- **timestamp**: The date and time when the event was detected, formatted in ISO 8601 for consistency and ease of use.
-- **camera_id**: A reference to the camera that captured the event, linking it to the camera data model for additional context.
-- **event_type**: A string that categorizes the event, allowing for easy filtering and reporting based on the type of detection.
-- **snapshot_url**: An optional field that provides a link to an image captured at the time of the event, useful for visual verification and analysis.
-- **status**: Indicates the current state of the event, which helps in managing the event lifecycle and tracking its resolution.
-
-## Future Considerations
-
-As the platform evolves, additional properties may be added to the event model to accommodate new features, such as:
-
-- **location**: GPS coordinates where the event occurred.
-- **confidence_score**: A numerical value indicating the confidence level of the detection.
-- **related_events**: An array of event IDs that are related to this event, allowing for better context and analysis of incidents.
-
-This data model is designed to be flexible and scalable, ensuring that it can adapt to the growing needs of the Event Monitoring and Management Platform.
\ No newline at end of file
+# Event Data Model
+
+The event data model defines the structure and properties of event data within the Event Monitoring and Management Platform. Each event represents a significant occurrence that may be detected by cameras, reported by citizens, or created by first responders. Events can have multiple reports contributing to them, allowing for comprehensive incident tracking.
+
+## Event Model Structure
+
+```json
+{
+  "_id": "ObjectId",             // MongoDB ObjectId
+  "companyId": "ObjectId",       // Reference to Company collection (multi-tenant isolation)
+  "eventTypeId": "ObjectId",     // Reference to EventType collection (dynamic types)
+  "title": "string",             // Human-readable event title
+  "description": "string",       // Optional detailed description
+  "status": "string",            // Current status: "active", "resolved", "closed"
+  "priority": "string",          // Priority level: "low", "medium", "high", "critical"
+  "location": {
+    "type": "Point",
+    "coordinates": [number, number]  // [longitude, latitude] GeoJSON format
+  },
+  "address": "string",           // Human-readable address
+  "reports": ["ObjectId"],       // Array of Report IDs contributing to this event
+  "assignedTo": "ObjectId",      // Reference to User (first_responder or operator)
+  "createdAt": "Date",           // Creation timestamp
+  "updatedAt": "Date",           // Last update timestamp
+  "resolvedAt": "Date",          // Resolution timestamp (optional)
+  "tags": ["string"]             // Array of tags for categorization
+}
+```
+
+## Properties Description
+
+- **_id**: MongoDB ObjectId serving as the unique identifier for each event.
+- **companyId**: Reference to the Company collection, ensuring multi-tenant data isolation.
+- **eventTypeId**: Reference to the EventType collection, enabling dynamic event categorization.
+- **title**: Human-readable title for the event (e.g., "Suspicious Activity Reported").
+- **description**: Optional detailed description of the event circumstances.
+- **status**: Current lifecycle status of the event:
+  - `"active"`: Event is ongoing and requires attention
+  - `"resolved"`: Event has been addressed but may need follow-up
+  - `"closed"`: Event is fully resolved and archived
+- **priority**: Urgency level affecting response time and resource allocation.
+- **location**: GeoJSON Point with longitude/latitude coordinates for mapping and proximity calculations.
+- **address**: Human-readable location description for display purposes.
+- **reports**: Array of Report ObjectIds that contribute information to this event. Allows multiple reports (citizen, camera, first responder) to build a complete incident picture.
+- **assignedTo**: Reference to User collection for assignment to first responders or operators.
+- **createdAt**: ISO 8601 timestamp when the event was first created.
+- **updatedAt**: ISO 8601 timestamp of the last modification.
+- **resolvedAt**: ISO 8601 timestamp when the event was resolved (optional).
+- **tags**: Array of strings for flexible categorization and filtering.
+
+## Event-Report Relationship
+
+Events are designed to aggregate multiple reports, allowing for comprehensive incident tracking:
+
+- **Multiple Reports per Event**: A single event can have multiple reports from different sources (citizens, cameras, first responders).
+- **Flexible Data Entry**: Not all event fields need to be populated initially - reports can contribute different pieces of information.
+- **Progressive Enrichment**: Events become more complete as additional reports are added.
+- **Source Attribution**: Each report maintains its own metadata (source, timestamp, confidence) while contributing to the overall event.
+
+## Status Workflow
+
+Events follow a defined lifecycle:
+
+1. **Creation**: Event created from first report (citizen, camera, or manual)
+2. **Active**: Event is being monitored and responded to
+3. **Resolved**: Immediate threat addressed, but follow-up may be needed
+4. **Closed**: Event fully resolved and archived
+
+## Multi-Tenant Considerations
+
+- All events are scoped to a specific company via `companyId`
+- Event types can be company-specific or shared
+- Location data enables company-specific geographic filtering
+- Assignment is limited to users within the same company
+
+## Future Considerations
+
+As the platform evolves, additional properties may be added:
+
+- **escalationLevel**: Automatic escalation based on priority and time thresholds
+- **responseTime**: SLA tracking for first responder response
+- **relatedEvents**: Links to similar or connected events
+- **attachments**: Additional media files beyond report-specific attachments
+- **customFields**: Company-specific additional data fields
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/data-models/reports.md b/event-monitoring-mvp-architecture/docs/data-models/reports.md
new file mode 100644
index 0000000..f5efb2b
--- /dev/null
+++ b/event-monitoring-mvp-architecture/docs/data-models/reports.md
@@ -0,0 +1,139 @@
+# Report Data Model
+
+The report data model defines the structure and properties of citizen and first responder reports within the Event Monitoring and Management Platform. Reports are separate entities that can contribute to events, allowing multiple reports to build a comprehensive incident picture without requiring all event fields to be populated.
+
+## Report Model Structure
+
+```json
+{
+  "_id": "ObjectId",             // MongoDB ObjectId
+  "companyId": "ObjectId",       // Reference to Company collection (multi-tenant isolation)
+  "eventId": "ObjectId",         // Reference to Event collection (optional - may create new event)
+  "reporterId": "ObjectId",      // Reference to User collection (citizen or first_responder)
+  "reportType": "string",        // Type of report: "citizen", "camera", "first_responder", "manual"
+  "title": "string",             // Brief title of the report
+  "description": "string",       // Detailed description of the incident
+  "location": {
+    "type": "Point",
+    "coordinates": [number, number]  // [longitude, latitude] GeoJSON format
+  },
+  "address": "string",           // Human-readable address
+  "eventTypeId": "ObjectId",     // Reference to EventType collection
+  "priority": "string",          // Reported priority: "low", "medium", "high", "critical"
+  "status": "string",            // Report status: "submitted", "reviewed", "verified", "rejected"
+  "attachments": [{
+    "type": "string",            // "image", "video", "audio"
+    "url": "string",             // File URL
+    "filename": "string",        // Original filename
+    "size": "number",            // File size in bytes
+    "uploadedAt": "Date"         // Upload timestamp
+  }],
+  "metadata": {
+    "deviceInfo": "object",      // Mobile device information
+    "appVersion": "string",      // Mobile app version
+    "confidence": "number",      // AI confidence score (for camera reports)
+    "source": "string"           // Source system identifier
+  },
+  "createdAt": "Date",           // Report submission timestamp
+  "updatedAt": "Date",           // Last update timestamp
+  "reviewedAt": "Date",          // Review timestamp (optional)
+  "reviewedBy": "ObjectId"       // Reference to User who reviewed (optional)
+}
+```
+
+## Properties Description
+
+- **_id**: MongoDB ObjectId serving as the unique identifier for each report.
+- **companyId**: Reference to the Company collection, ensuring multi-tenant data isolation.
+- **eventId**: Optional reference to an existing Event. If null, the report may trigger creation of a new event.
+- **reporterId**: Reference to the User who submitted the report (citizen or first_responder).
+- **reportType**: Classification of the report source:
+  - `"citizen"`: Submitted via mobile app by public users
+  - `"camera"`: Generated automatically by AI camera detection
+  - `"first_responder"`: Submitted by emergency personnel
+  - `"manual"`: Created manually by operators or admins
+- **title**: Brief, descriptive title of the incident.
+- **description**: Detailed narrative of what occurred, including relevant context.
+- **location**: GeoJSON Point with longitude/latitude coordinates for mapping and proximity calculations.
+- **address**: Human-readable location description derived from coordinates or user input.
+- **eventTypeId**: Reference to EventType for categorization (may differ from final event type).
+- **priority**: Urgency level as perceived by the reporter.
+- **status**: Current processing status of the report:
+  - `"submitted"`: Newly submitted, awaiting review
+  - `"reviewed"`: Reviewed by operator, may be linked to event
+  - `"verified"`: Confirmed as accurate and actionable
+  - `"rejected"`: Determined to be invalid or duplicate
+- **attachments**: Array of media files associated with the report (images, videos, audio).
+- **metadata**: Additional technical information about the report submission.
+- **createdAt**: ISO 8601 timestamp when the report was submitted.
+- **updatedAt**: ISO 8601 timestamp of the last modification.
+- **reviewedAt**: ISO 8601 timestamp when the report was reviewed (optional).
+- **reviewedBy**: Reference to the User who performed the review (optional).
+
+## Report-Event Relationship
+
+Reports serve as the building blocks for events:
+
+- **Independent Submission**: Reports can exist without being immediately linked to an event.
+- **Event Creation**: High-priority or verified reports can automatically create new events.
+- **Event Contribution**: Multiple reports can contribute information to a single event.
+- **Flexible Linking**: Reports can be linked to existing events during review or automatically based on location/time proximity.
+- **Data Enrichment**: Each report adds details that may not be available in other reports.
+
+## Report Types and Sources
+
+### Citizen Reports
+- Submitted via mobile app
+- May include photos, videos, or audio
+- Location based on device GPS
+- Anonymous or authenticated submission options
+
+### Camera Reports
+- Automatically generated by AI detection
+- Include snapshot images and confidence scores
+- Precise location from camera configuration
+- May trigger immediate event creation
+
+### First Responder Reports
+- Submitted by emergency personnel
+- Include real-time location tracking
+- May update existing events with response information
+- Higher priority and faster processing
+
+### Manual Reports
+- Created by operators or admins
+- May consolidate information from multiple sources
+- Used for incident documentation and follow-up
+
+## Processing Workflow
+
+1. **Submission**: Report created via API or automatic detection
+2. **Validation**: Basic validation of required fields and data integrity
+3. **Review**: Operator review for accuracy and relevance
+4. **Linking**: Association with existing event or creation of new event
+5. **Verification**: Confirmation of report details and attachments
+6. **Archival**: Long-term storage with appropriate retention policies
+
+## Multi-Tenant Considerations
+
+- All reports are scoped to a specific company via `companyId`
+- Report visibility is restricted to users within the same company
+- Location-based filtering respects company geographic boundaries
+- Attachment storage is segregated by company
+
+## Security and Privacy
+
+- Reports may contain sensitive incident information
+- Attachment files are stored securely with access controls
+- Location data is protected and only shared with authorized personnel
+- Citizen reports can be submitted anonymously when permitted by company policy
+
+## Future Considerations
+
+As the platform evolves, additional properties may be added:
+
+- **followUpReports**: Links to related reports in the same incident chain
+- **responseActions**: Tracking of actions taken in response to the report
+- **publicVisibility**: Options for public disclosure of resolved incidents
+- **translation**: Multi-language support for international deployments
+- **sentiment**: AI analysis of report text for priority assessment
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/data-models/users.md b/event-monitoring-mvp-architecture/docs/data-models/users.md
index ddd1e5a..fc2783f 100644
--- a/event-monitoring-mvp-architecture/docs/data-models/users.md
+++ b/event-monitoring-mvp-architecture/docs/data-models/users.md
@@ -1,35 +1,129 @@
-# User Data Model for Event Monitoring and Management Platform
-
-## User Model
-
-The user model defines the structure of user data within the Event Monitoring and Management Platform. It includes essential properties that facilitate user authentication, authorization, and role management.
-
-### Properties
-
-- **user_id**: Unique identifier for the user (String, UUID)
-- **username**: The username chosen by the user (String, required, unique)
-- **hashed_password**: The hashed password for user authentication (String, required)
-- **email**: The email address of the user (String, required, unique)
-- **role**: The role assigned to the user within the system (String, required, enum: ['admin', 'operator'])
-- **created_at**: Timestamp indicating when the user was created (Date, default: current date)
-- **updated_at**: Timestamp indicating the last time the user data was updated (Date, default: current date)
-
-### Example User Document
-
-```json
-{
-  "user_id": "123e4567-e89b-12d3-a456-426614174000",
-  "username": "john_doe",
-  "hashed_password": "$2b$10$EIXZ5Z1e5Z5Z5Z5Z5Z5Z5O",
-  "email": "john.doe@example.com",
-  "role": "operator",
-  "created_at": "2023-01-01T00:00:00Z",
-  "updated_at": "2023-01-01T00:00:00Z"
-}
-```
-
-### Notes
-
-- Ensure that passwords are stored securely using hashing algorithms.
-- User roles are critical for managing access control within the platform.
-- Timestamps should be automatically managed by the database or application logic to maintain data integrity.
\ No newline at end of file
+# User Data Model
+
+The user data model defines the structure and properties of user accounts within the Event Monitoring and Management Platform. Users can be web dashboard operators, mobile first responders, or citizen reporters, with role-based access control and multi-tenant isolation.
+
+## User Model Structure
+
+```json
+{
+  "_id": "ObjectId",             // MongoDB ObjectId
+  "companyId": "ObjectId",       // Reference to Company collection (multi-tenant isolation)
+  "email": "string",             // Email address for web users (optional for mobile-only users)
+  "phone": "string",             // Phone number for first responders and citizens (optional)
+  "username": "string",          // Unique username for login
+  "password": "string",          // Hashed password (bcrypt)
+  "role": "string",              // User role: citizen, first_responder, operator, admin, company_admin, super_admin
+  "firstName": "string",         // User's first name
+  "lastName": "string",          // User's last name
+  "isActive": "boolean",         // Account status (default: true)
+  "lastLogin": "Date",           // Last login timestamp
+  "createdAt": "Date",           // Account creation timestamp
+  "updatedAt": "Date",           // Last update timestamp
+  "preferences": {
+    "notifications": "boolean",  // Enable push notifications
+    "language": "string",        // Preferred language (default: "en")
+    "timezone": "string"         // Preferred timezone
+  },
+  "location": {
+    "type": "Point",
+    "coordinates": [number, number]  // [longitude, latitude] for first responders
+  },
+  "deviceTokens": ["string"],    // Array of device tokens for push notifications
+  "apiKey": "string"             // API key for mobile app authentication (first_responders only)
+}
+```
+
+## Properties Description
+
+- **_id**: MongoDB ObjectId serving as the unique identifier for each user.
+- **companyId**: Reference to the Company collection, ensuring multi-tenant data isolation. All users belong to a specific company.
+- **email**: Email address used for web dashboard authentication and notifications. Optional for mobile-only users.
+- **phone**: Phone number used for first responder and citizen mobile authentication. Optional for web-only users.
+- **username**: Unique username for login across all authentication methods.
+- **password**: Bcrypt-hashed password for secure authentication.
+- **role**: User role determining permissions and access levels:
+  - `"citizen"`: Mobile app users who can submit reports
+  - `"first_responder"`: Emergency personnel with live tracking and event assignment
+  - `"operator"`: Dashboard users who monitor and manage events
+  - `"admin"`: Company administrators with user management capabilities
+  - `"company_admin"`: Company-level administrators
+  - `"super_admin"`: System-wide administrators
+- **firstName** / **lastName**: User's full name for display and identification.
+- **isActive**: Boolean flag indicating if the account is active and can authenticate.
+- **lastLogin**: Timestamp of the user's most recent successful login.
+- **createdAt** / **updatedAt**: Automatic timestamps for account lifecycle tracking.
+- **preferences**: User-configurable settings for notifications, language, and timezone.
+- **location**: GeoJSON Point for first responders' current location (updated via mobile app).
+- **deviceTokens**: Array of FCM/APNs tokens for push notifications to mobile devices.
+- **apiKey**: Unique API key for mobile app authentication (generated for first_responders).
+
+## Authentication Methods
+
+Users can authenticate through multiple methods based on their role:
+
+- **Web Dashboard**: Email + password for operators, admins, company_admins, super_admins
+- **Mobile App**: Phone + password for first_responders and citizens
+- **API Access**: API key validation for mobile applications
+
+## Role-Based Permissions
+
+### Citizen
+- Submit reports via mobile app
+- View public event information
+- Receive notifications about local events
+
+### First Responder
+- All citizen permissions
+- Live location tracking
+- Event assignment and response
+- Access to detailed event information
+- Update event status
+
+### Operator
+- Monitor dashboard and maps
+- View all company events
+- Acknowledge and assign events
+- Generate reports and analytics
+
+### Admin
+- All operator permissions
+- Manage users within their company
+- Configure company settings
+- Access audit logs
+
+### Company Admin
+- All admin permissions
+- Manage company-wide settings
+- Access billing and usage information
+- Create and manage API keys
+
+### Super Admin
+- System-wide access
+- Create and manage companies
+- Access all data across tenants
+- System configuration and maintenance
+
+## Multi-Tenant Considerations
+
+- All users are scoped to a specific company via `companyId`
+- User management operations are restricted to the user's company
+- API keys are company-specific and can be rotated
+- Location data is only tracked for first responders within the company
+
+## Security Considerations
+
+- Passwords are hashed using bcrypt with appropriate salt rounds
+- API keys are generated using cryptographically secure random generation
+- Failed login attempts are tracked and rate-limited
+- Session tokens have appropriate expiration times
+- Device tokens are validated before sending notifications
+
+## Future Considerations
+
+As the platform evolves, additional properties may be added:
+
+- **twoFactorEnabled**: Enable 2FA for enhanced security
+- **loginHistory**: Track login attempts and devices
+- **certifications**: Track first responder certifications and training
+- **shiftSchedule**: Work schedule management for operators and responders
+- **emergencyContacts**: Emergency contact information
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/ai-detection-sequence.puml b/event-monitoring-mvp-architecture/docs/diagrams/ai-detection-sequence.puml
index 28a469c..3051820 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/ai-detection-sequence.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/ai-detection-sequence.puml
@@ -1,36 +1,36 @@
-@startuml AI Event Detection Flow
-!theme plain
-title Event Monitoring System - AI Event Detection Flow
-
-participant "IP Camera" as Camera
-participant "AI Analytics Service" as AI
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "WebSocket" as WS
-participant "React App" as Frontend
-
-Camera -> AI: Send video frames\n(RTSP stream)
-AI -> AI: Process frame\n(ML model inference)
-AI -> AI: Detect objects\n(person/vehicle detection)
-
-alt Event Detected
-    AI -> AI: Create detection payload\n{camera_id, timestamp, \ntype, coordinates, confidence}
-    AI -> Backend: POST /internal/ai/events\n(Internal API endpoint)
-    Backend -> Backend: Validate detection data
-    Backend -> DB: Insert event document\ndb.events.insertOne(eventData)
-    DB -> Backend: Created event
-    Backend -> WS: Broadcast event\nio.emit('newEvent', event)
-    WS -> Frontend: Real-time event notification
-    Frontend -> Frontend: Update UI\n(add marker to map, \nshow notification)
-    Frontend -> User: Display new event alert
-else No Event
-    AI -> AI: Continue processing\nnext frame
-end
-
-note over AI
-AI Service runs continuously
-Processing video streams from
-all connected cameras
-end note
-
+@startuml AI Event Detection Flow
+!theme plain
+title Event Monitoring System - AI Event Detection Flow
+
+participant "IP Camera" as Camera
+participant "AI Analytics Service" as AI
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "WebSocket" as WS
+participant "React App" as Frontend
+
+Camera -> AI: Send video frames\n(RTSP stream)
+AI -> AI: Process frame\n(ML model inference)
+AI -> AI: Detect objects\n(person/vehicle detection)
+
+alt Event Detected
+    AI -> AI: Create detection payload\n{camera_id, timestamp, \ntype, coordinates, confidence}
+    AI -> Backend: POST /internal/ai/events\n(Internal API endpoint)
+    Backend -> Backend: Validate detection data
+    Backend -> DB: Insert event document\ndb.events.insertOne(eventData)
+    DB -> Backend: Created event
+    Backend -> WS: Broadcast event\nio.emit('newEvent', event)
+    WS -> Frontend: Real-time event notification
+    Frontend -> Frontend: Update UI\n(add marker to map, \nshow notification)
+    Frontend -> User: Display new event alert
+else No Event
+    AI -> AI: Continue processing\nnext frame
+end
+
+note over AI
+AI Service runs continuously
+Processing video streams from
+all connected cameras
+end note
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/auth-sequence.puml b/event-monitoring-mvp-architecture/docs/diagrams/auth-sequence.puml
index e824619..757620e 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/auth-sequence.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/auth-sequence.puml
@@ -1,25 +1,25 @@
-@startuml User Authentication Flow
-!theme plain
-title Event Monitoring System - User Authentication Flow
-
-actor User
-participant "React App" as Frontend
-participant "Backend API" as Backend
-database "MongoDB" as DB
-
-User -> Frontend: Enter credentials
-Frontend -> Backend: POST /auth/login\n{username, password}
-Backend -> DB: Query users collection\ndb.users.findOne({username})
-DB -> Backend: User document
-Backend -> Backend: Validate password\n(bcrypt compare)
-alt Credentials Valid
-    Backend -> Backend: Generate JWT token
-    Backend -> Frontend: 200 OK\n{success: true, token, user}
-    Frontend -> Frontend: Store token in localStorage
-    Frontend -> User: Redirect to dashboard
-else Invalid Credentials
-    Backend -> Frontend: 401 Unauthorized\n{success: false, message}
-    Frontend -> User: Show error message
-end
-
+@startuml User Authentication Flow
+!theme plain
+title Event Monitoring System - User Authentication Flow
+
+actor User
+participant "React App" as Frontend
+participant "Backend API" as Backend
+database "MongoDB" as DB
+
+User -> Frontend: Enter credentials
+Frontend -> Backend: POST /auth/login\n{username, password}
+Backend -> DB: Query users collection\ndb.users.findOne({username})
+DB -> Backend: User document
+Backend -> Backend: Validate password\n(bcrypt compare)
+alt Credentials Valid
+    Backend -> Backend: Generate JWT token
+    Backend -> Frontend: 200 OK\n{success: true, token, user}
+    Frontend -> Frontend: Store token in localStorage
+    Frontend -> User: Redirect to dashboard
+else Invalid Credentials
+    Backend -> Frontend: 401 Unauthorized\n{success: false, message}
+    Frontend -> User: Show error message
+end
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/camera-management-sequence.puml b/event-monitoring-mvp-architecture/docs/diagrams/camera-management-sequence.puml
index ade131d..15f170d 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/camera-management-sequence.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/camera-management-sequence.puml
@@ -1,46 +1,46 @@
-@startuml Camera Management Flow
-!theme plain
-title Event Monitoring System - Camera Management Flow
-
-actor User
-participant "React App" as Frontend
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "IP Camera" as Camera
-
-== View Cameras ==
-User -> Frontend: Navigate to /cameras
-Frontend -> Backend: GET /api/cameras\nAuthorization: Bearer {token}
-Backend -> DB: Query cameras collection\ndb.cameras.find({createdBy: userId})
-DB -> Backend: Camera documents
-Backend -> Frontend: 200 OK\n{success: true, data: cameras[]}
-Frontend -> User: Display camera list
-
-== Add New Camera ==
-User -> Frontend: Click "Add Camera"
-Frontend -> User: Show AddCamera form
-User -> Frontend: Fill camera details\n(name, streamUrl, coordinates)
-Frontend -> Frontend: Validate form data\n(yup validation)
-Frontend -> Backend: POST /api/cameras\n{name, streamUrl, location, etc}
-Backend -> Backend: Validate JWT token
-Backend -> DB: Insert camera document\ndb.cameras.insertOne(cameraData)
-DB -> Backend: Created camera document
-Backend -> Frontend: 201 Created\n{success: true, data: camera}
-Frontend -> User: Success message\nRedirect to cameras list
-
-== Test Camera Connection ==
-User -> Frontend: Click "Test Connection"
-Frontend -> Frontend: Validate streamUrl exists
-Frontend -> Backend: POST /api/cameras/test\n{streamUrl}
-Backend -> Camera: Attempt connection\n(RTSP/HTTP request)
-alt Connection Successful
-    Camera -> Backend: Stream response
-    Backend -> Frontend: 200 OK\n{success: true, status: "connected"}
-    Frontend -> User: Show success indicator
-else Connection Failed
-    Camera -> Backend: Timeout/Error
-    Backend -> Frontend: 400 Bad Request\n{success: false, error: "connection_failed"}
-    Frontend -> User: Show error message
-end
-
+@startuml Camera Management Flow
+!theme plain
+title Event Monitoring System - Camera Management Flow
+
+actor User
+participant "React App" as Frontend
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "IP Camera" as Camera
+
+== View Cameras ==
+User -> Frontend: Navigate to /cameras
+Frontend -> Backend: GET /api/cameras\nAuthorization: Bearer {token}
+Backend -> DB: Query cameras collection\ndb.cameras.find({createdBy: userId})
+DB -> Backend: Camera documents
+Backend -> Frontend: 200 OK\n{success: true, data: cameras[]}
+Frontend -> User: Display camera list
+
+== Add New Camera ==
+User -> Frontend: Click "Add Camera"
+Frontend -> User: Show AddCamera form
+User -> Frontend: Fill camera details\n(name, streamUrl, coordinates)
+Frontend -> Frontend: Validate form data\n(yup validation)
+Frontend -> Backend: POST /api/cameras\n{name, streamUrl, location, etc}
+Backend -> Backend: Validate JWT token
+Backend -> DB: Insert camera document\ndb.cameras.insertOne(cameraData)
+DB -> Backend: Created camera document
+Backend -> Frontend: 201 Created\n{success: true, data: camera}
+Frontend -> User: Success message\nRedirect to cameras list
+
+== Test Camera Connection ==
+User -> Frontend: Click "Test Connection"
+Frontend -> Frontend: Validate streamUrl exists
+Frontend -> Backend: POST /api/cameras/test\n{streamUrl}
+Backend -> Camera: Attempt connection\n(RTSP/HTTP request)
+alt Connection Successful
+    Camera -> Backend: Stream response
+    Backend -> Frontend: 200 OK\n{success: true, status: "connected"}
+    Frontend -> User: Show success indicator
+else Connection Failed
+    Camera -> Backend: Timeout/Error
+    Backend -> Frontend: 400 Bad Request\n{success: false, error: "connection_failed"}
+    Frontend -> User: Show error message
+end
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/database-schema.puml b/event-monitoring-mvp-architecture/docs/diagrams/database-schema.puml
index 38db05e..53c54c5 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/database-schema.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/database-schema.puml
@@ -1,63 +1,63 @@
-@startuml Database Schema Relationships
-!theme plain
-title Event Monitoring System - Database Schema
-
-entity "users" {
-    * _id : ObjectId
-    --
-    * username : String
-    * email : String
-    * password : String (hashed)
-    * role : String
-    * createdAt : Date
-    * updatedAt : Date
-}
-
-entity "cameras" {
-    * _id : ObjectId
-    --
-    * name : String
-    * description : String
-    * streamUrl : String
-    * status : String
-    * type : String
-    * location : Object
-    * settings : Object
-    * isActive : Boolean
-    * createdBy : ObjectId
-    * createdAt : Date
-    * updatedAt : Date
-}
-
-entity "events" {
-    * _id : ObjectId
-    --
-    * type : String
-    * severity : String
-    * location : Object
-    * camera : ObjectId
-    * timestamp : Date
-    * description : String
-    * resolved : Boolean
-    * resolvedBy : ObjectId
-    * metadata : Object
-    * createdAt : Date
-}
-
-users ||--o{ cameras : "createdBy"
-cameras ||--o{ events : "camera"
-users ||--o{ events : "resolvedBy"
-
-note as N2
-MongoDB Collections:
-- users: System operators/admins
-- cameras: IP camera configurations
-- events: AI-detected security events
-
-Relationships:
-- One user can create many cameras
-- One camera can generate many events
-- One user can resolve many events
-end note
-
+@startuml Database Schema Relationships
+!theme plain
+title Event Monitoring System - Database Schema
+
+entity "users" {
+    * _id : ObjectId
+    --
+    * username : String
+    * email : String
+    * password : String (hashed)
+    * role : String
+    * createdAt : Date
+    * updatedAt : Date
+}
+
+entity "cameras" {
+    * _id : ObjectId
+    --
+    * name : String
+    * description : String
+    * streamUrl : String
+    * status : String
+    * type : String
+    * location : Object
+    * settings : Object
+    * isActive : Boolean
+    * createdBy : ObjectId
+    * createdAt : Date
+    * updatedAt : Date
+}
+
+entity "events" {
+    * _id : ObjectId
+    --
+    * type : String
+    * severity : String
+    * location : Object
+    * camera : ObjectId
+    * timestamp : Date
+    * description : String
+    * resolved : Boolean
+    * resolvedBy : ObjectId
+    * metadata : Object
+    * createdAt : Date
+}
+
+users ||--o{ cameras : "createdBy"
+cameras ||--o{ events : "camera"
+users ||--o{ events : "resolvedBy"
+
+note as N2
+MongoDB Collections:
+- users: System operators/admins
+- cameras: IP camera configurations
+- events: AI-detected security events
+
+Relationships:
+- One user can create many cameras
+- One camera can generate many events
+- One user can resolve many events
+end note
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/map-view-sequence.puml b/event-monitoring-mvp-architecture/docs/diagrams/map-view-sequence.puml
index 262c424..4752bbd 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/map-view-sequence.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/map-view-sequence.puml
@@ -1,54 +1,54 @@
-@startuml Map View Data Flow
-!theme plain
-title Event Monitoring System - Map View Data Flow
-
-actor User
-participant "React MapView" as Frontend
-participant "dataService.ts" as DataService
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "OpenStreetMap" as MapTiles
-
-User -> Frontend: Navigate to Map View
-Frontend -> Frontend: Initialize map component
-
-== Fetch Data ==
-Frontend -> DataService: fetchCamerasData()
-DataService -> Backend: GET /api/cameras
-alt API Available
-    Backend -> DB: db.cameras.find()
-    DB -> Backend: Camera documents
-    Backend -> DataService: Camera data
-else API Not Available
-    DataService -> DataService: Return MOCK_CAMERAS
-end
-DataService -> Frontend: Camera array
-
-Frontend -> DataService: fetchEventsData()
-DataService -> Backend: GET /api/events
-alt API Available
-    Backend -> DB: db.events.find()
-    DB -> Backend: Event documents
-    Backend -> DataService: Event data
-else API Not Available
-    DataService -> DataService: Return MOCK_EVENTS
-end
-DataService -> Frontend: Event array
-
-Frontend -> MapTiles: Request map tiles
-MapTiles -> Frontend: Map tile images
-
-Frontend -> Frontend: Apply filters\n(status, severity, search)
-Frontend -> Frontend: Create camera markers\n(color-coded by status)
-Frontend -> Frontend: Create event markers\n(sized by severity)
-Frontend -> User: Display interactive map
-
-User -> Frontend: Click camera marker
-Frontend -> Frontend: Show camera popup\nwith details
-Frontend -> User: Display camera info
-
-User -> Frontend: Click event marker
-Frontend -> Frontend: Show event popup\nwith severity/description
-Frontend -> User: Display event details
-
+@startuml Map View Data Flow
+!theme plain
+title Event Monitoring System - Map View Data Flow
+
+actor User
+participant "React MapView" as Frontend
+participant "dataService.ts" as DataService
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "OpenStreetMap" as MapTiles
+
+User -> Frontend: Navigate to Map View
+Frontend -> Frontend: Initialize map component
+
+== Fetch Data ==
+Frontend -> DataService: fetchCamerasData()
+DataService -> Backend: GET /api/cameras
+alt API Available
+    Backend -> DB: db.cameras.find()
+    DB -> Backend: Camera documents
+    Backend -> DataService: Camera data
+else API Not Available
+    DataService -> DataService: Return MOCK_CAMERAS
+end
+DataService -> Frontend: Camera array
+
+Frontend -> DataService: fetchEventsData()
+DataService -> Backend: GET /api/events
+alt API Available
+    Backend -> DB: db.events.find()
+    DB -> Backend: Event documents
+    Backend -> DataService: Event data
+else API Not Available
+    DataService -> DataService: Return MOCK_EVENTS
+end
+DataService -> Frontend: Event array
+
+Frontend -> MapTiles: Request map tiles
+MapTiles -> Frontend: Map tile images
+
+Frontend -> Frontend: Apply filters\n(status, severity, search)
+Frontend -> Frontend: Create camera markers\n(color-coded by status)
+Frontend -> Frontend: Create event markers\n(sized by severity)
+Frontend -> User: Display interactive map
+
+User -> Frontend: Click camera marker
+Frontend -> Frontend: Show camera popup\nwith details
+Frontend -> User: Display camera info
+
+User -> Frontend: Click event marker
+Frontend -> Frontend: Show event popup\nwith severity/description
+Frontend -> User: Display event details
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/system-architecture.puml b/event-monitoring-mvp-architecture/docs/diagrams/system-architecture.puml
index ed94c00..8650942 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/system-architecture.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/system-architecture.puml
@@ -1,68 +1,68 @@
-@startuml System Architecture Overview
-!theme plain
-title Event Monitoring System - Overall Architecture
-
-package "Frontend (React + TypeScript)" {
-    component [React Router] as Router
-    component [Material-UI Components] as UI
-    component [Leaflet Map] as Map
-    component [WebSocket Client] as WSClient
-    component [Data Service] as DataSvc
-}
-
-package "Backend (Node.js + Express)" {
-    component [Express API Server] as API
-    component [JWT Authentication] as Auth
-    component [WebSocket Server] as WSServer
-    component [Mongoose ODM] as ODM
-}
-
-package "AI Service (Python)" {
-    component [Video Processing] as VideoProc
-    component [ML Models] as ML
-    component [Event Detection] as EventDetect
-}
-
-database "MongoDB" {
-    collections users
-    collections cameras
-    collections events
-}
-
-cloud "External Services" {
-    component [IP Cameras] as Cameras
-    component [OpenStreetMap] as OSM
-}
-
-' Frontend connections
-Router --> UI
-UI --> Map
-UI --> DataSvc
-WSClient --> WSServer
-DataSvc --> API
-
-' Backend connections
-API --> Auth
-API --> ODM
-WSServer --> API
-ODM --> MongoDB
-
-' AI Service connections
-Cameras --> VideoProc
-VideoProc --> ML
-ML --> EventDetect
-EventDetect --> API
-
-' External connections
-Map --> OSM
-
-note as N1
-Data flows:
-1. User authentication via JWT
-2. Camera management (CRUD)
-3. Real-time event detection
-4. Live video streaming
-5. Interactive map with filters
-end note
-
+@startuml System Architecture Overview
+!theme plain
+title Event Monitoring System - Overall Architecture
+
+package "Frontend (React + TypeScript)" {
+    component [React Router] as Router
+    component [Material-UI Components] as UI
+    component [Leaflet Map] as Map
+    component [WebSocket Client] as WSClient
+    component [Data Service] as DataSvc
+}
+
+package "Backend (Node.js + Express)" {
+    component [Express API Server] as API
+    component [JWT Authentication] as Auth
+    component [WebSocket Server] as WSServer
+    component [Mongoose ODM] as ODM
+}
+
+package "AI Service (Python)" {
+    component [Video Processing] as VideoProc
+    component [ML Models] as ML
+    component [Event Detection] as EventDetect
+}
+
+database "MongoDB" {
+    collections users
+    collections cameras
+    collections events
+}
+
+cloud "External Services" {
+    component [IP Cameras] as Cameras
+    component [OpenStreetMap] as OSM
+}
+
+' Frontend connections
+Router --> UI
+UI --> Map
+UI --> DataSvc
+WSClient --> WSServer
+DataSvc --> API
+
+' Backend connections
+API --> Auth
+API --> ODM
+WSServer --> API
+ODM --> MongoDB
+
+' AI Service connections
+Cameras --> VideoProc
+VideoProc --> ML
+ML --> EventDetect
+EventDetect --> API
+
+' External connections
+Map --> OSM
+
+note as N1
+Data flows:
+1. User authentication via JWT
+2. Camera management (CRUD)
+3. Real-time event detection
+4. Live video streaming
+5. Interactive map with filters
+end note
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/system-flow-diagram.puml b/event-monitoring-mvp-architecture/docs/diagrams/system-flow-diagram.puml
index 83460d0..8b847ff 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/system-flow-diagram.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/system-flow-diagram.puml
@@ -1,171 +1,171 @@
-@startuml Event Monitoring System - Complete Flow Diagram
-!theme plain
-title Event Monitoring System - Complete System Flow
-
-start
-
-:User opens application;
-
-if (User authenticated?) then (no)
-    :Show login page;
-    :User enters credentials;
-    
-    if (Credentials valid?) then (no)
-        :Show error message;
-        stop
-    else (yes)
-        :Generate JWT token;
-        :Store token in localStorage;
-    endif
-else (yes)
-    :Load user session;
-endif
-
-:Display dashboard;
-
-while (User navigates system?) is (yes)
-    
-    switch (User selects?)
-    case (Dashboard)
-        :Load system overview;
-        :Display camera stats;
-        :Show recent events;
-    case (Cameras)
-        :Fetch camera list from API;
-        
-        if (API available?) then (no)
-            :Load mock camera data;
-        else (yes)
-            :Query MongoDB cameras collection;
-            :Return camera documents;
-        endif
-        
-        :Display camera grid;
-        
-        if (User clicks "Add Camera"?) then (yes)
-            :Show AddCamera form;
-            :User fills camera details;
-            
-            if (Form validation passes?) then (no)
-                :Show validation errors;
-            else (yes)
-                if (User tests connection?) then (yes)
-                    :Send test request to camera;
-                    
-                    if (Connection successful?) then (no)
-                        :Show connection error;
-                    else (yes)
-                        :Show success indicator;
-                    endif
-                endif
-                
-                :Submit camera data to API;
-                :Save to MongoDB;
-                :Redirect to cameras list;
-            endif
-        endif
-        
-    case (Live View)
-        :Fetch active cameras;
-        :Display video grid;
-        
-        if (User selects camera?) then (yes)
-            :Connect to video stream;
-            :Display live video;
-        endif
-        
-    case (Map View)
-        partition "Data Loading" {
-            fork
-                :Fetch cameras from API;
-                if (API available?) then (no)
-                    :Use MOCK_CAMERAS;
-                else (yes)
-                    :Query cameras from MongoDB;
-                endif
-            fork again
-                :Fetch events from API;
-                if (API available?) then (no)
-                    :Use MOCK_EVENTS;
-                else (yes)
-                    :Query events from MongoDB;
-                endif
-            fork again
-                :Load map tiles from OpenStreetMap;
-            end fork
-        }
-        
-        :Apply user filters;
-        :Create camera markers (color by status);
-        :Create event markers (size by severity);
-        :Display interactive map;
-        
-        if (User clicks marker?) then (yes)
-            if (Camera marker?) then (yes)
-                :Show camera details popup;
-                :Display in sidebar;
-            else (no)
-                :Show event details popup;
-            endif
-        endif
-        
-    case (Events)
-        :Fetch events with filters;
-        :Display events table;
-        
-        if (User applies filters?) then (yes)
-            :Update filter parameters;
-            :Refetch filtered events;
-        endif
-        
-        if (User resolves event?) then (yes)
-            :Send PATCH request to API;
-            :Update event in MongoDB;
-            :Update UI;
-        endif
-        
-    case (Settings/Profile)
-        :Display user settings;
-        :Allow profile updates;
-        
-    endswitch
-    
-endwhile (no)
-
-note right
-AI Detection Process runs continuously:
-
-1. IP Cameras stream video to AI Service
-2. AI Service processes frames with ML models
-3. When event detected:
-   - Create detection payload
-   - Send to Backend API
-   - Save event to MongoDB
-   - Broadcast via WebSocket
-4. Frontend receives real-time notification
-5. Update map markers and event list
-end note
-
-partition "Background Processes" {
-    start
-    :AI Service monitors camera streams;
-    
-    while (Processing video frames?) is (yes)
-        :Analyze frame with ML model;
-        
-        if (Event detected?) then (yes)
-            :Create detection payload;
-            :Send to Backend API;
-            :Validate and save to MongoDB;
-            :Broadcast via WebSocket;
-            :Update frontend in real-time;
-        endif
-    endwhile
-    stop
-}
-
-:User logs out;
-:Clear authentication token;
-stop
-
+@startuml Event Monitoring System - Complete Flow Diagram
+!theme plain
+title Event Monitoring System - Complete System Flow
+
+start
+
+:User opens application;
+
+if (User authenticated?) then (no)
+    :Show login page;
+    :User enters credentials;
+    
+    if (Credentials valid?) then (no)
+        :Show error message;
+        stop
+    else (yes)
+        :Generate JWT token;
+        :Store token in localStorage;
+    endif
+else (yes)
+    :Load user session;
+endif
+
+:Display dashboard;
+
+while (User navigates system?) is (yes)
+    
+    switch (User selects?)
+    case (Dashboard)
+        :Load system overview;
+        :Display camera stats;
+        :Show recent events;
+    case (Cameras)
+        :Fetch camera list from API;
+        
+        if (API available?) then (no)
+            :Load mock camera data;
+        else (yes)
+            :Query MongoDB cameras collection;
+            :Return camera documents;
+        endif
+        
+        :Display camera grid;
+        
+        if (User clicks "Add Camera"?) then (yes)
+            :Show AddCamera form;
+            :User fills camera details;
+            
+            if (Form validation passes?) then (no)
+                :Show validation errors;
+            else (yes)
+                if (User tests connection?) then (yes)
+                    :Send test request to camera;
+                    
+                    if (Connection successful?) then (no)
+                        :Show connection error;
+                    else (yes)
+                        :Show success indicator;
+                    endif
+                endif
+                
+                :Submit camera data to API;
+                :Save to MongoDB;
+                :Redirect to cameras list;
+            endif
+        endif
+        
+    case (Live View)
+        :Fetch active cameras;
+        :Display video grid;
+        
+        if (User selects camera?) then (yes)
+            :Connect to video stream;
+            :Display live video;
+        endif
+        
+    case (Map View)
+        partition "Data Loading" {
+            fork
+                :Fetch cameras from API;
+                if (API available?) then (no)
+                    :Use MOCK_CAMERAS;
+                else (yes)
+                    :Query cameras from MongoDB;
+                endif
+            fork again
+                :Fetch events from API;
+                if (API available?) then (no)
+                    :Use MOCK_EVENTS;
+                else (yes)
+                    :Query events from MongoDB;
+                endif
+            fork again
+                :Load map tiles from OpenStreetMap;
+            end fork
+        }
+        
+        :Apply user filters;
+        :Create camera markers (color by status);
+        :Create event markers (size by severity);
+        :Display interactive map;
+        
+        if (User clicks marker?) then (yes)
+            if (Camera marker?) then (yes)
+                :Show camera details popup;
+                :Display in sidebar;
+            else (no)
+                :Show event details popup;
+            endif
+        endif
+        
+    case (Events)
+        :Fetch events with filters;
+        :Display events table;
+        
+        if (User applies filters?) then (yes)
+            :Update filter parameters;
+            :Refetch filtered events;
+        endif
+        
+        if (User resolves event?) then (yes)
+            :Send PATCH request to API;
+            :Update event in MongoDB;
+            :Update UI;
+        endif
+        
+    case (Settings/Profile)
+        :Display user settings;
+        :Allow profile updates;
+        
+    endswitch
+    
+endwhile (no)
+
+note right
+AI Detection Process runs continuously:
+
+1. IP Cameras stream video to AI Service
+2. AI Service processes frames with ML models
+3. When event detected:
+   - Create detection payload
+   - Send to Backend API
+   - Save event to MongoDB
+   - Broadcast via WebSocket
+4. Frontend receives real-time notification
+5. Update map markers and event list
+end note
+
+partition "Background Processes" {
+    start
+    :AI Service monitors camera streams;
+    
+    while (Processing video frames?) is (yes)
+        :Analyze frame with ML model;
+        
+        if (Event detected?) then (yes)
+            :Create detection payload;
+            :Send to Backend API;
+            :Validate and save to MongoDB;
+            :Broadcast via WebSocket;
+            :Update frontend in real-time;
+        endif
+    endwhile
+    stop
+}
+
+:User logs out;
+:Clear authentication token;
+stop
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/diagrams/uml-sequence-diagrams.puml b/event-monitoring-mvp-architecture/docs/diagrams/uml-sequence-diagrams.puml
index be98945..3e7d3d3 100644
--- a/event-monitoring-mvp-architecture/docs/diagrams/uml-sequence-diagrams.puml
+++ b/event-monitoring-mvp-architecture/docs/diagrams/uml-sequence-diagrams.puml
@@ -1,369 +1,369 @@
-@startuml User Authentication Flow
-!theme plain
-title Event Monitoring System - User Authentication Flow
-
-actor User
-participant "React App" as Frontend
-participant "Backend API" as Backend
-database "MongoDB" as DB
-
-User -> Frontend: Enter credentials
-Frontend -> Backend: POST /auth/login\n{username, password}
-Backend -> DB: Query users collection\ndb.users.findOne({username})
-DB -> Backend: User document
-Backend -> Backend: Validate password\n(bcrypt compare)
-alt Credentials Valid
-    Backend -> Backend: Generate JWT token
-    Backend -> Frontend: 200 OK\n{success: true, token, user}
-    Frontend -> Frontend: Store token in localStorage
-    Frontend -> User: Redirect to dashboard
-else Invalid Credentials
-    Backend -> Frontend: 401 Unauthorized\n{success: false, message}
-    Frontend -> User: Show error message
-end
-
-@enduml
-
-@startuml Camera Management Flow
-!theme plain
-title Event Monitoring System - Camera Management Flow
-
-actor User
-participant "React App" as Frontend
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "IP Camera" as Camera
-
-== View Cameras ==
-User -> Frontend: Navigate to /cameras
-Frontend -> Backend: GET /api/cameras\nAuthorization: Bearer {token}
-Backend -> DB: Query cameras collection\ndb.cameras.find({createdBy: userId})
-DB -> Backend: Camera documents
-Backend -> Frontend: 200 OK\n{success: true, data: cameras[]}
-Frontend -> User: Display camera list
-
-== Add New Camera ==
-User -> Frontend: Click "Add Camera"
-Frontend -> User: Show AddCamera form
-User -> Frontend: Fill camera details\n(name, streamUrl, coordinates)
-Frontend -> Frontend: Validate form data\n(yup validation)
-Frontend -> Backend: POST /api/cameras\n{name, streamUrl, location, etc}
-Backend -> Backend: Validate JWT token
-Backend -> DB: Insert camera document\ndb.cameras.insertOne(cameraData)
-DB -> Backend: Created camera document
-Backend -> Frontend: 201 Created\n{success: true, data: camera}
-Frontend -> User: Success message\nRedirect to cameras list
-
-== Test Camera Connection ==
-User -> Frontend: Click "Test Connection"
-Frontend -> Frontend: Validate streamUrl exists
-Frontend -> Backend: POST /api/cameras/test\n{streamUrl}
-Backend -> Camera: Attempt connection\n(RTSP/HTTP request)
-alt Connection Successful
-    Camera -> Backend: Stream response
-    Backend -> Frontend: 200 OK\n{success: true, status: "connected"}
-    Frontend -> User: Show success indicator
-else Connection Failed
-    Camera -> Backend: Timeout/Error
-    Backend -> Frontend: 400 Bad Request\n{success: false, error: "connection_failed"}
-    Frontend -> User: Show error message
-end
-
-@enduml
-
-@startuml Live Video Streaming Flow
-!theme plain
-title Event Monitoring System - Live Video Streaming Flow
-
-actor User
-participant "React App" as Frontend
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "IP Camera/VMS" as VideoSource
-
-User -> Frontend: Navigate to Live View
-Frontend -> Backend: GET /api/cameras\nAuthorization: Bearer {token}
-Backend -> DB: Query active cameras\ndb.cameras.find({status: "online"})
-DB -> Backend: Active camera list
-Backend -> Frontend: Camera data with streamUrls
-
-Frontend -> User: Display camera grid
-User -> Frontend: Select camera to view
-Frontend -> VideoSource: Direct video stream connection\n(WebRTC/HLS/RTSP)
-VideoSource -> Frontend: Live video stream
-Frontend -> User: Display live video
-
-note over Frontend, VideoSource
-Video streaming happens directly 
-between frontend and camera/VMS
-to reduce server load
-end note
-
-@enduml
-
-@startuml AI Event Detection Flow
-!theme plain
-title Event Monitoring System - AI Event Detection Flow
-
-participant "IP Camera" as Camera
-participant "AI Analytics Service" as AI
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "WebSocket" as WS
-participant "React App" as Frontend
-
-Camera -> AI: Send video frames\n(RTSP stream)
-AI -> AI: Process frame\n(ML model inference)
-AI -> AI: Detect objects\n(person/vehicle detection)
-
-alt Event Detected
-    AI -> AI: Create detection payload\n{camera_id, timestamp, \ntype, coordinates, confidence}
-    AI -> Backend: POST /internal/ai/events\n(Internal API endpoint)
-    Backend -> Backend: Validate detection data
-    Backend -> DB: Insert event document\ndb.events.insertOne(eventData)
-    DB -> Backend: Created event
-    Backend -> WS: Broadcast event\nio.emit('newEvent', event)
-    WS -> Frontend: Real-time event notification
-    Frontend -> Frontend: Update UI\n(add marker to map, \nshow notification)
-    Frontend -> User: Display new event alert
-else No Event
-    AI -> AI: Continue processing\nnext frame
-end
-
-note over AI
-AI Service runs continuously
-Processing video streams from
-all connected cameras
-end note
-
-@enduml
-
-@startuml Map View Data Flow
-!theme plain
-title Event Monitoring System - Map View Data Flow
-
-actor User
-participant "React MapView" as Frontend
-participant "dataService.ts" as DataService
-participant "Backend API" as Backend
-database "MongoDB" as DB
-participant "OpenStreetMap" as MapTiles
-
-User -> Frontend: Navigate to Map View
-Frontend -> Frontend: Initialize map component
-
-== Fetch Data ==
-Frontend -> DataService: fetchCamerasData()
-DataService -> Backend: GET /api/cameras
-alt API Available
-    Backend -> DB: db.cameras.find()
-    DB -> Backend: Camera documents
-    Backend -> DataService: Camera data
-else API Not Available
-    DataService -> DataService: Return MOCK_CAMERAS
-end
-DataService -> Frontend: Camera array
-
-Frontend -> DataService: fetchEventsData()
-DataService -> Backend: GET /api/events
-alt API Available
-    Backend -> DB: db.events.find()
-    DB -> Backend: Event documents
-    Backend -> DataService: Event data
-else API Not Available
-    DataService -> DataService: Return MOCK_EVENTS
-end
-DataService -> Frontend: Event array
-
-Frontend -> MapTiles: Request map tiles
-MapTiles -> Frontend: Map tile images
-
-Frontend -> Frontend: Apply filters\n(status, severity, search)
-Frontend -> Frontend: Create camera markers\n(color-coded by status)
-Frontend -> Frontend: Create event markers\n(sized by severity)
-Frontend -> User: Display interactive map
-
-User -> Frontend: Click camera marker
-Frontend -> Frontend: Show camera popup\nwith details
-Frontend -> User: Display camera info
-
-User -> Frontend: Click event marker
-Frontend -> Frontend: Show event popup\nwith severity/description
-Frontend -> User: Display event details
-
-@enduml
-
-@startuml Event Management Flow
-!theme plain
-title Event Monitoring System - Event Management Flow
-
-actor "Security Operator" as User
-participant "React App" as Frontend
-participant "Backend API" as Backend
-database "MongoDB" as DB
-
-== View Events ==
-User -> Frontend: Navigate to Events page
-Frontend -> Backend: GET /api/events\n?status=&type=&severity=
-Backend -> DB: Query events with filters\ndb.events.find(filterQuery).sort({timestamp: -1})
-DB -> Backend: Event documents
-Backend -> Frontend: Paginated event list
-Frontend -> User: Display events table
-
-== Filter Events ==
-User -> Frontend: Apply filters\n(type, severity, status)
-Frontend -> Frontend: Update filter state
-Frontend -> Backend: GET /api/events\n?type=intrusion&severity=high
-Backend -> DB: Query with new filters
-DB -> Backend: Filtered events
-Backend -> Frontend: Updated event list
-Frontend -> User: Show filtered results
-
-== Resolve Event ==
-User -> Frontend: Click "Resolve" on event
-Frontend -> Backend: PATCH /api/events/{id}\n{resolved: true, resolvedBy: userId}
-Backend -> DB: Update event document\ndb.events.updateOne({_id}, {resolved: true})
-DB -> Backend: Updated document
-Backend -> Frontend: 200 OK\n{success: true, data: updatedEvent}
-Frontend -> Frontend: Update event in UI
-Frontend -> User: Show success message
-
-== View Event Details ==
-User -> Frontend: Click event row
-Frontend -> Frontend: Show event details modal
-Frontend -> User: Display full event info\n(location, camera, metadata)
-
-@enduml
-
-@startuml System Architecture Overview
-!theme plain
-title Event Monitoring System - Overall Architecture
-
-package "Frontend (React + TypeScript)" {
-    component [React Router] as Router
-    component [Material-UI Components] as UI
-    component [Leaflet Map] as Map
-    component [WebSocket Client] as WSClient
-    component [Data Service] as DataSvc
-}
-
-package "Backend (Node.js + Express)" {
-    component [Express API Server] as API
-    component [JWT Authentication] as Auth
-    component [WebSocket Server] as WSServer
-    component [Mongoose ODM] as ODM
-}
-
-package "AI Service (Python)" {
-    component [Video Processing] as VideoProc
-    component [ML Models] as ML
-    component [Event Detection] as EventDetect
-}
-
-database "MongoDB" {
-    collections users
-    collections cameras
-    collections events
-}
-
-cloud "External Services" {
-    component [IP Cameras] as Cameras
-    component [OpenStreetMap] as OSM
-}
-
-' Frontend connections
-Router --> UI
-UI --> Map
-UI --> DataSvc
-WSClient --> WSServer
-DataSvc --> API
-
-' Backend connections
-API --> Auth
-API --> ODM
-WSServer --> API
-ODM --> MongoDB
-
-' AI Service connections
-Cameras --> VideoProc
-VideoProc --> ML
-ML --> EventDetect
-EventDetect --> API
-
-' External connections
-Map --> OSM
-
-note as N1
-Data flows:
-1. User authentication via JWT
-2. Camera management (CRUD)
-3. Real-time event detection
-4. Live video streaming
-5. Interactive map with filters
-end note
-
-@enduml
-
-@startuml Database Schema Relationships
-!theme plain
-title Event Monitoring System - Database Schema
-
-entity "users" {
-    * _id : ObjectId
-    --
-    * username : String
-    * email : String
-    * password : String (hashed)
-    * role : String
-    * createdAt : Date
-    * updatedAt : Date
-}
-
-entity "cameras" {
-    * _id : ObjectId
-    --
-    * name : String
-    * description : String
-    * streamUrl : String
-    * status : String
-    * type : String
-    * location : Object
-    * settings : Object
-    * isActive : Boolean
-    * createdBy : ObjectId
-    * createdAt : Date
-    * updatedAt : Date
-}
-
-entity "events" {
-    * _id : ObjectId
-    --
-    * type : String
-    * severity : String
-    * location : Object
-    * camera : ObjectId
-    * timestamp : Date
-    * description : String
-    * resolved : Boolean
-    * resolvedBy : ObjectId
-    * metadata : Object
-    * createdAt : Date
-}
-
-users ||--o{ cameras : "createdBy"
-cameras ||--o{ events : "camera"
-users ||--o{ events : "resolvedBy"
-
-note as N2
-MongoDB Collections:
-- users: System operators/admins
-- cameras: IP camera configurations
-- events: AI-detected security events
-
-Relationships:
-- One user can create many cameras
-- One camera can generate many events
-- One user can resolve many events
-end note
-
+@startuml User Authentication Flow
+!theme plain
+title Event Monitoring System - User Authentication Flow
+
+actor User
+participant "React App" as Frontend
+participant "Backend API" as Backend
+database "MongoDB" as DB
+
+User -> Frontend: Enter credentials
+Frontend -> Backend: POST /auth/login\n{username, password}
+Backend -> DB: Query users collection\ndb.users.findOne({username})
+DB -> Backend: User document
+Backend -> Backend: Validate password\n(bcrypt compare)
+alt Credentials Valid
+    Backend -> Backend: Generate JWT token
+    Backend -> Frontend: 200 OK\n{success: true, token, user}
+    Frontend -> Frontend: Store token in localStorage
+    Frontend -> User: Redirect to dashboard
+else Invalid Credentials
+    Backend -> Frontend: 401 Unauthorized\n{success: false, message}
+    Frontend -> User: Show error message
+end
+
+@enduml
+
+@startuml Camera Management Flow
+!theme plain
+title Event Monitoring System - Camera Management Flow
+
+actor User
+participant "React App" as Frontend
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "IP Camera" as Camera
+
+== View Cameras ==
+User -> Frontend: Navigate to /cameras
+Frontend -> Backend: GET /api/cameras\nAuthorization: Bearer {token}
+Backend -> DB: Query cameras collection\ndb.cameras.find({createdBy: userId})
+DB -> Backend: Camera documents
+Backend -> Frontend: 200 OK\n{success: true, data: cameras[]}
+Frontend -> User: Display camera list
+
+== Add New Camera ==
+User -> Frontend: Click "Add Camera"
+Frontend -> User: Show AddCamera form
+User -> Frontend: Fill camera details\n(name, streamUrl, coordinates)
+Frontend -> Frontend: Validate form data\n(yup validation)
+Frontend -> Backend: POST /api/cameras\n{name, streamUrl, location, etc}
+Backend -> Backend: Validate JWT token
+Backend -> DB: Insert camera document\ndb.cameras.insertOne(cameraData)
+DB -> Backend: Created camera document
+Backend -> Frontend: 201 Created\n{success: true, data: camera}
+Frontend -> User: Success message\nRedirect to cameras list
+
+== Test Camera Connection ==
+User -> Frontend: Click "Test Connection"
+Frontend -> Frontend: Validate streamUrl exists
+Frontend -> Backend: POST /api/cameras/test\n{streamUrl}
+Backend -> Camera: Attempt connection\n(RTSP/HTTP request)
+alt Connection Successful
+    Camera -> Backend: Stream response
+    Backend -> Frontend: 200 OK\n{success: true, status: "connected"}
+    Frontend -> User: Show success indicator
+else Connection Failed
+    Camera -> Backend: Timeout/Error
+    Backend -> Frontend: 400 Bad Request\n{success: false, error: "connection_failed"}
+    Frontend -> User: Show error message
+end
+
+@enduml
+
+@startuml Live Video Streaming Flow
+!theme plain
+title Event Monitoring System - Live Video Streaming Flow
+
+actor User
+participant "React App" as Frontend
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "IP Camera/VMS" as VideoSource
+
+User -> Frontend: Navigate to Live View
+Frontend -> Backend: GET /api/cameras\nAuthorization: Bearer {token}
+Backend -> DB: Query active cameras\ndb.cameras.find({status: "online"})
+DB -> Backend: Active camera list
+Backend -> Frontend: Camera data with streamUrls
+
+Frontend -> User: Display camera grid
+User -> Frontend: Select camera to view
+Frontend -> VideoSource: Direct video stream connection\n(WebRTC/HLS/RTSP)
+VideoSource -> Frontend: Live video stream
+Frontend -> User: Display live video
+
+note over Frontend, VideoSource
+Video streaming happens directly 
+between frontend and camera/VMS
+to reduce server load
+end note
+
+@enduml
+
+@startuml AI Event Detection Flow
+!theme plain
+title Event Monitoring System - AI Event Detection Flow
+
+participant "IP Camera" as Camera
+participant "AI Analytics Service" as AI
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "WebSocket" as WS
+participant "React App" as Frontend
+
+Camera -> AI: Send video frames\n(RTSP stream)
+AI -> AI: Process frame\n(ML model inference)
+AI -> AI: Detect objects\n(person/vehicle detection)
+
+alt Event Detected
+    AI -> AI: Create detection payload\n{camera_id, timestamp, \ntype, coordinates, confidence}
+    AI -> Backend: POST /internal/ai/events\n(Internal API endpoint)
+    Backend -> Backend: Validate detection data
+    Backend -> DB: Insert event document\ndb.events.insertOne(eventData)
+    DB -> Backend: Created event
+    Backend -> WS: Broadcast event\nio.emit('newEvent', event)
+    WS -> Frontend: Real-time event notification
+    Frontend -> Frontend: Update UI\n(add marker to map, \nshow notification)
+    Frontend -> User: Display new event alert
+else No Event
+    AI -> AI: Continue processing\nnext frame
+end
+
+note over AI
+AI Service runs continuously
+Processing video streams from
+all connected cameras
+end note
+
+@enduml
+
+@startuml Map View Data Flow
+!theme plain
+title Event Monitoring System - Map View Data Flow
+
+actor User
+participant "React MapView" as Frontend
+participant "dataService.ts" as DataService
+participant "Backend API" as Backend
+database "MongoDB" as DB
+participant "OpenStreetMap" as MapTiles
+
+User -> Frontend: Navigate to Map View
+Frontend -> Frontend: Initialize map component
+
+== Fetch Data ==
+Frontend -> DataService: fetchCamerasData()
+DataService -> Backend: GET /api/cameras
+alt API Available
+    Backend -> DB: db.cameras.find()
+    DB -> Backend: Camera documents
+    Backend -> DataService: Camera data
+else API Not Available
+    DataService -> DataService: Return MOCK_CAMERAS
+end
+DataService -> Frontend: Camera array
+
+Frontend -> DataService: fetchEventsData()
+DataService -> Backend: GET /api/events
+alt API Available
+    Backend -> DB: db.events.find()
+    DB -> Backend: Event documents
+    Backend -> DataService: Event data
+else API Not Available
+    DataService -> DataService: Return MOCK_EVENTS
+end
+DataService -> Frontend: Event array
+
+Frontend -> MapTiles: Request map tiles
+MapTiles -> Frontend: Map tile images
+
+Frontend -> Frontend: Apply filters\n(status, severity, search)
+Frontend -> Frontend: Create camera markers\n(color-coded by status)
+Frontend -> Frontend: Create event markers\n(sized by severity)
+Frontend -> User: Display interactive map
+
+User -> Frontend: Click camera marker
+Frontend -> Frontend: Show camera popup\nwith details
+Frontend -> User: Display camera info
+
+User -> Frontend: Click event marker
+Frontend -> Frontend: Show event popup\nwith severity/description
+Frontend -> User: Display event details
+
+@enduml
+
+@startuml Event Management Flow
+!theme plain
+title Event Monitoring System - Event Management Flow
+
+actor "Security Operator" as User
+participant "React App" as Frontend
+participant "Backend API" as Backend
+database "MongoDB" as DB
+
+== View Events ==
+User -> Frontend: Navigate to Events page
+Frontend -> Backend: GET /api/events\n?status=&type=&severity=
+Backend -> DB: Query events with filters\ndb.events.find(filterQuery).sort({timestamp: -1})
+DB -> Backend: Event documents
+Backend -> Frontend: Paginated event list
+Frontend -> User: Display events table
+
+== Filter Events ==
+User -> Frontend: Apply filters\n(type, severity, status)
+Frontend -> Frontend: Update filter state
+Frontend -> Backend: GET /api/events\n?type=intrusion&severity=high
+Backend -> DB: Query with new filters
+DB -> Backend: Filtered events
+Backend -> Frontend: Updated event list
+Frontend -> User: Show filtered results
+
+== Resolve Event ==
+User -> Frontend: Click "Resolve" on event
+Frontend -> Backend: PATCH /api/events/{id}\n{resolved: true, resolvedBy: userId}
+Backend -> DB: Update event document\ndb.events.updateOne({_id}, {resolved: true})
+DB -> Backend: Updated document
+Backend -> Frontend: 200 OK\n{success: true, data: updatedEvent}
+Frontend -> Frontend: Update event in UI
+Frontend -> User: Show success message
+
+== View Event Details ==
+User -> Frontend: Click event row
+Frontend -> Frontend: Show event details modal
+Frontend -> User: Display full event info\n(location, camera, metadata)
+
+@enduml
+
+@startuml System Architecture Overview
+!theme plain
+title Event Monitoring System - Overall Architecture
+
+package "Frontend (React + TypeScript)" {
+    component [React Router] as Router
+    component [Material-UI Components] as UI
+    component [Leaflet Map] as Map
+    component [WebSocket Client] as WSClient
+    component [Data Service] as DataSvc
+}
+
+package "Backend (Node.js + Express)" {
+    component [Express API Server] as API
+    component [JWT Authentication] as Auth
+    component [WebSocket Server] as WSServer
+    component [Mongoose ODM] as ODM
+}
+
+package "AI Service (Python)" {
+    component [Video Processing] as VideoProc
+    component [ML Models] as ML
+    component [Event Detection] as EventDetect
+}
+
+database "MongoDB" {
+    collections users
+    collections cameras
+    collections events
+}
+
+cloud "External Services" {
+    component [IP Cameras] as Cameras
+    component [OpenStreetMap] as OSM
+}
+
+' Frontend connections
+Router --> UI
+UI --> Map
+UI --> DataSvc
+WSClient --> WSServer
+DataSvc --> API
+
+' Backend connections
+API --> Auth
+API --> ODM
+WSServer --> API
+ODM --> MongoDB
+
+' AI Service connections
+Cameras --> VideoProc
+VideoProc --> ML
+ML --> EventDetect
+EventDetect --> API
+
+' External connections
+Map --> OSM
+
+note as N1
+Data flows:
+1. User authentication via JWT
+2. Camera management (CRUD)
+3. Real-time event detection
+4. Live video streaming
+5. Interactive map with filters
+end note
+
+@enduml
+
+@startuml Database Schema Relationships
+!theme plain
+title Event Monitoring System - Database Schema
+
+entity "users" {
+    * _id : ObjectId
+    --
+    * username : String
+    * email : String
+    * password : String (hashed)
+    * role : String
+    * createdAt : Date
+    * updatedAt : Date
+}
+
+entity "cameras" {
+    * _id : ObjectId
+    --
+    * name : String
+    * description : String
+    * streamUrl : String
+    * status : String
+    * type : String
+    * location : Object
+    * settings : Object
+    * isActive : Boolean
+    * createdBy : ObjectId
+    * createdAt : Date
+    * updatedAt : Date
+}
+
+entity "events" {
+    * _id : ObjectId
+    --
+    * type : String
+    * severity : String
+    * location : Object
+    * camera : ObjectId
+    * timestamp : Date
+    * description : String
+    * resolved : Boolean
+    * resolvedBy : ObjectId
+    * metadata : Object
+    * createdAt : Date
+}
+
+users ||--o{ cameras : "createdBy"
+cameras ||--o{ events : "camera"
+users ||--o{ events : "resolvedBy"
+
+note as N2
+MongoDB Collections:
+- users: System operators/admins
+- cameras: IP camera configurations
+- events: AI-detected security events
+
+Relationships:
+- One user can create many cameras
+- One camera can generate many events
+- One user can resolve many events
+end note
+
 @enduml
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/non-functional/deployment.md b/event-monitoring-mvp-architecture/docs/non-functional/deployment.md
index c7a2a44..685d0b7 100644
--- a/event-monitoring-mvp-architecture/docs/non-functional/deployment.md
+++ b/event-monitoring-mvp-architecture/docs/non-functional/deployment.md
@@ -1,72 +1,72 @@
-# Deployment Strategy for Event Monitoring and Management Platform MVP
-
-## Overview
-
-This document outlines the deployment strategy for the MVP of the Event Monitoring and Management Platform. It includes details on environment setup, configuration, and considerations for future scalability and modifications.
-
-## Environment Setup
-
-1. **Infrastructure Requirements**
-   - Cloud Provider: Choose a cloud provider (e.g., AWS, Azure, Google Cloud) for hosting the application.
-   - Virtual Machines (VMs): Provision VMs for the backend API, AI service, and database.
-   - Load Balancer: Set up a load balancer to distribute incoming traffic across multiple instances of the backend API.
-
-2. **Containerization**
-   - Use Docker to containerize the application components (backend API, AI service).
-   - Create Docker images for each service and push them to a container registry (e.g., Docker Hub, AWS ECR).
-
-3. **Orchestration**
-   - Utilize Kubernetes or Docker Compose for orchestrating the deployment of containers.
-   - Define deployment configurations, services, and ingress rules for routing traffic.
-
-## Configuration
-
-1. **Environment Variables**
-   - Store sensitive information (e.g., database credentials, API keys) in environment variables.
-   - Use a configuration management tool (e.g., dotenv, AWS Secrets Manager) to manage environment variables securely.
-
-2. **Database Configuration**
-   - Set up MongoDB as a managed service (e.g., MongoDB Atlas) or deploy it on a VM.
-   - Configure connection strings and ensure proper access controls are in place.
-
-3. **Networking**
-   - Configure Virtual Private Cloud (VPC) settings to isolate application components.
-   - Set up security groups and firewall rules to restrict access to the database and services.
-
-## Deployment Process
-
-1. **Continuous Integration/Continuous Deployment (CI/CD)**
-   - Implement a CI/CD pipeline using tools like GitHub Actions, Jenkins, or GitLab CI.
-   - Automate the build, test, and deployment processes for the application.
-
-2. **Deployment Steps**
-   - Build Docker images for the backend API and AI service.
-   - Push images to the container registry.
-   - Deploy containers to the orchestration platform (Kubernetes/Docker Compose).
-   - Run database migrations and seed initial data if necessary.
-
-## Monitoring and Logging
-
-1. **Monitoring**
-   - Set up monitoring tools (e.g., Prometheus, Grafana) to track application performance and resource usage.
-   - Configure alerts for critical metrics (e.g., CPU usage, memory consumption).
-
-2. **Logging**
-   - Implement centralized logging using tools like ELK Stack (Elasticsearch, Logstash, Kibana) or a cloud-based logging service.
-   - Ensure logs are structured and include relevant information for troubleshooting.
-
-## Future Considerations
-
-1. **Scalability**
-   - Design the architecture to support horizontal scaling of services.
-   - Plan for the addition of more AI models and external integrations in future phases.
-
-2. **Backup and Recovery**
-   - Implement regular backup strategies for the database and application data.
-   - Define recovery procedures to restore services in case of failure.
-
-3. **Security Enhancements**
-   - Regularly review and update security measures as the application evolves.
-   - Consider implementing additional security features such as rate limiting and IP whitelisting.
-
+# Deployment Strategy for Event Monitoring and Management Platform MVP
+
+## Overview
+
+This document outlines the deployment strategy for the MVP of the Event Monitoring and Management Platform. It includes details on environment setup, configuration, and considerations for future scalability and modifications.
+
+## Environment Setup
+
+1. **Infrastructure Requirements**
+   - Cloud Provider: Choose a cloud provider (e.g., AWS, Azure, Google Cloud) for hosting the application.
+   - Virtual Machines (VMs): Provision VMs for the backend API, AI service, and database.
+   - Load Balancer: Set up a load balancer to distribute incoming traffic across multiple instances of the backend API.
+
+2. **Containerization**
+   - Use Docker to containerize the application components (backend API, AI service).
+   - Create Docker images for each service and push them to a container registry (e.g., Docker Hub, AWS ECR).
+
+3. **Orchestration**
+   - Utilize Kubernetes or Docker Compose for orchestrating the deployment of containers.
+   - Define deployment configurations, services, and ingress rules for routing traffic.
+
+## Configuration
+
+1. **Environment Variables**
+   - Store sensitive information (e.g., database credentials, API keys) in environment variables.
+   - Use a configuration management tool (e.g., dotenv, AWS Secrets Manager) to manage environment variables securely.
+
+2. **Database Configuration**
+   - Set up MongoDB as a managed service (e.g., MongoDB Atlas) or deploy it on a VM.
+   - Configure connection strings and ensure proper access controls are in place.
+
+3. **Networking**
+   - Configure Virtual Private Cloud (VPC) settings to isolate application components.
+   - Set up security groups and firewall rules to restrict access to the database and services.
+
+## Deployment Process
+
+1. **Continuous Integration/Continuous Deployment (CI/CD)**
+   - Implement a CI/CD pipeline using tools like GitHub Actions, Jenkins, or GitLab CI.
+   - Automate the build, test, and deployment processes for the application.
+
+2. **Deployment Steps**
+   - Build Docker images for the backend API and AI service.
+   - Push images to the container registry.
+   - Deploy containers to the orchestration platform (Kubernetes/Docker Compose).
+   - Run database migrations and seed initial data if necessary.
+
+## Monitoring and Logging
+
+1. **Monitoring**
+   - Set up monitoring tools (e.g., Prometheus, Grafana) to track application performance and resource usage.
+   - Configure alerts for critical metrics (e.g., CPU usage, memory consumption).
+
+2. **Logging**
+   - Implement centralized logging using tools like ELK Stack (Elasticsearch, Logstash, Kibana) or a cloud-based logging service.
+   - Ensure logs are structured and include relevant information for troubleshooting.
+
+## Future Considerations
+
+1. **Scalability**
+   - Design the architecture to support horizontal scaling of services.
+   - Plan for the addition of more AI models and external integrations in future phases.
+
+2. **Backup and Recovery**
+   - Implement regular backup strategies for the database and application data.
+   - Define recovery procedures to restore services in case of failure.
+
+3. **Security Enhancements**
+   - Regularly review and update security measures as the application evolves.
+   - Consider implementing additional security features such as rate limiting and IP whitelisting.
+
 By following this deployment strategy, the Event Monitoring and Management Platform MVP will be set up for success, ensuring a robust foundation for future enhancements and scalability.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/non-functional/security.md b/event-monitoring-mvp-architecture/docs/non-functional/security.md
index 858345a..787fb66 100644
--- a/event-monitoring-mvp-architecture/docs/non-functional/security.md
+++ b/event-monitoring-mvp-architecture/docs/non-functional/security.md
@@ -1,37 +1,37 @@
-# Security Considerations for the Event Monitoring and Management Platform
-
-## 1. Authentication
-
-- Implement JWT (JSON Web Tokens) for user authentication.
-- Ensure secure password storage using hashing algorithms (e.g., bcrypt).
-- Enforce strong password policies (minimum length, complexity requirements).
-- Implement multi-factor authentication (MFA) for added security.
-
-## 2. Authorization
-
-- Utilize Role-Based Access Control (RBAC) to manage user permissions.
-- Define user roles (e.g., admin, operator) with specific access rights.
-- Ensure that sensitive endpoints are protected and accessible only to authorized users.
-
-## 3. Data Protection
-
-- Use HTTPS for all communications between the client and server to encrypt data in transit.
-- Implement data encryption at rest for sensitive information stored in the database.
-- Regularly audit and monitor access logs for suspicious activities.
-
-## 4. API Security
-
-- Validate and sanitize all incoming data to prevent injection attacks (e.g., SQL injection, XSS).
-- Implement rate limiting on API endpoints to mitigate DDoS attacks.
-- Use API keys or tokens for external service integrations to ensure secure access.
-
-## 5. Security Best Practices
-
-- Regularly update dependencies and libraries to patch known vulnerabilities.
-- Conduct security assessments and penetration testing to identify potential weaknesses.
-- Educate team members on security best practices and the importance of maintaining a secure environment.
-
-## 6. Compliance
-
-- Ensure compliance with relevant regulations (e.g., GDPR, CCPA) regarding data protection and user privacy.
+# Security Considerations for the Event Monitoring and Management Platform
+
+## 1. Authentication
+
+- Implement JWT (JSON Web Tokens) for user authentication.
+- Ensure secure password storage using hashing algorithms (e.g., bcrypt).
+- Enforce strong password policies (minimum length, complexity requirements).
+- Implement multi-factor authentication (MFA) for added security.
+
+## 2. Authorization
+
+- Utilize Role-Based Access Control (RBAC) to manage user permissions.
+- Define user roles (e.g., admin, operator) with specific access rights.
+- Ensure that sensitive endpoints are protected and accessible only to authorized users.
+
+## 3. Data Protection
+
+- Use HTTPS for all communications between the client and server to encrypt data in transit.
+- Implement data encryption at rest for sensitive information stored in the database.
+- Regularly audit and monitor access logs for suspicious activities.
+
+## 4. API Security
+
+- Validate and sanitize all incoming data to prevent injection attacks (e.g., SQL injection, XSS).
+- Implement rate limiting on API endpoints to mitigate DDoS attacks.
+- Use API keys or tokens for external service integrations to ensure secure access.
+
+## 5. Security Best Practices
+
+- Regularly update dependencies and libraries to patch known vulnerabilities.
+- Conduct security assessments and penetration testing to identify potential weaknesses.
+- Educate team members on security best practices and the importance of maintaining a secure environment.
+
+## 6. Compliance
+
+- Ensure compliance with relevant regulations (e.g., GDPR, CCPA) regarding data protection and user privacy.
 - Maintain documentation of security policies and procedures for auditing purposes.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/prompts/diagram_agent_prompt.md b/event-monitoring-mvp-architecture/docs/prompts/diagram_agent_prompt.md
index d411e41..f5a9161 100644
--- a/event-monitoring-mvp-architecture/docs/prompts/diagram_agent_prompt.md
+++ b/event-monitoring-mvp-architecture/docs/prompts/diagram_agent_prompt.md
@@ -1,280 +1,280 @@
-# diagram_agent_prompt.md
-
-Create a detailed system architecture diagram for the MVP "Event Monitoring and Management Platform" with live video, AI detection, map, and events. The tech stack is:
-
-* Frontend: React (Web)
-* Backend API: Node.js + Express
-* Database: MongoDB
-* AI Service: separate microservice (Python or similar) for video analytics
-* External systems: IP Cameras or VMS, Map Provider (e.g., Mapbox/Google Maps)
-
-The diagram should clearly show **components, data flows, and boundaries**.
-
-### 1. High-Level Layout
-
-Organize the diagram in layers:
-
-* **Top layer**: Users & client (Web browser)
-* **Middle layer**: Backend (Node/Express API) and AI Service
-* **Bottom layer**: Database (MongoDB), Video Source (Cameras / VMS), Map Provider
-
-Use grouping or boxes to show:
-
-* â€œClient / Frontendâ€
-* â€œBackend APIâ€
-* â€œAI & Video Analyticsâ€
-* â€œData Storageâ€
-* â€œExternal Servicesâ€
-
-### 2. Actors / Users
-
-Add a user actor:
-
-* **Security Operator / Control Room User**
-
-  * Interacts via the **Web Browser (React app)**
-  * Can:
-
-    * Log in
-    * Watch live video
-    * See events list
-    * See map with cameras & events
-
-### 3. Frontend (React Web App)
-
-Show a **React Web Application** box with internal logical modules (they can be sub-boxes, compartments, or just labels):
-
-1. **Auth Module**
-
-   * Login form
-   * Sends credentials to `/auth/login`
-   * Receives JWT token
-
-2. **Live Video View**
-
-   * Requests video stream URLs from backend
-   * Embeds video player (e.g., HLS/WebRTC/RTSP via gateway)
-   * Shows one or a few cameras
-
-3. **Events List / Events Panel**
-
-   * Calls backend endpoint `/events` to fetch event list
-   * Displays basic event details: time, camera, type
-
-4. **Map View Module**
-
-   * Loads map from Map Provider SDK (e.g., Mapbox/Google Maps)
-   * Requests camera locations from backend (`/cameras`)
-   * Requests active events from backend (`/events?status=active`)
-   * Shows camera markers and highlights cameras with events
-
-5. **Event Details View**
-
-   * On click of event: fetch `/events/{id}` for details
-   * Displays snapshot/image and metadata
-
-The React app communicates **only** with the Backend API (Node/Express), not directly with AI or DB.
-
-### 4. Backend API (Node.js + Express)
-
-Draw a **Backend API (Node + Express)** container that exposes REST endpoints.
-
-Inside it, show logical sub-components / services:
-
-1. **Auth Controller / Service**
-
-   * Endpoint: `POST /auth/login`
-   * Validates user credentials against `Users` collection in MongoDB
-   * Issues JWT tokens
-
-2. **Camera Service**
-
-   * Endpoint: `GET /cameras`
-   * Returns a list of cameras with:
-
-     * ID
-     * Name
-     * Location (GPS)
-     * Stream URL or reference ID for VMS
-
-3. **Event Service**
-
-   * Endpoints:
-
-     * `GET /events`
-     * `GET /events/{id}`
-   * Reads event records from MongoDB
-   * Filters by:
-
-     * time
-     * camera
-     * event type
-     * status (active / resolved)
-
-4. **Video Gateway / Stream Info Endpoint (MVP-simple)**
-
-   * Endpoint: `GET /cameras/{id}/stream`
-   * Returns a URL / token to access the live video stream (NOTE: actual streaming can be handled by a VMS or a media server, not implemented fully in MVP)
-
-5. **AI Integration Service**
-
-   * Receives detection results from AI Service via HTTP callback or message queue (for MVP, HTTP is enough)
-   * When AI sends a detection event:
-
-     * Validates data
-     * Creates a new Event document in MongoDB
-     * Optionally links to a snapshot image path
-
-6. **Map / Geolocation Service (simple)**
-
-   * Stores and serves static camera GPS coordinates
-   * No advanced GIS logic in MVP
-
-**Backend to Database Communication:**
-
-* The Backend API connects to **MongoDB** and works with these collections:
-
-  1. `users`
-
-     * username
-     * hashed_password
-     * role (admin/operator)
-
-  2. `cameras`
-
-     * camera_id
-     * name
-     * location (lat, lon)
-     * stream_url or VMS reference
-
-  3. `events`
-
-     * event_id
-     * timestamp
-     * camera_id
-     * event_type (e.g., person_detected, vehicle_detected)
-     * snapshot_url (optional)
-     * status (e.g., new, acknowledged, closed)
-
-### 5. AI & Video Analytics Service (Separate Microservice)
-
-Draw a separate box labeled **AI Analytics Service**.
-
-Responsibilities:
-
-* Receives **video frames or video stream reference** from Video Ingestion layer or VMS
-* Runs **ONE AI model in MVP** (e.g., object detection: people + vehicles)
-* For each detection:
-
-  * Builds a detection payload with:
-
-    * camera_id
-    * timestamp
-    * detection_type (person/vehicle)
-    * coordinates (optional)
-    * confidence score
-  * Sends HTTP POST to Backend API, e.g. `POST /internal/ai/events`
-
-The AI Service is **not** directly visible to frontend.
-
-Optionally, show:
-
-* A **â€œFrame Extractor / Video Ingestionâ€** small component that:
-
-  * Connects to the RTSP stream
-  * Samples frames (e.g., 1â€“5 FPS)
-  * Sends frames to the AI model
-
-### 6. Database Layer (MongoDB)
-
-Draw a **MongoDB** container with labeled collections:
-
-* `users`
-* `cameras`
-* `events`
-
-Show arrows:
-
-* From Backend API to MongoDB (CRUD operations)
-* AI Service never speaks directly to DB (only via Backend API)
-
-### 7. External Systems
-
-Add external systems as separate boxes:
-
-1. **IP Cameras / VMS**
-
-   * Output: Live video stream (RTSP / HLS / VMS proprietary)
-   * Connected to:
-
-     * Video Ingestion / AI Service (for analytics)
-     * Video gateway / streaming server (if applicable)
-
-2. **Map Provider**
-
-   * Example: Mapbox / Google Maps
-   * Provides:
-
-     * Map tiles
-     * Basemap
-   * Used directly by the **React Frontend** via SDK or JS API
-
-### 8. Data Flows (Label Arrows Clearly)
-
-Please draw and label arrows for these main flows:
-
-1. **User Login Flow**
-
-   * User â†’ React App â†’ Backend `/auth/login` â†’ MongoDB (validate user) â†’ React stores JWT
-
-2. **Live Video Flow (Simplified MVP)**
-
-   * Camera â†’ VMS/Stream Server â†’ React Video Player (using URL fetched from Backend)
-   * React requests `/cameras/{id}/stream` to get stream info
-
-3. **AI Detection Flow**
-
-   * Camera â†’ Video Ingestion/AI Service â†’ AI Model â†’ Detection Event
-   * AI Service â†’ `POST /internal/ai/events` on Backend API
-   * Backend API â†’ MongoDB (`events` collection)
-
-4. **Event List Flow**
-
-   * React App â†’ `GET /events` (Backend API) â†’ MongoDB â†’ React shows table/list
-
-5. **Map View Flow**
-
-   * React Map Module â†’ `GET /cameras` (for camera positions)
-   * React Map Module â†’ `GET /events?status=active` (for active events)
-   * Map Provider â†’ delivers tiles/background map
-   * React places markers and highlights cameras with events
-
-### 9. Non-Functional Notes (Short Annotations)
-
-Add text annotations or notes mentioning:
-
-* MVP focus:
-
-  * Small number of cameras (e.g., 1â€“5)
-  * One AI model only
-  * Simple RBAC (admin/operator)
-  * No SMS/email alerts yet
-  * No geofencing in MVP
-* All communication between frontend and backend over HTTPS
-* Backendâ€“AI communication using internal HTTP calls (no heavy message bus in MVP)
-
-### 10. Diagram Style
-
-Use any style you like (C4 Container diagram, layered boxes, or classical system architecture), but:
-
-* Make boundaries clear:
-
-  * Frontend
-  * Backend
-  * AI Service
-  * Database
-  * External Systems
-* Label all arrows with:
-
-  * Protocol (HTTP/HTTPS, RTSP)
+# diagram_agent_prompt.md
+
+Create a detailed system architecture diagram for the MVP "Event Monitoring and Management Platform" with live video, AI detection, map, and events. The tech stack is:
+
+* Frontend: React (Web)
+* Backend API: Node.js + Express
+* Database: MongoDB
+* AI Service: separate microservice (Python or similar) for video analytics
+* External systems: IP Cameras or VMS, Map Provider (e.g., Mapbox/Google Maps)
+
+The diagram should clearly show **components, data flows, and boundaries**.
+
+### 1. High-Level Layout
+
+Organize the diagram in layers:
+
+* **Top layer**: Users & client (Web browser)
+* **Middle layer**: Backend (Node/Express API) and AI Service
+* **Bottom layer**: Database (MongoDB), Video Source (Cameras / VMS), Map Provider
+
+Use grouping or boxes to show:
+
+* â€œClient / Frontendâ€
+* â€œBackend APIâ€
+* â€œAI & Video Analyticsâ€
+* â€œData Storageâ€
+* â€œExternal Servicesâ€
+
+### 2. Actors / Users
+
+Add a user actor:
+
+* **Security Operator / Control Room User**
+
+  * Interacts via the **Web Browser (React app)**
+  * Can:
+
+    * Log in
+    * Watch live video
+    * See events list
+    * See map with cameras & events
+
+### 3. Frontend (React Web App)
+
+Show a **React Web Application** box with internal logical modules (they can be sub-boxes, compartments, or just labels):
+
+1. **Auth Module**
+
+   * Login form
+   * Sends credentials to `/auth/login`
+   * Receives JWT token
+
+2. **Live Video View**
+
+   * Requests video stream URLs from backend
+   * Embeds video player (e.g., HLS/WebRTC/RTSP via gateway)
+   * Shows one or a few cameras
+
+3. **Events List / Events Panel**
+
+   * Calls backend endpoint `/events` to fetch event list
+   * Displays basic event details: time, camera, type
+
+4. **Map View Module**
+
+   * Loads map from Map Provider SDK (e.g., Mapbox/Google Maps)
+   * Requests camera locations from backend (`/cameras`)
+   * Requests active events from backend (`/events?status=active`)
+   * Shows camera markers and highlights cameras with events
+
+5. **Event Details View**
+
+   * On click of event: fetch `/events/{id}` for details
+   * Displays snapshot/image and metadata
+
+The React app communicates **only** with the Backend API (Node/Express), not directly with AI or DB.
+
+### 4. Backend API (Node.js + Express)
+
+Draw a **Backend API (Node + Express)** container that exposes REST endpoints.
+
+Inside it, show logical sub-components / services:
+
+1. **Auth Controller / Service**
+
+   * Endpoint: `POST /auth/login`
+   * Validates user credentials against `Users` collection in MongoDB
+   * Issues JWT tokens
+
+2. **Camera Service**
+
+   * Endpoint: `GET /cameras`
+   * Returns a list of cameras with:
+
+     * ID
+     * Name
+     * Location (GPS)
+     * Stream URL or reference ID for VMS
+
+3. **Event Service**
+
+   * Endpoints:
+
+     * `GET /events`
+     * `GET /events/{id}`
+   * Reads event records from MongoDB
+   * Filters by:
+
+     * time
+     * camera
+     * event type
+     * status (active / resolved)
+
+4. **Video Gateway / Stream Info Endpoint (MVP-simple)**
+
+   * Endpoint: `GET /cameras/{id}/stream`
+   * Returns a URL / token to access the live video stream (NOTE: actual streaming can be handled by a VMS or a media server, not implemented fully in MVP)
+
+5. **AI Integration Service**
+
+   * Receives detection results from AI Service via HTTP callback or message queue (for MVP, HTTP is enough)
+   * When AI sends a detection event:
+
+     * Validates data
+     * Creates a new Event document in MongoDB
+     * Optionally links to a snapshot image path
+
+6. **Map / Geolocation Service (simple)**
+
+   * Stores and serves static camera GPS coordinates
+   * No advanced GIS logic in MVP
+
+**Backend to Database Communication:**
+
+* The Backend API connects to **MongoDB** and works with these collections:
+
+  1. `users`
+
+     * username
+     * hashed_password
+     * role (admin/operator)
+
+  2. `cameras`
+
+     * camera_id
+     * name
+     * location (lat, lon)
+     * stream_url or VMS reference
+
+  3. `events`
+
+     * event_id
+     * timestamp
+     * camera_id
+     * event_type (e.g., person_detected, vehicle_detected)
+     * snapshot_url (optional)
+     * status (e.g., new, acknowledged, closed)
+
+### 5. AI & Video Analytics Service (Separate Microservice)
+
+Draw a separate box labeled **AI Analytics Service**.
+
+Responsibilities:
+
+* Receives **video frames or video stream reference** from Video Ingestion layer or VMS
+* Runs **ONE AI model in MVP** (e.g., object detection: people + vehicles)
+* For each detection:
+
+  * Builds a detection payload with:
+
+    * camera_id
+    * timestamp
+    * detection_type (person/vehicle)
+    * coordinates (optional)
+    * confidence score
+  * Sends HTTP POST to Backend API, e.g. `POST /internal/ai/events`
+
+The AI Service is **not** directly visible to frontend.
+
+Optionally, show:
+
+* A **â€œFrame Extractor / Video Ingestionâ€** small component that:
+
+  * Connects to the RTSP stream
+  * Samples frames (e.g., 1â€“5 FPS)
+  * Sends frames to the AI model
+
+### 6. Database Layer (MongoDB)
+
+Draw a **MongoDB** container with labeled collections:
+
+* `users`
+* `cameras`
+* `events`
+
+Show arrows:
+
+* From Backend API to MongoDB (CRUD operations)
+* AI Service never speaks directly to DB (only via Backend API)
+
+### 7. External Systems
+
+Add external systems as separate boxes:
+
+1. **IP Cameras / VMS**
+
+   * Output: Live video stream (RTSP / HLS / VMS proprietary)
+   * Connected to:
+
+     * Video Ingestion / AI Service (for analytics)
+     * Video gateway / streaming server (if applicable)
+
+2. **Map Provider**
+
+   * Example: Mapbox / Google Maps
+   * Provides:
+
+     * Map tiles
+     * Basemap
+   * Used directly by the **React Frontend** via SDK or JS API
+
+### 8. Data Flows (Label Arrows Clearly)
+
+Please draw and label arrows for these main flows:
+
+1. **User Login Flow**
+
+   * User â†’ React App â†’ Backend `/auth/login` â†’ MongoDB (validate user) â†’ React stores JWT
+
+2. **Live Video Flow (Simplified MVP)**
+
+   * Camera â†’ VMS/Stream Server â†’ React Video Player (using URL fetched from Backend)
+   * React requests `/cameras/{id}/stream` to get stream info
+
+3. **AI Detection Flow**
+
+   * Camera â†’ Video Ingestion/AI Service â†’ AI Model â†’ Detection Event
+   * AI Service â†’ `POST /internal/ai/events` on Backend API
+   * Backend API â†’ MongoDB (`events` collection)
+
+4. **Event List Flow**
+
+   * React App â†’ `GET /events` (Backend API) â†’ MongoDB â†’ React shows table/list
+
+5. **Map View Flow**
+
+   * React Map Module â†’ `GET /cameras` (for camera positions)
+   * React Map Module â†’ `GET /events?status=active` (for active events)
+   * Map Provider â†’ delivers tiles/background map
+   * React places markers and highlights cameras with events
+
+### 9. Non-Functional Notes (Short Annotations)
+
+Add text annotations or notes mentioning:
+
+* MVP focus:
+
+  * Small number of cameras (e.g., 1â€“5)
+  * One AI model only
+  * Simple RBAC (admin/operator)
+  * No SMS/email alerts yet
+  * No geofencing in MVP
+* All communication between frontend and backend over HTTPS
+* Backendâ€“AI communication using internal HTTP calls (no heavy message bus in MVP)
+
+### 10. Diagram Style
+
+Use any style you like (C4 Container diagram, layered boxes, or classical system architecture), but:
+
+* Make boundaries clear:
+
+  * Frontend
+  * Backend
+  * AI Service
+  * Database
+  * External Systems
+* Label all arrows with:
+
+  * Protocol (HTTP/HTTPS, RTSP)
   * Main payload type (video stream, JSON, etc.)
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/prompts/mvp_architecture_initiation.md b/event-monitoring-mvp-architecture/docs/prompts/mvp_architecture_initiation.md
index 81f2d0b..20f4371 100644
--- a/event-monitoring-mvp-architecture/docs/prompts/mvp_architecture_initiation.md
+++ b/event-monitoring-mvp-architecture/docs/prompts/mvp_architecture_initiation.md
@@ -1,79 +1,79 @@
-# mvp_architecture_initiation.md
-
-# MVP Architecture Initiation for Event Monitoring and Management Platform
-
-## Introduction
-
-This document serves as a detailed prompt to initiate the development of the basic MVP architecture for the Event Monitoring and Management Platform. The architecture is designed to be modular, ensuring easy expansion and modification in the future.
-
-## Key Components
-
-1. **Frontend**
-   - **Technology**: React
-   - **Responsibilities**:
-     - User authentication and session management
-     - Display live video feeds from cameras
-     - Show a list of events with relevant details
-     - Provide a map view with camera locations and event highlights
-
-2. **Backend API**
-   - **Technology**: Node.js + Express
-   - **Responsibilities**:
-     - Handle user authentication and authorization
-     - Serve endpoints for camera data and event management
-     - Integrate with the AI service for event detection
-     - Manage data storage and retrieval from the database
-
-3. **AI Service**
-   - **Technology**: Python (or similar)
-   - **Responsibilities**:
-     - Process video streams to detect events (e.g., people, vehicles)
-     - Send detection results back to the backend API for event creation
-
-4. **Database**
-   - **Technology**: MongoDB
-   - **Responsibilities**:
-     - Store user data, camera configurations, and event records
-     - Support CRUD operations for data management
-
-5. **External Systems**
-   - **IP Cameras / VMS**: Provide live video streams
-   - **Map Provider**: Supply map tiles and geolocation services
-
-## Data Flows
-
-1. **User Authentication Flow**
-   - User submits credentials via the frontend
-   - Frontend sends a request to the backend API for authentication
-   - Backend validates credentials and returns a JWT token
-
-2. **Live Video Stream Flow**
-   - Frontend requests video stream URLs from the backend API
-   - Backend retrieves stream information and responds with URLs
-   - Frontend displays the live video using the provided URLs
-
-3. **Event Detection Flow**
-   - AI service processes video frames and detects events
-   - AI service sends detection results to the backend API
-   - Backend creates new event records in the database based on AI results
-
-4. **Event Management Flow**
-   - Frontend requests the list of events from the backend API
-   - Backend retrieves events from the database and sends them to the frontend
-   - Frontend displays the events in a user-friendly format
-
-5. **Map Integration Flow**
-   - Frontend requests camera locations and active events from the backend API
-   - Backend responds with the necessary data for map visualization
-   - Frontend uses the map provider's SDK to display the map with camera markers and event highlights
-
-## System Requirements
-
-- **Scalability**: The architecture should support the addition of more cameras and AI models in future phases.
-- **Security**: Implement robust authentication and authorization mechanisms to protect user data and system integrity.
-- **Performance**: Ensure low latency in video streaming and event detection to provide real-time monitoring capabilities.
-- **Maintainability**: Structure the codebase and architecture to facilitate easy updates and modifications as new requirements emerge.
-
-## Conclusion
-
+# mvp_architecture_initiation.md
+
+# MVP Architecture Initiation for Event Monitoring and Management Platform
+
+## Introduction
+
+This document serves as a detailed prompt to initiate the development of the basic MVP architecture for the Event Monitoring and Management Platform. The architecture is designed to be modular, ensuring easy expansion and modification in the future.
+
+## Key Components
+
+1. **Frontend**
+   - **Technology**: React
+   - **Responsibilities**:
+     - User authentication and session management
+     - Display live video feeds from cameras
+     - Show a list of events with relevant details
+     - Provide a map view with camera locations and event highlights
+
+2. **Backend API**
+   - **Technology**: Node.js + Express
+   - **Responsibilities**:
+     - Handle user authentication and authorization
+     - Serve endpoints for camera data and event management
+     - Integrate with the AI service for event detection
+     - Manage data storage and retrieval from the database
+
+3. **AI Service**
+   - **Technology**: Python (or similar)
+   - **Responsibilities**:
+     - Process video streams to detect events (e.g., people, vehicles)
+     - Send detection results back to the backend API for event creation
+
+4. **Database**
+   - **Technology**: MongoDB
+   - **Responsibilities**:
+     - Store user data, camera configurations, and event records
+     - Support CRUD operations for data management
+
+5. **External Systems**
+   - **IP Cameras / VMS**: Provide live video streams
+   - **Map Provider**: Supply map tiles and geolocation services
+
+## Data Flows
+
+1. **User Authentication Flow**
+   - User submits credentials via the frontend
+   - Frontend sends a request to the backend API for authentication
+   - Backend validates credentials and returns a JWT token
+
+2. **Live Video Stream Flow**
+   - Frontend requests video stream URLs from the backend API
+   - Backend retrieves stream information and responds with URLs
+   - Frontend displays the live video using the provided URLs
+
+3. **Event Detection Flow**
+   - AI service processes video frames and detects events
+   - AI service sends detection results to the backend API
+   - Backend creates new event records in the database based on AI results
+
+4. **Event Management Flow**
+   - Frontend requests the list of events from the backend API
+   - Backend retrieves events from the database and sends them to the frontend
+   - Frontend displays the events in a user-friendly format
+
+5. **Map Integration Flow**
+   - Frontend requests camera locations and active events from the backend API
+   - Backend responds with the necessary data for map visualization
+   - Frontend uses the map provider's SDK to display the map with camera markers and event highlights
+
+## System Requirements
+
+- **Scalability**: The architecture should support the addition of more cameras and AI models in future phases.
+- **Security**: Implement robust authentication and authorization mechanisms to protect user data and system integrity.
+- **Performance**: Ensure low latency in video streaming and event detection to provide real-time monitoring capabilities.
+- **Maintainability**: Structure the codebase and architecture to facilitate easy updates and modifications as new requirements emerge.
+
+## Conclusion
+
 This prompt outlines the foundational architecture for the MVP of the Event Monitoring and Management Platform. By adhering to this structure, the development team can ensure a scalable, secure, and maintainable system that meets the initial project goals while allowing for future enhancements.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/prompts/requirements_refinement_prompt.md b/event-monitoring-mvp-architecture/docs/prompts/requirements_refinement_prompt.md
index c3c8cf4..0a91590 100644
--- a/event-monitoring-mvp-architecture/docs/prompts/requirements_refinement_prompt.md
+++ b/event-monitoring-mvp-architecture/docs/prompts/requirements_refinement_prompt.md
@@ -1,61 +1,61 @@
-# requirements_refinement_prompt.md
-
-This document serves as a prompt for refining the project requirements for the Event Monitoring and Management Platform. It aims to ensure clarity, completeness, and alignment among stakeholders before development begins.
-
----
-
-## Requirements Refinement Prompt
-
-### Objective
-To gather and refine the requirements for the Event Monitoring and Management Platform MVP, ensuring that all stakeholders have a clear understanding of the project scope, functionalities, and constraints.
-
-### Key Areas for Discussion
-
-1. **User Roles and Permissions**
-   - Define the different user roles (e.g., Control Room Operator, Security Manager, System Admin).
-   - Specify the permissions associated with each role.
-
-2. **Core Functionalities**
-   - Confirm the essential features to be included in the MVP:
-     - Live video streaming from cameras.
-     - AI-based event detection (specify which model to prioritize).
-     - Event management capabilities (creation, classification, tracking).
-     - Map visualization of camera locations and events.
-     - Basic authentication and user management.
-
-3. **Integration Requirements**
-   - Identify external systems that need to be integrated (e.g., VMS, GIS providers).
-   - Discuss the data exchange formats and protocols for these integrations.
-
-4. **Data Management**
-   - Clarify the data models for users, cameras, and events.
-   - Discuss data retention policies and storage solutions.
-
-5. **Performance and Scalability**
-   - Establish performance benchmarks for the MVP (e.g., number of simultaneous streams).
-   - Outline scalability considerations for future phases.
-
-6. **Security Considerations**
-   - Define security requirements, including authentication methods and data protection measures.
-   - Discuss compliance with relevant regulations (e.g., GDPR).
-
-7. **Non-Functional Requirements**
-   - Identify non-functional requirements such as usability, reliability, and maintainability.
-
-8. **Reporting and Analytics**
-   - Discuss the reporting capabilities needed for management and operational insights.
-   - Define the metrics and KPIs to be tracked.
-
-### Questions for Stakeholders
-- What are the critical success factors for the MVP?
-- Are there any specific user scenarios or use cases that must be addressed?
-- What are the potential risks or challenges that could impact the project?
-
-### Next Steps
-- Schedule a meeting with all stakeholders to review and discuss the above areas.
-- Document any changes or additions to the requirements based on stakeholder feedback.
-- Finalize the requirements document to guide the development process.
-
---- 
-
+# requirements_refinement_prompt.md
+
+This document serves as a prompt for refining the project requirements for the Event Monitoring and Management Platform. It aims to ensure clarity, completeness, and alignment among stakeholders before development begins.
+
+---
+
+## Requirements Refinement Prompt
+
+### Objective
+To gather and refine the requirements for the Event Monitoring and Management Platform MVP, ensuring that all stakeholders have a clear understanding of the project scope, functionalities, and constraints.
+
+### Key Areas for Discussion
+
+1. **User Roles and Permissions**
+   - Define the different user roles (e.g., Control Room Operator, Security Manager, System Admin).
+   - Specify the permissions associated with each role.
+
+2. **Core Functionalities**
+   - Confirm the essential features to be included in the MVP:
+     - Live video streaming from cameras.
+     - AI-based event detection (specify which model to prioritize).
+     - Event management capabilities (creation, classification, tracking).
+     - Map visualization of camera locations and events.
+     - Basic authentication and user management.
+
+3. **Integration Requirements**
+   - Identify external systems that need to be integrated (e.g., VMS, GIS providers).
+   - Discuss the data exchange formats and protocols for these integrations.
+
+4. **Data Management**
+   - Clarify the data models for users, cameras, and events.
+   - Discuss data retention policies and storage solutions.
+
+5. **Performance and Scalability**
+   - Establish performance benchmarks for the MVP (e.g., number of simultaneous streams).
+   - Outline scalability considerations for future phases.
+
+6. **Security Considerations**
+   - Define security requirements, including authentication methods and data protection measures.
+   - Discuss compliance with relevant regulations (e.g., GDPR).
+
+7. **Non-Functional Requirements**
+   - Identify non-functional requirements such as usability, reliability, and maintainability.
+
+8. **Reporting and Analytics**
+   - Discuss the reporting capabilities needed for management and operational insights.
+   - Define the metrics and KPIs to be tracked.
+
+### Questions for Stakeholders
+- What are the critical success factors for the MVP?
+- Are there any specific user scenarios or use cases that must be addressed?
+- What are the potential risks or challenges that could impact the project?
+
+### Next Steps
+- Schedule a meeting with all stakeholders to review and discuss the above areas.
+- Document any changes or additions to the requirements based on stakeholder feedback.
+- Finalize the requirements document to guide the development process.
+
+--- 
+
 This prompt is designed to facilitate a comprehensive discussion around the project requirements, ensuring that all aspects are considered and agreed upon before moving forward with development.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/roadmap/mvp_scope.md b/event-monitoring-mvp-architecture/docs/roadmap/mvp_scope.md
index 937eb7d..9fa9122 100644
--- a/event-monitoring-mvp-architecture/docs/roadmap/mvp_scope.md
+++ b/event-monitoring-mvp-architecture/docs/roadmap/mvp_scope.md
@@ -1,45 +1,45 @@
-# MVP Scope for Event Monitoring and Management Platform
-
-## Overview
-
-The MVP (Minimum Viable Product) for the Event Monitoring and Management Platform is designed to provide essential functionalities that enable real-time monitoring and management of events through video analytics. This document outlines the key features and functionalities included in the initial release, ensuring a solid foundation for future expansion and modification.
-
-## Key Features
-
-1. **Live Video Streaming**
-   - Support for connecting to a limited number of IP cameras (1-5) for live video feeds.
-   - Ability to view live video streams in the web application.
-
-2. **AI Detection**
-   - Implementation of a single AI model focused on either people detection or vehicle detection.
-   - Automatic event creation based on AI detection results, including timestamp, camera ID, and event type.
-
-3. **Event Management**
-   - Basic event management capabilities, allowing users to view a list of detected events.
-   - Event details including time, camera, and type displayed in the user interface.
-
-4. **Map Integration**
-   - Integration with a simple map provider (e.g., Google Maps or Mapbox) to visualize camera locations.
-   - Highlighting of cameras with active events on the map.
-
-5. **User Authentication**
-   - Basic authentication mechanism for users to log in to the system.
-   - Role-based access control distinguishing between admin and operator roles.
-
-6. **Dashboard Interface**
-   - A user-friendly dashboard that consolidates live video, event lists, and map views.
-   - Simple navigation structure to access different functionalities.
-
-## Future Expansion
-
-The MVP is structured to allow for easy expansion and modification in future phases. Potential enhancements include:
-
-- Integration of multiple AI models for advanced detection capabilities (e.g., license plate recognition, face recognition).
-- Enhanced event lifecycle management with features for assignment, collaboration, and escalation.
-- Advanced GIS functionalities, including geofencing and historical tracking.
-- Implementation of alert channels (SMS, email, push notifications) for real-time notifications.
-- Comprehensive reporting and analytics features to provide insights into event trends and system performance.
-
-## Conclusion
-
+# MVP Scope for Event Monitoring and Management Platform
+
+## Overview
+
+The MVP (Minimum Viable Product) for the Event Monitoring and Management Platform is designed to provide essential functionalities that enable real-time monitoring and management of events through video analytics. This document outlines the key features and functionalities included in the initial release, ensuring a solid foundation for future expansion and modification.
+
+## Key Features
+
+1. **Live Video Streaming**
+   - Support for connecting to a limited number of IP cameras (1-5) for live video feeds.
+   - Ability to view live video streams in the web application.
+
+2. **AI Detection**
+   - Implementation of a single AI model focused on either people detection or vehicle detection.
+   - Automatic event creation based on AI detection results, including timestamp, camera ID, and event type.
+
+3. **Event Management**
+   - Basic event management capabilities, allowing users to view a list of detected events.
+   - Event details including time, camera, and type displayed in the user interface.
+
+4. **Map Integration**
+   - Integration with a simple map provider (e.g., Google Maps or Mapbox) to visualize camera locations.
+   - Highlighting of cameras with active events on the map.
+
+5. **User Authentication**
+   - Basic authentication mechanism for users to log in to the system.
+   - Role-based access control distinguishing between admin and operator roles.
+
+6. **Dashboard Interface**
+   - A user-friendly dashboard that consolidates live video, event lists, and map views.
+   - Simple navigation structure to access different functionalities.
+
+## Future Expansion
+
+The MVP is structured to allow for easy expansion and modification in future phases. Potential enhancements include:
+
+- Integration of multiple AI models for advanced detection capabilities (e.g., license plate recognition, face recognition).
+- Enhanced event lifecycle management with features for assignment, collaboration, and escalation.
+- Advanced GIS functionalities, including geofencing and historical tracking.
+- Implementation of alert channels (SMS, email, push notifications) for real-time notifications.
+- Comprehensive reporting and analytics features to provide insights into event trends and system performance.
+
+## Conclusion
+
 The MVP scope outlined in this document serves as a foundational blueprint for the development of the Event Monitoring and Management Platform. By focusing on essential features and ensuring a modular architecture, the project is positioned for successful implementation and future growth.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/docs/roadmap/phase2_plus.md b/event-monitoring-mvp-architecture/docs/roadmap/phase2_plus.md
index cd385a9..e51cdca 100644
--- a/event-monitoring-mvp-architecture/docs/roadmap/phase2_plus.md
+++ b/event-monitoring-mvp-architecture/docs/roadmap/phase2_plus.md
@@ -1,69 +1,69 @@
-# Future Phases Roadmap for Event Monitoring and Management Platform
-
-## Phase 2: Enhancements and Additional Features
-
-### 1. Multiple AI Models
-- **Objective**: Expand the AI capabilities by integrating additional models.
-- **Models to Consider**:
-  - License Plate Recognition (LPR)
-  - Facial Recognition
-  - Behavioral Anomaly Detection
-  - Abandoned Object Detection
-
-### 2. Advanced Event Lifecycle Management
-- **Objective**: Improve the event management system to support complex workflows.
-- **Features**:
-  - Event assignment to specific users or teams
-  - Collaboration tools for operators to discuss events
-  - Escalation procedures for high-severity events
-
-### 3. Role-Based Access Control (RBAC) and Single Sign-On (SSO)
-- **Objective**: Enhance security and user management.
-- **Features**:
-  - Implement RBAC to define user roles and permissions
-  - Integrate SSO for seamless user authentication across platforms
-
-### 4. Enhanced GIS and Geofencing Capabilities
-- **Objective**: Improve geographical data handling and event monitoring.
-- **Features**:
-  - Advanced geofencing capabilities to trigger alerts based on location
-  - Historical tracking of moving objects (vehicles, persons)
-  - Integration with additional GIS data sources
-
-### 5. Alert Channels and Notifications
-- **Objective**: Implement a robust notification system for real-time alerts.
-- **Features**:
-  - Support for multiple alert channels (SMS, email, push notifications)
-  - Customizable alert settings based on user preferences
-  - Integration with emergency response systems
-
-### 6. Reporting and Analytics Enhancements
-- **Objective**: Provide deeper insights into event data and trends.
-- **Features**:
-  - Advanced reporting capabilities with customizable metrics
-  - Trend analysis tools to identify patterns over time
-  - Export options for reports in various formats (CSV, PDF)
-
-### 7. Performance and Scalability Improvements
-- **Objective**: Ensure the system can handle increased load and data volume.
-- **Strategies**:
-  - Implement distributed processing for AI tasks
-  - Optimize database queries and indexing for faster access
-  - Load balancing strategies for high availability
-
-### 8. User Interface Enhancements
-- **Objective**: Improve user experience and interface design.
-- **Features**:
-  - Responsive design improvements for mobile and tablet users
-  - Dark mode and customizable themes
-  - User feedback mechanisms to gather insights for further improvements
-
-### 9. Compliance and Regulatory Considerations
-- **Objective**: Ensure the platform adheres to relevant regulations.
-- **Considerations**:
-  - GDPR compliance for data protection and privacy
-  - Local regulations regarding surveillance and data storage
-  - Regular audits and assessments to maintain compliance
-
-### Conclusion
+# Future Phases Roadmap for Event Monitoring and Management Platform
+
+## Phase 2: Enhancements and Additional Features
+
+### 1. Multiple AI Models
+- **Objective**: Expand the AI capabilities by integrating additional models.
+- **Models to Consider**:
+  - License Plate Recognition (LPR)
+  - Facial Recognition
+  - Behavioral Anomaly Detection
+  - Abandoned Object Detection
+
+### 2. Advanced Event Lifecycle Management
+- **Objective**: Improve the event management system to support complex workflows.
+- **Features**:
+  - Event assignment to specific users or teams
+  - Collaboration tools for operators to discuss events
+  - Escalation procedures for high-severity events
+
+### 3. Role-Based Access Control (RBAC) and Single Sign-On (SSO)
+- **Objective**: Enhance security and user management.
+- **Features**:
+  - Implement RBAC to define user roles and permissions
+  - Integrate SSO for seamless user authentication across platforms
+
+### 4. Enhanced GIS and Geofencing Capabilities
+- **Objective**: Improve geographical data handling and event monitoring.
+- **Features**:
+  - Advanced geofencing capabilities to trigger alerts based on location
+  - Historical tracking of moving objects (vehicles, persons)
+  - Integration with additional GIS data sources
+
+### 5. Alert Channels and Notifications
+- **Objective**: Implement a robust notification system for real-time alerts.
+- **Features**:
+  - Support for multiple alert channels (SMS, email, push notifications)
+  - Customizable alert settings based on user preferences
+  - Integration with emergency response systems
+
+### 6. Reporting and Analytics Enhancements
+- **Objective**: Provide deeper insights into event data and trends.
+- **Features**:
+  - Advanced reporting capabilities with customizable metrics
+  - Trend analysis tools to identify patterns over time
+  - Export options for reports in various formats (CSV, PDF)
+
+### 7. Performance and Scalability Improvements
+- **Objective**: Ensure the system can handle increased load and data volume.
+- **Strategies**:
+  - Implement distributed processing for AI tasks
+  - Optimize database queries and indexing for faster access
+  - Load balancing strategies for high availability
+
+### 8. User Interface Enhancements
+- **Objective**: Improve user experience and interface design.
+- **Features**:
+  - Responsive design improvements for mobile and tablet users
+  - Dark mode and customizable themes
+  - User feedback mechanisms to gather insights for further improvements
+
+### 9. Compliance and Regulatory Considerations
+- **Objective**: Ensure the platform adheres to relevant regulations.
+- **Considerations**:
+  - GDPR compliance for data protection and privacy
+  - Local regulations regarding surveillance and data storage
+  - Regular audits and assessments to maintain compliance
+
+### Conclusion
 The roadmap for Phase 2 and beyond outlines a comprehensive plan for enhancing the Event Monitoring and Management Platform. By focusing on expanding AI capabilities, improving event management, enhancing security, and optimizing performance, the platform will be well-positioned to meet the evolving needs of its users and stakeholders.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/package.json b/event-monitoring-mvp-architecture/package.json
index 6c95f6f..66a5801 100644
--- a/event-monitoring-mvp-architecture/package.json
+++ b/event-monitoring-mvp-architecture/package.json
@@ -1,39 +1,39 @@
-{
-  "name": "event-monitoring-mvp-architecture",
-  "version": "1.0.0",
-  "description": "MVP architecture for an Event Monitoring and Management Platform.",
-  "main": "src/app.ts",
-  "scripts": {
-    "start": "node dist/app.js",
-    "build": "tsc",
-    "dev": "ts-node src/app.ts",
-    "test": "jest"
-  },
-  "repository": {
-    "type": "git",
-    "url": "https://github.com/yourusername/event-monitoring-mvp-architecture.git"
-  },
-  "keywords": [
-    "event-monitoring",
-    "MVP",
-    "architecture",
-    "video-analytics",
-    "AI"
-  ],
-  "author": "Your Name",
-  "license": "MIT",
-  "dependencies": {
-    "express": "^4.17.1",
-    "mongoose": "^5.10.9",
-    "jsonwebtoken": "^8.5.1",
-    "cors": "^2.8.5"
-  },
-  "devDependencies": {
-    "typescript": "^4.1.2",
-    "ts-node": "^9.1.1",
-    "jest": "^26.6.3",
-    "@types/jest": "^26.0.0",
-    "@types/node": "^14.14.6",
-    "@types/express": "^4.17.8"
-  }
+{
+  "name": "event-monitoring-mvp-architecture",
+  "version": "1.0.0",
+  "description": "MVP architecture for an Event Monitoring and Management Platform.",
+  "main": "src/app.ts",
+  "scripts": {
+    "start": "node dist/app.js",
+    "build": "tsc",
+    "dev": "ts-node src/app.ts",
+    "test": "jest"
+  },
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/yourusername/event-monitoring-mvp-architecture.git"
+  },
+  "keywords": [
+    "event-monitoring",
+    "MVP",
+    "architecture",
+    "video-analytics",
+    "AI"
+  ],
+  "author": "Your Name",
+  "license": "MIT",
+  "dependencies": {
+    "express": "^4.17.1",
+    "mongoose": "^5.10.9",
+    "jsonwebtoken": "^8.5.1",
+    "cors": "^2.8.5"
+  },
+  "devDependencies": {
+    "typescript": "^4.1.2",
+    "ts-node": "^9.1.1",
+    "jest": "^26.6.3",
+    "@types/jest": "^26.0.0",
+    "@types/node": "^14.14.6",
+    "@types/express": "^4.17.8"
+  }
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/src/app.ts b/event-monitoring-mvp-architecture/src/app.ts
index ab5cd1b..d2a3d87 100644
--- a/event-monitoring-mvp-architecture/src/app.ts
+++ b/event-monitoring-mvp-architecture/src/app.ts
@@ -1,32 +1,32 @@
-import express from 'express';
-import mongoose from 'mongoose';
-import bodyParser from 'body-parser';
-import cors from 'cors';
-import { userRoutes } from './routes/userRoutes';
-import { cameraRoutes } from './routes/cameraRoutes';
-import { eventRoutes } from './routes/eventRoutes';
-
-const app = express();
-const PORT = process.env.PORT || 5000;
-
-// Middleware
-app.use(cors());
-app.use(bodyParser.json());
-
-// Database connection
-mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/event-monitoring', {
-    useNewUrlParser: true,
-    useUnifiedTopology: true,
-})
-.then(() => console.log('MongoDB connected'))
-.catch(err => console.error('MongoDB connection error:', err));
-
-// Routes
-app.use('/api/users', userRoutes);
-app.use('/api/cameras', cameraRoutes);
-app.use('/api/events', eventRoutes);
-
-// Start the server
-app.listen(PORT, () => {
-    console.log(`Server is running on http://localhost:${PORT}`);
+import express from 'express';
+import mongoose from 'mongoose';
+import bodyParser from 'body-parser';
+import cors from 'cors';
+import { userRoutes } from './routes/userRoutes';
+import { cameraRoutes } from './routes/cameraRoutes';
+import { eventRoutes } from './routes/eventRoutes';
+
+const app = express();
+const PORT = process.env.PORT || 5000;
+
+// Middleware
+app.use(cors());
+app.use(bodyParser.json());
+
+// Database connection
+mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/event-monitoring', {
+    useNewUrlParser: true,
+    useUnifiedTopology: true,
+})
+.then(() => console.log('MongoDB connected'))
+.catch(err => console.error('MongoDB connection error:', err));
+
+// Routes
+app.use('/api/users', userRoutes);
+app.use('/api/cameras', cameraRoutes);
+app.use('/api/events', eventRoutes);
+
+// Start the server
+app.listen(PORT, () => {
+    console.log(`Server is running on http://localhost:${PORT}`);
 });
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/src/types/index.ts b/event-monitoring-mvp-architecture/src/types/index.ts
index 7be1b79..d15f93b 100644
--- a/event-monitoring-mvp-architecture/src/types/index.ts
+++ b/event-monitoring-mvp-architecture/src/types/index.ts
@@ -1,25 +1,25 @@
-export interface User {
-    id: string;
-    username: string;
-    hashedPassword: string;
-    role: 'admin' | 'operator';
-}
-
-export interface Camera {
-    id: string;
-    name: string;
-    location: {
-        latitude: number;
-        longitude: number;
-    };
-    streamUrl: string;
-}
-
-export interface Event {
-    id: string;
-    timestamp: Date;
-    cameraId: string;
-    eventType: 'person_detected' | 'vehicle_detected' | 'suspicious_behavior' | 'abandoned_object';
-    snapshotUrl?: string;
-    status: 'new' | 'acknowledged' | 'resolved' | 'closed';
+export interface User {
+    id: string;
+    username: string;
+    hashedPassword: string;
+    role: 'admin' | 'operator';
+}
+
+export interface Camera {
+    id: string;
+    name: string;
+    location: {
+        latitude: number;
+        longitude: number;
+    };
+    streamUrl: string;
+}
+
+export interface Event {
+    id: string;
+    timestamp: Date;
+    cameraId: string;
+    eventType: 'person_detected' | 'vehicle_detected' | 'suspicious_behavior' | 'abandoned_object';
+    snapshotUrl?: string;
+    status: 'new' | 'acknowledged' | 'resolved' | 'closed';
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/01-PROJECT-OVERVIEW.md b/event-monitoring-mvp-architecture/team-documentation/01-PROJECT-OVERVIEW.md
index 8a7a7f9..a987404 100644
--- a/event-monitoring-mvp-architecture/team-documentation/01-PROJECT-OVERVIEW.md
+++ b/event-monitoring-mvp-architecture/team-documentation/01-PROJECT-OVERVIEW.md
@@ -1,297 +1,224 @@
-# Event Monitoring MVP - Complete Project Overview
-
-## ğŸ“‹ What We're Building
-
-The Event Monitoring MVP is a **security system** that uses cameras and artificial intelligence to monitor areas and detect important events (like people entering restricted zones). Think of it as a smart security guard that never sleeps!
-
-### ğŸ¯ Main Goals
-
-1. **Monitor Security Cameras** - Connect to multiple security cameras around a facility
-2. **Detect Events** - Use AI to automatically spot people, vehicles, or suspicious activity
-3. **Alert Security Teams** - Instantly notify guards when something important happens
-4. **Track Everything** - Keep a record of all events for investigation and reporting
-5. **Easy Management** - Provide a user-friendly web interface to control everything
-
-## ğŸ—ï¸ What We've Already Built
-
-### âœ… Completed Features
-
-#### 1. **User Authentication System**
-- **What it does**: Secure login/logout system so only authorized people can access the system
-- **Why it's important**: Protects sensitive security data from unauthorized access
-- **Technologies used**: JWT (JSON Web Tokens) for secure authentication
-
-#### 2. **Interactive Dashboard**
-- **What it does**: Main control center showing live statistics, camera status, and recent events
-- **Features include**:
-  - Real-time camera count and status
-  - Recent security events feed
-  - Quick action buttons
-  - System health indicators
-- **Why it's important**: Gives security operators a quick overview of everything happening
-
-#### 3. **Camera Management System**
-- **What it does**: Add, configure, and monitor security cameras
-- **Features include**:
-  - Add new cameras with RTSP/HTTP stream URLs
-  - View camera status (online/offline)
-  - Configure camera settings
-  - Grid view of all cameras
-- **Why it's important**: Central control for all security cameras in the system
-
-#### 4. **Interactive Map View**
-- **What it does**: Shows camera locations and events on a real map
-- **Features include**:
-  - Interactive map using Mapbox (like Google Maps but for security)
-  - Camera markers showing status (green=online, red=offline)
-  - Event markers showing recent incidents
-  - Click cameras to see details
-- **Why it's important**: Visual representation helps security teams understand spatial relationships
-
-#### 5. **Event Management**
-- **What it does**: View, filter, and manage security events
-- **Features include**:
-  - List all detected events
-  - Filter by date, camera, event type
-  - Event details with timestamps
-  - Status tracking (pending, acknowledged, resolved)
-- **Why it's important**: Helps security teams investigate and track incidents
-
-#### 6. **User Profile Management**
-- **What it does**: Manage user account information and view activity
-- **Features include**:
-  - Edit profile information
-  - View recent activity history
-  - Performance statistics
-  - Account security settings
-- **Why it's important**: Personalized experience and activity tracking
-
-#### 7. **System Settings**
-- **What it does**: Configure system preferences and behavior
-- **Features include**:
-  - Notification preferences (email, SMS, push notifications)
-  - Display settings (dark mode, language)
-  - Audio configuration
-  - Security settings (session timeout, 2FA)
-- **Why it's important**: Customizable system behavior for different users
-
-#### 8. **Backend API System**
-- **What it does**: Server that handles all data and business logic
-- **Features include**:
-  - RESTful API endpoints for all operations
-  - Database integration with MongoDB
-  - Real-time communication via WebSockets
-  - User authentication and authorization
-- **Why it's important**: The "brain" of the system that coordinates everything
-
-#### 9. **AI Service Foundation**
-- **What it does**: Python service for AI-powered video analysis
-- **Current status**: Basic structure in place, ready for AI model integration
-- **Why it's important**: This is where the "smart" detection happens
-
-## ğŸš§ What We're Currently Working On
-
-### ğŸ”„ In Development
-
-#### 1. **AI Object Detection**
-- **Goal**: Automatically detect people, vehicles, and objects in camera feeds
-- **Technology**: YOLOv8 (You Only Look Once) - a state-of-the-art object detection AI model
-- **Status**: AI service structure completed, model integration in progress
-
-#### 2. **Real-time Video Processing**
-- **Goal**: Process live camera streams and generate events when something is detected
-- **Technology**: OpenCV for video processing, WebRTC for streaming
-- **Status**: Video processing framework in place, real-time analysis in development
-
-#### 3. **Event Generation System**
-- **Goal**: Automatically create events when AI detects something important
-- **Features**:
-  - Configurable detection zones
-  - Severity classification (low, medium, high, critical)
-  - Smart filtering to avoid false alarms
-- **Status**: Event structure completed, AI integration pending
-
-## ğŸ”® Future Implementation Plans
-
-### ğŸ“… Phase 1 (Next 2-4 weeks)
-1. **Complete AI Integration**
-   - Integrate YOLOv8 model for object detection
-   - Implement real-time video stream processing
-   - Create automatic event generation
-
-2. **Enhanced Alerts**
-   - Email notifications for critical events
-   - SMS alerts for emergency situations
-   - Push notifications to mobile devices
-
-3. **Live Video Streaming**
-   - Real-time video display in the web interface
-   - Multiple camera view support
-   - Video recording for events
-
-### ğŸ“… Phase 2 (1-2 months)
-1. **Advanced AI Features**
-   - Face recognition for authorized personnel
-   - Behavior analysis (loitering, running, fighting)
-   - Vehicle license plate recognition
-
-2. **Mobile Application**
-   - Native mobile app for security guards
-   - Push notifications for events
-   - Quick response actions
-
-3. **Advanced Analytics**
-   - Event pattern analysis
-   - Predictive security insights
-   - Comprehensive reporting dashboard
-
-### ğŸ“… Phase 3 (2-3 months)
-1. **Enterprise Features**
-   - Multi-tenant support (multiple organizations)
-   - Advanced role-based permissions
-   - Integration with existing security systems
-
-2. **Machine Learning Improvements**
-   - Custom model training for specific environments
-   - Adaptive learning from user feedback
-   - Reduced false positive rates
-
-## ğŸ¯ Target Users
-
-### Primary Users
-1. **Security Guards/Operators**
-   - Monitor multiple cameras simultaneously
-   - Respond to real-time alerts
-   - Investigate security incidents
-
-2. **Security Managers**
-   - Oversee system operations
-   - Generate reports for management
-   - Configure system settings and policies
-
-3. **Facility Managers**
-   - Monitor overall facility security
-   - Review incident reports
-   - Plan security improvements
-
-### Use Cases
-1. **Corporate Buildings**: Monitor entrances, parking lots, and restricted areas
-2. **Retail Stores**: Detect shoplifting, monitor customer areas
-3. **Warehouses**: Secure inventory, monitor loading docks
-4. **Schools/Universities**: Campus security, emergency response
-5. **Residential Complexes**: Monitor common areas, parking, entrances
-
-## ğŸ›ï¸ System Architecture Overview
-
-### Frontend (Web Interface)
-- **Technology**: React.js with TypeScript
-- **Purpose**: User interface that security operators interact with
-- **Features**: Dashboard, camera views, event management, settings
-
-### Backend (Server/API)
-- **Technology**: Node.js with Express
-- **Purpose**: Handles data, user authentication, and coordinates between components
-- **Features**: User management, camera data, event storage, real-time communication
-
-### AI Service (Smart Detection)
-- **Technology**: Python with YOLOv8 and OpenCV
-- **Purpose**: Analyzes video streams and detects objects/events
-- **Features**: Object detection, motion analysis, event generation
-
-### Database (Data Storage)
-- **Technology**: MongoDB
-- **Purpose**: Stores all system data
-- **Data**: Users, cameras, events, settings, logs
-
-### Communication Flow
-1. **Cameras** send video streams to **AI Service**
-2. **AI Service** analyzes video and detects events
-3. **AI Service** sends events to **Backend**
-4. **Backend** stores events in **Database**
-5. **Backend** sends real-time alerts to **Frontend**
-6. **Frontend** displays events to security operators
-
-## ğŸš€ Why This Project Matters
-
-### Business Value
-- **Reduces Security Costs**: Fewer human guards needed for monitoring
-- **Improves Response Time**: Instant alerts vs. manual observation
-- **24/7 Operation**: Never sleeps, never gets distracted
-- **Evidence Collection**: Automatic recording of security incidents
-- **Scalability**: Can monitor hundreds of cameras with minimal staff
-
-### Technical Learning Value
-- **Full-Stack Development**: Frontend, backend, database, AI
-- **Modern Technologies**: Latest tools and frameworks
-- **Real-World Application**: Solves actual business problems
-- **Microservices Architecture**: Industry-standard system design
-- **AI/ML Integration**: Cutting-edge technology application
-
-## ğŸ“ Learning Opportunities for the Team
-
-### Frontend Development
-- **React.js**: Modern web application framework
-- **TypeScript**: Type-safe JavaScript for better code quality
-- **Material-UI**: Professional component library
-- **State Management**: Redux for complex application state
-- **Real-time Updates**: WebSocket integration
-
-### Backend Development
-- **Node.js/Express**: Server-side JavaScript development
-- **API Design**: RESTful services and best practices
-- **Database Design**: MongoDB schema design and optimization
-- **Authentication**: Secure user management with JWT
-- **Real-time Communication**: WebSocket implementation
-
-### AI/Machine Learning
-- **Computer Vision**: Object detection and image processing
-- **Neural Networks**: Understanding how AI models work
-- **Python Programming**: AI/ML development ecosystem
-- **OpenCV**: Industry-standard computer vision library
-- **Model Integration**: Connecting AI models to real applications
-
-### DevOps and Deployment
-- **Docker**: Containerization for consistent deployment
-- **Environment Management**: Configuration and secrets
-- **Logging and Monitoring**: Application observability
-- **Testing**: Unit tests, integration tests, and quality assurance
-
-## ğŸ¯ Success Metrics
-
-### Technical Metrics
-- **Detection Accuracy**: >95% accuracy for person detection
-- **Response Time**: <2 seconds from event to alert
-- **System Uptime**: >99.9% availability
-- **Concurrent Users**: Support for 50+ simultaneous users
-- **Video Processing**: Handle 20+ camera streams simultaneously
-
-### User Experience Metrics
-- **Login Time**: <3 seconds to authenticate
-- **Page Load Speed**: <2 seconds for all pages
-- **Mobile Responsiveness**: Works on all device sizes
-- **User Satisfaction**: >4.5/5 rating from security operators
-
-## ğŸ› ï¸ Development Best Practices We're Following
-
-### Code Quality
-- **TypeScript**: Type safety across frontend and backend
-- **Code Comments**: Detailed documentation for learning
-- **Consistent Naming**: Clear, descriptive variable and function names
-- **Error Handling**: Comprehensive error management
-- **Testing**: Unit and integration tests for reliability
-
-### Security
-- **Input Validation**: All user inputs are validated
-- **Authentication**: Secure login with JWT tokens
-- **Authorization**: Role-based access control
-- **Data Encryption**: Passwords hashed with bcrypt
-- **HTTPS**: Secure communication in production
-
-### Performance
-- **Optimized Images**: Compressed assets for faster loading
-- **Code Splitting**: Load only necessary code for each page
-- **Database Indexing**: Fast query performance
-- **Caching**: Reduced server load and faster responses
-- **Lazy Loading**: Load content only when needed
-
-This project represents a complete, production-ready security system that demonstrates modern software development practices and cutting-edge AI technology. It's an excellent learning platform that covers the full spectrum of software development skills!
\ No newline at end of file
+# Event Monitoring Platform - Project Overview
+
+## Vision
+The Event Monitoring and Management Platform is a comprehensive system designed to enhance community safety through intelligent incident detection, reporting, and response coordination. By combining AI-powered camera surveillance, mobile citizen reporting, and professional first responder management, the platform creates a connected ecosystem for proactive incident management.
+
+## Current Status: MVP Implementation
+The platform is currently in active MVP development with multi-tenant architecture supporting standalone mobile applications for citizen reporting and first responder coordination.
+
+## Key Features
+
+### ğŸ” Intelligent Detection
+- AI-powered camera analytics using YOLOv8
+- Real-time object and activity detection
+- Automated event creation from camera feeds
+
+### ğŸ“± Mobile Integration
+- Citizen reporting app with anonymous submissions
+- First responder app with live location tracking
+- API key-based multi-tenant authentication
+
+### ğŸ¢ Multi-Tenant Architecture
+- Company-based data isolation
+- Flexible subscription plans
+- Scalable user management
+
+### ğŸ“Š Centralized Dashboard
+- Real-time event monitoring
+- Interactive mapping interface
+- Comprehensive analytics and reporting
+
+### ğŸš¨ Response Coordination
+- Automated event assignment
+- Real-time communication via WebSockets
+- Status tracking and resolution workflows
+
+## Technology Stack
+
+### Backend
+- **Runtime**: Node.js with Express.js
+- **Language**: TypeScript for type safety
+- **Database**: MongoDB with Mongoose ODM
+- **Authentication**: JWT with multi-method support
+- **Real-time**: WebSocket integration
+
+### Frontend
+- **Framework**: React with TypeScript
+- **State Management**: Redux Toolkit
+- **Mapping**: Leaflet for interactive maps
+- **UI Components**: Material-UI component library
+
+### AI Service
+- **Runtime**: Python with FastAPI
+- **ML Framework**: PyTorch with YOLOv8
+- **Computer Vision**: OpenCV for image processing
+
+### Infrastructure
+- **Containerization**: Docker for all services
+- **Orchestration**: Docker Compose for development
+- **Reverse Proxy**: Nginx for production deployment
+- **Database**: MongoDB with replica sets
+
+## Architecture Overview
+
+The platform follows a microservices architecture with clear separation of concerns:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   Mobile Apps   â”‚    â”‚  Web Dashboard  â”‚    â”‚   AI Cameras    â”‚
+â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
+â”‚ â€¢ Citizen App   â”‚    â”‚ â€¢ React SPA     â”‚    â”‚ â€¢ YOLOv8       â”‚
+â”‚ â€¢ Responder App â”‚    â”‚ â€¢ Real-time     â”‚    â”‚ â€¢ RTSP Streams  â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
+          â”‚                      â”‚                      â”‚
+          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                                 â”‚
+                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                    â”‚   API Gateway   â”‚
+                    â”‚                 â”‚
+                    â”‚ â€¢ Authenticationâ”‚
+                    â”‚ â€¢ Rate Limiting â”‚
+                    â”‚ â€¢ Request Proxy â”‚
+                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
+                              â”‚
+                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                    â”‚  Core Services  â”‚
+                    â”‚                 â”‚
+                    â”‚ â€¢ Event Mgmt    â”‚
+                    â”‚ â€¢ User Mgmt     â”‚
+                    â”‚ â€¢ Report Mgmt   â”‚
+                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
+                              â”‚
+                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                    â”‚    Database     â”‚
+                    â”‚                 â”‚
+                    â”‚ â€¢ MongoDB       â”‚
+                    â”‚ â€¢ Multi-tenant  â”‚
+                    â”‚ â€¢ Geo-spatial   â”‚
+                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+## Development Roadmap
+
+### Phase 1: MVP Core (Current)
+- âœ… Multi-tenant company management
+- âœ… API key authentication system
+- âœ… Mobile report submission
+- âœ… Event aggregation from reports
+- âœ… Web dashboard with real-time updates
+- âœ… AI camera integration
+- ğŸ”„ First responder location tracking
+
+### Phase 2: Enhanced Features
+- ğŸ“‹ Advanced analytics and reporting
+- ğŸ“‹ Mobile app development (React Native)
+- ğŸ“‹ Push notification system
+- ğŸ“‹ Offline data synchronization
+- ğŸ“‹ Custom event type configuration
+- ğŸ“‹ Integration APIs for third-party systems
+
+### Phase 3: Enterprise Scale
+- ğŸ“‹ Multi-region deployment
+- ğŸ“‹ Advanced AI model training
+- ğŸ“‹ Machine learning pipeline
+- ğŸ“‹ Advanced user permission system
+- ğŸ“‹ Audit logging and compliance
+- ğŸ“‹ Performance monitoring and alerting
+
+## Team Structure
+
+### Development Teams
+- **Backend Team**: API development, database design, authentication
+- **Frontend Team**: Web dashboard, user experience, responsive design
+- **AI/ML Team**: Computer vision, model training, detection algorithms
+- **Mobile Team**: React Native apps, offline functionality, device integration
+- **DevOps Team**: Infrastructure, deployment, monitoring, security
+
+### Key Roles
+- **Technical Lead**: Overall architecture and technical direction
+- **Product Manager**: Feature prioritization and stakeholder management
+- **UX/UI Designer**: User experience design and interface consistency
+- **QA Lead**: Testing strategy and quality assurance
+- **DevOps Engineer**: Infrastructure and deployment automation
+
+## Quality Assurance
+
+### Testing Strategy
+- **Unit Tests**: Individual component testing
+- **Integration Tests**: API endpoint and service interaction testing
+- **End-to-End Tests**: Complete user workflow testing
+- **Performance Tests**: Load testing and performance benchmarking
+- **Security Tests**: Penetration testing and vulnerability assessment
+
+### Code Quality
+- **TypeScript**: Strict type checking enabled
+- **ESLint**: Code style and quality enforcement
+- **Pre-commit Hooks**: Automated testing and linting
+- **Code Reviews**: Mandatory peer review process
+- **Documentation**: Comprehensive API and code documentation
+
+## Deployment and Operations
+
+### Development Environment
+- Local Docker Compose setup
+- Hot reload for all services
+- Automated testing on commit
+- Development database with sample data
+
+### Staging Environment
+- Full infrastructure replication
+- Automated deployment from main branch
+- Integration testing environment
+- Performance testing sandbox
+
+### Production Environment
+- Container orchestration (Kubernetes)
+- Multi-region deployment capability
+- Automated scaling and load balancing
+- Comprehensive monitoring and alerting
+- Backup and disaster recovery
+
+## Security Considerations
+
+### Data Protection
+- End-to-end encryption for sensitive data
+- Multi-tenant data isolation
+- GDPR and privacy regulation compliance
+- Secure API key management
+
+### Access Control
+- Role-based access control (RBAC)
+- Multi-factor authentication support
+- Session management and timeout
+- Audit logging for all access
+
+### Network Security
+- HTTPS-only communication
+- API rate limiting and throttling
+- CORS policy enforcement
+- Web application firewall (WAF)
+
+## Success Metrics
+
+### Technical Metrics
+- **Uptime**: 99.9% service availability
+- **Response Time**: <200ms API response time
+- **Throughput**: 1000+ concurrent users
+- **Accuracy**: >95% AI detection accuracy
+
+### Business Metrics
+- **User Adoption**: Number of active companies and users
+- **Incident Response**: Average time to incident resolution
+- **Report Volume**: Number of citizen reports processed
+- **System Utilization**: Camera uptime and detection coverage
+
+## Getting Started
+
+New team members should:
+1. Review this project overview document
+2. Read the [team coordination protocol](../team-coordination-protocol.md)
+3. Follow the [beginner guide](./06-BEGINNER-GUIDE.md)
+4. Set up their development environment
+5. Join relevant team communication channels
+
+For detailed technical documentation, see the [architecture documentation](../event-monitoring-mvp-architecture/) directory.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/02-TECHNOLOGY-STACK.md b/event-monitoring-mvp-architecture/team-documentation/02-TECHNOLOGY-STACK.md
index 5e926e4..3b1ab8a 100644
--- a/event-monitoring-mvp-architecture/team-documentation/02-TECHNOLOGY-STACK.md
+++ b/event-monitoring-mvp-architecture/team-documentation/02-TECHNOLOGY-STACK.md
@@ -1,714 +1,454 @@
-# Technology Stack Guide - Understanding Our Tools
-
-## ğŸ“ Learning Path: From Beginner to Advanced
-
-This guide explains all the technologies we use in our Event Monitoring MVP, designed specifically for students and new developers. Each section includes what the technology does, why we chose it, and how it fits into our project.
-
-## ğŸŒ Frontend Technologies (What Users See)
-
-### React.js âš›ï¸
-**What it is**: A JavaScript library for building user interfaces
-**Think of it as**: Like building with LEGO blocks - each component is a reusable piece
-
-#### Why We Chose React
-- **Component-Based**: Build once, use anywhere (like creating a "Login Button" and using it on multiple pages)
-- **Large Community**: Millions of developers, tons of tutorials and help
-- **Job Market**: High demand skill in the industry
-- **Fast Development**: Hot reloading means you see changes instantly
-
-#### How We Use It
-```javascript
-// Example: A simple camera component
-function CameraCard({ camera }) {
-  return (
-    <div className="camera-card">
-      <h3>{camera.name}</h3>
-      <p>Status: {camera.online ? 'Online' : 'Offline'}</p>
-    </div>
-  );
-}
-```
-
-#### Learning Resources
-- **Official Tutorial**: [React Tutorial](https://react.dev/learn)
-- **Our Implementation**: Look at `/frontend/src/components/` folder
-- **Key Concepts to Learn**: Components, Props, State, JSX syntax
-
----
-
-### TypeScript ğŸ“
-**What it is**: JavaScript with type checking
-**Think of it as**: Adding guardrails to prevent common programming mistakes
-
-#### Why We Chose TypeScript
-- **Catch Bugs Early**: Tells you about errors before your code runs
-- **Better IDE Support**: Auto-completion and intelligent suggestions
-- **Easier Refactoring**: Change code safely across the entire project
-- **Industry Standard**: Most modern projects use TypeScript
-
-#### Example Comparison
-```javascript
-// Regular JavaScript (can cause runtime errors)
-function addNumbers(a, b) {
-  return a + b;
-}
-addNumbers("5", 3); // Returns "53" (string concatenation) - Bug!
-
-// TypeScript (prevents the error)
-function addNumbers(a: number, b: number): number {
-  return a + b;
-}
-addNumbers("5", 3); // ERROR: Cannot assign string to number parameter
-```
-
-#### Learning Resources
-- **Official Handbook**: [TypeScript Handbook](https://www.typescriptlang.org/docs/)
-- **Our Types**: Check `/frontend/src/types/` and `/backend/src/types/`
-- **Key Concepts**: Basic types, interfaces, generics
-
----
-
-### Material-UI (MUI) ğŸ¨
-**What it is**: Pre-built, beautiful UI components for React
-**Think of it as**: A design toolkit with professional-looking buttons, forms, and layouts
-
-#### Why We Chose Material-UI
-- **Google's Design System**: Based on Material Design principles
-- **Accessibility**: Built-in support for screen readers and keyboard navigation
-- **Consistency**: All components look and feel cohesive
-- **Time Saving**: Don't need to design buttons, forms, etc. from scratch
-
-#### How We Use It
-```javascript
-import { Button, TextField, Card } from '@mui/material';
-
-function LoginForm() {
-  return (
-    <Card>
-      <TextField label="Username" variant="outlined" />
-      <TextField label="Password" type="password" variant="outlined" />
-      <Button variant="contained" color="primary">
-        Login
-      </Button>
-    </Card>
-  );
-}
-```
-
-#### Learning Resources
-- **Official Documentation**: [MUI Docs](https://mui.com/)
-- **Our Usage**: Look at any component in `/frontend/src/components/`
-- **Key Concepts**: Theme system, component props, responsive design
-
----
-
-### Redux Toolkit ğŸ—ƒï¸
-**What it is**: State management for React applications
-**Think of it as**: A global storage box that any component can read from or write to
-
-#### Why We Need State Management
-Imagine you're logged in as "John Smith". Without Redux:
-- Every component needs to ask "Who is logged in?" 
-- When you logout, every component needs to be told individually
-- Data gets messy and hard to track
-
-With Redux:
-- One central place stores "John Smith is logged in"
-- Any component can check this instantly
-- When you logout, one action updates everywhere
-
-#### How We Use It
-```javascript
-// Store user information globally
-const authSlice = createSlice({
-  name: 'auth',
-  initialState: { user: null, isLoggedIn: false },
-  reducers: {
-    login: (state, action) => {
-      state.user = action.payload;
-      state.isLoggedIn = true;
-    },
-    logout: (state) => {
-      state.user = null;
-      state.isLoggedIn = false;
-    }
-  }
-});
-```
-
-#### Learning Resources
-- **Redux Toolkit Documentation**: [Redux Toolkit](https://redux-toolkit.js.org/)
-- **Our Implementation**: `/frontend/src/store/store.ts`
-- **Key Concepts**: Store, slices, actions, reducers
-
----
-
-### React Query (TanStack Query) ğŸ”„
-**What it is**: Data fetching and caching library
-**Think of it as**: Smart waiter who remembers your orders and doesn't ask the kitchen again if you just ordered
-
-#### Why We Use React Query
-- **Automatic Caching**: Fetch data once, use it everywhere
-- **Background Updates**: Keeps data fresh without user action
-- **Loading States**: Automatically handles loading, error, and success states
-- **Offline Support**: Works even when internet is spotty
-
-#### Example
-```javascript
-// Fetch camera data with automatic caching
-function CameraList() {
-  const { data: cameras, isLoading, error } = useQuery({
-    queryKey: ['cameras'],
-    queryFn: () => fetch('/api/cameras').then(res => res.json()),
-    refetchInterval: 5000 // Update every 5 seconds
-  });
-
-  if (isLoading) return <div>Loading cameras...</div>;
-  if (error) return <div>Error loading cameras</div>;
-  
-  return <div>{cameras.map(camera => <CameraCard key={camera.id} camera={camera} />)}</div>;
-}
-```
-
-#### Learning Resources
-- **Official Documentation**: [TanStack Query](https://tanstack.com/query/latest)
-- **Our Usage**: Look for `useQuery` in components
-- **Key Concepts**: Queries, mutations, caching, invalidation
-
----
-
-## ğŸ–¥ï¸ Backend Technologies (The Server Brain)
-
-### Node.js ğŸ’š
-**What it is**: JavaScript runtime that lets you write server code in JavaScript
-**Think of it as**: Using the same language (JavaScript) for both frontend and backend
-
-#### Why We Chose Node.js
-- **Same Language**: Team only needs to learn JavaScript/TypeScript
-- **Fast Development**: Share code between frontend and backend
-- **Great Package Ecosystem**: NPM has packages for everything
-- **Real-time Features**: Excellent WebSocket support for live updates
-
-#### How It Works
-```javascript
-// Simple server example
-const express = require('express');
-const app = express();
-
-app.get('/api/cameras', (req, res) => {
-  // Fetch cameras from database
-  const cameras = getCamerasFromDatabase();
-  res.json(cameras);
-});
-
-app.listen(5000, () => {
-  console.log('Server running on port 5000');
-});
-```
-
-#### Learning Resources
-- **Official Documentation**: [Node.js Docs](https://nodejs.org/en/docs/)
-- **Our Implementation**: `/backend/src/app.ts`
-- **Key Concepts**: Event loop, modules, async/await
-
----
-
-### Express.js ğŸš‚
-**What it is**: Web framework for Node.js that makes building APIs easy
-**Think of it as**: The postal system that routes requests to the right destination
-
-#### Why We Use Express
-- **Simple Routing**: Easy to define API endpoints
-- **Middleware Support**: Add authentication, logging, etc. easily
-- **Industry Standard**: Most Node.js projects use Express
-- **Flexible**: Can build APIs, websites, or both
-
-#### How We Structure Our API
-```javascript
-// User authentication routes
-app.post('/api/auth/login', loginController);
-app.post('/api/auth/register', registerController);
-app.get('/api/auth/me', authenticateToken, getCurrentUser);
-
-// Camera management routes
-app.get('/api/cameras', authenticateToken, getAllCameras);
-app.post('/api/cameras', authenticateToken, addCamera);
-app.put('/api/cameras/:id', authenticateToken, updateCamera);
-app.delete('/api/cameras/:id', authenticateToken, deleteCamera);
-```
-
-#### Learning Resources
-- **Official Documentation**: [Express.js](https://expressjs.com/)
-- **Our Routes**: `/backend/src/routes/` folder
-- **Key Concepts**: Routing, middleware, request/response objects
-
----
-
-### MongoDB ğŸƒ
-**What it is**: NoSQL database that stores data as JSON-like documents
-**Think of it as**: A filing cabinet where each folder can have different types of documents
-
-#### Why We Chose MongoDB
-- **Flexible Schema**: Easy to change data structure as project grows
-- **JSON-like**: Data looks similar to JavaScript objects
-- **Scalable**: Handles large amounts of data efficiently
-- **Developer Friendly**: Easy to work with for web applications
-
-#### Data Structure Examples
-```javascript
-// User document
-{
-  "_id": "user123",
-  "username": "john_doe",
-  "email": "john@example.com",
-  "role": "security_guard",
-  "createdAt": "2024-01-15T10:30:00Z",
-  "profile": {
-    "firstName": "John",
-    "lastName": "Doe",
-    "department": "Security"
-  }
-}
-
-// Camera document
-{
-  "_id": "cam456",
-  "name": "Main Entrance Camera",
-  "location": {
-    "latitude": 40.7128,
-    "longitude": -74.0060,
-    "address": "123 Main St, New York"
-  },
-  "streamUrl": "rtsp://camera.example.com:554/stream",
-  "status": "online",
-  "settings": {
-    "resolution": "1920x1080",
-    "frameRate": 30,
-    "nightVision": true
-  }
-}
-```
-
-#### Learning Resources
-- **Official Documentation**: [MongoDB Docs](https://docs.mongodb.com/)
-- **Our Models**: `/backend/src/models/` folder
-- **Key Concepts**: Documents, collections, queries, indexing
-
----
-
-### Socket.IO ğŸ“¡
-**What it is**: Real-time communication between server and browser
-**Think of it as**: Walkie-talkies between the server and web page
-
-#### Why We Need Real-Time Communication
-In a security system, things happen fast:
-- Camera goes offline â†’ Security team needs to know immediately
-- AI detects intrusion â†’ Alert must appear instantly on all screens
-- New event occurs â†’ All operators should see it without refreshing
-
-#### How It Works
-```javascript
-// Server sends real-time updates
-io.emit('camera-status-changed', {
-  cameraId: 'cam456',
-  status: 'offline',
-  timestamp: new Date()
-});
-
-io.emit('new-event', {
-  id: 'event789',
-  type: 'person_detected',
-  cameraId: 'cam456',
-  confidence: 0.95
-});
-
-// Frontend listens for updates
-socket.on('camera-status-changed', (data) => {
-  updateCameraStatus(data.cameraId, data.status);
-});
-
-socket.on('new-event', (event) => {
-  addEventToList(event);
-  showNotification(`New ${event.type} detected!`);
-});
-```
-
-#### Learning Resources
-- **Official Documentation**: [Socket.IO](https://socket.io/docs/)
-- **Our Implementation**: Look for `io.emit` in backend, `socket.on` in frontend
-- **Key Concepts**: Events, rooms, namespaces, acknowledgments
-
----
-
-## ğŸ¤– AI/ML Technologies (The Smart Brain)
-
-### Python ğŸ
-**What it is**: Programming language excellent for AI and data science
-**Think of it as**: The preferred language for teaching computers to "see" and "understand"
-
-#### Why Python for AI
-- **AI Libraries**: TensorFlow, PyTorch, OpenCV all built for Python
-- **Easy Syntax**: Beginner-friendly language
-- **Data Science**: Great tools for working with data
-- **Community**: Huge AI/ML community and resources
-
-#### Basic AI Service Structure
-```python
-# AI service main application
-from fastapi import FastAPI
-import cv2
-from ultralytics import YOLO
-
-app = FastAPI()
-model = YOLO('yolov8n.pt')  # Load AI model
-
-@app.post("/analyze-frame")
-async def analyze_frame(image_data):
-    # Process the image
-    results = model(image_data)
-    
-    # Extract detected objects
-    detections = []
-    for result in results:
-        for box in result.boxes:
-            detections.append({
-                'class': box.cls,
-                'confidence': box.conf,
-                'coordinates': box.xyxy
-            })
-    
-    return {'detections': detections}
-```
-
-#### Learning Resources
-- **Python Tutorial**: [Python.org Tutorial](https://docs.python.org/3/tutorial/)
-- **Our AI Service**: `/ai-service/` folder
-- **Key Concepts**: Functions, classes, modules, data types
-
----
-
-### YOLOv8 (You Only Look Once) ğŸ‘ï¸
-**What it is**: State-of-the-art object detection AI model
-**Think of it as**: A computer vision system that can instantly identify objects in images
-
-#### How YOLO Works
-1. **Input**: Give it a photo or video frame
-2. **Processing**: Scans the entire image in one pass
-3. **Output**: Returns what objects it found and where they are
-
-#### What It Can Detect
-- **People**: Individuals, groups, body positions
-- **Vehicles**: Cars, trucks, bikes, motorcycles
-- **Objects**: Bags, weapons, phones, laptops
-- **Animals**: Dogs, cats, birds
-
-#### Example Detection Result
-```python
-# YOLO analyzes a frame and returns:
-{
-  'detections': [
-    {
-      'class': 'person',
-      'confidence': 0.95,
-      'box': [100, 150, 200, 400],  # x1, y1, x2, y2 coordinates
-      'center': [150, 275]
-    },
-    {
-      'class': 'car',
-      'confidence': 0.87,
-      'box': [300, 200, 600, 350],
-      'center': [450, 275]
-    }
-  ]
-}
-```
-
-#### Learning Resources
-- **Ultralytics Documentation**: [YOLOv8 Docs](https://docs.ultralytics.com/)
-- **Computer Vision Course**: [CS231n Stanford](http://cs231n.stanford.edu/)
-- **Key Concepts**: Object detection, neural networks, confidence scores
-
----
-
-### OpenCV ğŸ“¹
-**What it is**: Computer vision library for image and video processing
-**Think of it as**: Photoshop for programmers, but automated
-
-#### What OpenCV Does
-- **Read Videos**: Load video files or camera streams
-- **Process Images**: Resize, filter, enhance images
-- **Draw Annotations**: Add rectangles, text, lines to images
-- **Video Analysis**: Detect motion, track objects
-
-#### How We Use It
-```python
-import cv2
-
-# Read video frame
-cap = cv2.VideoCapture('rtsp://camera-url')
-ret, frame = cap.read()
-
-# Resize frame for processing
-frame = cv2.resize(frame, (640, 480))
-
-# Draw detection box on frame
-cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
-cv2.putText(frame, 'Person Detected', (x1, y1-10), 
-            cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)
-
-# Save or stream the annotated frame
-cv2.imwrite('detection_result.jpg', frame)
-```
-
-#### Learning Resources
-- **OpenCV Documentation**: [OpenCV Docs](https://docs.opencv.org/)
-- **Python OpenCV Tutorial**: [OpenCV Python Tutorial](https://opencv-python-tutroals.readthedocs.io/)
-- **Key Concepts**: Image arrays, color spaces, transformations
-
----
-
-### FastAPI âš¡
-**What it is**: Modern Python web framework for building APIs
-**Think of it as**: Express.js but for Python, with automatic documentation
-
-#### Why We Chose FastAPI for AI Service
-- **Fast Performance**: One of the fastest Python frameworks
-- **Automatic Documentation**: Generates API docs automatically
-- **Type Safety**: Built-in support for Python type hints
-- **Async Support**: Handle multiple requests simultaneously
-
-#### Example AI API Endpoint
-```python
-from fastapi import FastAPI, File, UploadFile
-from pydantic import BaseModel
-
-app = FastAPI(title="Event Monitoring AI Service")
-
-class DetectionResponse(BaseModel):
-    objects_found: int
-    detections: list
-    processing_time: float
-
-@app.post("/detect", response_model=DetectionResponse)
-async def detect_objects(image: UploadFile = File(...)):
-    """
-    Analyze an image and detect objects
-    """
-    # Process the uploaded image
-    image_data = await image.read()
-    results = await process_with_yolo(image_data)
-    
-    return DetectionResponse(
-        objects_found=len(results),
-        detections=results,
-        processing_time=0.15
-    )
-```
-
-#### Learning Resources
-- **FastAPI Documentation**: [FastAPI Docs](https://fastapi.tiangolo.com/)
-- **Our AI Service**: `/ai-service/app.py`
-- **Key Concepts**: Path operations, dependency injection, background tasks
-
----
-
-## ğŸ› ï¸ DevOps & Deployment Technologies
-
-### Docker ğŸ³
-**What it is**: Containerization platform that packages applications with all dependencies
-**Think of it as**: Shipping containers for software - works the same everywhere
-
-#### Why We Use Docker
-- **Consistency**: Runs the same on your laptop, server, or cloud
-- **Isolation**: Each service runs independently
-- **Easy Deployment**: Ship the container, not the code
-- **Development**: Everyone gets identical environment
-
-#### How Our Docker Setup Works
-```yaml
-# docker-compose.yml - Orchestrates all services
-version: '3.8'
-services:
-  frontend:
-    build: ./frontend
-    ports:
-      - "3000:80"
-    depends_on:
-      - backend
-  
-  backend:
-    build: ./backend
-    ports:
-      - "5000:5000"
-    environment:
-      - MONGO_URL=mongodb://mongo:27017/eventmonitoring
-    depends_on:
-      - mongo
-  
-  ai-service:
-    build: ./ai-service
-    ports:
-      - "8000:8000"
-    volumes:
-      - ./ai-service/models:/app/models
-  
-  mongo:
-    image: mongo:6.0
-    ports:
-      - "27017:27017"
-    volumes:
-      - mongo_data:/data/db
-```
-
-#### Learning Resources
-- **Docker Documentation**: [Docker Docs](https://docs.docker.com/)
-- **Our Docker Files**: `Dockerfile` in each service folder
-- **Key Concepts**: Images, containers, volumes, networks
-
----
-
-### Git & GitHub ğŸ“š
-**What it is**: Version control system for tracking code changes
-**Think of it as**: Google Docs version history, but for code
-
-#### Why Version Control is Critical
-- **Track Changes**: See what changed, when, and who changed it
-- **Collaboration**: Multiple developers can work on same project
-- **Backup**: Code is stored safely in multiple places
-- **Branching**: Work on features without breaking main code
-
-#### Basic Git Workflow
-```bash
-# Download the project
-git clone https://github.com/your-team/event-monitoring-mvp.git
-
-# Create a new feature branch
-git checkout -b feature/add-camera-settings
-
-# Make changes, then stage them
-git add .
-
-# Commit with descriptive message
-git commit -m "Add camera resolution settings to UI"
-
-# Push to GitHub
-git push origin feature/add-camera-settings
-
-# Create Pull Request on GitHub for team review
-```
-
-#### Learning Resources
-- **Git Tutorial**: [Git Tutorial](https://git-scm.com/docs/gittutorial)
-- **GitHub Guides**: [GitHub Guides](https://guides.github.com/)
-- **Key Concepts**: Repositories, branches, commits, merges, pull requests
-
----
-
-## ğŸŒ Additional Important Technologies
-
-### JWT (JSON Web Tokens) ğŸ”
-**What it is**: Secure way to transmit information between parties
-**Think of it as**: Digital passport that proves who you are
-
-#### How JWT Authentication Works
-1. User logs in with username/password
-2. Server verifies credentials
-3. Server creates JWT token with user info
-4. Client stores token and sends with every request
-5. Server verifies token to authenticate requests
-
-```javascript
-// JWT structure
-{
-  "header": {
-    "alg": "HS256",
-    "typ": "JWT"
-  },
-  "payload": {
-    "userId": "123",
-    "username": "john_doe",
-    "role": "security_guard",
-    "exp": 1640995200  // Expiration time
-  },
-  "signature": "secret-signature-hash"
-}
-```
-
----
-
-### WebRTC ğŸ“¹
-**What it is**: Real-time communication for browsers (video, audio, data)
-**Think of it as**: Video calling technology built into browsers
-
-#### Why We'll Use WebRTC
-- **Low Latency**: Minimal delay for live video
-- **Browser Native**: No plugins required
-- **Peer-to-Peer**: Direct connection when possible
-- **Adaptive**: Adjusts quality based on connection
-
----
-
-### Mapbox ğŸ—ºï¸
-**What it is**: Platform for custom maps and location services
-**Think of it as**: Google Maps that you can customize for your needs
-
-#### How We Use Maps
-- **Camera Locations**: Show where each camera is positioned
-- **Event Visualization**: Display where events occurred
-- **Coverage Areas**: Show camera viewing ranges
-- **Navigation**: Help security teams navigate to incidents
-
----
-
-## ğŸ¯ Technology Integration: How It All Works Together
-
-### Request Flow Example: User Logs In
-1. **Frontend (React)**: User enters username/password
-2. **Frontendâ†’Backend**: HTTP POST to `/api/auth/login`
-3. **Backend (Express)**: Validates credentials against MongoDB
-4. **Backendâ†’Frontend**: Returns JWT token
-5. **Frontend**: Stores token, redirects to dashboard
-6. **Frontend**: All future requests include JWT token
-
-### Real-Time Event Flow: AI Detects Person
-1. **Camera**: Sends video stream to AI Service
-2. **AI Service (Python/YOLO)**: Detects person in frame
-3. **AI Serviceâ†’Backend**: HTTP POST new event data
-4. **Backend**: Saves event to MongoDB
-5. **Backend**: Broadcasts event via Socket.IO
-6. **Frontend**: Receives real-time event, shows alert
-7. **Frontend**: Updates dashboard and event list
-
-### Development Workflow
-1. **Git**: Clone repository to local machine
-2. **Docker**: Start all services with one command
-3. **Development**: Make changes to code
-4. **Testing**: Verify changes work correctly
-5. **Git**: Commit and push changes
-6. **Review**: Team reviews code via pull request
-7. **Deployment**: Merge to main branch, deploy to production
-
-## ğŸš€ Getting Started: Next Steps for New Developers
-
-### Prerequisites to Learn
-1. **JavaScript/TypeScript Basics**: Variables, functions, objects, arrays
-2. **HTML/CSS Fundamentals**: Basic web page structure and styling
-3. **Command Line Basics**: Navigate folders, run commands
-4. **Git Basics**: Clone, add, commit, push, pull
-
-### Recommended Learning Order
-1. **Week 1-2**: JavaScript fundamentals, HTML/CSS basics
-2. **Week 3-4**: React basics, component concepts
-3. **Week 5-6**: TypeScript, API concepts
-4. **Week 7-8**: Node.js, Express basics
-5. **Week 9-10**: Database concepts, MongoDB
-6. **Week 11-12**: Docker, deployment concepts
-
-### Hands-On Practice
-1. **Start Small**: Modify existing components before creating new ones
-2. **Use Browser Dev Tools**: Inspect elements, check console for errors
-3. **Read Our Code**: Every file has detailed comments explaining what it does
-4. **Ask Questions**: Use our team chat for any confusion
-5. **Test Changes**: Always verify your changes work before committing
-
-This technology stack represents the modern standard for full-stack web development with AI integration. Each technology was chosen for its learning value, industry relevance, and project suitability. Take time to understand each piece - they all work together to create our complete security monitoring system!
\ No newline at end of file
+# Technology Stack and Architecture
+
+## Overview
+The Event Monitoring Platform employs a modern, scalable technology stack designed for high-performance incident detection, real-time processing, and multi-tenant operation. This document provides detailed information about each technology component and architectural decisions.
+
+## Core Architecture
+
+### Microservices Design
+The platform follows a microservices architecture with clear service boundaries:
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   API Gateway   â”‚    â”‚  Auth Service  â”‚    â”‚  Event Service  â”‚
+â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
+â”‚ â€¢ Request       â”‚    â”‚ â€¢ JWT Tokens    â”‚    â”‚ â€¢ Event Mgmt    â”‚
+â”‚ â€¢ Routing       â”‚    â”‚ â€¢ API Keys      â”‚    â”‚ â€¢ Aggregation   â”‚
+â”‚ â€¢ Rate Limiting â”‚    â”‚ â€¢ Sessions      â”‚    â”‚ â€¢ Real-time     â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚                       â”‚                       â”‚
+         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                                 â”‚
+                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                    â”‚  User Service  â”‚    â”‚  Report Service â”‚
+                    â”‚                 â”‚    â”‚                 â”‚
+                    â”‚ â€¢ Multi-tenant  â”‚    â”‚ â€¢ Submissions   â”‚
+                    â”‚ â€¢ Roles/Perms   â”‚    â”‚ â€¢ Validation    â”‚
+                    â”‚ â€¢ Profiles      â”‚    â”‚ â€¢ Linking       â”‚
+                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+## Backend Services
+
+### Node.js + Express + TypeScript
+
+**Why Node.js?**
+- **Non-blocking I/O**: Perfect for real-time applications with WebSocket connections
+- **NPM Ecosystem**: Rich ecosystem of packages for various functionalities
+- **JavaScript Everywhere**: Unified language across frontend and backend
+- **Performance**: V8 engine provides excellent performance for I/O operations
+
+**Why Express?**
+- **Minimalist**: Lightweight framework that doesn't impose structure
+- **Middleware**: Powerful middleware system for authentication, logging, CORS
+- **Routing**: Flexible routing with parameter handling
+- **Community**: Extensive documentation and community support
+
+**Why TypeScript?**
+- **Type Safety**: Compile-time type checking prevents runtime errors
+- **Developer Experience**: Excellent IDE support with IntelliSense
+- **Refactoring**: Safe refactoring with type-aware tools
+- **Scalability**: Better maintainability for large codebases
+
+**Key Packages:**
+```json
+{
+  "express": "^4.18.0",
+  "mongoose": "^7.0.0",
+  "jsonwebtoken": "^9.0.0",
+  "bcryptjs": "^2.4.3",
+  "socket.io": "^4.7.0",
+  "helmet": "^6.0.0",
+  "cors": "^2.8.5",
+  "winston": "^3.8.0",
+  "joi": "^17.9.0"
+}
+```
+
+### MongoDB + Mongoose
+
+**Why MongoDB?**
+- **Document Model**: Flexible schema for varying event data structures
+- **Geo-spatial Queries**: Native support for location-based event filtering
+- **Scalability**: Horizontal scaling with sharding
+- **JSON-like**: Natural fit with JavaScript applications
+- **Multi-tenant**: Database-level isolation capabilities
+
+**Why Mongoose?**
+- **Schema Validation**: Ensures data consistency and validation
+- **Type Safety**: TypeScript integration for model definitions
+- **Middleware**: Pre/post hooks for business logic
+- **Query Building**: Fluent API for complex queries
+
+**Database Design:**
+```javascript
+// Multi-tenant collection pattern
+const eventSchema = new Schema({
+  companyId: { type: ObjectId, required: true, index: true },
+  eventTypeId: { type: ObjectId, ref: 'EventType' },
+  // ... other fields
+});
+
+// Compound indexes for performance
+eventSchema.index({ companyId: 1, status: 1, createdAt: -1 });
+eventSchema.index({ companyId: 1, location: '2dsphere' });
+```
+
+## Frontend Architecture
+
+### React + TypeScript
+
+**Why React?**
+- **Component-Based**: Modular, reusable UI components
+- **Virtual DOM**: Efficient rendering and updates
+- **Ecosystem**: Rich ecosystem of libraries and tools
+- **Community**: Largest frontend framework community
+
+**Why TypeScript?**
+- **Type Safety**: Prevents common JavaScript errors
+- **Better DX**: Enhanced IDE support and refactoring
+- **Self-Documenting**: Types serve as documentation
+- **Scalability**: Maintainable code as application grows
+
+**State Management - Redux Toolkit**
+```typescript
+// Modern Redux with TypeScript
+interface EventState {
+  events: Event[];
+  loading: boolean;
+  error: string | null;
+}
+
+const eventSlice = createSlice({
+  name: 'events',
+  initialState,
+  reducers: {
+    setEvents: (state, action: PayloadAction<Event[]>) => {
+      state.events = action.payload;
+    }
+  }
+});
+```
+
+### UI Component Library - Material-UI
+
+**Why Material-UI?**
+- **Design System**: Consistent, professional appearance
+- **Accessibility**: Built-in accessibility features
+- **Theming**: Customizable design tokens
+- **Component Rich**: Comprehensive component library
+- **TypeScript**: Full TypeScript support
+
+**Key Components:**
+- **Data Grid**: Advanced table with sorting, filtering, pagination
+- **Maps**: Integration with mapping libraries
+- **Forms**: Validation and error handling
+- **Charts**: Data visualization components
+
+## AI Service Architecture
+
+### Python + FastAPI
+
+**Why Python?**
+- **ML Ecosystem**: Rich ecosystem of ML libraries (PyTorch, TensorFlow)
+- **Scientific Computing**: NumPy, SciPy, OpenCV support
+- **Productivity**: Rapid development and prototyping
+
+**Why FastAPI?**
+- **Performance**: High performance with async support
+- **Type Safety**: Pydantic models for validation
+- **Documentation**: Automatic OpenAPI documentation
+- **Modern**: Built on ASGI for async operations
+
+**AI Pipeline:**
+```python
+# YOLOv8 object detection pipeline
+from ultralytics import YOLO
+import cv2
+
+model = YOLO('yolov8n.pt')  # Load model
+
+def detect_objects(frame):
+    results = model(frame, conf=0.5)  # Run inference
+    detections = []
+    for result in results:
+        for box in result.boxes:
+            detection = {
+                'class': model.names[int(box.cls)],
+                'confidence': float(box.conf),
+                'bbox': box.xyxy.tolist()
+            }
+            detections.append(detection)
+    return detections
+```
+
+## Real-time Communication
+
+### WebSocket Implementation
+
+**Why WebSockets?**
+- **Bidirectional**: Real-time communication in both directions
+- **Efficient**: Lower overhead than polling
+- **Persistent**: Maintains connection for instant updates
+- **Fallback**: Socket.io provides fallback mechanisms
+
+**Implementation:**
+```typescript
+// Frontend WebSocket client
+import io from 'socket.io-client';
+
+const socket = io(process.env.REACT_APP_WS_URL, {
+  auth: { token: localStorage.getItem('authToken') }
+});
+
+// Listen for real-time updates
+socket.on('event_created', (event) => {
+  dispatch(addEvent(event));
+});
+
+socket.on('event_updated', (update) => {
+  dispatch(updateEvent(update));
+});
+```
+
+## Infrastructure and Deployment
+
+### Docker Containerization
+
+**Why Docker?**
+- **Consistency**: Same environment across development, staging, production
+- **Isolation**: Service isolation and dependency management
+- **Scalability**: Easy horizontal scaling
+- **Portability**: Run anywhere with container runtime
+
+**Multi-stage Dockerfile:**
+```dockerfile
+# Build stage
+FROM node:18-alpine AS builder
+WORKDIR /app
+COPY package*.json ./
+RUN npm ci --only=production
+
+# Production stage
+FROM node:18-alpine AS production
+WORKDIR /app
+COPY --from=builder /app/node_modules ./node_modules
+COPY . .
+EXPOSE 3000
+CMD ["npm", "start"]
+```
+
+### Docker Compose for Development
+
+**Development Setup:**
+```yaml
+version: '3.8'
+services:
+  api:
+    build: ./backend
+    ports:
+      - "3000:3000"
+    environment:
+      - NODE_ENV=development
+      - MONGODB_URI=mongodb://mongodb:27017
+    depends_on:
+      - mongodb
+
+  frontend:
+    build: ./frontend
+    ports:
+      - "3001:3000"
+
+  mongodb:
+    image: mongo:6.0
+    ports:
+      - "27017:27017"
+    volumes:
+      - mongodb_data:/data/db
+
+  ai-service:
+    build: ./ai-service
+    ports:
+      - "8000:8000"
+```
+
+## Security Architecture
+
+### Authentication & Authorization
+
+**JWT Token Structure:**
+```typescript
+interface JWTPayload {
+  userId: string;
+  companyId: string;
+  role: UserRole;
+  iat: number;
+  exp: number;
+}
+```
+
+**API Key Validation:**
+```typescript
+// Middleware for API key validation
+const validateApiKey = async (req, res, next) => {
+  const apiKey = req.headers['x-api-key'];
+  const company = await Company.findOne({ apiKey });
+
+  if (!company) {
+    return res.status(403).json({ error: 'Invalid API key' });
+  }
+
+  req.company = company;
+  next();
+};
+```
+
+### Data Security
+
+**Encryption:**
+- **At Rest**: MongoDB field-level encryption for sensitive data
+- **In Transit**: TLS 1.3 for all communications
+- **Passwords**: bcrypt with salt rounds
+- **API Keys**: SHA-256 hashed in logs
+
+**Access Control:**
+- **RBAC**: Role-based permissions per endpoint
+- **Company Isolation**: Automatic company scoping on all queries
+- **Field-Level Security**: Sensitive fields filtered by role
+
+## Monitoring and Observability
+
+### Application Monitoring
+
+**Winston Logging:**
+```typescript
+import winston from 'winston';
+
+const logger = winston.createLogger({
+  level: 'info',
+  format: winston.format.json(),
+  transports: [
+    new winston.transports.File({ filename: 'error.log', level: 'error' }),
+    new winston.transports.File({ filename: 'combined.log' })
+  ]
+});
+```
+
+**Performance Monitoring:**
+- **Response Times**: Middleware to track API response times
+- **Error Rates**: Centralized error tracking and alerting
+- **Resource Usage**: Memory, CPU, and database connection monitoring
+
+### Health Checks
+
+**Service Health Endpoints:**
+```typescript
+// Health check endpoint
+app.get('/health', async (req, res) => {
+  const dbStatus = await checkDatabaseConnection();
+  const servicesStatus = await checkServiceDependencies();
+
+  res.json({
+    status: 'ok',
+    timestamp: new Date().toISOString(),
+    services: {
+      database: dbStatus,
+      redis: servicesStatus.redis,
+      ai_service: servicesStatus.ai
+    }
+  });
+});
+```
+
+## Development Tools and Practices
+
+### Code Quality
+
+**ESLint Configuration:**
+```json
+{
+  "extends": [
+    "@typescript-eslint/recommended",
+    "prettier"
+  ],
+  "parser": "@typescript-eslint/parser",
+  "rules": {
+    "@typescript-eslint/no-unused-vars": "error",
+    "@typescript-eslint/explicit-function-return-type": "warn"
+  }
+}
+```
+
+### Testing Strategy
+
+**Testing Pyramid:**
+- **Unit Tests**: Jest for component testing (80%)
+- **Integration Tests**: API endpoint testing (15%)
+- **E2E Tests**: Cypress for user workflow testing (5%)
+
+**Test Example:**
+```typescript
+describe('Event Service', () => {
+  it('should create event from report', async () => {
+    const report = await createTestReport();
+    const event = await eventService.createFromReport(report);
+
+    expect(event.reports).toContain(report._id);
+    expect(event.status).toBe('active');
+  });
+});
+```
+
+## Performance Optimization
+
+### Database Optimization
+
+**Indexing Strategy:**
+```javascript
+// Optimized indexes for common queries
+Event.collection.createIndex({ companyId: 1, status: 1, createdAt: -1 });
+Event.collection.createIndex({ companyId: 1, location: '2dsphere' });
+Event.collection.createIndex({ companyId: 1, 'reports.0': 1 });
+```
+
+**Query Optimization:**
+- **Pagination**: Cursor-based pagination for large datasets
+- **Projection**: Only fetch required fields
+- **Aggregation Pipeline**: Efficient data processing
+
+### Caching Strategy
+
+**Redis Implementation:**
+```typescript
+import { createClient } from 'redis';
+
+const redis = createClient();
+
+// Cache event types (frequently accessed)
+app.get('/api/event-types', cache('5m'), async (req, res) => {
+  const types = await EventType.find({ isActive: true });
+  res.json(types);
+});
+```
+
+## Future Technology Considerations
+
+### Potential Upgrades
+
+**API Gateway:**
+- **Kong**: More advanced API gateway features
+- **Express Gateway**: Lighter alternative with good plugin ecosystem
+
+**Database:**
+- **MongoDB Atlas**: Managed cloud database with advanced features
+- **PostgreSQL**: Consider for complex relational data if needed
+
+**Real-time:**
+- **Socket.io Clusters**: For horizontal scaling
+- **Kafka**: Event streaming for large-scale deployments
+
+**Deployment:**
+- **Kubernetes**: Container orchestration for production scaling
+- **Istio**: Service mesh for advanced traffic management
+
+This technology stack provides a solid foundation for the Event Monitoring Platform while maintaining flexibility for future enhancements and scaling requirements.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/03-ARCHITECTURE-DIAGRAMS.md b/event-monitoring-mvp-architecture/team-documentation/03-ARCHITECTURE-DIAGRAMS.md
index ad7ff2d..4ff2266 100644
--- a/event-monitoring-mvp-architecture/team-documentation/03-ARCHITECTURE-DIAGRAMS.md
+++ b/event-monitoring-mvp-architecture/team-documentation/03-ARCHITECTURE-DIAGRAMS.md
@@ -1,591 +1,524 @@
-# System Architecture & Design Patterns
-
-## ğŸ—ï¸ Architecture Overview
-
-Our Event Monitoring MVP follows a **microservices architecture** with clear separation of concerns. This design makes the system scalable, maintainable, and allows different teams to work on different parts independently.
-
-## ğŸ¯ Architectural Principles
-
-### 1. **Separation of Concerns**
-Each service has one primary responsibility:
-- **Frontend**: User interface and user experience
-- **Backend**: Business logic and data management  
-- **AI Service**: Computer vision and event detection
-- **Database**: Data persistence and retrieval
-
-### 2. **Loose Coupling**
-Services communicate through well-defined APIs, not direct code dependencies:
-```
-Frontend â†â†’ REST API â†â†’ Backend â†â†’ MongoDB
-                â†•
-         AI Service â†â†’ WebSocket
-```
-
-### 3. **High Cohesion**
-Related functionality is grouped together within each service.
-
-### 4. **Scalability**
-Each service can be scaled independently based on demand.
-
-## ğŸ›ï¸ Detailed Architecture Diagram
-
-```
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                           USER LAYER                                â”‚
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚  ğŸ‘¤ Security Guards    ğŸ‘¤ Managers    ğŸ‘¤ Administrators             â”‚
-â”‚           â”‚                 â”‚                 â”‚                     â”‚
-â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
-â”‚                             â”‚                                       â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-                              â”‚ HTTPS
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                      PRESENTATION LAYER                              â”‚
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚                    React Frontend (Port 3000)                      â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚  Dashboard  â”‚ â”‚   Events    â”‚ â”‚   Cameras   â”‚ â”‚   MapView   â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚  LiveView   â”‚ â”‚   Profile   â”‚ â”‚  Settings   â”‚ â”‚    Login    â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚                             â”‚                                       â”‚
-â”‚  State Management: Redux    â”‚ Real-time: Socket.IO                  â”‚
-â”‚  HTTP Clients: React Query â”‚ UI Components: Material-UI              â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-                              â”‚ REST API + WebSocket
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                        APPLICATION LAYER                             â”‚
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚                   Node.js Backend (Port 5000)                      â”‚
-â”‚                                                                     â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚    Auth     â”‚ â”‚   Camera    â”‚ â”‚    Event    â”‚ â”‚    User     â”‚    â”‚
-â”‚  â”‚ Controller  â”‚ â”‚ Controller  â”‚ â”‚ Controller  â”‚ â”‚ Controller  â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚         â”‚               â”‚               â”‚               â”‚           â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚ Auth Routes â”‚ â”‚Camera Routesâ”‚ â”‚Event Routes â”‚ â”‚ User Routes â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚                             â”‚                                       â”‚
-â”‚  Middleware: JWT Auth       â”‚ Real-time: Socket.IO Server           â”‚
-â”‚  Validation & Error Handlingâ”‚ API Framework: Express.js             â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-                              â”‚ HTTP Requests
-                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-                    â”‚         â”‚         â”‚
-                    â–¼         â”‚         â–¼
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚      AI SERVICE             â”‚â”‚ â”‚            DATA LAYER                   â”‚
-â”‚   Python (Port 8000)       â”‚â”‚ â”‚                                         â”‚
-â”‚                             â”‚â”‚ â”‚         MongoDB (Port 27017)            â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚â”‚ â”‚                                         â”‚
-â”‚  â”‚   YOLOv8 Model      â”‚    â”‚â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚  Object Detection   â”‚    â”‚â”‚ â”‚  â”‚    Users    â”‚ â”‚     Cameras     â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚â”‚ â”‚  â”‚ Collection  â”‚ â”‚   Collection    â”‚    â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚  â”‚   OpenCV Video      â”‚    â”‚â”‚ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚    Processing       â”‚    â”‚â”‚ â”‚  â”‚   Events    â”‚ â”‚     Sessions    â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚â”‚ â”‚  â”‚ Collection  â”‚ â”‚   Collection    â”‚    â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚â”‚ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚  â”‚   FastAPI Server    â”‚    â”‚â”‚ â”‚                                         â”‚
-â”‚  â”‚   REST Endpoints    â”‚    â”‚â”‚ â”‚  Indexes: User email, Camera location   â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚â”‚ â”‚  Sharding: Ready for horizontal scale   â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-                              â”‚
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                      INFRASTRUCTURE LAYER                            â”‚
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚                         Docker Containers                           â”‚
-â”‚                                                                     â”‚
-â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
-â”‚  â”‚  frontend   â”‚ â”‚   backend   â”‚ â”‚ ai-service  â”‚ â”‚    mongo    â”‚    â”‚
-â”‚  â”‚ container   â”‚ â”‚  container  â”‚ â”‚  container  â”‚ â”‚  container  â”‚    â”‚
-â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
-â”‚                                                                     â”‚
-â”‚  Network: event-monitoring-network                                  â”‚
-â”‚  Volumes: mongo_data, ai_models                                     â”‚
-â”‚  Environment: .env files for configuration                          â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-                              â”‚
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚                        EXTERNAL LAYER                               â”‚
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚                                                                     â”‚
-â”‚  ğŸ“¹ RTSP Cameras  ğŸŒ Mapbox API  ğŸ“§ Email Service  ğŸ“± SMS Service    â”‚
-â”‚                                                                     â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-```
-
-## ğŸ”„ Data Flow Patterns
-
-### 1. **User Authentication Flow**
-```
-User Input â†’ Frontend â†’ Backend â†’ MongoDB â†’ JWT â†’ Frontend â†’ Local Storage
-```
-
-**Detailed Steps:**
-1. User enters credentials in Login component
-2. Frontend sends POST request to `/api/auth/login`
-3. Backend validates credentials against MongoDB users collection
-4. Backend generates JWT token with user info
-5. Frontend receives token and stores in localStorage
-6. Frontend redirects to Dashboard
-7. All subsequent requests include JWT in Authorization header
-
-### 2. **Real-Time Event Detection Flow**
-```
-Camera Stream â†’ AI Service â†’ Backend â†’ MongoDB â†’ Socket.IO â†’ Frontend
-```
-
-**Detailed Steps:**
-1. Camera sends RTSP stream to AI Service
-2. AI Service processes frame with YOLOv8
-3. Detection found â†’ AI Service sends HTTP POST to Backend
-4. Backend validates and stores event in MongoDB
-5. Backend broadcasts event via Socket.IO to all connected clients
-6. Frontend receives real-time event and updates UI
-7. User sees instant notification and updated event list
-
-### 3. **Camera Management Flow**
-```
-User Action â†’ Frontend â†’ Backend â†’ MongoDB â†’ Socket.IO â†’ All Clients
-```
-
-**Detailed Steps:**
-1. User adds/modifies camera in Camera component
-2. Frontend sends API request to backend
-3. Backend validates and updates camera in MongoDB
-4. Backend broadcasts camera status change via Socket.IO
-5. All connected clients update their camera displays
-6. Map view updates with new camera location
-
-## ğŸ—ï¸ Design Patterns Used
-
-### 1. **Model-View-Controller (MVC) - Backend**
-
-#### **Models** (`/backend/src/models/`)
-Define data structure and business rules:
-```javascript
-// User.ts - Defines user data structure
-export interface IUser {
-  _id: string;
-  username: string;
-  email: string;
-  passwordHash: string;
-  role: UserRole;
-  profile: UserProfile;
-  createdAt: Date;
-  lastLoginAt?: Date;
-}
-
-export const UserSchema = new mongoose.Schema({
-  username: { type: String, required: true, unique: true },
-  email: { type: String, required: true, unique: true },
-  passwordHash: { type: String, required: true },
-  role: { type: String, enum: ['admin', 'manager', 'guard'], default: 'guard' },
-  // ... more fields
-});
-```
-
-#### **Views** (API Responses)
-Controllers format data for frontend consumption:
-```javascript
-// Clean user data for frontend (no password!)
-const userResponse = {
-  id: user._id,
-  username: user.username,
-  email: user.email,
-  role: user.role,
-  profile: user.profile
-};
-```
-
-#### **Controllers** (`/backend/src/controllers/`)
-Handle business logic and coordinate between models and views:
-```javascript
-// userController.ts
-export const getCurrentUser = async (req: AuthenticatedRequest, res: Response) => {
-  try {
-    const user = await User.findById(req.userId).select('-passwordHash');
-    if (!user) {
-      return res.status(404).json({ error: 'User not found' });
-    }
-    res.json(user);
-  } catch (error) {
-    res.status(500).json({ error: 'Server error' });
-  }
-};
-```
-
-### 2. **Component-Based Architecture - Frontend**
-
-#### **Container Components** (Smart Components)
-Manage state and data:
-```javascript
-// Dashboard.tsx - Container component
-function Dashboard() {
-  const { data: cameras } = useQuery(['cameras'], fetchCameras);
-  const { data: events } = useQuery(['events'], fetchRecentEvents);
-  const dispatch = useDispatch();
-  
-  return (
-    <Layout>
-      <DashboardStats cameras={cameras} />
-      <RecentEvents events={events} />
-      <QuickActions onRefresh={() => dispatch(refreshData())} />
-    </Layout>
-  );
-}
-```
-
-#### **Presentation Components** (Dumb Components)
-Just display data:
-```javascript
-// DashboardStats.tsx - Presentation component
-interface DashboardStatsProps {
-  cameras: Camera[];
-}
-
-function DashboardStats({ cameras }: DashboardStatsProps) {
-  const onlineCount = cameras.filter(c => c.status === 'online').length;
-  
-  return (
-    <Grid container spacing={3}>
-      <Grid item xs={12} sm={6} md={3}>
-        <StatCard title="Total Cameras" value={cameras.length} />
-      </Grid>
-      <Grid item xs={12} sm={6} md={3}>
-        <StatCard title="Online" value={onlineCount} color="success" />
-      </Grid>
-    </Grid>
-  );
-}
-```
-
-### 3. **Repository Pattern - Data Access**
-
-#### **Database Layer Abstraction**
-```javascript
-// database.ts - Repository pattern
-export class UserRepository {
-  async findByEmail(email: string): Promise<IUser | null> {
-    return User.findOne({ email }).exec();
-  }
-  
-  async create(userData: CreateUserData): Promise<IUser> {
-    const user = new User(userData);
-    return user.save();
-  }
-  
-  async updateLastLogin(userId: string): Promise<void> {
-    await User.findByIdAndUpdate(userId, { lastLoginAt: new Date() });
-  }
-}
-
-// Usage in controller
-const userRepo = new UserRepository();
-const user = await userRepo.findByEmail(email);
-```
-
-### 4. **Observer Pattern - Real-Time Updates**
-
-#### **Socket.IO Event System**
-```javascript
-// Backend - Event broadcasting
-class EventNotificationService {
-  private io: SocketIOServer;
-  
-  broadcastNewEvent(event: IEvent) {
-    this.io.emit('new-event', {
-      id: event._id,
-      type: event.type,
-      cameraId: event.cameraId,
-      timestamp: event.createdAt,
-      severity: event.severity
-    });
-  }
-  
-  broadcastCameraStatus(cameraId: string, status: string) {
-    this.io.emit('camera-status-changed', { cameraId, status });
-  }
-}
-
-// Frontend - Event listening
-useEffect(() => {
-  socket.on('new-event', (event) => {
-    dispatch(addEvent(event));
-    showNotification(`${event.type} detected!`);
-  });
-  
-  socket.on('camera-status-changed', ({ cameraId, status }) => {
-    dispatch(updateCameraStatus({ cameraId, status }));
-  });
-}, []);
-```
-
-### 5. **Factory Pattern - Service Creation**
-
-#### **Service Factory for AI Models**
-```python
-# ai-service/src/services/model_factory.py
-class ModelFactory:
-    @staticmethod
-    def create_detector(model_type: str):
-        if model_type == 'yolov8':
-            return YOLOv8Detector()
-        elif model_type == 'faster_rcnn':
-            return FasterRCNNDetector()
-        else:
-            raise ValueError(f"Unknown model type: {model_type}")
-
-# Usage
-detector = ModelFactory.create_detector('yolov8')
-results = detector.detect(frame)
-```
-
-### 6. **Middleware Pattern - Request Processing**
-
-#### **Authentication Middleware**
-```javascript
-// auth.ts middleware
-export const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
-  const authHeader = req.headers['authorization'];
-  const token = authHeader && authHeader.split(' ')[1];
-  
-  if (!token) {
-    return res.status(401).json({ error: 'Access token required' });
-  }
-  
-  jwt.verify(token, process.env.JWT_SECRET!, (err, decoded) => {
-    if (err) {
-      return res.status(403).json({ error: 'Invalid token' });
-    }
-    req.userId = (decoded as any).userId;
-    next();
-  });
-};
-
-// Usage in routes
-router.get('/cameras', authenticateToken, getCameras);
-```
-
-## ğŸ“Š Database Design
-
-### **Collection Schemas**
-
-#### Users Collection
-```javascript
-{
-  _id: ObjectId,
-  username: String (unique, indexed),
-  email: String (unique, indexed),
-  passwordHash: String,
-  role: String ('admin' | 'manager' | 'guard'),
-  profile: {
-    firstName: String,
-    lastName: String,
-    department: String,
-    phoneNumber: String
-  },
-  settings: {
-    emailNotifications: Boolean,
-    smsNotifications: Boolean,
-    theme: String ('light' | 'dark')
-  },
-  createdAt: Date,
-  lastLoginAt: Date
-}
-```
-
-#### Cameras Collection
-```javascript
-{
-  _id: ObjectId,
-  name: String (indexed),
-  location: {
-    latitude: Number,
-    longitude: Number,
-    address: String,
-    zone: String
-  },
-  streamUrl: String,
-  status: String ('online' | 'offline' | 'maintenance'),
-  settings: {
-    resolution: String,
-    frameRate: Number,
-    nightVision: Boolean,
-    motionDetection: Boolean
-  },
-  aiEnabled: Boolean,
-  lastSeen: Date,
-  createdAt: Date,
-  createdBy: ObjectId (ref: 'User')
-}
-```
-
-#### Events Collection
-```javascript
-{
-  _id: ObjectId,
-  type: String ('person_detected' | 'vehicle_detected' | 'motion_detected'),
-  cameraId: ObjectId (ref: 'Camera', indexed),
-  severity: String ('low' | 'medium' | 'high' | 'critical'),
-  confidence: Number (0-1),
-  boundingBox: {
-    x: Number,
-    y: Number,
-    width: Number,
-    height: Number
-  },
-  metadata: {
-    objectCount: Number,
-    detectedClasses: [String],
-    frameNumber: Number
-  },
-  status: String ('pending' | 'acknowledged' | 'resolved'),
-  acknowledgedBy: ObjectId (ref: 'User'),
-  acknowledgedAt: Date,
-  createdAt: Date (indexed)
-}
-```
-
-#### Sessions Collection (for JWT blacklisting)
-```javascript
-{
-  _id: ObjectId,
-  userId: ObjectId (ref: 'User', indexed),
-  tokenHash: String,
-  expiresAt: Date (indexed, TTL),
-  createdAt: Date,
-  userAgent: String,
-  ipAddress: String
-}
-```
-
-### **Database Indexes for Performance**
-```javascript
-// Critical indexes for query performance
-db.users.createIndex({ email: 1 }, { unique: true });
-db.users.createIndex({ username: 1 }, { unique: true });
-
-db.cameras.createIndex({ name: 1 });
-db.cameras.createIndex({ "location.zone": 1 });
-db.cameras.createIndex({ status: 1 });
-
-db.events.createIndex({ cameraId: 1, createdAt: -1 });
-db.events.createIndex({ type: 1, createdAt: -1 });
-db.events.createIndex({ severity: 1, status: 1 });
-db.events.createIndex({ createdAt: -1 }); // Recent events
-
-db.sessions.createIndex({ userId: 1 });
-db.sessions.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL
-```
-
-## ğŸ”’ Security Architecture
-
-### **Defense in Depth Strategy**
-
-#### 1. **Frontend Security**
-- JWT token stored securely (httpOnly cookies in production)
-- Input validation and sanitization
-- XSS prevention with Content Security Policy
-- CSRF protection for state-changing operations
-
-#### 2. **API Security**
-- JWT authentication on all protected routes
-- Rate limiting to prevent abuse
-- Input validation with Joi/Yup schemas
-- SQL injection prevention (using ODM)
-- CORS configuration for allowed origins
-
-#### 3. **Database Security**
-- MongoDB authentication enabled
-- Database connections over encrypted channels
-- Sensitive data encryption at rest
-- Regular security updates and patches
-
-#### 4. **Infrastructure Security**
-- Docker containers with minimal attack surface
-- Network segmentation with Docker networks
-- Environment variables for sensitive configuration
-- SSL/TLS encryption for all external communications
-
-### **Authentication & Authorization Flow**
-```
-1. User Login â†’ Credentials validation â†’ JWT generation
-2. JWT contains: { userId, role, exp, iat }
-3. Every API request â†’ JWT verification â†’ Role-based access
-4. Roles: 'admin' (full access), 'manager' (read/write), 'guard' (read-only)
-```
-
-## ğŸš€ Scalability Considerations
-
-### **Horizontal Scaling Strategy**
-
-#### 1. **Stateless Services**
-- No server-side sessions (JWT tokens)
-- Each request contains all necessary information
-- Services can be replicated without shared state
-
-#### 2. **Database Scaling**
-- MongoDB sharding by camera location/zone
-- Read replicas for heavy read workloads
-- Separate analytics database for historical data
-
-#### 3. **Caching Strategy**
-- Redis for session management and real-time data
-- Browser caching for static assets
-- API response caching for frequently requested data
-
-#### 4. **Load Balancing**
-```
-Internet â†’ Load Balancer â†’ Multiple Backend Instances
-                      â†’ Multiple AI Service Instances
-                      â†’ MongoDB Cluster
-```
-
-### **Performance Optimization**
-
-#### 1. **Frontend Optimization**
-- Code splitting for faster initial load
-- Lazy loading of components
-- Image compression and optimization
-- CDN for static assets
-
-#### 2. **Backend Optimization**
-- Database query optimization
-- Connection pooling
-- Asynchronous processing for heavy operations
-- API response compression
-
-#### 3. **AI Service Optimization**
-- Model optimization for inference speed
-- GPU acceleration for video processing
-- Batch processing of multiple streams
-- Result caching for recent frames
-
-## ğŸ”„ DevOps & Deployment Architecture
-
-### **Environment Strategy**
-```
-Development â†’ Testing â†’ Staging â†’ Production
-     â†“           â†“         â†“          â†“
-Docker Compose  K8s    K8s Cluster  K8s Cluster
-Local DB        Test DB   Stage DB   Prod DB
-```
-
-### **CI/CD Pipeline**
-```
-Code Commit â†’ GitHub Actions â†’ Tests â†’ Build â†’ Deploy
-                    â†“
-              Unit Tests + Integration Tests
-                    â†“
-              Docker Image Build
-                    â†“
-              Security Scanning
-                    â†“
-              Automated Deployment
-```
-
-This architecture provides a robust, scalable, and maintainable foundation for our Event Monitoring MVP. Each pattern and design decision supports our goals of reliability, performance, and developer productivity while maintaining security and scalability for future growth.
\ No newline at end of file
+# Architecture Diagrams
+
+This document contains the key architectural diagrams for the Event Monitoring and Management Platform, illustrating the system design, data flows, and component interactions.
+
+## Table of Contents
+1. [System Context Diagram](#system-context-diagram)
+2. [Container Architecture](#container-architecture)
+3. [Component Architecture](#component-architecture)
+4. [Data Flow Diagrams](#data-flow-diagrams)
+5. [Multi-Tenant Architecture](#multi-tenant-architecture)
+6. [Mobile Integration Flow](#mobile-integration-flow)
+7. [Real-time Communication](#real-time-communication)
+
+## System Context Diagram
+
+```mermaid
+graph TB
+    subgraph "External Systems"
+        Citizen[Citizen Mobile App]
+        Responder[First Responder App]
+        Cameras[IP Cameras]
+        VMS[Video Management System]
+    end
+
+    subgraph "Event Monitoring Platform"
+        API[API Gateway]
+        Auth[Authentication Service]
+        Events[Event Management]
+        Reports[Report Processing]
+        Users[User Management]
+        Companies[Company Management]
+        AI[AI Detection Service]
+        Dashboard[Web Dashboard]
+    end
+
+    subgraph "Infrastructure"
+        MongoDB[(MongoDB)]
+        Redis[(Redis Cache)]
+        FileStore[(File Storage)]
+    end
+
+    Citizen --> API
+    Responder --> API
+    Cameras --> AI
+    VMS --> API
+
+    API --> Auth
+    API --> Events
+    API --> Reports
+    API --> Users
+    API --> Companies
+
+    Events --> MongoDB
+    Reports --> MongoDB
+    Users --> MongoDB
+    Companies --> MongoDB
+
+    AI --> Events
+    Dashboard --> API
+
+    Events --> Redis
+    Reports --> FileStore
+```
+
+## Container Architecture
+
+```mermaid
+graph TB
+    subgraph "Client Layer"
+        Web[Web Browser<br/>React SPA]
+        Mobile[Citizen/Responder<br/>Mobile Apps]
+    end
+
+    subgraph "API Gateway Layer"
+        Gateway[API Gateway<br/>Express.js]
+        Auth[Auth Middleware<br/>JWT/API Keys]
+        RateLimit[Rate Limiting<br/>Redis]
+        CORS[CORS Handling]
+    end
+
+    subgraph "Service Layer"
+        EventSvc[Event Service<br/>Event Mgmt/Aggregation]
+        ReportSvc[Report Service<br/>Submission/Validation]
+        UserSvc[User Service<br/>Multi-tenant Users]
+        CompanySvc[Company Service<br/>Tenant Management]
+        AISvc[AI Service<br/>Detection Processing]
+    end
+
+    subgraph "Data Layer"
+        MongoDB[(MongoDB<br/>Primary Database)]
+        Redis[(Redis<br/>Cache/Session Store)]
+        S3[(Object Storage<br/>Files/Media)]
+    end
+
+    Web --> Gateway
+    Mobile --> Gateway
+
+    Gateway --> Auth
+    Gateway --> RateLimit
+    Gateway --> CORS
+
+    Auth --> EventSvc
+    Auth --> ReportSvc
+    Auth --> UserSvc
+    Auth --> CompanySvc
+
+    EventSvc --> AISvc
+
+    EventSvc --> MongoDB
+    ReportSvc --> MongoDB
+    UserSvc --> MongoDB
+    CompanySvc --> MongoDB
+
+    EventSvc --> Redis
+    ReportSvc --> S3
+```
+
+## Component Architecture
+
+```mermaid
+graph TB
+    subgraph "Event Management Component"
+        EventController[Event Controller<br/>REST Endpoints]
+        EventService[Event Service<br/>Business Logic]
+        EventModel[Event Model<br/>Mongoose Schema]
+        EventValidation[Event Validation<br/>Joi Schemas]
+    end
+
+    subgraph "Report Processing Component"
+        ReportController[Report Controller<br/>REST Endpoints]
+        ReportService[Report Service<br/>Business Logic]
+        ReportModel[Report Model<br/>Mongoose Schema]
+        ReportValidation[Report Validation<br/>Joi Schemas]
+    end
+
+    subgraph "Authentication Component"
+        AuthController[Auth Controller<br/>Login/Register]
+        AuthService[Auth Service<br/>JWT/API Keys]
+        AuthMiddleware[Auth Middleware<br/>Request Validation]
+        SessionStore[Session Store<br/>Redis]
+    end
+
+    subgraph "Real-time Component"
+        WebSocketServer[WebSocket Server<br/>Socket.io]
+        EventEmitter[Event Emitter<br/>Real-time Updates]
+        NotificationSvc[Notification Service<br/>Push Messages]
+    end
+
+    EventController --> EventService
+    EventService --> EventModel
+    EventService --> EventValidation
+
+    ReportController --> ReportService
+    ReportService --> ReportModel
+    ReportService --> ReportValidation
+
+    AuthController --> AuthService
+    AuthService --> AuthMiddleware
+    AuthService --> SessionStore
+
+    WebSocketServer --> EventEmitter
+    EventEmitter --> NotificationSvc
+
+    EventService -.-> EventEmitter
+    ReportService -.-> EventEmitter
+```
+
+## Data Flow Diagrams
+
+### Event Creation Flow
+
+```mermaid
+sequenceDiagram
+    participant Citizen as Citizen App
+    participant API as API Gateway
+    participant ReportSvc as Report Service
+    participant EventSvc as Event Service
+    participant DB as MongoDB
+    participant WS as WebSocket
+
+    Citizen->>API: POST /api/mobile/reports
+    API->>API: Validate API Key
+    API->>ReportSvc: Create Report
+    ReportSvc->>DB: Save Report
+    ReportSvc->>EventSvc: Check Auto-Creation Rules
+    EventSvc->>DB: Create Event (if needed)
+    EventSvc->>DB: Link Report to Event
+    EventSvc->>WS: Broadcast Event Update
+    WS->>Dashboard: Real-time Update
+    API->>Citizen: Report Created Response
+```
+
+### Multi-Tenant Data Isolation
+
+```mermaid
+graph TD
+    subgraph "Company A (API Key: abc123)"
+        A_Users[(Users<br/>companyId: A)]
+        A_Events[(Events<br/>companyId: A)]
+        A_Reports[(Reports<br/>companyId: A)]
+        A_Cameras[(Cameras<br/>companyId: A)]
+    end
+
+    subgraph "Company B (API Key: def456)"
+        B_Users[(Users<br/>companyId: B)]
+        B_Events[(Events<br/>companyId: B)]
+        B_Reports[(Reports<br/>companyId: B)]
+        B_Cameras[(Cameras<br/>companyId: B)]
+    end
+
+    subgraph "Shared/Global Data"
+        EventTypes[(Event Types<br/>companyId: null)]
+        GlobalSettings[(Global Settings)]
+    end
+
+    API[API Gateway] --> A_Users
+    API --> A_Events
+    API --> A_Reports
+    API --> A_Cameras
+
+    API --> B_Users
+    API --> B_Events
+    API --> B_Reports
+    API --> B_Cameras
+
+    API --> EventTypes
+    API --> GlobalSettings
+```
+
+## Multi-Tenant Architecture
+
+```mermaid
+graph TB
+    subgraph "Tenant Isolation Layers"
+        APIKey[API Key Validation<br/>X-API-Key Header]
+        CompanyCtx[Company Context<br/>Request.company]
+        DataFilter[Data Filtering<br/>companyId: {$eq: ctx.companyId}]
+        Permission[Permission Check<br/>Role + Company Scope]
+    end
+
+    subgraph "Database Collections"
+        Companies[(Companies)]
+        Users[(Users<br/>companyId indexed)]
+        Events[(Events<br/>companyId indexed)]
+        Reports[(Reports<br/>companyId indexed)]
+        Cameras[(Cameras<br/>companyId indexed)]
+        EventTypes[(Event Types<br/>companyId nullable)]
+    end
+
+    APIKey --> CompanyCtx
+    CompanyCtx --> DataFilter
+    CompanyCtx --> Permission
+
+    DataFilter --> Users
+    DataFilter --> Events
+    DataFilter --> Reports
+    DataFilter --> Cameras
+
+    Permission --> Companies
+    Permission --> EventTypes
+```
+
+## Mobile Integration Flow
+
+```mermaid
+sequenceDiagram
+    participant Mobile as Mobile App
+    participant API as API Gateway
+    participant Auth as Auth Service
+    participant ReportSvc as Report Service
+    participant EventSvc as Event Service
+    participant DB as Database
+
+    Mobile->>API: Request with X-API-Key
+    API->>Auth: Validate API Key
+    Auth->>DB: Lookup Company
+    Auth->>API: Company Context
+
+    Mobile->>API: POST /api/mobile/reports
+    API->>ReportSvc: Process Report
+    ReportSvc->>DB: Validate Event Type
+    ReportSvc->>DB: Save Report
+    ReportSvc->>EventSvc: Check Auto-Creation
+    EventSvc->>DB: Create/Link Event
+    EventSvc->>API: Success Response
+    API->>Mobile: Report ID + Event Status
+```
+
+## Real-time Communication
+
+```mermaid
+graph TD
+    subgraph "WebSocket Architecture"
+        Client[Web Dashboard<br/>Socket.io Client]
+        Gateway[API Gateway<br/>Socket.io Server]
+        Redis[Redis Adapter<br/>Cluster Support]
+        EventBus[Event Bus<br/>Internal Events]
+    end
+
+    subgraph "Event Types"
+        EventCreated[EVENT_CREATED<br/>New incident]
+        EventUpdated[EVENT_UPDATED<br/>Status/location change]
+        ReportSubmitted[REPORT_SUBMITTED<br/>New report]
+        LocationUpdate[LOCATION_UPDATE<br/>Responder tracking]
+        Notification[NOTIFICATION<br/>System alerts]
+    end
+
+    subgraph "Broadcast Groups"
+        CompanyRoom[Company Room<br/>company_{id}]
+        UserRoom[User Room<br/>user_{id}]
+        GlobalRoom[Global Room<br/>system]
+    end
+
+    Client --> Gateway
+    Gateway --> Redis
+    Gateway --> EventBus
+
+    EventBus --> EventCreated
+    EventBus --> EventUpdated
+    EventBus --> ReportSubmitted
+    EventBus --> LocationUpdate
+    EventBus --> Notification
+
+    EventCreated --> CompanyRoom
+    EventUpdated --> CompanyRoom
+    ReportSubmitted --> CompanyRoom
+    LocationUpdate --> UserRoom
+    Notification --> GlobalRoom
+```
+
+## Database Schema Relationships
+
+```mermaid
+erDiagram
+    Company ||--o{ User : has
+    Company ||--o{ Event : owns
+    Company ||--o{ Report : owns
+    Company ||--o{ Camera : owns
+    Company ||--o{ EventType : "may have custom"
+
+    EventType ||--o{ Event : categorizes
+    EventType ||--o{ Report : categorizes
+
+    Event ||--o{ Report : "aggregates"
+    Event }o--o{ User : "assigned to"
+
+    User ||--o{ Report : submits
+    User ||--o{ Event : "may create"
+
+    Camera ||--o{ Report : generates
+
+    Event {
+        ObjectId _id
+        ObjectId companyId
+        ObjectId eventTypeId
+        string title
+        string status
+        string priority
+        Point location
+        ObjectIdArray reports
+        ObjectId assignedTo
+        Date createdAt
+    }
+
+    Report {
+        ObjectId _id
+        ObjectId companyId
+        ObjectId eventId
+        ObjectId reporterId
+        string reportType
+        string title
+        string description
+        Point location
+        ObjectIdArray attachments
+        Date createdAt
+    }
+
+    User {
+        ObjectId _id
+        ObjectId companyId
+        string email
+        string phone
+        string role
+        boolean isActive
+        Date lastLogin
+    }
+
+    Company {
+        ObjectId _id
+        string name
+        string apiKey
+        object subscription
+        object settings
+    }
+```
+
+## Deployment Architecture
+
+```mermaid
+graph TB
+    subgraph "Load Balancer"
+        Nginx[Nginx Reverse Proxy<br/>SSL Termination<br/>Rate Limiting]
+    end
+
+    subgraph "Application Layer"
+        API1[API Server 1<br/>Node.js]
+        API2[API Server 2<br/>Node.js]
+        API3[API Server 3<br/>Node.js]
+    end
+
+    subgraph "Service Layer"
+        AI1[AI Service 1<br/>Python]
+        AI2[AI Service 2<br/>Python]
+    end
+
+    subgraph "Data Layer"
+        MongoDB1[(MongoDB Primary)]
+        MongoDB2[(MongoDB Secondary)]
+        MongoDB3[(MongoDB Arbiter)]
+        Redis[(Redis Cluster)]
+    end
+
+    subgraph "Storage"
+        MinIO[MinIO S3<br/>File Storage]
+    end
+
+    Client[External Clients] --> Nginx
+    Nginx --> API1
+    Nginx --> API2
+    Nginx --> API3
+
+    API1 --> AI1
+    API2 --> AI2
+    API3 --> AI1
+
+    API1 --> MongoDB1
+    API2 --> MongoDB1
+    API3 --> MongoDB1
+
+    MongoDB1 --> MongoDB2
+    MongoDB2 --> MongoDB3
+
+    API1 --> Redis
+    API2 --> Redis
+    API3 --> Redis
+
+    API1 --> MinIO
+    API2 --> MinIO
+    API3 --> MinIO
+```
+
+## Security Architecture
+
+```mermaid
+graph TD
+    subgraph "Network Security"
+        WAF[Web Application Firewall<br/>ModSecurity]
+        DDoS[DDoS Protection<br/>CloudFlare]
+        Firewall[Network Firewall<br/>IP Whitelisting]
+    end
+
+    subgraph "Application Security"
+        Auth[Authentication<br/>JWT + API Keys]
+        Authz[Authorization<br/>RBAC + Company Scope]
+        InputVal[Input Validation<br/>Joi + Sanitization]
+        Encryption[Data Encryption<br/>TLS + Field Encryption]
+    end
+
+    subgraph "Data Security"
+        AccessCtrl[Access Control<br/>Query Filtering]
+        Audit[Audit Logging<br/>All Operations]
+        Backup[Encrypted Backups<br/>Daily Rotation]
+        Retention[Data Retention<br/>Compliance Rules]
+    end
+
+    WAF --> Auth
+    DDoS --> Auth
+    Firewall --> Auth
+
+    Auth --> Authz
+    Authz --> InputVal
+    InputVal --> Encryption
+
+    Encryption --> AccessCtrl
+    AccessCtrl --> Audit
+    Audit --> Backup
+    Backup --> Retention
+```
+
+## Performance Architecture
+
+```mermaid
+graph TD
+    subgraph "Caching Layers"
+        CDN[CDN<br/>Static Assets]
+        AppCache[Application Cache<br/>Redis]
+        DBCache[Database Cache<br/>MongoDB WiredTiger]
+    end
+
+    subgraph "Optimization Strategies"
+        ConnectionPool[Connection Pooling<br/>MongoDB]
+        QueryOptimization[Query Optimization<br/>Indexes + Aggregation]
+        Compression[Response Compression<br/>Gzip]
+        Pagination[Cursor Pagination<br/>Large Datasets]
+    end
+
+    subgraph "Monitoring"
+        APM[Application Performance<br/>New Relic]
+        Metrics[Custom Metrics<br/>Prometheus]
+        Alerts[Alerting<br/>PagerDuty]
+    end
+
+    CDN --> AppCache
+    AppCache --> DBCache
+
+    ConnectionPool --> QueryOptimization
+    QueryOptimization --> Compression
+    Compression --> Pagination
+
+    APM --> Metrics
+    Metrics --> Alerts
+```
+
+These diagrams provide a comprehensive view of the Event Monitoring Platform's architecture, showing how components interact, data flows through the system, and how multi-tenant isolation is maintained across all layers.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/04-DEVELOPMENT-WORKFLOW.md b/event-monitoring-mvp-architecture/team-documentation/04-DEVELOPMENT-WORKFLOW.md
index a7d1d3c..bafef9e 100644
--- a/event-monitoring-mvp-architecture/team-documentation/04-DEVELOPMENT-WORKFLOW.md
+++ b/event-monitoring-mvp-architecture/team-documentation/04-DEVELOPMENT-WORKFLOW.md
@@ -1,669 +1,595 @@
-# Development Workflow & Best Practices
-
-## ğŸš€ Getting Started: Your First Day
-
-### **Prerequisites Setup Checklist**
-Before you can start developing, ensure you have these tools installed:
-
-#### Required Software
-- [ ] **Node.js** (v18+) - [Download here](https://nodejs.org/)
-- [ ] **Python** (v3.9+) - [Download here](https://python.org/)
-- [ ] **Docker Desktop** - [Download here](https://docker.com/products/docker-desktop/)
-- [ ] **Git** - [Download here](https://git-scm.com/)
-- [ ] **VS Code** (recommended) - [Download here](https://code.visualstudio.com/)
-
-#### Recommended VS Code Extensions
-```json
-{
-  "recommendations": [
-    "ms-vscode.vscode-typescript-next",
-    "bradlc.vscode-tailwindcss",
-    "ms-python.python",
-    "ms-vscode.vscode-json",
-    "esbenp.prettier-vscode",
-    "ms-vscode.vscode-eslint",
-    "ms-azuretools.vscode-docker"
-  ]
-}
-```
-
-### **Repository Setup**
-```bash
-# 1. Clone the repository
-git clone https://github.com/your-team/event-monitoring-mvp.git
-cd event-monitoring-mvp
-
-# 2. Checkout your feature branch
-git checkout -b feature/your-name-first-task
-
-# 3. Install dependencies (all services)
-npm run install-all
-
-# 4. Start the development environment
-docker-compose up --build
-```
-
-### **Environment Configuration**
-Create environment files for each service:
-
-#### **Backend Environment** (`.env`)
-```bash
-# Database Configuration
-MONGO_URL=mongodb://localhost:27017/eventmonitoring_dev
-MONGO_TEST_URL=mongodb://localhost:27017/eventmonitoring_test
-
-# JWT Configuration
-JWT_SECRET=your-super-secret-jwt-key-change-in-production
-JWT_EXPIRES_IN=7d
-
-# Server Configuration
-PORT=5000
-NODE_ENV=development
-
-# External Services
-MAPBOX_API_KEY=your-mapbox-api-key
-EMAIL_SERVICE_URL=http://localhost:8001
-SMS_SERVICE_URL=http://localhost:8002
-
-# AI Service Configuration
-AI_SERVICE_URL=http://localhost:8000
-AI_SERVICE_API_KEY=your-ai-service-key
-```
-
-#### **Frontend Environment** (`.env`)
-```bash
-# API Configuration
-REACT_APP_API_URL=http://localhost:5000/api
-REACT_APP_SOCKET_URL=http://localhost:5000
-
-# External Services
-REACT_APP_MAPBOX_TOKEN=your-mapbox-token
-
-# Development Settings
-REACT_APP_ENVIRONMENT=development
-REACT_APP_LOG_LEVEL=debug
-```
-
-#### **AI Service Environment** (`.env`)
-```bash
-# Service Configuration
-PORT=8000
-HOST=0.0.0.0
-ENVIRONMENT=development
-
-# Model Configuration
-MODEL_PATH=/app/models/yolov8n.pt
-CONFIDENCE_THRESHOLD=0.5
-DEVICE=cpu  # or 'cuda' if you have GPU
-
-# Backend Integration
-BACKEND_URL=http://backend:5000
-API_KEY=your-ai-service-api-key
-```
-
-## ğŸ”„ Development Workflow
-
-### **Branch Strategy: GitFlow Simplified**
-
-#### **Branch Types**
-- **`main`** - Production-ready code only
-- **`develop`** - Latest development integration
-- **`feature/task-description`** - New features
-- **`bugfix/issue-description`** - Bug fixes
-- **`hotfix/critical-issue`** - Emergency production fixes
-
-#### **Workflow Steps**
-```bash
-# 1. Start with latest develop branch
-git checkout develop
-git pull origin develop
-
-# 2. Create your feature branch
-git checkout -b feature/add-camera-alerts
-
-# 3. Work on your changes
-# ... make changes to code ...
-
-# 4. Test your changes locally
-npm test
-docker-compose up --build
-
-# 5. Commit with descriptive messages
-git add .
-git commit -m "feat: add real-time camera offline alerts
-
-- Add Socket.IO listener for camera status changes
-- Update dashboard to show offline camera notifications
-- Add red indicator for offline cameras in camera list
-- Include unit tests for new notification system"
-
-# 6. Push to GitHub
-git push origin feature/add-camera-alerts
-
-# 7. Create Pull Request on GitHub
-# 8. Request code review from team members
-# 9. Address review feedback if needed
-# 10. Merge after approval
-```
-
-### **Commit Message Convention**
-We follow [Conventional Commits](https://conventionalcommits.org/) for clear commit history:
-
-```bash
-# Format: type(scope): description
-#
-# Types:
-feat:     # New feature
-fix:      # Bug fix
-docs:     # Documentation changes
-style:    # Code style changes (formatting, no logic change)
-refactor: # Code refactoring (no new features or bug fixes)
-test:     # Adding or updating tests
-chore:    # Build process or auxiliary tool changes
-
-# Examples:
-git commit -m "feat(auth): add password reset functionality"
-git commit -m "fix(cameras): resolve stream connection timeout issue"
-git commit -m "docs(readme): update installation instructions"
-git commit -m "test(events): add unit tests for event filtering"
-```
-
-## ğŸ§ª Testing Strategy
-
-### **Testing Pyramid**
-
-#### **Unit Tests** (70% of tests)
-Test individual functions and components:
-
-```javascript
-// Example: Backend unit test
-describe('User Authentication', () => {
-  test('should hash password correctly', async () => {
-    const password = 'testPassword123';
-    const hashedPassword = await hashPassword(password);
-    
-    expect(hashedPassword).not.toBe(password);
-    expect(await comparePassword(password, hashedPassword)).toBe(true);
-  });
-  
-  test('should generate valid JWT token', () => {
-    const user = { id: '123', role: 'guard' };
-    const token = generateToken(user);
-    const decoded = verifyToken(token);
-    
-    expect(decoded.id).toBe(user.id);
-    expect(decoded.role).toBe(user.role);
-  });
-});
-```
-
-```javascript
-// Example: Frontend unit test
-describe('CameraCard Component', () => {
-  test('renders camera information correctly', () => {
-    const mockCamera = {
-      id: '1',
-      name: 'Main Entrance',
-      status: 'online',
-      location: 'Building A'
-    };
-    
-    render(<CameraCard camera={mockCamera} />);
-    
-    expect(screen.getByText('Main Entrance')).toBeInTheDocument();
-    expect(screen.getByText('online')).toBeInTheDocument();
-    expect(screen.getByText('Building A')).toBeInTheDocument();
-  });
-});
-```
-
-#### **Integration Tests** (20% of tests)
-Test how services work together:
-
-```javascript
-// Example: API integration test
-describe('Camera API Integration', () => {
-  test('should create and retrieve camera', async () => {
-    const cameraData = {
-      name: 'Test Camera',
-      streamUrl: 'rtsp://test.camera.com',
-      location: { lat: 40.7128, lng: -74.0060 }
-    };
-    
-    // Create camera
-    const createResponse = await request(app)
-      .post('/api/cameras')
-      .set('Authorization', `Bearer ${authToken}`)
-      .send(cameraData)
-      .expect(201);
-      
-    const cameraId = createResponse.body.id;
-    
-    // Retrieve camera
-    const getResponse = await request(app)
-      .get(`/api/cameras/${cameraId}`)
-      .set('Authorization', `Bearer ${authToken}`)
-      .expect(200);
-      
-    expect(getResponse.body.name).toBe(cameraData.name);
-    expect(getResponse.body.streamUrl).toBe(cameraData.streamUrl);
-  });
-});
-```
-
-#### **End-to-End Tests** (10% of tests)
-Test complete user workflows:
-
-```javascript
-// Example: E2E test with Playwright
-test('user can login and view dashboard', async ({ page }) => {
-  // Navigate to login page
-  await page.goto('/login');
-  
-  // Fill login form
-  await page.fill('[data-testid="username"]', 'testuser');
-  await page.fill('[data-testid="password"]', 'testpass');
-  await page.click('[data-testid="login-button"]');
-  
-  // Verify redirect to dashboard
-  await expect(page).toHaveURL('/dashboard');
-  await expect(page.locator('[data-testid="welcome-message"]')).toBeVisible();
-  
-  // Verify camera count is displayed
-  await expect(page.locator('[data-testid="camera-count"]')).toBeVisible();
-});
-```
-
-### **Running Tests**
-
-#### **All Services**
-```bash
-# Run all tests across all services
-npm run test:all
-
-# Run tests with coverage
-npm run test:coverage
-
-# Run tests in watch mode during development
-npm run test:watch
-```
-
-#### **Individual Services**
-```bash
-# Backend tests
-cd backend
-npm test
-npm run test:coverage
-
-# Frontend tests
-cd frontend
-npm test
-npm run test:coverage
-
-# AI Service tests
-cd ai-service
-python -m pytest
-python -m pytest --cov=src
-```
-
-## ğŸ” Code Review Process
-
-### **Pull Request Template**
-Every PR should include:
-
-```markdown
-## Description
-Brief description of changes and motivation
-
-## Type of Change
-- [ ] Bug fix (non-breaking change which fixes an issue)
-- [ ] New feature (non-breaking change which adds functionality)
-- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
-- [ ] Documentation update
-
-## Testing
-- [ ] Unit tests added/updated
-- [ ] Integration tests added/updated
-- [ ] Manual testing completed
-- [ ] All tests passing
-
-## Screenshots (if applicable)
-Include before/after screenshots for UI changes
-
-## Checklist
-- [ ] Code follows project style guidelines
-- [ ] Self-review completed
-- [ ] Code is commented where necessary
-- [ ] Documentation updated
-- [ ] No console.log or debug code left behind
-```
-
-### **Review Checklist for Reviewers**
-
-#### **Code Quality**
-- [ ] Code follows established patterns and conventions
-- [ ] Functions are small and focused (single responsibility)
-- [ ] Variable and function names are descriptive
-- [ ] No code duplication (DRY principle)
-- [ ] Error handling is comprehensive
-- [ ] Security considerations are addressed
-
-#### **Functionality**
-- [ ] Feature works as described
-- [ ] Edge cases are handled
-- [ ] No obvious bugs or logical errors
-- [ ] Performance implications considered
-- [ ] Backward compatibility maintained
-
-#### **Testing**
-- [ ] Adequate test coverage
-- [ ] Tests are meaningful and test the right things
-- [ ] All tests pass
-- [ ] No test flakiness
-
-#### **Documentation**
-- [ ] Code is self-documenting with good naming
-- [ ] Complex logic is commented
-- [ ] API changes are documented
-- [ ] README updated if needed
-
-## ğŸ”§ Development Tools & Scripts
-
-### **Package.json Scripts**
-
-#### **Root Package.json**
-```json
-{
-  "scripts": {
-    "install-all": "npm install && cd frontend && npm install && cd ../backend && npm install && cd ../ai-service && pip install -r requirements.txt",
-    "dev": "docker-compose up --build",
-    "dev:services": "concurrently \"npm run dev:backend\" \"npm run dev:frontend\" \"npm run dev:ai\"",
-    "dev:backend": "cd backend && npm run dev",
-    "dev:frontend": "cd frontend && npm run start",
-    "dev:ai": "cd ai-service && python -m uvicorn app:app --reload --port 8000",
-    "test:all": "npm run test:backend && npm run test:frontend && npm run test:ai",
-    "test:backend": "cd backend && npm test",
-    "test:frontend": "cd frontend && npm test -- --coverage --verbose",
-    "test:ai": "cd ai-service && python -m pytest",
-    "lint:all": "npm run lint:backend && npm run lint:frontend",
-    "lint:backend": "cd backend && npm run lint",
-    "lint:frontend": "cd frontend && npm run lint",
-    "build:all": "npm run build:frontend && npm run build:backend",
-    "build:frontend": "cd frontend && npm run build",
-    "build:backend": "cd backend && npm run build",
-    "docker:build": "docker-compose build",
-    "docker:up": "docker-compose up",
-    "docker:down": "docker-compose down",
-    "docker:logs": "docker-compose logs -f",
-    "db:seed": "cd backend && npm run db:seed",
-    "db:reset": "cd backend && npm run db:reset"
-  }
-}
-```
-
-### **Development Shortcuts**
-
-#### **VS Code Tasks** (`.vscode/tasks.json`)
-```json
-{
-  "version": "2.0.0",
-  "tasks": [
-    {
-      "label": "Start Dev Environment",
-      "type": "shell",
-      "command": "docker-compose up --build",
-      "group": "build",
-      "presentation": {
-        "echo": true,
-        "reveal": "always",
-        "panel": "new"
-      }
-    },
-    {
-      "label": "Run All Tests",
-      "type": "shell",
-      "command": "npm run test:all",
-      "group": "test",
-      "presentation": {
-        "echo": true,
-        "reveal": "always"
-      }
-    }
-  ]
-}
-```
-
-#### **Makefile Shortcuts**
-```makefile
-# Quick development commands
-.PHONY: dev test clean install
-
-dev:
-	docker-compose up --build
-
-test:
-	npm run test:all
-
-clean:
-	docker-compose down -v
-	docker system prune -f
-
-install:
-	npm run install-all
-
-seed:
-	npm run db:seed
-
-logs:
-	docker-compose logs -f
-
-restart:
-	docker-compose restart
-
-# Database operations
-db-reset:
-	docker-compose down -v
-	docker-compose up -d mongo
-	sleep 5
-	npm run db:seed
-
-# Production builds
-build:
-	npm run build:all
-	docker-compose build
-
-# Linting and formatting
-lint:
-	npm run lint:all
-
-format:
-	npm run format:all
-```
-
-## ğŸ› Debugging Guide
-
-### **Common Issues & Solutions**
-
-#### **Frontend Issues**
-
-**Issue: "Module not found" errors**
-```bash
-# Solution: Clear node_modules and reinstall
-cd frontend
-rm -rf node_modules package-lock.json
-npm install
-npm start
-```
-
-**Issue: TypeScript errors**
-```bash
-# Solution: Check types and restart TypeScript service
-npm run type-check
-# In VS Code: Ctrl+Shift+P â†’ "TypeScript: Restart TS Server"
-```
-
-**Issue: Socket.IO connection failed**
-```javascript
-// Check backend is running and Socket.IO configuration
-// Frontend: src/services/socket.ts
-const socket = io('http://localhost:5000', {
-  autoConnect: false,
-  timeout: 20000,
-});
-
-// Backend: app.ts
-const io = new Server(server, {
-  cors: {
-    origin: "http://localhost:3000",
-    methods: ["GET", "POST"]
-  }
-});
-```
-
-#### **Backend Issues**
-
-**Issue: MongoDB connection failed**
-```bash
-# Solution: Ensure MongoDB is running
-docker-compose up mongo
-# Or locally:
-mongod --dbpath /usr/local/var/mongodb
-```
-
-**Issue: JWT token errors**
-```javascript
-// Check JWT_SECRET is set in environment
-console.log('JWT_SECRET exists:', !!process.env.JWT_SECRET);
-
-// Verify token format in frontend
-const token = localStorage.getItem('token');
-console.log('Token format:', token?.startsWith('Bearer ') ? 'Correct' : 'Missing Bearer prefix');
-```
-
-#### **AI Service Issues**
-
-**Issue: Python dependencies missing**
-```bash
-# Solution: Reinstall requirements
-cd ai-service
-pip install -r requirements.txt
-# Or with virtual environment:
-python -m venv venv
-source venv/bin/activate  # On Windows: venv\Scripts\activate
-pip install -r requirements.txt
-```
-
-**Issue: YOLO model not loading**
-```python
-# Check model file exists
-import os
-model_path = '/app/models/yolov8n.pt'
-print(f"Model exists: {os.path.exists(model_path)}")
-
-# Download model if missing
-from ultralytics import YOLO
-model = YOLO('yolov8n.pt')  # Auto-downloads if not present
-```
-
-### **Debugging Tools**
-
-#### **Browser DevTools**
-```javascript
-// Frontend debugging helpers
-console.log('Redux State:', store.getState());
-console.log('Socket connected:', socket.connected);
-
-// Network tab: Check API requests
-// Console tab: Check for JavaScript errors
-// Application tab: Check localStorage and cookies
-```
-
-#### **Backend Debugging**
-```javascript
-// Debug middleware
-app.use((req, res, next) => {
-  console.log(`${req.method} ${req.path}`, {
-    body: req.body,
-    headers: req.headers,
-    user: req.userId
-  });
-  next();
-});
-
-// Debug database queries
-mongoose.set('debug', process.env.NODE_ENV === 'development');
-```
-
-#### **Docker Debugging**
-```bash
-# View container logs
-docker-compose logs -f [service-name]
-
-# Execute commands in running container
-docker-compose exec backend bash
-docker-compose exec mongo mongo
-
-# Check container resource usage
-docker stats
-
-# Rebuild specific service
-docker-compose build [service-name]
-docker-compose up [service-name]
-```
-
-## ğŸ“Š Performance Monitoring
-
-### **Development Metrics**
-
-#### **Frontend Performance**
-```javascript
-// React DevTools Profiler
-// Chrome DevTools Lighthouse
-// Bundle analyzer
-npm run analyze
-
-// Performance monitoring
-import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';
-
-getCLS(console.log);
-getFID(console.log);
-getFCP(console.log);
-getLCP(console.log);
-getTTFB(console.log);
-```
-
-#### **Backend Performance**
-```javascript
-// API response times
-app.use((req, res, next) => {
-  const start = Date.now();
-  res.on('finish', () => {
-    const duration = Date.now() - start;
-    console.log(`${req.method} ${req.path} - ${duration}ms`);
-  });
-  next();
-});
-
-// Database query performance
-mongoose.set('debug', (collectionName, method, query, doc) => {
-  console.log(`${collectionName}.${method}`, JSON.stringify(query), doc);
-});
-```
-
-## ğŸ¯ Success Metrics
-
-### **Development Quality Metrics**
-- **Code Coverage**: >80% for all services
-- **Build Time**: <5 minutes for full build
-- **Test Execution**: <2 minutes for all unit tests
-- **PR Review Time**: <24 hours average
-- **Bug Rate**: <1 bug per 100 lines of code
-
-### **Performance Targets**
-- **Frontend Load Time**: <2 seconds initial load
-- **API Response Time**: <200ms average
-- **Real-time Latency**: <100ms for Socket.IO events
-- **Database Query Time**: <50ms average
-- **AI Processing**: <500ms per frame
-
-This development workflow ensures consistent, high-quality code delivery while maintaining team productivity and code maintainability. Following these practices will help new team members quickly become productive contributors to the project!
\ No newline at end of file
+# Development Workflow
+
+This document outlines the development processes, tools, and best practices for the Event Monitoring Platform. Following these guidelines ensures code quality, collaboration efficiency, and successful project delivery.
+
+## Table of Contents
+1. [Git Workflow](#git-workflow)
+2. [Branching Strategy](#branching-strategy)
+3. [Code Review Process](#code-review-process)
+4. [Testing Strategy](#testing-strategy)
+5. [CI/CD Pipeline](#cicd-pipeline)
+6. [Development Environment](#development-environment)
+7. [Code Quality Standards](#code-quality-standards)
+8. [Release Process](#release-process)
+
+## Git Workflow
+
+### Git Flow Strategy
+
+We use a modified Git Flow approach optimized for continuous deployment:
+
+```mermaid
+gitGraph
+    commit id: "Initial commit"
+    branch develop
+    checkout develop
+    commit id: "Feature development"
+    branch feature/login-system
+    checkout feature/login-system
+    commit id: "Implement login UI"
+    commit id: "Add authentication logic"
+    checkout develop
+    merge feature/login-system
+    branch release/v1.0.0
+    checkout release/v1.0.0
+    commit id: "Bump version"
+    commit id: "Update changelog"
+    checkout main
+    merge release/v1.0.0 tag: "v1.0.0"
+    checkout develop
+    merge release/v1.0.0
+    branch hotfix/security-patch
+    checkout hotfix/security-patch
+    commit id: "Fix security vulnerability"
+    checkout main
+    merge hotfix/security-patch tag: "v1.0.1"
+    checkout develop
+    merge hotfix/security-patch
+```
+
+### Branch Naming Convention
+
+- `main`: Production-ready code
+- `develop`: Integration branch for features
+- `feature/`: New features (e.g., `feature/user-authentication`)
+- `bugfix/`: Bug fixes (e.g., `bugfix/login-validation`)
+- `hotfix/`: Critical production fixes (e.g., `hotfix/security-patch`)
+- `release/`: Release preparation (e.g., `release/v1.2.0`)
+
+### Commit Message Standards
+
+Follow conventional commit format:
+
+```
+type(scope): description
+
+[optional body]
+
+[optional footer]
+```
+
+**Types:**
+- `feat`: New feature
+- `fix`: Bug fix
+- `docs`: Documentation changes
+- `style`: Code style changes (formatting, etc.)
+- `refactor`: Code refactoring
+- `test`: Adding or updating tests
+- `chore`: Maintenance tasks
+
+**Examples:**
+```
+feat(auth): add JWT token refresh functionality
+
+fix(api): resolve memory leak in event processing
+
+docs(api): update endpoint documentation for reports
+
+test(events): add unit tests for event validation
+```
+
+## Branching Strategy
+
+### Feature Development
+
+1. **Create Feature Branch**
+   ```bash
+   git checkout develop
+   git pull origin develop
+   git checkout -b feature/user-profile-page
+   ```
+
+2. **Develop and Commit**
+   ```bash
+   # Make changes
+   git add .
+   git commit -m "feat(profile): implement user profile page"
+   ```
+
+3. **Push and Create PR**
+   ```bash
+   git push origin feature/user-profile-page
+   # Create pull request on GitHub
+   ```
+
+### Hotfix Process
+
+1. **Create Hotfix Branch**
+   ```bash
+   git checkout main
+   git pull origin main
+   git checkout -b hotfix/critical-security-fix
+   ```
+
+2. **Implement Fix**
+   ```bash
+   # Fix the issue
+   git add .
+   git commit -m "fix(security): patch XSS vulnerability"
+   ```
+
+3. **Merge to Main and Develop**
+   ```bash
+   git checkout main
+   git merge hotfix/critical-security-fix
+   git tag -a v1.1.1 -m "Security hotfix"
+   git push origin main --tags
+
+   git checkout develop
+   git merge hotfix/critical-security-fix
+   git push origin develop
+   ```
+
+## Code Review Process
+
+### Pull Request Guidelines
+
+**Before Creating PR:**
+- [ ] All tests pass locally
+- [ ] Code follows style guidelines
+- [ ] Documentation updated
+- [ ] Self-review completed
+- [ ] Branch up-to-date with develop
+
+**PR Template:**
+```markdown
+## Description
+Brief description of changes
+
+## Type of Change
+- [ ] Bug fix
+- [ ] New feature
+- [ ] Breaking change
+- [ ] Documentation update
+
+## Testing
+- [ ] Unit tests added/updated
+- [ ] Integration tests pass
+- [ ] Manual testing completed
+
+## Screenshots (if applicable)
+Add screenshots of UI changes
+
+## Checklist
+- [ ] Code follows style guidelines
+- [ ] Documentation updated
+- [ ] Tests pass
+- [ ] No security vulnerabilities
+```
+
+### Review Process
+
+1. **Automated Checks**: CI runs tests, linting, security scans
+2. **Peer Review**: At least one team member reviews code
+3. **Approval**: Code owner approves changes
+4. **Merge**: Squash merge to develop branch
+
+### Code Review Checklist
+
+**For Reviewers:**
+- [ ] Code is readable and well-documented
+- [ ] Business logic is correct
+- [ ] Security best practices followed
+- [ ] Performance considerations addressed
+- [ ] Tests are comprehensive
+- [ ] No hardcoded secrets or credentials
+- [ ] Error handling is appropriate
+- [ ] Database queries are optimized
+
+## Testing Strategy
+
+### Testing Pyramid
+
+```
+End-to-End Tests (5%)
+    â†•
+Integration Tests (15%)
+    â†•
+Unit Tests (80%)
+```
+
+### Unit Testing
+
+**Frontend (Jest + React Testing Library):**
+```typescript
+describe('EventCard', () => {
+  it('displays event title and status', () => {
+    const event = {
+      id: '1',
+      title: 'Test Event',
+      status: 'active',
+      priority: 'high'
+    };
+
+    render(<EventCard event={event} />);
+
+    expect(screen.getByText('Test Event')).toBeInTheDocument();
+    expect(screen.getByText('active')).toBeInTheDocument();
+  });
+});
+```
+
+**Backend (Jest + Supertest):**
+```typescript
+describe('POST /api/events', () => {
+  it('creates new event with valid data', async () => {
+    const eventData = {
+      title: 'Test Event',
+      eventTypeId: testEventTypeId,
+      companyId: testCompanyId
+    };
+
+    const response = await request(app)
+      .post('/api/events')
+      .set('Authorization', `Bearer ${testToken}`)
+      .send(eventData)
+      .expect(201);
+
+    expect(response.body.title).toBe('Test Event');
+  });
+});
+```
+
+### Integration Testing
+
+**API Integration Tests:**
+```typescript
+describe('Event Report Flow', () => {
+  it('creates event from citizen report', async () => {
+    // Submit citizen report
+    const reportResponse = await request(app)
+      .post('/api/mobile/reports')
+      .set('X-API-Key', testApiKey)
+      .send(citizenReportData);
+
+    // Verify event was created
+    const eventResponse = await request(app)
+      .get(`/api/events/${reportResponse.body.eventId}`)
+      .set('Authorization', `Bearer ${adminToken}`);
+
+    expect(eventResponse.body.reports).toContain(reportResponse.body._id);
+  });
+});
+```
+
+### End-to-End Testing
+
+**Using Cypress:**
+```typescript
+describe('Event Management', () => {
+  it('allows operator to create and assign event', () => {
+    cy.login('operator@test.com', 'password');
+
+    cy.visit('/events');
+    cy.get('[data-cy=create-event]').click();
+
+    cy.get('[data-cy=event-title]').type('Test Incident');
+    cy.get('[data-cy=event-type]').select('Security');
+    cy.get('[data-cy=submit]').click();
+
+    cy.get('[data-cy=event-list]').should('contain', 'Test Incident');
+  });
+});
+```
+
+### Test Coverage Requirements
+
+- **Unit Tests**: Minimum 80% coverage
+- **Integration Tests**: All critical user journeys
+- **E2E Tests**: Core workflows and user journeys
+
+## CI/CD Pipeline
+
+### GitHub Actions Workflow
+
+```yaml
+name: CI/CD Pipeline
+
+on:
+  push:
+    branches: [ main, develop ]
+  pull_request:
+    branches: [ main, develop ]
+
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    services:
+      mongodb:
+        image: mongo:6.0
+        ports:
+          - 27017:27017
+
+    steps:
+      - uses: actions/checkout@v3
+
+      - name: Setup Node.js
+        uses: actions/setup-node@v3
+        with:
+          node-version: '18'
+
+      - name: Install dependencies
+        run: npm ci
+
+      - name: Run linting
+        run: npm run lint
+
+      - name: Run tests
+        run: npm run test:ci
+
+      - name: Upload coverage
+        uses: codecov/codecov-action@v3
+
+  security:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - name: Run security scan
+        uses: securecodewarrior/github-action-gosec@master
+        with:
+          args: './...'
+
+  deploy-staging:
+    needs: [test, security]
+    if: github.ref == 'refs/heads/develop'
+    runs-on: ubuntu-latest
+    steps:
+      - name: Deploy to staging
+        run: |
+          echo "Deploy to staging environment"
+
+  deploy-production:
+    needs: [test, security]
+    if: github.ref == 'refs/heads/main'
+    runs-on: ubuntu-latest
+    steps:
+      - name: Deploy to production
+        run: |
+          echo "Deploy to production environment"
+```
+
+### Pipeline Stages
+
+1. **Lint**: Code style and formatting checks
+2. **Test**: Unit and integration tests
+3. **Security**: Vulnerability scanning
+4. **Build**: Docker image creation
+5. **Deploy**: Environment-specific deployment
+
+## Development Environment
+
+### Local Setup
+
+**Prerequisites:**
+- Node.js 18+
+- Python 3.9+
+- Docker Desktop
+- Git
+
+**Setup Steps:**
+```bash
+# Clone repository
+git clone <repository-url>
+cd event-monitoring-mvp
+
+# Start infrastructure
+docker-compose up -d mongodb redis
+
+# Backend setup
+cd backend
+npm install
+cp .env.example .env
+npm run setup-db
+npm run dev
+
+# Frontend setup (new terminal)
+cd frontend
+npm install
+cp .env.example .env
+npm start
+
+# AI service setup (new terminal)
+cd ai-service
+pip install -r requirements.txt
+python main.py
+```
+
+### Environment Configuration
+
+**.env Structure:**
+```bash
+# Application
+NODE_ENV=development
+PORT=3000
+
+# Database
+MONGODB_URI=mongodb://localhost:27017/event-monitoring-dev
+
+# Authentication
+JWT_SECRET=your-super-secret-jwt-key
+JWT_EXPIRES_IN=24h
+
+# External Services
+REDIS_URL=redis://localhost:6379
+
+# File Storage
+AWS_S3_BUCKET=dev-event-monitoring-files
+AWS_ACCESS_KEY_ID=your-access-key
+AWS_SECRET_ACCESS_KEY=your-secret-key
+
+# AI Service
+AI_SERVICE_URL=http://localhost:8000
+
+# Email (optional)
+SMTP_HOST=smtp.gmail.com
+SMTP_PORT=587
+SMTP_USER=your-email@gmail.com
+SMTP_PASS=your-app-password
+```
+
+## Code Quality Standards
+
+### TypeScript Standards
+
+**tsconfig.json:**
+```json
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "module": "commonjs",
+    "strict": true,
+    "esModuleInterop": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true,
+    "resolveJsonModule": true,
+    "declaration": true,
+    "outDir": "./dist",
+    "rootDir": "./src"
+  },
+  "include": ["src/**/*"],
+  "exclude": ["node_modules", "dist", "**/*.test.ts"]
+}
+```
+
+### ESLint Configuration
+
+**.eslintrc.js:**
+```javascript
+module.exports = {
+  env: {
+    node: true,
+    es2021: true,
+  },
+  extends: [
+    'eslint:recommended',
+    '@typescript-eslint/recommended',
+    'prettier',
+  ],
+  parser: '@typescript-eslint/parser',
+  parserOptions: {
+    ecmaVersion: 12,
+    sourceType: 'module',
+  },
+  plugins: ['@typescript-eslint'],
+  rules: {
+    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
+    '@typescript-eslint/explicit-function-return-type': 'warn',
+    '@typescript-eslint/no-explicit-any': 'warn',
+  },
+};
+```
+
+### Pre-commit Hooks
+
+**Husky + lint-staged:**
+```json
+{
+  "husky": {
+    "hooks": {
+      "pre-commit": "lint-staged",
+      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
+    }
+  },
+  "lint-staged": {
+    "*.{ts,tsx}": [
+      "eslint --fix",
+      "prettier --write",
+      "jest --findRelatedTests --passWithNoTests"
+    ],
+    "*.{json,md}": [
+      "prettier --write"
+    ]
+  }
+}
+```
+
+## Release Process
+
+### Version Numbering
+
+Follow [Semantic Versioning](https://semver.org/):
+- **MAJOR**: Breaking changes
+- **MINOR**: New features (backward compatible)
+- **PATCH**: Bug fixes (backward compatible)
+
+### Release Steps
+
+1. **Create Release Branch**
+   ```bash
+   git checkout develop
+   git pull origin develop
+   git checkout -b release/v1.2.0
+   ```
+
+2. **Update Version**
+   ```bash
+   # Update package.json
+   npm version 1.2.0 --no-git-tag-version
+
+   # Update changelog
+   # Update version in docs
+   ```
+
+3. **Testing**
+   ```bash
+   # Run full test suite
+   npm run test
+
+   # Manual testing checklist
+   # - All user journeys work
+   # - No regressions
+   # - Performance acceptable
+   ```
+
+4. **Merge and Tag**
+   ```bash
+   git checkout main
+   git merge release/v1.2.0
+   git tag -a v1.2.0 -m "Release version 1.2.0"
+   git push origin main --tags
+
+   git checkout develop
+   git merge release/v1.2.0
+   git push origin develop
+
+   git branch -d release/v1.2.0
+   ```
+
+5. **Deploy**
+   ```bash
+   # Trigger production deployment
+   # Update documentation
+   # Notify stakeholders
+   ```
+
+### Rollback Procedure
+
+If issues are discovered post-release:
+
+1. **Assess Impact**: Determine severity and user impact
+2. **Create Hotfix**: If critical, create hotfix branch from main
+3. **Deploy Previous Version**: Roll back to previous stable version
+4. **Investigate**: Root cause analysis and fix development
+5. **Re-release**: Deploy corrected version
+
+This development workflow ensures consistent, high-quality code delivery while maintaining system stability and enabling rapid iteration.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/05-IMPLEMENTATION-ROADMAP.md b/event-monitoring-mvp-architecture/team-documentation/05-IMPLEMENTATION-ROADMAP.md
index cbdd54e..5463250 100644
--- a/event-monitoring-mvp-architecture/team-documentation/05-IMPLEMENTATION-ROADMAP.md
+++ b/event-monitoring-mvp-architecture/team-documentation/05-IMPLEMENTATION-ROADMAP.md
@@ -1,540 +1,338 @@
-# Implementation Roadmap & Future Features
-
-## ğŸ¯ Current MVP Status (What's Done)
-
-### âœ… **Phase 0: Foundation Complete**
-
-#### **User Authentication & Management**
-- [x] JWT-based secure authentication system
-- [x] User registration and login functionality
-- [x] Role-based access control (Admin, Manager, Guard)
-- [x] User profile management with editable information
-- [x] Password hashing with bcrypt
-- [x] Session management and token expiration
-
-#### **Core Backend Infrastructure**
-- [x] Node.js/Express REST API server
-- [x] MongoDB database with proper schemas
-- [x] Real-time WebSocket communication via Socket.IO
-- [x] Comprehensive error handling and validation
-- [x] CORS configuration for frontend integration
-- [x] Environment configuration management
-
-#### **Frontend User Interface**
-- [x] React/TypeScript application with modern UI
-- [x] Material-UI component library integration
-- [x] Redux Toolkit for state management
-- [x] React Query for API data fetching
-- [x] Responsive design for desktop and mobile
-- [x] Dark/light theme support
-
-#### **Core Features Implemented**
-- [x] **Dashboard**: Overview with statistics and recent activity
-- [x] **Camera Management**: Add, view, configure security cameras
-- [x] **Event Management**: View and manage security events
-- [x] **Interactive Map**: Mapbox integration showing camera/event locations
-- [x] **Live View**: Framework for real-time camera streams
-- [x] **User Profile**: Personal information and activity tracking
-- [x] **Settings**: System preferences and notifications
-
-#### **DevOps & Infrastructure**
-- [x] Docker containerization for all services
-- [x] Docker Compose for local development environment
-- [x] MongoDB database with proper indexing
-- [x] Environment variable management
-- [x] Comprehensive documentation and comments
-
-## ğŸš§ **Phase 1: AI Integration (Next 4-6 Weeks)**
-
-### **Priority 1: Object Detection System**
-
-#### **AI Service Enhancement**
-```python
-# Target implementation structure
-class VideoProcessor:
-    def __init__(self):
-        self.model = YOLO('yolov8n.pt')
-        self.confidence_threshold = 0.5
-        
-    async def process_frame(self, frame_data: bytes) -> DetectionResult:
-        """Process single frame for object detection"""
-        # Convert bytes to OpenCV image
-        # Run YOLO detection
-        # Filter results by confidence
-        # Return structured detection data
-        
-    async def process_stream(self, stream_url: str) -> AsyncGenerator[Event]:
-        """Continuously process RTSP stream"""
-        # Connect to camera RTSP stream
-        # Process frames in real-time
-        # Generate events for significant detections
-        # Yield events to backend
-```
-
-**Week 1-2 Goals:**
-- [ ] Integrate YOLOv8 model for person/vehicle detection
-- [ ] Implement real-time video stream processing with OpenCV
-- [ ] Create detection result formatting and validation
-- [ ] Build frame preprocessing and optimization pipeline
-
-**Week 3-4 Goals:**
-- [ ] Connect AI service to backend event system
-- [ ] Implement automatic event generation from detections
-- [ ] Add confidence scoring and filtering mechanisms
-- [ ] Create detection zone configuration (polygonal areas)
-
-**Acceptance Criteria:**
-- AI service can detect persons with >90% accuracy
-- Processing latency <500ms per frame
-- Automatic event creation for high-confidence detections
-- Configurable detection zones per camera
-
-### **Priority 2: Real-Time Video Streaming**
-
-#### **Frontend Video Player**
-```typescript
-interface VideoStreamProps {
-  cameraId: string;
-  streamUrl: string;
-  aiOverlay?: boolean;
-  detectionBoxes?: DetectionBox[];
-}
-
-const VideoStream: React.FC<VideoStreamProps> = ({
-  cameraId,
-  streamUrl,
-  aiOverlay = true,
-  detectionBoxes = []
-}) => {
-  // WebRTC connection for low-latency streaming
-  // Canvas overlay for detection bounding boxes
-  // Stream quality controls
-  // Recording functionality
-};
-```
-
-**Implementation Tasks:**
-- [ ] WebRTC integration for low-latency video streaming
-- [ ] Video player component with detection overlays
-- [ ] Stream quality adaptation based on bandwidth
-- [ ] Multi-camera grid view for monitoring multiple streams
-
-### **Priority 3: Enhanced Event Management**
-
-#### **Smart Event Classification**
-```javascript
-// Event types with AI confidence
-const eventTypes = {
-  PERSON_DETECTED: {
-    severity: 'medium',
-    autoAcknowledge: false,
-    notificationTypes: ['dashboard', 'email']
-  },
-  VEHICLE_DETECTED: {
-    severity: 'low',
-    autoAcknowledge: true,
-    notificationTypes: ['dashboard']
-  },
-  UNAUTHORIZED_AREA: {
-    severity: 'high',
-    autoAcknowledge: false,
-    notificationTypes: ['dashboard', 'email', 'sms', 'push']
-  },
-  LOITERING_DETECTED: {
-    severity: 'high',
-    autoAcknowledge: false,
-    notificationTypes: ['dashboard', 'email']
-  }
-};
-```
-
-**Features to Implement:**
-- [ ] Intelligent event severity classification
-- [ ] Automated alert routing based on event type
-- [ ] Event aggregation to reduce noise
-- [ ] Historical event pattern analysis
-
-## ğŸ”® **Phase 2: Advanced Features (Weeks 7-12)**
-
-### **Priority 1: Mobile Application**
-
-#### **React Native Mobile App**
-```typescript
-// Core mobile features
-interface MobileFeatures {
-  pushNotifications: boolean;
-  offlineMode: boolean;
-  quickResponse: boolean;
-  geoLocation: boolean;
-}
-
-const MobileApp = () => {
-  // Push notification handler
-  // Offline event synchronization
-  // Quick acknowledge/resolve actions
-  // GPS location for response tracking
-};
-```
-
-**Mobile Development Timeline:**
-- **Week 7-8**: React Native setup and core navigation
-- **Week 9-10**: Push notification integration
-- **Week 11-12**: Offline mode and synchronization
-
-### **Priority 2: Advanced Analytics Dashboard**
-
-#### **Analytics Features**
-```typescript
-interface AnalyticsData {
-  eventTrends: {
-    daily: EventCount[];
-    weekly: EventCount[];
-    monthly: EventCount[];
-  };
-  cameraPerformance: {
-    uptimePercent: number;
-    eventsPerHour: number;
-    detectionAccuracy: number;
-  };
-  responseMetrics: {
-    averageResponseTime: number;
-    acknowledgeRate: number;
-    falsePositiveRate: number;
-  };
-}
-```
-
-**Analytics Implementation:**
-- [ ] Event trend analysis and visualization
-- [ ] Camera performance monitoring
-- [ ] Security team response metrics
-- [ ] Predictive analytics for security patterns
-
-### **Priority 3: Integration Ecosystem**
-
-#### **External Service Integrations**
-```javascript
-// Integration configuration
-const integrations = {
-  emailService: {
-    provider: 'SendGrid',
-    templates: ['alert', 'summary', 'report']
-  },
-  smsService: {
-    provider: 'Twilio',
-    emergencyNumbers: ['admin', 'security_manager']
-  },
-  accessControl: {
-    provider: 'Generic_API',
-    endpoints: ['unlock_door', 'lockdown_area']
-  },
-  securitySystem: {
-    provider: 'Custom_Integration',
-    features: ['arm_disarm', 'zone_status']
-  }
-};
-```
-
-**Integration Roadmap:**
-- **Week 9**: Email notification system (SendGrid/Mailgun)
-- **Week 10**: SMS alerts for critical events (Twilio)
-- **Week 11**: Access control system integration
-- **Week 12**: Existing security system API integration
-
-## ğŸš€ **Phase 3: Enterprise Features (Months 4-6)**
-
-### **Scalability & Performance**
-
-#### **Microservices Architecture Evolution**
-```yaml
-# Kubernetes deployment structure
-apiVersion: apps/v1
-kind: Deployment
-metadata:
-  name: event-monitoring-stack
-spec:
-  replicas: 3
-  selector:
-    matchLabels:
-      app: event-monitoring
-  template:
-    spec:
-      containers:
-      - name: backend
-        image: event-monitoring/backend:latest
-        resources:
-          requests:
-            memory: "256Mi"
-            cpu: "250m"
-          limits:
-            memory: "512Mi"
-            cpu: "500m"
-```
-
-**Enterprise Scalability Features:**
-- [ ] Kubernetes orchestration for production deployment
-- [ ] Auto-scaling based on camera load and detection volume
-- [ ] Redis caching layer for improved performance
-- [ ] CDN integration for video streaming
-- [ ] Database sharding for multi-tenant support
-
-### **Advanced AI Capabilities**
-
-#### **Machine Learning Enhancements**
-```python
-class AdvancedAIFeatures:
-    def __init__(self):
-        self.face_recognition_model = FaceRecognitionModel()
-        self.behavior_analysis_model = BehaviorAnalysisModel()
-        self.license_plate_reader = LicensePlateReader()
-    
-    async def analyze_person(self, person_detection: Detection):
-        """Advanced person analysis"""
-        # Face recognition for authorized personnel
-        # Behavior analysis (running, loitering, fighting)
-        # Age/gender estimation for analytics
-        
-    async def analyze_vehicle(self, vehicle_detection: Detection):
-        """Advanced vehicle analysis"""
-        # License plate recognition
-        # Vehicle type classification
-        # Speed estimation
-        # Parking violation detection
-```
-
-**Advanced AI Timeline:**
-- **Month 4**: Face recognition system for authorized personnel
-- **Month 5**: Behavior analysis (loitering, running, altercations)
-- **Month 6**: License plate recognition and vehicle analytics
-
-### **Multi-Tenant Architecture**
-
-#### **Enterprise Multi-Tenancy**
-```typescript
-interface TenantConfiguration {
-  tenantId: string;
-  organizationName: string;
-  cameras: Camera[];
-  users: User[];
-  settings: {
-    brandingConfig: BrandingConfig;
-    featureFlags: FeatureFlags;
-    subscriptionTier: 'basic' | 'pro' | 'enterprise';
-  };
-}
-
-class TenantManager {
-  async createTenant(config: TenantConfiguration): Promise<Tenant>;
-  async isolateData(tenantId: string): Promise<Database>;
-  async configureBranding(tenantId: string, branding: BrandingConfig): Promise<void>;
-}
-```
-
-**Multi-Tenancy Features:**
-- [ ] Tenant isolation for data security
-- [ ] Custom branding per organization
-- [ ] Feature flag management per tenant
-- [ ] Usage analytics and billing integration
-
-## ğŸ¯ **Success Metrics & KPIs**
-
-### **Phase 1 Success Criteria**
-- **Detection Accuracy**: >95% for person detection, >90% for vehicles
-- **Processing Performance**: <300ms latency per frame
-- **System Reliability**: >99.5% uptime for AI service
-- **User Adoption**: 100% of security team actively using system
-
-### **Phase 2 Success Criteria**
-- **Mobile Adoption**: >80% of users install mobile app
-- **Response Time**: <2 minutes average incident response
-- **False Positive Rate**: <5% of generated events
-- **Analytics Utilization**: >70% of managers use analytics dashboard
-
-### **Phase 3 Success Criteria**
-- **Enterprise Readiness**: Support 500+ concurrent users
-- **Multi-Tenant Capability**: Support 10+ organizations
-- **Advanced AI Accuracy**: >98% face recognition, >95% behavior detection
-- **Integration Coverage**: 80% of existing security systems compatible
-
-## ğŸ› ï¸ **Technical Implementation Details**
-
-### **Database Schema Evolution**
-
-#### **Current Schema (Phase 0)**
-```javascript
-// Basic collections established
-- users (authentication and profiles)
-- cameras (basic camera management)
-- events (simple event logging)
-- sessions (JWT session management)
-```
-
-#### **Phase 1 Schema Additions**
-```javascript
-// AI and detection enhancements
-- detections: {
-    eventId: ObjectId,
-    cameraId: ObjectId,
-    timestamp: Date,
-    boundingBoxes: [{
-      class: String,
-      confidence: Number,
-      coordinates: { x, y, width, height }
-    }],
-    frameNumber: Number,
-    processingTime: Number
-  }
-
-- camera_zones: {
-    cameraId: ObjectId,
-    name: String,
-    polygon: [{ x: Number, y: Number }],
-    alertEnabled: Boolean,
-    eventTypes: [String]
-  }
-```
-
-#### **Phase 2 Schema Additions**
-```javascript
-// Analytics and mobile support
-- analytics_events: {
-    date: Date,
-    cameraId: ObjectId,
-    eventCounts: Object,
-    performanceMetrics: Object
-  }
-
-- mobile_tokens: {
-    userId: ObjectId,
-    deviceToken: String,
-    platform: String,
-    lastUsed: Date
-  }
-
-- alert_rules: {
-    name: String,
-    conditions: Object,
-    actions: [String],
-    enabled: Boolean
-  }
-```
-
-### **API Evolution Roadmap**
-
-#### **Phase 1 New Endpoints**
-```javascript
-// AI Service Integration
-POST /api/ai/analyze-frame          // Submit frame for analysis
-POST /api/ai/start-stream          // Begin real-time stream processing
-GET  /api/ai/detection-stats       // AI performance metrics
-
-// Enhanced Events
-GET  /api/events/analytics         // Event trend data
-POST /api/events/acknowledge       // Bulk acknowledge events
-PUT  /api/events/:id/resolve       // Resolve with notes
-
-// Camera Zones
-POST /api/cameras/:id/zones        // Create detection zone
-PUT  /api/cameras/:id/zones/:zoneId // Update zone configuration
-```
-
-#### **Phase 2 New Endpoints**
-```javascript
-// Mobile API
-POST /api/mobile/register-device   // Register for push notifications
-POST /api/mobile/sync-offline      // Sync offline changes
-GET  /api/mobile/quick-actions     // Get quick response options
-
-// Analytics
-GET  /api/analytics/dashboard      // Dashboard metrics
-GET  /api/analytics/export         // Export analytics data
-POST /api/analytics/custom-query   // Custom analytics queries
-```
-
-### **Frontend Component Evolution**
-
-#### **Phase 1 New Components**
-```typescript
-// AI-Enhanced Video Player
-<VideoPlayer 
-  cameraId="cam1" 
-  showDetections={true}
-  detectionTypes={['person', 'vehicle']}
-  onDetection={(event) => handleNewDetection(event)}
-/>
-
-// Detection Zone Configuration
-<ZoneEditor 
-  cameraView={cameraImage}
-  zones={existingZones}
-  onSave={(zones) => updateCameraZones(zones)}
-/>
-
-// Real-Time Event Stream
-<EventStream 
-  filter={{ severity: 'high' }}
-  autoRefresh={true}
-  onNewEvent={(event) => showAlert(event)}
-/>
-```
-
-#### **Phase 2 New Components**
-```typescript
-// Advanced Analytics Dashboard
-<AnalyticsDashboard 
-  dateRange={last30Days}
-  metrics={['events', 'response_time', 'camera_uptime']}
-  exportFormats={['pdf', 'excel', 'csv']}
-/>
-
-// Mobile-Optimized Components
-<MobileEventCard 
-  event={event}
-  quickActions={['acknowledge', 'resolve', 'escalate']}
-/>
-```
-
-## ğŸ“š **Learning & Development Path**
-
-### **For New Developers**
-
-#### **Week 1-2: Foundation**
-- Complete JavaScript/TypeScript fundamentals
-- Learn React basics and component lifecycle
-- Understand API concepts and HTTP methods
-- Practice with Git version control
-
-#### **Week 3-4: Project Integration**
-- Set up development environment
-- Complete first small feature (UI enhancement)
-- Learn debugging with browser dev tools
-- Understand project structure and patterns
-
-#### **Week 5-6: Advanced Features**
-- Work on backend API development
-- Learn database design and MongoDB operations
-- Implement real-time features with Socket.IO
-- Begin understanding AI integration concepts
-
-#### **Week 7-8: Specialization**
-Choose focus area:
-- **Frontend Specialist**: Advanced React patterns, performance optimization
-- **Backend Specialist**: API design, database optimization, system architecture
-- **AI Integration**: Computer vision, machine learning, Python development
-- **DevOps**: Docker, deployment, monitoring, scaling
-
-### **For Project Managers**
-
-#### **Sprint Planning Guidelines**
-- **2-week sprints** with clear deliverables
-- **Story points** based on complexity (1=simple, 5=complex, 8=very complex)
-- **Definition of Done**: Tests written, code reviewed, documentation updated
-- **Velocity tracking** to improve estimation accuracy
-
-#### **Risk Management**
-- **Technical Risks**: AI model performance, real-time processing latency
-- **Resource Risks**: Developer availability, hardware requirements
-- **Integration Risks**: Third-party API dependencies, legacy system compatibility
-- **Mitigation Strategies**: Prototype early, maintain fallback options
-
-This roadmap provides a clear path from our current MVP to a production-ready enterprise security monitoring system. Each phase builds upon previous work while introducing new capabilities that expand the system's value and market appeal.
\ No newline at end of file
+# Implementation Roadmap
+
+This document outlines the phased implementation plan for the Event Monitoring and Management Platform MVP, with detailed milestones, deliverables, and success criteria.
+
+## Table of Contents
+1. [Current Status](#current-status)
+2. [Phase 1: MVP Core (Current)](#phase-1-mvp-core-current)
+3. [Phase 2: Enhanced Features](#phase-2-enhanced-features)
+4. [Phase 3: Enterprise Scale](#phase-3-enterprise-scale)
+5. [Success Metrics](#success-metrics)
+6. [Risk Mitigation](#risk-mitigation)
+7. [Resource Requirements](#resource-requirements)
+
+## Current Status
+
+### âœ… Completed (Phase 1 MVP - Core)
+- [x] Multi-tenant company management with API keys
+- [x] User authentication (web + mobile first responders)
+- [x] Report submission from mobile apps
+- [x] Event aggregation from multiple reports
+- [x] Web dashboard with real-time updates
+- [x] AI camera integration (YOLOv8)
+- [x] Basic event type system
+- [x] Database schema and API endpoints
+- [x] Docker containerization
+- [x] Team coordination protocol
+- [x] Architecture documentation
+
+### ğŸ”„ In Progress
+- [ ] Documentation synchronization
+- [ ] First responder location tracking
+- [ ] Mobile app development coordination
+- [ ] Performance optimization
+- [ ] Security hardening
+
+### ğŸ“‹ Next Priority
+- [ ] Advanced analytics and reporting
+- [ ] Push notification system
+- [ ] Offline data synchronization
+- [ ] Custom event type configuration
+
+## Phase 1: MVP Core (Current)
+
+### Milestone 1.1: Multi-Tenant Foundation âœ…
+**Duration**: 2 weeks
+**Deliverables**:
+- Company model with API key generation
+- Database migration scripts
+- API key validation middleware
+- Basic company management endpoints
+
+**Success Criteria**:
+- API key validation working for all endpoints
+- Company data properly isolated
+- Basic company CRUD operations functional
+
+### Milestone 1.2: Authentication System âœ…
+**Duration**: 2 weeks
+**Deliverables**:
+- JWT-based web authentication
+- Phone/password for first responders
+- API key validation for mobile apps
+- Role-based access control
+- Session management
+
+**Success Criteria**:
+- Web users can register/login securely
+- First responders can authenticate via mobile
+- API key validation prevents unauthorized access
+- Password reset functionality working
+
+### Milestone 1.3: Report & Event System âœ…
+**Duration**: 3 weeks
+**Deliverables**:
+- Report submission API (citizen + camera + first responder)
+- Event creation and aggregation logic
+- Report-to-event linking system
+- Basic event type management
+- Real-time event updates via WebSocket
+
+**Success Criteria**:
+- Mobile apps can submit reports successfully
+- Events are created from high-priority reports
+- Multiple reports can contribute to single event
+- Real-time updates work in dashboard
+
+### Milestone 1.4: AI Camera Integration âœ…
+**Duration**: 2 weeks
+**Deliverables**:
+- YOLOv8 model integration
+- Camera stream processing
+- Detection result processing
+- Automatic report generation
+- Confidence threshold configuration
+
+**Success Criteria**:
+- Camera feeds processed in real-time
+- AI detections create reports automatically
+- Detection accuracy meets 90% threshold
+- System handles multiple camera streams
+
+### Milestone 1.5: Web Dashboard âœ…
+**Duration**: 3 weeks
+**Deliverables**:
+- React dashboard with map visualization
+- Event list and detail views
+- Real-time updates via WebSocket
+- Basic user management interface
+- Responsive design for mobile/tablet
+
+**Success Criteria**:
+- Dashboard loads within 3 seconds
+- Real-time updates work reliably
+- Map shows events and responder locations
+- Interface works on all major browsers
+
+### Milestone 1.6: Infrastructure & Deployment âœ…
+**Duration**: 2 weeks
+**Deliverables**:
+- Docker Compose for development
+- Production-ready Docker images
+- Nginx reverse proxy configuration
+- Environment-specific configurations
+- Basic monitoring and logging
+
+**Success Criteria**:
+- `docker-compose up` starts full system
+- All services communicate properly
+- Environment variables properly configured
+- Basic health checks implemented
+
+## Phase 2: Enhanced Features
+
+### Milestone 2.1: Advanced Analytics (Q1 2024)
+**Duration**: 4 weeks
+**Deliverables**:
+- Event analytics dashboard
+- Report generation and export
+- Performance metrics tracking
+- Custom date range filtering
+- Geographic heat maps
+
+**Success Criteria**:
+- Analytics load within 5 seconds
+- Export functionality works for all formats
+- Historical data accessible for 1+ years
+- Real-time metrics update correctly
+
+### Milestone 2.2: Push Notifications (Q1 2024)
+**Duration**: 3 weeks
+**Deliverables**:
+- FCM/APNs integration
+- Notification preferences
+- Push notification templates
+- Delivery tracking and analytics
+- Mobile app notification handling
+
+**Success Criteria**:
+- Notifications delivered within 5 seconds
+- 95%+ delivery success rate
+- User preferences respected
+- Analytics show notification engagement
+
+### Milestone 2.3: Offline Synchronization (Q1 2024)
+**Duration**: 4 weeks
+**Deliverables**:
+- Offline report queuing
+- Conflict resolution strategies
+- Data synchronization protocols
+- Mobile app offline indicators
+- Background sync management
+
+**Success Criteria**:
+- Reports submitted offline sync when connected
+- No data loss during offline periods
+- Conflict resolution works automatically
+- Sync status clearly indicated to users
+
+### Milestone 2.4: Custom Event Types (Q2 2024)
+**Duration**: 3 weeks
+**Deliverables**:
+- Dynamic event type creation
+- Company-specific type management
+- Hierarchical type relationships
+- Type-specific workflows
+- Import/export functionality
+
+**Success Criteria**:
+- Companies can create custom event types
+- Type hierarchies work correctly
+- Mobile apps reflect new types immediately
+- Type management interface intuitive
+
+### Milestone 2.5: Enhanced Mobile Features (Q2 2024)
+**Duration**: 4 weeks
+**Deliverables**:
+- Advanced location tracking
+- Offline map functionality
+- Media attachment optimization
+- Battery optimization
+- Background location services
+
+**Success Criteria**:
+- Location accuracy within 10 meters
+- Battery usage < 5% per hour during tracking
+- Media uploads work reliably
+- Offline maps load within 3 seconds
+
+## Phase 3: Enterprise Scale
+
+### Milestone 3.1: Multi-Region Deployment (Q3 2024)
+**Duration**: 6 weeks
+**Deliverables**:
+- Kubernetes orchestration
+- Multi-region database replication
+- CDN integration for media
+- Global load balancing
+- Cross-region failover
+
+**Success Criteria**:
+- Zero-downtime deployments
+- Data replicated across regions
+- Global user access < 100ms latency
+- Automatic failover works correctly
+
+### Milestone 3.2: Advanced AI Features (Q3 2024)
+**Duration**: 8 weeks
+**Deliverables**:
+- Custom model training pipeline
+- Advanced detection types
+- Video analytics and tracking
+- ML model performance monitoring
+- Automated model updates
+
+**Success Criteria**:
+- Detection accuracy > 95%
+- Model training completes within 4 hours
+- Performance monitoring alerts work
+- Model updates deploy automatically
+
+### Milestone 3.3: Enterprise Security (Q4 2024)
+**Duration**: 6 weeks
+**Deliverables**:
+- SOC 2 compliance implementation
+- Advanced audit logging
+- Data encryption at rest
+- Network segmentation
+- Penetration testing and remediation
+
+**Success Criteria**:
+- SOC 2 Type II certification achieved
+- All data encrypted in transit and at rest
+- Security audit passes with zero critical issues
+- Incident response plan documented and tested
+
+### Milestone 3.4: Advanced Integrations (Q4 2024)
+**Duration**: 8 weeks
+**Deliverables**:
+- Third-party API integrations
+- Webhook system for real-time data
+- Custom integration framework
+- API rate limiting and management
+- Integration documentation and SDKs
+
+**Success Criteria**:
+- 5+ major integrations working
+- Webhook delivery reliability > 99.9%
+- Custom integrations can be built in < 1 week
+- API documentation auto-generated
+
+## Success Metrics
+
+### Technical Metrics
+- **Uptime**: 99.9% service availability
+- **Response Time**: < 200ms API response time (P95)
+- **Throughput**: Support 10,000+ concurrent users
+- **Data Accuracy**: > 99.9% data consistency
+- **Security**: Zero security incidents
+
+### Business Metrics
+- **User Adoption**: 100+ active companies within 6 months
+- **Incident Response**: Average < 5 minutes response time
+- **Report Volume**: Process 10,000+ reports per month
+- **Mobile Usage**: 80%+ reports submitted via mobile
+- **Customer Satisfaction**: > 4.5/5 user satisfaction score
+
+### Quality Metrics
+- **Test Coverage**: > 85% code coverage
+- **Bug Rate**: < 0.5 bugs per 1000 lines of code
+- **Performance**: < 2 second page load times
+- **Accessibility**: WCAG 2.1 AA compliance
+- **Documentation**: 100% API documentation coverage
+
+## Risk Mitigation
+
+### Technical Risks
+- **Scalability Issues**: Regular performance testing, horizontal scaling design
+- **Data Loss**: Multi-region backups, point-in-time recovery
+- **Security Vulnerabilities**: Automated security scanning, regular audits
+- **Integration Complexity**: Modular architecture, comprehensive testing
+
+### Business Risks
+- **Market Adoption**: MVP validation, user feedback integration
+- **Competition**: Unique AI + mobile combination, first-mover advantage
+- **Regulatory Changes**: Compliance monitoring, flexible architecture
+- **Resource Constraints**: Phased development, MVP-first approach
+
+### Operational Risks
+- **Team Continuity**: Documentation, knowledge sharing, cross-training
+- **Vendor Dependencies**: Multiple vendor options, open standards
+- **Deployment Issues**: Blue-green deployments, automated rollback
+- **Support Load**: Self-service resources, tiered support model
+
+## Resource Requirements
+
+### Development Team
+- **Phase 1**: 4-6 developers (2 backend, 1 frontend, 1 AI/ML, 1 DevOps)
+- **Phase 2**: 6-8 developers (additional mobile, QA, analytics)
+- **Phase 3**: 10-12 developers (additional security, integrations, SRE)
+
+### Infrastructure Costs
+- **Development**: $500-1000/month (cloud development environment)
+- **Staging**: $1000-2000/month (full environment replication)
+- **Production**: $2000-5000/month (initial, scales with usage)
+- **AI/ML**: $1000-3000/month (GPU instances for model training)
+
+### Third-Party Services
+- **Cloud Provider**: AWS/GCP/Azure ($500-2000/month)
+- **Monitoring**: DataDog/New Relic ($200-500/month)
+- **Security**: Snyk/SonarQube ($100-300/month)
+- **CI/CD**: GitHub Actions ($0-100/month)
+
+### Timeline and Budget
+- **Phase 1**: 4 months, $150K-250K
+- **Phase 2**: 4 months, $300K-500K
+- **Phase 3**: 6 months, $600K-1M
+
+This roadmap provides a clear path forward while maintaining flexibility to adapt to user feedback, technical discoveries, and market conditions. Regular reviews and adjustments will ensure the platform meets its goals efficiently and effectively.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/06-BEGINNER-GUIDE.md b/event-monitoring-mvp-architecture/team-documentation/06-BEGINNER-GUIDE.md
index d6efc6f..2690b67 100644
--- a/event-monitoring-mvp-architecture/team-documentation/06-BEGINNER-GUIDE.md
+++ b/event-monitoring-mvp-architecture/team-documentation/06-BEGINNER-GUIDE.md
@@ -1,680 +1,319 @@
-# Beginner's Guide to Software Development
-
-## ğŸ“ Welcome to Software Development!
-
-This guide is designed specifically for students and new developers joining our Event Monitoring MVP project. We'll explain fundamental concepts in simple terms and show you how they apply to our real project.
-
-## ğŸŒŸ What is Software Development?
-
-**Software development** is the process of creating computer programs that solve real-world problems. Think of it like building with digital LEGO blocks - you combine different pieces (code) to create something useful (an application).
-
-### **Our Project Example**
-We're building a security system that:
-1. **Watches** cameras automatically (instead of human guards watching 24/7)
-2. **Thinks** using AI to spot people or vehicles
-3. **Alerts** security teams when something important happens
-4. **Remembers** everything for later investigation
-
-## ğŸ§© Core Programming Concepts
-
-### **Variables - Storing Information**
-Variables are like labeled boxes that hold information.
-
-```javascript
-// Think of these as labeled storage boxes
-let cameraName = "Main Entrance Camera";
-let isOnline = true;
-let numberOfPeople = 3;
-
-// In our project, we store camera information like this:
-const camera = {
-  name: "Main Entrance Camera",
-  status: "online",
-  location: "Building A - Level 1"
-};
-```
-
-**Real-world analogy**: Like writing information on a sticky note and putting it on your desk for later.
-
-### **Functions - Reusable Actions**
-Functions are like recipes - a set of instructions you can use over and over.
-
-```javascript
-// A function to check if a camera is working
-function isCameraOnline(camera) {
-  if (camera.status === "online") {
-    return true;
-  } else {
-    return false;
-  }
-}
-
-// Now we can use this function anywhere
-let mainCamera = { name: "Main Camera", status: "online" };
-let isWorking = isCameraOnline(mainCamera); // Returns true
-```
-
-**Real-world analogy**: Like having a recipe for making coffee - once you write it down, anyone can follow the steps.
-
-### **Objects - Grouping Related Information**
-Objects bundle related information together, like a profile card.
-
-```javascript
-// Instead of separate variables:
-let cameraName = "Main Entrance";
-let cameraStatus = "online";
-let cameraLocation = { x: 100, y: 200 };
-
-// We group them in an object:
-const camera = {
-  name: "Main Entrance",
-  status: "online",
-  location: { x: 100, y: 200 },
-  // Functions can be inside objects too!
-  turnOn: function() {
-    this.status = "online";
-  }
-};
-```
-
-**Real-world analogy**: Like a business card that has all your contact information in one place.
-
-### **Arrays - Lists of Things**
-Arrays store multiple items in a list.
-
-```javascript
-// A list of all our cameras
-const cameras = [
-  "Main Entrance Camera",
-  "Parking Lot Camera", 
-  "Back Door Camera"
-];
-
-// Access items by position (starting from 0)
-console.log(cameras[0]); // "Main Entrance Camera"
-console.log(cameras[1]); // "Parking Lot Camera"
-
-// Add a new camera to the list
-cameras.push("Rooftop Camera");
-```
-
-**Real-world analogy**: Like a shopping list where each item has a number.
-
-## ğŸŒ Web Development Basics
-
-### **Frontend vs Backend**
-Think of a restaurant:
-- **Frontend** = The dining room (what customers see and interact with)
-- **Backend** = The kitchen (where the actual work happens, hidden from customers)
-
-#### **Frontend (The User Interface)**
-What users see and click on:
-```html
-<!-- HTML: The structure -->
-<div class="camera-card">
-  <h3>Main Entrance Camera</h3>
-  <button onclick="turnOnCamera()">Turn On</button>
-</div>
-```
-
-```css
-/* CSS: The styling (colors, layout) */
-.camera-card {
-  background-color: white;
-  border: 1px solid gray;
-  padding: 20px;
-  border-radius: 10px;
-}
-```
-
-```javascript
-// JavaScript: The behavior
-function turnOnCamera() {
-  alert("Camera is now online!");
-}
-```
-
-#### **Backend (The Server)**
-Handles data and business logic:
-```javascript
-// When user clicks "Turn On Camera" button,
-// the frontend sends a request to the backend:
-app.post('/api/cameras/turn-on', (request, response) => {
-  // 1. Validate the user has permission
-  if (!userHasPermission(request.user)) {
-    return response.status(403).json({ error: "Not authorized" });
-  }
-  
-  // 2. Actually turn on the camera
-  const result = turnOnPhysicalCamera(request.body.cameraId);
-  
-  // 3. Send back the result
-  response.json({ success: true, message: "Camera turned on" });
-});
-```
-
-### **Databases - Long-term Memory**
-Databases store information permanently, like a filing cabinet.
-
-```javascript
-// Instead of losing data when the program stops:
-let cameras = []; // This disappears when computer restarts
-
-// We save to a database:
-const camera = {
-  id: 1,
-  name: "Main Entrance",
-  createdDate: "2024-01-15",
-  status: "online"
-};
-
-// Save to database (MongoDB in our project)
-db.cameras.insertOne(camera);
-```
-
-**Real-world analogy**: Like writing important information in a notebook instead of just remembering it.
-
-## ğŸ¨ Our Technology Stack (Simplified)
-
-### **Frontend Technologies**
-
-#### **React - Building User Interfaces**
-React lets us build webpages with reusable components.
-
-```javascript
-// A component is like a custom HTML element
-function CameraCard({ camera }) {
-  return (
-    <div className="camera-card">
-      <h3>{camera.name}</h3>
-      <p>Status: {camera.status}</p>
-      {camera.status === 'online' ? (
-        <span style={{color: 'green'}}>â—</span>
-      ) : (
-        <span style={{color: 'red'}}>â—</span>
-      )}
-    </div>
-  );
-}
-
-// Use the component multiple times
-function CameraList({ cameras }) {
-  return (
-    <div>
-      {cameras.map(camera => (
-        <CameraCard key={camera.id} camera={camera} />
-      ))}
-    </div>
-  );
-}
-```
-
-**Why React?**: Imagine building with LEGO blocks where each block can be reused in different projects.
-
-#### **TypeScript - JavaScript with Safety**
-TypeScript prevents common programming mistakes by checking your code before it runs.
-
-```typescript
-// JavaScript (can cause errors):
-function addCameras(a, b) {
-  return a + b;
-}
-addCameras("5", 3); // Returns "53" instead of 8 - Bug!
-
-// TypeScript (prevents errors):
-function addCameras(a: number, b: number): number {
-  return a + b;
-}
-addCameras("5", 3); // ERROR: Cannot use string where number expected
-```
-
-**Why TypeScript?**: Like having spell-check for code - catches mistakes before they cause problems.
-
-### **Backend Technologies**
-
-#### **Node.js - JavaScript on the Server**
-Lets us use JavaScript for both frontend and backend.
-
-```javascript
-// A simple web server
-const express = require('express');
-const app = express();
-
-// When someone visits /api/cameras, send back camera data
-app.get('/api/cameras', (request, response) => {
-  const cameras = [
-    { id: 1, name: "Main Entrance", status: "online" },
-    { id: 2, name: "Parking Lot", status: "offline" }
-  ];
-  response.json(cameras);
-});
-
-// Start the server
-app.listen(5000, () => {
-  console.log('Server running on port 5000');
-});
-```
-
-**Why Node.js?**: Like having one language (JavaScript) for everything instead of learning multiple languages.
-
-#### **MongoDB - Document Database**
-Stores data in flexible, JSON-like documents.
-
-```javascript
-// Traditional databases use rigid tables:
-Users Table:
-| ID | Name     | Email           |
-| 1  | John Doe | john@email.com  |
-
-// MongoDB uses flexible documents:
-{
-  "_id": 1,
-  "name": "John Doe", 
-  "email": "john@email.com",
-  "profile": {
-    "department": "Security",
-    "shift": "Night",
-    "permissions": ["view_cameras", "acknowledge_events"]
-  }
-}
-```
-
-**Why MongoDB?**: Like using a flexible notebook where each page can have different information, instead of a rigid form.
-
-## ğŸ¤– Artificial Intelligence Concepts
-
-### **What is AI in Our Project?**
-Our AI is like a digital security guard that can "see" and "understand" what's happening in camera footage.
-
-#### **Computer Vision - Teaching Computers to See**
-```python
-# Simplified version of what our AI does:
-
-def analyze_camera_frame(image):
-    # 1. Look at the image
-    objects_found = []
-    
-    # 2. Scan for people
-    people_locations = find_people_in_image(image)
-    for location in people_locations:
-        objects_found.append({
-            "type": "person",
-            "confidence": 0.95,  # 95% sure it's a person
-            "location": location
-        })
-    
-    # 3. Scan for vehicles  
-    vehicles = find_vehicles_in_image(image)
-    for vehicle in vehicles:
-        objects_found.append({
-            "type": "vehicle", 
-            "confidence": 0.87,
-            "location": vehicle
-        })
-    
-    return objects_found
-
-# When we find something important:
-detections = analyze_camera_frame(camera_image)
-if len(detections) > 0:
-    send_alert_to_security_team(detections)
-```
-
-#### **Machine Learning Models**
-Think of ML models like teaching a computer to recognize patterns.
-
-**Training Process (like teaching a child):**
-1. **Show examples**: "This is a person, this is a car, this is a tree"
-2. **Test understanding**: "What do you see in this new image?"
-3. **Correct mistakes**: "No, that's a person, not a tree"
-4. **Repeat until accurate**: After thousands of examples, it gets good at recognizing
-
-**Our Model (YOLOv8):**
-- Already trained on millions of images
-- Can identify 80+ different types of objects
-- Processes images very quickly (real-time)
-
-## ğŸ”§ Development Tools
-
-### **Version Control - Git**
-Git tracks changes to code like "Track Changes" in Microsoft Word, but much more powerful.
-
-```bash
-# Save your current work
-git add .                    # Stage all changes
-git commit -m "Add camera offline alert feature"  # Save with description
-
-# Share with team  
-git push origin feature/camera-alerts    # Upload to GitHub
-
-# Get team updates
-git pull origin main         # Download latest changes from team
-```
-
-**Why Git?**: Like having an infinite "undo" button that works across your entire team.
-
-### **Code Editor - VS Code**
-A powerful text editor designed for programming.
-
-**Essential VS Code Features:**
-- **Syntax highlighting**: Colors code to make it easier to read
-- **Auto-completion**: Suggests what you might want to type
-- **Error detection**: Shows mistakes as you type
-- **Integrated terminal**: Run commands without leaving the editor
-- **Extensions**: Add functionality (like spell-check for code)
-
-### **Package Managers - npm**
-npm manages external code libraries (like an app store for code).
-
-```bash
-# Install a library that someone else wrote
-npm install express         # Web server framework
-npm install react          # User interface library
-npm install mongoose       # Database connection library
-
-# All libraries listed in package.json file:
-{
-  "dependencies": {
-    "express": "4.18.2",
-    "react": "18.2.0", 
-    "mongoose": "7.5.0"
-  }
-}
-```
-
-**Why npm?**: Like using pre-built furniture instead of making everything from scratch.
-
-## ğŸ“š Learning Path for Beginners
-
-### **Phase 1: Programming Fundamentals (Weeks 1-4)**
-
-#### **Week 1: HTML & CSS**
-Learn to create basic web pages:
-```html
-<!DOCTYPE html>
-<html>
-<head>
-  <title>My Security Dashboard</title>
-  <style>
-    .header { background-color: blue; color: white; padding: 20px; }
-    .camera-list { display: flex; gap: 20px; }
-  </style>
-</head>
-<body>
-  <div class="header">
-    <h1>Security Monitoring System</h1>
-  </div>
-  <div class="camera-list">
-    <div>Camera 1: Online</div>
-    <div>Camera 2: Offline</div>
-  </div>
-</body>
-</html>
-```
-
-**Practice Projects:**
-- Create a personal webpage
-- Build a simple calculator layout
-- Design a camera status dashboard mockup
-
-#### **Week 2: JavaScript Basics**
-Learn programming fundamentals:
-```javascript
-// Variables and data types
-let userName = "Security Guard";
-let isLoggedIn = false;
-let cameras = ["Camera 1", "Camera 2", "Camera 3"];
-
-// Functions
-function login(username, password) {
-  if (username === "admin" && password === "secure123") {
-    isLoggedIn = true;
-    return "Login successful";
-  } else {
-    return "Login failed";
-  }
-}
-
-// Loops
-for (let i = 0; i < cameras.length; i++) {
-  console.log("Checking " + cameras[i]);
-}
-
-// Objects
-let user = {
-  name: "John Doe",
-  role: "Security Manager",
-  permissions: ["view_cameras", "manage_users"]
-};
-```
-
-**Practice Projects:**
-- Build a simple camera status checker
-- Create a basic login form with validation
-- Make a event counter application
-
-#### **Week 3: React Fundamentals**
-Learn component-based development:
-```javascript
-import React from 'react';
-
-// Simple component
-function WelcomeMessage({ userName }) {
-  return <h1>Welcome, {userName}!</h1>;
-}
-
-// Component with state
-function CameraStatus() {
-  const [isOnline, setIsOnline] = React.useState(true);
-  
-  return (
-    <div>
-      <p>Camera Status: {isOnline ? 'Online' : 'Offline'}</p>
-      <button onClick={() => setIsOnline(!isOnline)}>
-        Toggle Status
-      </button>
-    </div>
-  );
-}
-
-// Using components
-function App() {
-  return (
-    <div>
-      <WelcomeMessage userName="Security Team" />
-      <CameraStatus />
-    </div>
-  );
-}
-```
-
-**Practice Projects:**
-- Build a todo list app
-- Create a camera dashboard with multiple components
-- Make an event log viewer
-
-#### **Week 4: API Integration**
-Learn to connect frontend with backend:
-```javascript
-// Fetch data from server
-async function getCameras() {
-  try {
-    const response = await fetch('/api/cameras');
-    const cameras = await response.json();
-    return cameras;
-  } catch (error) {
-    console.error('Error fetching cameras:', error);
-    return [];
-  }
-}
-
-// Use in React component
-function CameraList() {
-  const [cameras, setCameras] = React.useState([]);
-  
-  React.useEffect(() => {
-    getCameras().then(setCameras);
-  }, []);
-  
-  return (
-    <div>
-      {cameras.map(camera => (
-        <div key={camera.id}>
-          {camera.name}: {camera.status}
-        </div>
-      ))}
-    </div>
-  );
-}
-```
-
-### **Phase 2: Project Integration (Weeks 5-8)**
-
-#### **Week 5: Environment Setup**
-- Install Node.js, Git, VS Code
-- Clone the project repository
-- Run the project locally with Docker
-- Make your first small change
-
-#### **Week 6: Code Reading & Understanding**
-- Read through existing components
-- Understand the project structure
-- Follow data flow from frontend to backend
-- Ask questions about confusing parts
-
-#### **Week 7: First Feature Development**
-- Choose a small feature to implement
-- Write code following project patterns
-- Test your changes thoroughly
-- Submit a pull request for review
-
-#### **Week 8: Testing & Quality**
-- Learn to write unit tests
-- Understand debugging techniques
-- Practice code review process
-- Learn Git branching and merging
-
-### **Phase 3: Specialization (Weeks 9-12)**
-Choose your focus area and dive deeper:
-
-#### **Frontend Specialist Track**
-- Advanced React patterns (custom hooks, context)
-- State management with Redux
-- Performance optimization techniques
-- Responsive design and accessibility
-
-#### **Backend Specialist Track**
-- API design best practices
-- Database schema design
-- Authentication and security
-- Performance monitoring and optimization
-
-#### **Full-Stack Track**
-- Understand entire application flow
-- DevOps basics (Docker, deployment)
-- System architecture concepts
-- Integration testing
-
-## ğŸ¯ Success Tips for New Developers
-
-### **Learning Strategies**
-1. **Start Small**: Begin with tiny changes before big features
-2. **Ask Questions**: No question is too basic - everyone was a beginner once
-3. **Read Documentation**: Get comfortable reading official docs and tutorials
-4. **Practice Daily**: Even 30 minutes of coding daily builds skills
-5. **Debug Systematically**: Learn to use browser dev tools and debugger
-
-### **Common Beginner Mistakes (and How to Avoid Them)**
-
-#### **Mistake 1: Not Reading Error Messages**
-```javascript
-// Error: Cannot read property 'name' of undefined
-// Beginner reaction: "It's broken!"
-// Better approach: Check if the object exists first
-
-// Bad:
-function displayCamera(camera) {
-  return camera.name;  // Crashes if camera is null/undefined
-}
-
-// Good:
-function displayCamera(camera) {
-  if (!camera) {
-    return "No camera data";
-  }
-  return camera.name || "Unnamed camera";
-}
-```
-
-#### **Mistake 2: Not Using Version Control Properly**
-```bash
-# Bad: Making changes without commits
-# Work for hours, then everything breaks, no way to undo
-
-# Good: Commit frequently
-git add .
-git commit -m "Add camera status indicator"
-# Continue working...
-git add .  
-git commit -m "Fix camera status color styling"
-```
-
-#### **Mistake 3: Copy-Pasting Without Understanding**
-```javascript
-// Bad: Copy code without understanding
-// (Leads to bugs and confusion)
-
-// Good: Understand each line
-function authenticateUser(username, password) {
-  // Hash the password to compare with stored hash
-  const hashedPassword = hashPassword(password);
-  
-  // Look up user in database
-  const user = findUserByUsername(username);
-  
-  // Compare hashed passwords securely
-  if (user && user.passwordHash === hashedPassword) {
-    return generateToken(user);
-  }
-  return null;
-}
-```
-
-### **Resources for Continued Learning**
-
-#### **Online Tutorials**
-- **JavaScript**: [MDN JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
-- **React**: [Official React Tutorial](https://react.dev/learn)
-- **Node.js**: [Node.js Getting Started Guide](https://nodejs.org/en/docs/guides/getting-started-guide/)
-
-#### **Practice Platforms**
-- **FreeCodeCamp**: Free interactive coding lessons
-- **Codecademy**: Structured programming courses
-- **LeetCode**: Coding challenges and algorithms
-- **Project Euler**: Mathematical programming problems
-
-#### **YouTube Channels**
-- **Traversy Media**: Web development tutorials
-- **The Net Ninja**: JavaScript and React tutorials
-- **Academind**: Full-stack development courses
-
-### **Building Your Developer Toolkit**
-
-#### **Essential Skills Checklist**
-- [ ] Can read and write basic HTML/CSS
-- [ ] Understands JavaScript fundamentals (variables, functions, loops)
-- [ ] Can create React components
-- [ ] Knows how to use Git for version control
-- [ ] Can debug issues using browser dev tools
-- [ ] Understands how APIs work
-- [ ] Can read error messages and search for solutions
-- [ ] Knows when and how to ask for help
-
-#### **Soft Skills for Success**
-- **Problem-solving**: Break big problems into smaller pieces
-- **Communication**: Explain technical concepts clearly
-- **Collaboration**: Work effectively with team members
-- **Patience**: Programming requires persistence and patience
-- **Curiosity**: Always be eager to learn new technologies
-
-Remember: Every expert was once a beginner. The key is consistent practice, asking questions, and never being afraid to make mistakes - that's how you learn!
\ No newline at end of file
+# Event Monitoring Platform - Beginner Guide
+
+Welcome to the Event Monitoring and Management Platform! This guide will help new team members understand the system architecture, key concepts, and development workflow.
+
+## Table of Contents
+1. [System Overview](#system-overview)
+2. [Multi-Tenant Architecture](#multi-tenant-architecture)
+3. [User Roles and Authentication](#user-roles-and-authentication)
+4. [Events vs Reports](#events-vs-reports)
+5. [Mobile Integration](#mobile-integration)
+6. [Development Workflow](#development-workflow)
+7. [Key Technologies](#key-technologies)
+8. [Getting Started](#getting-started)
+
+## System Overview
+
+The Event Monitoring Platform is a comprehensive system for detecting, reporting, and managing security and safety incidents. It combines:
+
+- **AI-powered camera detection** for automatic incident identification
+- **Mobile citizen reporting** for community engagement
+- **First responder coordination** with real-time location tracking
+- **Web dashboard** for centralized monitoring and management
+- **Multi-tenant architecture** supporting multiple independent organizations
+
+## Multi-Tenant Architecture
+
+The platform uses a **company-based multi-tenant model** where each organization has isolated data and configurations:
+
+### Key Concepts
+- **Company**: Top-level tenant with API key authentication
+- **API Key**: Unique identifier for mobile app access and company validation
+- **Data Isolation**: All data (users, events, cameras) is scoped to specific companies
+- **Shared Services**: Global event types and system features available to all companies
+
+### Company Setup
+```javascript
+// Example company configuration
+{
+  name: "City Police Department",
+  apiKey: "cpd_abc123def456",
+  subscription: {
+    plan: "professional",
+    maxUsers: 50,
+    maxCameras: 25
+  }
+}
+```
+
+## User Roles and Authentication
+
+The system supports multiple user types with different authentication methods:
+
+### Web Dashboard Users
+- **operator**: Monitors events, manages assignments
+- **admin**: User management within company
+- **company_admin**: Company-wide settings and billing
+- **super_admin**: System-wide company management
+
+*Authentication*: Email + password with JWT tokens
+
+### Mobile Users
+- **citizen**: Community reporters via mobile app
+- **first_responder**: Emergency personnel with live tracking
+
+*Authentication*: Phone + password for first responders, API key validation for all mobile access
+
+### Authentication Flow
+```javascript
+// Web login
+POST /api/auth/login
+{
+  email: "operator@company.com",
+  password: "securepass"
+}
+
+// Mobile access
+Headers: X-API-Key: company_api_key
+POST /api/mobile/reports
+{
+  // report data
+}
+```
+
+## Events vs Reports
+
+Understanding the relationship between events and reports is crucial:
+
+### Reports
+- **Individual submissions** from citizens, cameras, or first responders
+- **Flexible data entry** - not all fields required
+- **Multiple sources** can contribute to the same incident
+- **Independent entities** that may or may not create events
+
+### Events
+- **Aggregated incidents** built from one or more reports
+- **Central coordination point** for response and management
+- **Assigned to responders** and tracked through resolution
+- **May be created automatically** from high-priority reports
+
+### Relationship Example
+```
+Report 1 (Citizen): "Suspicious person near park"
+Report 2 (Camera): AI detection at same location
+Report 3 (First Responder): "On scene, assessing situation"
+
+â†“ All linked to â†“
+
+Event: "Suspicious Activity - Central Park"
+- Status: Active
+- Assigned to: Officer Smith
+- Priority: High
+```
+
+## Mobile Integration
+
+Mobile apps connect through API key authentication:
+
+### Citizen App
+- Browse public event types
+- Submit anonymous or authenticated reports
+- Include photos, videos, location data
+- Receive notifications about local events
+
+### First Responder App
+- Phone/password authentication
+- Live location tracking during responses
+- Access to assigned event details
+- Update event status and add reports
+
+### API Key Validation
+```javascript
+// Every mobile request includes
+Headers: {
+  'X-API-Key': 'company_specific_api_key'
+}
+
+// Backend validates company access
+const company = await validateApiKey(req.headers['x-api-key']);
+if (!company) throw new ForbiddenError();
+```
+
+## Development Workflow
+
+### Project Structure
+```
+event-monitoring-mvp/
+â”œâ”€â”€ backend/           # Node.js/Express API server
+â”œâ”€â”€ frontend/          # React dashboard application
+â”œâ”€â”€ ai-service/        # Python AI detection service
+â”œâ”€â”€ docker/           # Container configurations
+â””â”€â”€ scripts/          # Database setup and utilities
+
+event-monitoring-mvp-architecture/
+â””â”€â”€ docs/            # Architecture documentation
+```
+
+### Development Setup
+1. **Clone repositories**
+2. **Install dependencies**: `npm install` in backend/frontend
+3. **Environment setup**: Copy `.env.example` to `.env`
+4. **Database**: Run `npm run setup-db` to initialize MongoDB
+5. **Start services**: `docker-compose up` for full stack
+
+### Key Scripts
+```bash
+# Backend development
+npm run dev          # Start with hot reload
+npm run build        # Production build
+npm run test         # Run test suite
+
+# Database management
+npm run setup-db     # Initialize database
+npm run seed-db      # Add sample data
+
+# Docker operations
+docker-compose up    # Start all services
+docker-compose down  # Stop services
+```
+
+## Key Technologies
+
+### Backend
+- **Node.js + Express**: RESTful API server
+- **TypeScript**: Type-safe development
+- **MongoDB + Mongoose**: Document database with schemas
+- **JWT**: Authentication tokens
+- **WebSocket**: Real-time updates
+
+### Frontend
+- **React + TypeScript**: Component-based UI
+- **Redux**: State management
+- **Leaflet**: Interactive maps
+- **Material-UI**: Component library
+
+### AI Service
+- **Python + FastAPI**: ML service API
+- **YOLOv8**: Object detection
+- **OpenCV**: Computer vision processing
+
+### Infrastructure
+- **Docker**: Containerized deployment
+- **Nginx**: Reverse proxy and load balancing
+- **MongoDB**: Primary database
+- **Redis**: Caching and session storage
+
+## Getting Started
+
+### 1. Environment Setup
+```bash
+# Install Node.js 18+, Python 3.9+, Docker
+
+# Clone the project
+git clone <repository-url>
+cd event-monitoring-mvp
+
+# Install backend dependencies
+cd backend
+npm install
+
+# Install frontend dependencies
+cd ../frontend
+npm install
+
+# Install AI service dependencies
+cd ../ai-service
+pip install -r requirements.txt
+```
+
+### 2. Configuration
+```bash
+# Copy environment files
+cp backend/.env.example backend/.env
+cp frontend/.env.example frontend/.env
+
+# Edit .env files with your settings
+# - Database connection strings
+# - JWT secrets
+# - API keys
+# - Service URLs
+```
+
+### 3. Database Setup
+```bash
+# Start MongoDB
+docker run -d -p 27017:27017 --name mongodb mongo:latest
+
+# Initialize database schema
+cd backend
+npm run setup-db
+
+# Optional: Add sample data
+npm run seed-db
+```
+
+### 4. Running the Application
+```bash
+# Start all services
+docker-compose up -d
+
+# Or run individually
+cd backend && npm run dev
+cd frontend && npm start
+cd ai-service && python main.py
+```
+
+### 5. Testing
+```bash
+# API tests
+cd backend
+npm test
+
+# Mobile API testing
+# Use tools like Postman or curl with X-API-Key header
+
+# Example API call
+curl -X POST http://localhost:3000/api/mobile/reports \
+  -H "X-API-Key: your_company_api_key" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "reportType": "citizen",
+    "title": "Test Report",
+    "description": "Testing mobile integration",
+    "eventTypeId": "...",
+    "location": {
+      "type": "Point",
+      "coordinates": [-118.2437, 34.0522]
+    }
+  }'
+```
+
+## Common Tasks
+
+### Adding a New Event Type
+1. Use admin dashboard or API to create event type
+2. Set category, priority, and public visibility
+3. Configure auto-creation rules if needed
+4. Test with mobile app submission
+
+### Setting Up a New Company
+1. Create company via super_admin API
+2. Note the generated API key
+3. Configure company settings and subscription
+4. Create initial admin user
+5. Provide API key to mobile app developers
+
+### Troubleshooting
+- **API Key Issues**: Verify X-API-Key header is present and valid
+- **Database Connection**: Check MongoDB is running and connection string
+- **CORS Errors**: Ensure frontend URL is in allowed origins
+- **WebSocket Issues**: Check firewall settings for port 8080
+
+## Next Steps
+
+1. **Read the Architecture Docs**: Deep dive into [system architecture](docs/architecture/)
+2. **Explore the API**: Review [backend endpoints](docs/api/backend_endpoints.md)
+3. **Understand Data Models**: Check [data model documentation](docs/data-models/)
+4. **Join Team Coordination**: Follow the [team coordination protocol](../team-coordination-protocol.md)
+
+Welcome aboard! The Event Monitoring Platform is a complex but rewarding system to work with. Don't hesitate to ask questions and contribute to our growing codebase.
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/team-documentation/README.md b/event-monitoring-mvp-architecture/team-documentation/README.md
deleted file mode 100644
index 8c7c3c6..0000000
--- a/event-monitoring-mvp-architecture/team-documentation/README.md
+++ /dev/null
@@ -1,208 +0,0 @@
-# Team Documentation Index
-
-Welcome to the comprehensive team documentation for the Event Monitoring MVP project! This documentation is specifically designed for student developers who are new to coding and need detailed explanations of our system.
-
-## ğŸ“š Documentation Structure
-
-### **01. [Project Overview](./01-PROJECT-OVERVIEW.md)**
-**Complete understanding of what we're building**
-- ğŸ¯ Project goals and main features
-- âœ… What we've already completed
-- ğŸš§ Current development status
-- ğŸ”® Future implementation plans
-- ğŸ›ï¸ System architecture overview
-- ğŸ“ Learning opportunities for students
-- ğŸš€ Business value and success metrics
-
-**Best for:** Understanding the big picture and project goals
-
----
-
-### **02. [Technology Stack Guide](./02-TECHNOLOGY-STACK.md)**
-**Deep dive into all technologies we use**
-- ğŸŒ Frontend technologies (React, TypeScript, Material-UI)
-- ğŸ–¥ï¸ Backend technologies (Node.js, Express, MongoDB)
-- ğŸ¤– AI/ML technologies (Python, YOLOv8, OpenCV)
-- ğŸ› ï¸ DevOps tools (Docker, Git, VS Code)
-- ğŸ”— How everything connects together
-- ğŸ“– Learning resources for each technology
-
-**Best for:** Understanding the tools and why we chose them
-
----
-
-### **03. [Architecture & Design Patterns](./03-ARCHITECTURE-DIAGRAMS.md)**
-**System design and architectural patterns**
-- ğŸ—ï¸ Microservices architecture overview
-- ğŸ”„ Data flow patterns and communication
-- ğŸ“Š Database design and schemas
-- ğŸ”’ Security architecture
-- ğŸ“ˆ Scalability considerations
-- ğŸ¨ Design patterns we implement (MVC, Observer, Factory)
-
-**Best for:** Understanding how the system is structured and why
-
----
-
-### **04. [Development Workflow](./04-DEVELOPMENT-WORKFLOW.md)**
-**Complete guide to working on the project**
-- ğŸš€ Getting started checklist
-- ğŸ”„ Git workflow and branching strategy
-- ğŸ§ª Testing strategy and best practices
-- ğŸ” Code review process
-- ğŸ› Debugging guide and common issues
-- ğŸ“Š Performance monitoring
-
-**Best for:** Daily development work and team collaboration
-
----
-
-### **05. [Implementation Roadmap](./05-IMPLEMENTATION-ROADMAP.md)**
-**Detailed plan for future development**
-- ğŸ“‹ Current MVP status (what's done)
-- ğŸš§ Phase 1: AI Integration (next 4-6 weeks)
-- ğŸ”® Phase 2: Advanced Features (months 2-3)
-- ğŸš€ Phase 3: Enterprise Features (months 4-6)
-- ğŸ¯ Success metrics and KPIs
-- ğŸ“š Learning path for developers
-
-**Best for:** Planning work and understanding project timeline
-
----
-
-### **06. [Beginner's Guide](./06-BEGINNER-GUIDE.md)**
-**Complete introduction for students new to programming**
-- ğŸ“ Programming fundamentals explained simply
-- ğŸŒ Web development concepts
-- ğŸ§© How our technologies fit together
-- ğŸ“š Step-by-step learning path (12-week plan)
-- ğŸ¯ Success tips and common mistakes
-- ğŸ› ï¸ Building your developer toolkit
-
-**Best for:** Students completely new to programming
-
----
-
-## ğŸ¯ How to Use This Documentation
-
-### **For New Team Members**
-1. **Start here:** Read [Project Overview](./01-PROJECT-OVERVIEW.md) to understand what we're building
-2. **Learn the tools:** Study [Technology Stack Guide](./02-TECHNOLOGY-STACK.md) for the technologies
-3. **Understand the code:** Read [Architecture & Design Patterns](./03-ARCHITECTURE-DIAGRAMS.md)
-4. **Start developing:** Follow [Development Workflow](./04-DEVELOPMENT-WORKFLOW.md) to set up your environment
-5. **Plan your learning:** Use [Beginner's Guide](./06-BEGINNER-GUIDE.md) if you're new to programming
-
-### **For Project Managers**
-1. **Project status:** [Project Overview](./01-PROJECT-OVERVIEW.md) for current status
-2. **Future planning:** [Implementation Roadmap](./05-IMPLEMENTATION-ROADMAP.md) for timeline and features
-3. **Team capability:** [Beginner's Guide](./06-BEGINNER-GUIDE.md) to understand team learning needs
-4. **Process oversight:** [Development Workflow](./04-DEVELOPMENT-WORKFLOW.md) for team processes
-
-### **For Technical Leads**
-1. **Architecture review:** [Architecture & Design Patterns](./03-ARCHITECTURE-DIAGRAMS.md) for system design
-2. **Technology decisions:** [Technology Stack Guide](./02-TECHNOLOGY-STACK.md) for technical choices
-3. **Development standards:** [Development Workflow](./04-DEVELOPMENT-WORKFLOW.md) for quality processes
-4. **Mentoring support:** [Beginner's Guide](./06-BEGINNER-GUIDE.md) for helping junior developers
-
-## ğŸš€ Quick Start Checklist
-
-### **Day 1: Understanding**
-- [ ] Read [Project Overview](./01-PROJECT-OVERVIEW.md) completely
-- [ ] Skim [Technology Stack Guide](./02-TECHNOLOGY-STACK.md) to familiarize with tools
-- [ ] Review team roles and responsibilities
-- [ ] Set up communication channels (Slack, email, etc.)
-
-### **Day 2-3: Environment Setup**
-- [ ] Follow [Development Workflow - Getting Started](./04-DEVELOPMENT-WORKFLOW.md#getting-started-your-first-day)
-- [ ] Install required software (Node.js, Docker, VS Code, etc.)
-- [ ] Clone the repository and run the project locally
-- [ ] Complete the beginner tutorial if new to programming
-
-### **Day 4-5: First Contribution**
-- [ ] Pick a small task from the current sprint
-- [ ] Create a feature branch following our Git workflow
-- [ ] Make a small change and submit a pull request
-- [ ] Participate in code review process
-
-### **Week 2+: Regular Development**
-- [ ] Choose specialization path (frontend, backend, or full-stack)
-- [ ] Take on progressively larger tasks
-- [ ] Mentor newer team members as you learn
-- [ ] Contribute to documentation improvements
-
-## ğŸ“– Documentation Maintenance
-
-### **Keeping Documentation Current**
-- **Update responsibility:** Each developer updates docs when making changes
-- **Review schedule:** Documentation reviewed every 2 weeks
-- **Version control:** All docs are version-controlled with code
-- **Feedback loop:** Team members suggest improvements during code reviews
-
-### **Contributing to Documentation**
-```bash
-# Update documentation alongside code changes
-git checkout -b feature/add-user-management
-# ... make code changes ...
-# ... update relevant documentation ...
-git add .
-git commit -m "feat: add user management with documentation updates"
-git push origin feature/add-user-management
-```
-
-## ğŸ“ Learning Resources
-
-### **Project-Specific**
-- **Code Examples:** Every concept includes real code from our project
-- **Hands-On Practice:** Documentation includes exercises and practice projects
-- **Progressive Complexity:** Content organized from basic to advanced
-- **Student-Friendly:** Written specifically for coding students
-
-### **External Resources**
-- **Official Docs:** Links to official documentation for all technologies
-- **Tutorials:** Curated list of beginner-friendly tutorials
-- **Video Content:** Recommended YouTube channels and courses
-- **Practice Platforms:** Coding challenge websites for skill building
-
-## ğŸ’¡ Documentation Philosophy
-
-### **Student-Centered Design**
-- **Clear Explanations:** Technical concepts explained in simple terms
-- **Real-World Context:** Show how concepts apply to our actual project
-- **Progressive Learning:** Build complexity gradually
-- **Practical Focus:** Emphasize what students need to know for this project
-
-### **Living Documentation**
-- **Always Current:** Updated with every significant code change
-- **Team Collaboration:** Multiple contributors ensure accuracy
-- **Feedback Integration:** Regular updates based on team feedback
-- **Continuous Improvement:** Documentation evolves with the project
-
-## ğŸ¤ Getting Help
-
-### **When You're Stuck**
-1. **Check Documentation:** Search these docs first
-2. **Search Issues:** Check GitHub issues for similar problems
-3. **Ask Team Chat:** Use team communication channels
-4. **Schedule Pairing:** Work with senior developer on complex issues
-5. **Code Review:** Submit draft PR for early feedback
-
-### **Documentation Questions**
-- **Missing Information:** Open an issue to request documentation additions
-- **Unclear Explanations:** Suggest improvements via pull request
-- **New Topics:** Propose new documentation sections
-- **Examples Needed:** Request more code examples for complex topics
-
-Remember: This documentation is designed to support your learning journey from complete beginner to confident contributor. Take your time, ask questions, and use these resources to build your skills progressively!
-
----
-
-## ğŸ“§ Contact Information
-
-- **Technical Lead:** [Add contact information]
-- **Project Manager:** [Add contact information]  
-- **Team Chat:** [Add Slack/Discord channel]
-- **Email List:** [Add team email]
-
-*Last Updated: [Current Date]*
-*Version: 1.0*
-*Contributors: [List team members who contributed to documentation]*
\ No newline at end of file
diff --git a/event-monitoring-mvp-architecture/tsconfig.json b/event-monitoring-mvp-architecture/tsconfig.json
index ba46f39..5f12d6e 100644
--- a/event-monitoring-mvp-architecture/tsconfig.json
+++ b/event-monitoring-mvp-architecture/tsconfig.json
@@ -1,18 +1,18 @@
-{
-  "compilerOptions": {
-    "target": "ES6",
-    "module": "commonjs",
-    "strict": true,
-    "esModuleInterop": true,
-    "skipLibCheck": true,
-    "forceConsistentCasingInFileNames": true,
-    "outDir": "./dist",
-    "rootDir": "./src",
-    "baseUrl": "./src",
-    "paths": {
-      "*": ["types/*"]
-    }
-  },
-  "include": ["src/**/*"],
-  "exclude": ["node_modules", "dist"]
+{
+  "compilerOptions": {
+    "target": "ES6",
+    "module": "commonjs",
+    "strict": true,
+    "esModuleInterop": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true,
+    "outDir": "./dist",
+    "rootDir": "./src",
+    "baseUrl": "./src",
+    "paths": {
+      "*": ["types/*"]
+    }
+  },
+  "include": ["src/**/*"],
+  "exclude": ["node_modules", "dist"]
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp/.github/copilot-instructions.md b/event-monitoring-mvp/.github/copilot-instructions.md
new file mode 100644
index 0000000..6dc9156
--- /dev/null
+++ b/event-monitoring-mvp/.github/copilot-instructions.md
@@ -0,0 +1,1049 @@
+# Copilot Instructions for Event Monitoring MVP
+
+This file contains coding standards, architectural patterns, and development practices for the Event Monitoring MVP project. These instructions help ensure consistent code quality and maintainability across the team, including mobile citizen reporting integration.
+
+## ğŸ—ï¸ Project Architecture
+
+### Overview
+This is a microservices-based event monitoring system with the following structure:
+- **Frontend**: React + TypeScript + Redux (SPA for operators/admins)
+- **Backend**: Node.js + Express + TypeScript (REST API + WebSocket)
+- **Mobile API**: Citizen reporting endpoints with flexible authentication
+- **AI Service**: Python + FastAPI (AI detection processing)
+- **Database**: MongoDB (document-based storage with flexible schemas)
+- **Infrastructure**: Docker + Docker Compose
+
+### User Types & Authentication
+- **Citizens**: Mobile app users with phone-based authentication (anonymous reporting allowed)
+- **Operators**: Dashboard users with email/password authentication
+- **Admins**: Full system access with comprehensive permissions
+- **Mobile Admins**: Manage mobile app features and citizen-reported events
+- **Super Admins**: Ultimate authority with permission management capabilities
+
+### Service Communication
+- Frontend â†” Backend: REST API + WebSocket for real-time updates
+- Mobile App â†” Backend: REST API with mobile-optimized endpoints (`/api/mobile/*`)
+- Backend â†” AI Service: HTTP API for detection processing
+- Backend â†” Database: Mongoose ODM with flexible schemas and inheritance
+
+## ğŸ“ Project Structure Standards
+
+### Backend (`/backend/src/`)
+```
+src/
+â”œâ”€â”€ app.ts                    # Main Express application
+â”œâ”€â”€ controllers/             # Request handlers and business logic
+â”‚   â”œâ”€â”€ mobileEventController.ts    # Citizen reporting endpoints
+â”‚   â”œâ”€â”€ mobileAuthController.ts     # Phone-based authentication
+â”‚   â””â”€â”€ eventController.ts          # Standard event management
+â”œâ”€â”€ middleware/             # Authentication, validation, error handling
+â”‚   â”œâ”€â”€ mobileAuth.ts       # Phone verification and anonymous auth
+â”‚   â””â”€â”€ auth.ts             # Standard JWT authentication
+â”œâ”€â”€ models/                 # MongoDB schemas and interfaces
+â”‚   â”œâ”€â”€ EventType.ts        # Dynamic event type system
+â”‚   â”œâ”€â”€ Permission.ts       # Granular permission management
+â”‚   â”œâ”€â”€ User.ts            # Enhanced user model with roles
+â”‚   â””â”€â”€ Event.ts           # Updated event model with EventType refs
+â”œâ”€â”€ routes/                # API route definitions
+â”‚   â”œâ”€â”€ mobile/           # Mobile-specific endpoints
+â”‚   â””â”€â”€ eventTypes.ts     # EventType management for mobile team
+â””â”€â”€ utils/                # Database connection and utilities
+    â”œâ”€â”€ eventTypeMapper.ts  # Backward compatibility layer
+    â””â”€â”€ mediaUpload.ts      # Mobile image/video processing
+```
+
+### Frontend (`/frontend/src/`)
+```
+src/
+â”œâ”€â”€ App.tsx                 # Main application component
+â”œâ”€â”€ components/             # Reusable UI components
+â”œâ”€â”€ pages/                  # Page-level components
+â”œâ”€â”€ services/               # API calls and external services
+â”œâ”€â”€ store/                  # Redux state management
+â””â”€â”€ types/                  # TypeScript type definitions
+```
+
+## ğŸ¯ TypeScript Coding Standards
+
+### File Organization
+- Use **PascalCase** for component files: `EventCard.tsx`, `UserController.ts`
+- Use **camelCase** for utility files: `database.ts`, `validation.ts`
+- Export interfaces with `I` prefix: `IEvent`, `IUser`, `ICamera`, `IEventType`, `IPermission`
+- Mobile controllers use `mobile` prefix: `mobileEventController.ts`, `mobileAuthController.ts`
+
+### Enhanced Model System
+The project uses a flexible schema system to support mobile integration:
+
+```typescript
+// Dynamic EventType model for flexible event categorization
+export interface IEventType extends Document {
+  name: string;
+  category: 'security' | 'traffic' | 'emergency' | 'maintenance' | 'social' | 'environmental';
+  parentType?: mongoose.Types.ObjectId; // Hierarchical types/subtypes
+  isPublic: boolean; // Available for citizen reporters
+  allowedRoles: string[]; // Which user roles can use this type
+  defaultSeverity: 'low' | 'medium' | 'high' | 'critical' | 'emergency';
+  requiredFields: string[]; // Dynamic field requirements
+}
+
+// Enhanced Event model with EventType integration
+export interface IEvent extends Document {
+  eventType: {
+    typeId: mongoose.Types.ObjectId; // Reference to EventType
+    name: string; // Cached for performance
+    category: string; // Cached for performance
+  };
+  type?: string; // Legacy field for backward compatibility
+  reporter: {
+    userId?: mongoose.Types.ObjectId;
+    isAnonymous: boolean;
+    sessionId?: string; // For anonymous mobile users
+    deviceInfo?: { platform: 'ios' | 'android' | 'web' };
+  };
+  mobileSubmission?: {
+    submittedOffline: boolean;
+    networkType: 'wifi' | 'cellular' | 'unknown';
+  };
+}
+
+// Flexible User model with multiple authentication methods
+export interface IUser extends Document {
+  role: 'citizen' | 'operator' | 'admin' | 'mobile_admin' | 'super_admin';
+  authMethod: 'email_password' | 'phone_otp' | 'social_oauth';
+  phone?: string; // For mobile authentication
+  permissions: {
+    granted: mongoose.Types.ObjectId[]; // Individual permissions
+    inherited: mongoose.Types.ObjectId[]; // Role-based permissions
+  };
+  mobileSettings?: {
+    deviceTokens: string[]; // Push notification support
+  };
+}
+```
+
+### Function Documentation
+Always include JSDoc comments for functions and components:
+```typescript
+/**
+ * Creates a new event in the system
+ * 
+ * @param eventData - The event data to create
+ * @param userId - ID of the user creating the event
+ * @returns Promise<IEvent> - The created event
+ * @throws {ValidationError} When event data is invalid
+ */
+export const createEvent = async (eventData: CreateEventDTO, userId: string): Promise<IEvent> => {
+  // Implementation here
+};
+```
+
+## ğŸ”§ API Development Patterns
+
+### Dual API Structure
+The system supports both traditional operator APIs and mobile citizen APIs:
+
+**Operator/Admin APIs** (`/api/*`):
+```typescript
+// Standard authentication with JWT
+GET  /api/events                    # Paginated event listing with filters
+POST /api/events                    # Create event (operators/admins)
+PUT  /api/events/:id                # Update event details
+```
+
+**Mobile Citizen APIs** (`/api/mobile/*`):
+```typescript
+// Phone-based or anonymous authentication
+GET  /api/mobile/event-types        # Public event types for citizens
+POST /api/mobile/events             # Citizen event reporting
+POST /api/mobile/auth/phone-verify  # Phone number verification
+GET  /api/mobile/events/my          # User's submitted events
+```
+
+### Enhanced Controller Structure
+All controllers now support flexible permissions and mobile optimization:
+
+```typescript
+export const createMobileEvent = [
+  // Mobile-optimized validation
+  body('eventType.typeId').isMongoId().withMessage('Valid event type is required'),
+  body('location.coordinates').isArray({ min: 2, max: 2 }),
+  body('reporter.isAnonymous').isBoolean(),
+  
+  // Permission check with EventType validation
+  async (req: Request, res: Response): Promise<void> => {
+    try {
+      const errors = validationResult(req);
+      if (!errors.isEmpty()) {
+        res.status(400).json({ 
+          success: false, 
+          message: 'Validation failed', 
+          errors: errors.array() 
+        });
+        return;
+      }
+
+      // Verify EventType is public and allowed for citizen role
+      const eventType = await EventType.findById(req.body.eventType.typeId);
+      if (!eventType?.isPublic || !eventType.allowedRoles.includes('citizen')) {
+        res.status(403).json({
+          success: false,
+          message: 'Event type not available for public reporting'
+        });
+        return;
+      }
+
+      // Create event with validation requirements
+      const event = await Event.create({
+        ...req.body,
+        eventType: {
+          typeId: eventType._id,
+          name: eventType.name,
+          category: eventType.category
+        },
+        source: 'mobile_app',
+        validation: {
+          requiresApproval: eventType.requiresVerification,
+          autoApproved: !eventType.requiresVerification
+        }
+      });
+      
+      // Mobile-optimized response
+      res.status(201).json({
+        success: true,
+        message: 'Event reported successfully',
+        data: { 
+          event: {
+            id: event._id,
+            status: event.status,
+            requiresApproval: event.validation.requiresApproval
+          }
+        }
+      });
+    } catch (error) {
+      console.error('Mobile event creation error:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to report event'
+      });
+    }
+  }
+];
+```
+
+### Enhanced Response Format Standards
+All API responses follow this format with additional mobile considerations:
+
+```typescript
+interface APIResponse<T = any> {
+  success: boolean;
+  message: string;
+  data?: T;
+  errors?: ValidationError[];
+  pagination?: {
+    page: number;
+    limit: number;
+    total: number;
+    totalPages: number;
+  };
+  // Mobile-specific fields
+  requiresAuth?: boolean;      // Indicates if authentication is needed
+  syncTimestamp?: Date;        // For offline sync coordination
+  rateLimit?: {                // Rate limiting info for mobile apps
+    remaining: number;
+    resetTime: Date;
+  };
+}
+
+// Mobile event submission response
+interface MobileEventResponse {
+  success: boolean;
+  message: string;
+  data: {
+    event: {
+      id: string;
+      status: string;
+      requiresApproval: boolean;
+      estimatedProcessingTime?: number; // In minutes
+    };
+  };
+  nextActions?: {              // Guide user on next steps
+    canUploadMedia: boolean;
+    canTrackStatus: boolean;
+    contactInfo?: string;
+  };
+}
+```
+
+## âš›ï¸ React Component Standards
+
+### Component Structure
+```typescript
+/**
+ * EventCard Component
+ * 
+ * Displays event information in a card format with status indicators
+ * and action buttons for event management.
+ * 
+ * @param event - The event data to display
+ * @param onStatusChange - Callback when event status is changed
+ * @param className - Additional CSS classes
+ */
+interface EventCardProps {
+  event: IEvent;
+  onStatusChange?: (eventId: string, newStatus: string) => void;
+  className?: string;
+}
+
+const EventCard: React.FC<EventCardProps> = ({ event, onStatusChange, className }) => {
+  // Component logic here
+  
+  return (
+    <div className={`event-card ${className || ''}`}>
+      {/* Component JSX */}
+    </div>
+  );
+};
+
+export default EventCard;
+```
+
+### Redux State Management
+- Use Redux Toolkit for state management
+- Create separate slices for each domain (auth, events, cameras, users)
+- Use typed hooks (`useAppSelector`, `useAppDispatch`)
+
+```typescript
+// Store slice example
+const eventSlice = createSlice({
+  name: 'events',
+  initialState: {
+    items: [] as IEvent[],
+    loading: false,
+    error: null
+  },
+  reducers: {
+    setLoading: (state, action) => {
+      state.loading = action.payload;
+    },
+    setEvents: (state, action) => {
+      state.items = action.payload;
+    }
+  }
+});
+```
+
+## ğŸ—„ï¸ Enhanced Database Standards
+
+### Flexible Schema Design with EventType System
+The system uses dynamic EventType references instead of hardcoded enums:
+
+```typescript
+// EventType model for dynamic type management
+const EventTypeSchema = new Schema<IEventType>({
+  name: { 
+    type: String, 
+    required: true,
+    unique: true
+  },
+  category: {
+    type: String,
+    enum: ['security', 'traffic', 'emergency', 'maintenance', 'social', 'environmental'],
+    required: true
+  },
+  parentType: {
+    type: Schema.Types.ObjectId,
+    ref: 'EventType', // Supports hierarchical types/subtypes
+    default: null
+  },
+  isPublic: {
+    type: Boolean,
+    default: false // Can citizens use this type?
+  },
+  allowedRoles: {
+    type: [String],
+    required: true,
+    validate: {
+      validator: function(roles: string[]) {
+        const validRoles = ['citizen', 'operator', 'admin', 'mobile_admin', 'super_admin'];
+        return roles.every(role => validRoles.includes(role));
+      }
+    }
+  },
+  defaultSeverity: {
+    type: String,
+    enum: ['low', 'medium', 'high', 'critical', 'emergency'],
+    default: 'medium'
+  },
+  requiredFields: {
+    type: [String], // Dynamic field requirements
+    default: ['title', 'location']
+  },
+  autoAssignmentRules: {
+    // Intelligent auto-assignment based on location, time, severity
+    location: {
+      type: { type: String, enum: ['Point'] },
+      coordinates: [Number],
+      radius: Number
+    },
+    assignTo: { type: Schema.Types.ObjectId, ref: 'User' }
+  }
+});
+
+// Enhanced Event model with EventType integration
+const EventSchema = new Schema<IEvent>({
+  eventType: {
+    typeId: {
+      type: Schema.Types.ObjectId,
+      ref: 'EventType',
+      required: function() { return !this.type; } // Either new or legacy
+    },
+    name: String, // Cached for performance
+    category: String // Cached for performance
+  },
+  type: {
+    // Legacy field for backward compatibility
+    type: String,
+    enum: ['security_incident', 'traffic_violation', 'emergency', '...'],
+    required: function() { return !this.eventType?.typeId; }
+  },
+  reporter: {
+    isAnonymous: { type: Boolean, default: false },
+    sessionId: String, // For anonymous mobile tracking
+    deviceInfo: {
+      platform: { type: String, enum: ['ios', 'android', 'web'] }
+    }
+  },
+  mobileSubmission: {
+    submittedOffline: { type: Boolean, default: false },
+    submissionAttempts: { type: Number, default: 1 },
+    networkType: { type: String, enum: ['wifi', 'cellular', 'unknown'] }
+  },
+  validation: {
+    requiresApproval: { type: Boolean, default: false },
+    approvedBy: { type: Schema.Types.ObjectId, ref: 'User' },
+    autoApproved: { type: Boolean, default: false }
+  }
+});
+
+// Pre-save middleware to populate EventType cache
+EventSchema.pre('save', async function() {
+  if (this.eventType?.typeId && this.isModified('eventType.typeId')) {
+    const eventType = await mongoose.model('EventType').findById(this.eventType.typeId);
+    if (eventType) {
+      this.eventType.name = eventType.name;
+      this.eventType.category = eventType.category;
+      // Auto-set defaults from EventType
+      if (this.isNew) {
+        this.severity = this.severity || eventType.defaultSeverity;
+        this.priority = this.priority || eventType.defaultPriority;
+      }
+    }
+  }
+});
+```
+
+## ğŸ³ Docker & Environment Standards
+
+### Docker Configuration
+- Use multi-stage builds for production optimization
+- Include health checks in all services
+- Use environment variables for configuration
+- Follow security best practices (non-root users, minimal base images)
+
+### Environment Variables
+Always use environment variables for:
+- Database connection strings
+- API keys and secrets
+- Service URLs and ports
+- Feature flags
+
+```env
+# Database Configuration
+MONGODB_URI=mongodb://localhost:27017/event_monitoring
+MONGODB_TEST_URI=mongodb://localhost:27017/event_monitoring_test
+
+# Authentication
+JWT_SECRET=your_jwt_secret_here
+JWT_EXPIRES_IN=7d
+
+# AI Service
+AI_SERVICE_URL=http://ai-service:8000
+AI_SERVICE_API_KEY=your_ai_api_key
+```
+
+## ğŸ” Enhanced Security & Authorization Standards
+
+### Multi-Tier Authentication System
+Support for different user types with appropriate authentication methods:
+
+```typescript
+// Phone-based authentication for mobile citizens
+export const verifyPhoneOTP = async (phone: string, otp: string) => {
+  // Verify OTP and create/update user
+  const user = await User.findOneAndUpdate(
+    { phone, authMethod: 'phone_otp' },
+    {
+      $set: { 
+        'authentication.phoneVerified': true,
+        lastLogin: new Date()
+      },
+      $inc: { 'usage.loginCount': 1 }
+    },
+    { new: true, upsert: true }
+  );
+  
+  // Generate session token (shorter lived for mobile)
+  const token = jwt.sign(
+    { userId: user._id, role: user.role },
+    process.env.JWT_SECRET,
+    { expiresIn: '7d' } // Extended for mobile convenience
+  );
+  
+  return { user, token };
+};
+
+// Permission-based middleware with context awareness
+export const requirePermission = (permissionName: string, options: {
+  resource?: string;
+  action?: string;
+  allowAnonymous?: boolean;
+  mobileOptimized?: boolean;
+} = {}) => {
+  return async (req: Request, res: Response, next: NextFunction) => {
+    try {
+      // Handle anonymous access for certain mobile endpoints
+      if (options.allowAnonymous && !req.user) {
+        // Rate limit anonymous requests more aggressively
+        const rateLimitConfig = options.mobileOptimized ? 
+          { windowMs: 15 * 60 * 1000, max: 5 } : // 5 per 15 minutes
+          { windowMs: 15 * 60 * 1000, max: 100 };
+        // Apply rate limiting logic here
+        return next();
+      }
+      
+      if (!req.user) {
+        return res.status(401).json({
+          success: false,
+          message: 'Authentication required',
+          requiresAuth: true
+        });
+      }
+      
+      // Context for permission checking
+      const context = {
+        location: req.body?.location || req.query?.location,
+        severity: req.body?.severity || req.query?.severity,
+        currentTime: new Date(),
+        userIp: req.ip
+      };
+      
+      const hasPermission = await req.user.hasPermission(permissionName, context);
+      if (!hasPermission) {
+        return res.status(403).json({
+          success: false,
+          message: 'Insufficient permissions'
+        });
+      }
+      
+      next();
+    } catch (error) {
+      console.error('Permission check error:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Permission validation failed'
+      });
+    }
+  };
+};
+```
+
+### Granular Permission System
+The system implements flexible role-based access control with individual permission assignment:
+
+```typescript
+// Permission model for fine-grained authorization
+const PermissionSchema = new Schema<IPermission>({
+  name: { type: String, unique: true, required: true },
+  resource: {
+    type: String,
+    enum: ['events', 'cameras', 'users', 'eventTypes', 'permissions', 'mobile_users'],
+    required: true
+  },
+  actions: {
+    type: [String],
+    enum: ['read', 'create', 'update', 'delete', 'assign', 'approve', 'reject'],
+    required: true
+  },
+  scope: {
+    type: String,
+    enum: ['global', 'location', 'department', 'self', 'assigned'],
+    default: 'self'
+  },
+  conditions: {
+    locations: [{ type: Schema.Types.ObjectId, ref: 'Location' }],
+    severity: [{ type: String, enum: ['low', 'medium', 'high', 'critical', 'emergency'] }],
+    timeRestrictions: {
+      allowedHours: [{ start: Number, end: Number }],
+      allowedDays: [{ type: Number, min: 0, max: 6 }]
+    }
+  }
+});
+
+// Enhanced User model with flexible permissions
+const UserSchema = new Schema<IUser>({
+  role: {
+    type: String,
+    enum: ['citizen', 'operator', 'admin', 'mobile_admin', 'super_admin'],
+    default: 'citizen'
+  },
+  authMethod: {
+    type: String,
+    enum: ['email_password', 'phone_otp', 'social_oauth'],
+    default: 'email_password'
+  },
+  phone: {
+    type: String,
+    sparse: true,
+    match: /^\+?[1-9]\d{1,14}$/
+  },
+  permissions: {
+    granted: [{ type: Schema.Types.ObjectId, ref: 'Permission' }],
+    inherited: [{ type: Schema.Types.ObjectId, ref: 'Permission' }],
+    lastUpdated: { type: Date, default: Date.now }
+  },
+  authentication: {
+    phoneVerified: { type: Boolean, default: false },
+    emailVerified: { type: Boolean, default: false },
+    failedAttempts: { type: Number, default: 0 },
+    lockoutUntil: Date
+  }
+});
+
+// Permission checking method
+UserSchema.methods.hasPermission = async function(permissionName: string, context?: any) {
+  const allPermissionIds = [...this.permissions.granted, ...this.permissions.inherited];
+  const permissions = await mongoose.model('Permission').find({ 
+    _id: { $in: allPermissionIds },
+    name: permissionName 
+  });
+  return permissions.some(permission => permission.appliesToConditions(context || {}));
+};
+```
+
+## ğŸ“± Mobile API Integration Standards
+
+### Mobile-First Design Principles
+- **Offline Support**: All critical features should work offline and sync when connected
+- **Battery Efficiency**: Minimize API calls and optimize data transfer
+- **Progressive Enhancement**: Gracefully degrade features based on network conditions
+- **Anonymous Friendly**: Support anonymous reporting with optional authentication
+
+### Mobile Endpoint Patterns
+```typescript
+// Mobile event submission with offline support
+POST /api/mobile/events
+{
+  "eventType": { "typeId": "ObjectId", "name": "Traffic Issue" },
+  "title": "Pothole on Main Street",
+  "location": {
+    "coordinates": [-122.4194, 37.7749],
+    "accuracy": 10,
+    "source": "gps"
+  },
+  "media": {
+    "images": ["data:image/jpeg;base64,..."], // Support base64 for offline
+    "videos": []
+  },
+  "reporter": {
+    "isAnonymous": true,
+    "sessionId": "uuid-for-anonymous-tracking"
+  },
+  "mobileSubmission": {
+    "submittedOffline": false,
+    "clientTimestamp": "2024-01-01T12:00:00Z",
+    "networkType": "wifi"
+  }
+}
+
+// Mobile-optimized response
+{
+  "success": true,
+  "message": "Event submitted successfully",
+  "data": {
+    "event": {
+      "id": "event-id",
+      "status": "pending",
+      "trackingNumber": "EV-2024-001",
+      "requiresApproval": true,
+      "estimatedProcessingTime": 30
+    }
+  },
+  "nextActions": {
+    "canUploadMedia": true,
+    "canTrackStatus": true,
+    "mediaUploadEndpoint": "/api/mobile/events/event-id/media"
+  },
+  "syncTimestamp": "2024-01-01T12:00:00Z"
+}
+
+// EventType management for mobile team
+GET /api/mobile/event-types
+{
+  "success": true,
+  "data": [
+    {
+      "id": "type-id",
+      "name": "Traffic Issue",
+      "category": "traffic",
+      "description": "Report traffic problems",
+      "requiredFields": ["title", "location"],
+      "allowsMedia": true,
+      "parentType": {
+        "id": "parent-id",
+        "name": "Transportation"
+      }
+    }
+  ]
+}
+```
+
+### Offline Synchronization Support
+```typescript
+// Batch sync endpoint for offline submissions
+POST /api/mobile/sync/events
+{
+  "events": [
+    {
+      "clientId": "client-generated-uuid",
+      "submittedAt": "2024-01-01T10:00:00Z",
+      "eventData": { /* event object */ }
+    }
+  ],
+  "lastSyncTimestamp": "2024-01-01T09:00:00Z"
+}
+
+// Response with conflict resolution
+{
+  "success": true,
+  "data": {
+    "synced": [
+      {
+        "clientId": "client-uuid-1",
+        "serverId": "server-generated-id",
+        "status": "created"
+      }
+    ],
+    "conflicts": [
+      {
+        "clientId": "client-uuid-2",
+        "reason": "duplicate_location_time",
+        "resolution": "merged_with_existing",
+        "serverId": "existing-event-id"
+      }
+    ]
+  },
+  "nextSyncAfter": "2024-01-01T12:30:00Z"
+}
+```
+
+### Anonymous User Session Management
+```typescript
+// Anonymous session creation
+POST /api/mobile/auth/anonymous-session
+{
+  "deviceInfo": {
+    "platform": "ios",
+    "version": "17.0",
+    "appVersion": "1.2.0"
+  },
+  "location": {
+    "coordinates": [-122.4194, 37.7749],
+    "accuracy": 50
+  }
+}
+
+// Session response
+{
+  "success": true,
+  "data": {
+    "sessionId": "anonymous-uuid",
+    "permissions": ["submit_events", "view_own_events"],
+    "expiresAt": "2024-01-02T12:00:00Z",
+    "rateLimit": {
+      "eventsPerHour": 5,
+      "remaining": 5
+    }
+  }
+}
+```
+
+## ğŸ“ Documentation Standards
+
+### Code Comments
+- Use JSDoc for functions and classes
+- Explain complex business logic
+- Document API endpoints with examples
+- Include error scenarios in documentation
+
+### README Structure
+Each module should have a README with:
+- Purpose and functionality
+- Setup and installation steps
+- API documentation (if applicable)
+- Usage examples
+- Troubleshooting section
+
+## ğŸš€ Deployment & DevOps
+
+### Git Workflow
+- Use feature branches for new development
+- Require pull requests for main branch
+- Include meaningful commit messages
+- Tag releases with semantic versioning
+
+### CI/CD Pipeline
+- Run tests on all pull requests
+- Build and push Docker images
+- Deploy to staging environment first
+- Automated rollback procedures
+
+## ğŸ¨ UI/UX Standards
+
+### Component Design
+- Mobile-first responsive design
+- Consistent color scheme and typography
+- Loading states for all async operations
+- Error boundaries for graceful error handling
+- Accessibility compliance (WCAG 2.1)
+
+### User Experience
+- Clear navigation and breadcrumbs
+- Immediate feedback for user actions
+- Progressive loading for large datasets
+- Offline support where applicable
+
+## ğŸ”„ Real-time Features
+
+### WebSocket Communication
+```typescript
+// Socket.IO event patterns
+socket.on('event:created', (event: IEvent) => {
+  // Handle new event notification
+  dispatch(addEvent(event));
+  showNotification(`New ${event.severity} event: ${event.title}`);
+});
+
+socket.on('camera:status_changed', (camera: ICamera) => {
+  // Update camera status in real-time
+  dispatch(updateCameraStatus(camera));
+});
+```
+
+## ğŸ“Š Performance Standards
+
+### Optimization Guidelines
+- Use React.memo for expensive components
+- Implement virtual scrolling for large lists
+- Use database indexing for frequently queried fields
+- Implement caching for static data
+- Optimize images and media files
+- Use pagination for large datasets
+
+### Monitoring Requirements
+- Log all errors with context
+- Monitor API response times
+- Track user interactions
+- Monitor resource usage
+- Set up alerts for critical issues
+
+## ğŸ·ï¸ Enhanced Naming Conventions
+
+### Variables and Functions
+- Use descriptive, self-documenting names
+- Boolean variables start with `is`, `has`, `can`, `should`
+- Functions use verb-noun pattern: `createEvent`, `validateUser`, `syncMobileEvents`
+- Constants use SCREAMING_SNAKE_CASE: `MAX_FILE_SIZE`, `MOBILE_API_VERSION`
+- Mobile-specific functions use `mobile` prefix: `processMobileEvent`, `validateMobileAuth`
+
+### Database Collections and Fields
+- Collection names are lowercase plural: `events`, `eventtypes`, `permissions`, `rolepermissions`
+- Field names use camelCase: `createdAt`, `assignedTo`, `eventType.typeId`
+- Avoid abbreviations: use `description` not `desc`, `coordinates` not `coords`
+- Mobile fields use descriptive prefixes: `mobileSubmission`, `deviceInfo`, `sessionId`
+
+### API Endpoints
+- Standard endpoints: `/api/resource` (e.g., `/api/events`, `/api/users`)
+- Mobile endpoints: `/api/mobile/resource` (e.g., `/api/mobile/events`, `/api/mobile/auth`)
+- EventType management: `/api/event-types` (accessible by mobile team)
+- Sync endpoints: `/api/mobile/sync/*` for offline coordination
+
+## ğŸ“Š Performance & Monitoring Standards
+
+### Mobile-Optimized Performance
+```typescript
+// Implement pagination for mobile with smaller page sizes
+const getMobileEvents = async (req: Request, res: Response) => {
+  const page = parseInt(req.query.page as string) || 1;
+  const limit = Math.min(parseInt(req.query.limit as string) || 10, 20); // Max 20 for mobile
+  
+  const events = await Event.find({ 
+    'reporter.userId': req.user._id 
+  })
+    .select('_id title status createdAt eventType.name') // Limited fields for mobile
+    .sort({ createdAt: -1 })
+    .limit(limit)
+    .skip((page - 1) * limit)
+    .lean(); // Use lean() for better performance
+    
+  res.json({
+    success: true,
+    data: events,
+    pagination: {
+      page,
+      limit,
+      total: await Event.countDocuments({ 'reporter.userId': req.user._id })
+    }
+  });
+};
+
+// Implement response caching for EventTypes
+const getCachedEventTypes = async (req: Request, res: Response) => {
+  const cacheKey = 'public-event-types';
+  const cached = await redis.get(cacheKey);
+  
+  if (cached) {
+    return res.json({ 
+      success: true, 
+      data: JSON.parse(cached),
+      cached: true 
+    });
+  }
+  
+  const eventTypes = await EventType.find({ 
+    isActive: true, 
+    isPublic: true 
+  }).lean();
+  
+  await redis.setex(cacheKey, 300, JSON.stringify(eventTypes)); // 5 min cache
+  
+  res.json({ success: true, data: eventTypes });
+};
+```
+
+### Error Handling & Logging
+```typescript
+// Mobile-specific error responses
+export const mobileErrorHandler = (error: any, req: Request, res: Response, next: NextFunction) => {
+  console.error('Mobile API Error:', {
+    error: error.message,
+    stack: error.stack,
+    endpoint: req.path,
+    userAgent: req.headers['user-agent'],
+    userId: req.user?._id
+  });
+
+  // Don't expose internal errors to mobile clients
+  if (error.name === 'ValidationError') {
+    return res.status(400).json({
+      success: false,
+      message: 'Invalid request data',
+      errors: Object.values(error.errors).map((e: any) => ({
+        field: e.path,
+        message: e.message
+      })),
+      code: 'VALIDATION_ERROR'
+    });
+  }
+
+  if (error.name === 'CastError') {
+    return res.status(400).json({
+      success: false,
+      message: 'Invalid data format',
+      code: 'INVALID_FORMAT'
+    });
+  }
+
+  // Generic error for production
+  res.status(500).json({
+    success: false,
+    message: 'Something went wrong. Please try again.',
+    code: 'INTERNAL_ERROR',
+    supportInfo: process.env.NODE_ENV === 'production' ? 
+      'Contact support if problem persists' : error.message
+  });
+};
+```
+
+## ğŸš€ Deployment & Integration Standards
+
+### Environment Configuration
+```bash
+# Mobile-specific environment variables
+MOBILE_API_VERSION=1.0
+MOBILE_RATE_LIMIT_PER_HOUR=100
+ANONYMOUS_RATE_LIMIT_PER_HOUR=10
+MOBILE_FILE_UPLOAD_MAX_SIZE=10MB
+MOBILE_SESSION_DURATION=7d
+
+# EventType management
+EVENTTYPE_CACHE_DURATION=300
+EVENTTYPE_AUTO_APPROVAL_THRESHOLD=0.8
+
+# Permission system
+PERMISSION_CACHE_DURATION=600
+ROLE_PERMISSION_SYNC_INTERVAL=3600
+
+# Backward compatibility
+LEGACY_EVENT_TYPE_SUPPORT=true
+MIGRATION_MODE=gradual
+```
+
+### Documentation Requirements
+Always document:
+- Mobile API endpoints with request/response examples
+- Permission requirements for each endpoint
+- EventType usage and management procedures
+- Backward compatibility considerations
+- Migration procedures for legacy data
+
+```typescript
+/**
+ * Create Event (Mobile API)
+ * 
+ * Allows citizen reporters to submit events using dynamic EventTypes.
+ * Supports offline submission and automatic approval workflows.
+ * 
+ * @route POST /api/mobile/events
+ * @permission events.create (auto-granted to verified citizens)
+ * @rateLimit 5 per hour for anonymous, 20 per hour for verified
+ * 
+ * @requestBody {Object} event - Event data
+ * @requestBody {Object} event.eventType - EventType reference
+ * @requestBody {string} event.eventType.typeId - Must be public EventType
+ * @requestBody {Array<number>} event.location.coordinates - [lng, lat]
+ * @requestBody {boolean} event.reporter.isAnonymous - Anonymous reporting flag
+ * 
+ * @response {Object} result - Creation result
+ * @response {Object} result.data.event - Created event summary
+ * @response {Object} result.nextActions - Available follow-up actions
+ * 
+ * @example
+ * // Request
+ * {
+ *   "eventType": { "typeId": "64a1b2c3d4e5f6789abcdef0" },
+ *   "title": "Broken streetlight",
+ *   "location": { "coordinates": [-122.4194, 37.7749] },
+ *   "reporter": { "isAnonymous": true }
+ * }
+ * 
+ * // Response
+ * {
+ *   "success": true,
+ *   "data": { "event": { "id": "...", "status": "pending" } },
+ *   "nextActions": { "canUploadMedia": true }
+ * }
+ */
+export const createMobileEvent = [/* implementation */];
+```
+
+Remember: The goal is to write code that seamlessly integrates mobile citizen reporting with the existing operator system, maintains backward compatibility during migration, and provides a flexible foundation for future enhancements. When in doubt, prioritize user experience, system flexibility, and clear documentation over rigid implementation patterns.
\ No newline at end of file
diff --git a/event-monitoring-mvp/CHANGES_OVERVIEW.md b/event-monitoring-mvp/CHANGES_OVERVIEW.md
new file mode 100644
index 0000000..a91ea93
--- /dev/null
+++ b/event-monitoring-mvp/CHANGES_OVERVIEW.md
@@ -0,0 +1,111 @@
+# Changes Overview (Camera/VMS Work)
+
+This document summarizes the major changes made to support camera/VMS integration,
+live view playback, and demo/production flows.
+
+## Major Features Added
+
+1) VMS server registry with auth (Shinobi)
+- Create, update, list, and delete VMS servers.
+- Stores Shinobi `apiKey` and `groupKey` so backend can generate stream URLs.
+
+2) Camera â†” VMS mapping + stream URLs
+- Connect/disconnect camera to a VMS server (stores `camera.vms` mapping).
+- Stream endpoint returns `liveEmbedUrl`, `liveHlsUrl`, and `snapshotUrl` for Shinobi.
+
+3) Live View playback (HLS + iframe fallback)
+- Live view prefers HLS playback using `hls.js` and a `<video>` element.
+- Falls back to Shinobi embed iframe if HLS is unavailable.
+
+4) Camera connection testing (RTSP and VMS)
+- Backend test endpoint supports:
+  - Direct RTSP/HTTP reachability (TCP/HTTP).
+  - VMS-based test for Shinobi (HLS/snapshot reachability).
+
+5) Demo vs production split
+- Cameras page now separates Shinobi Demo/Test flow vs Production flow.
+- Demo flow supports monitor discovery and batch import from Shinobi.
+- Demo cameras are tagged with `metadata.source = "shinobi-demo"` to allow bulk cleanup.
+
+6) Monitor payload hardening (Shinobi)
+- Normalizes monitor discovery responses so UI doesn't crash on non-array payloads.
+- Adds a refresh option for VMS server lists in Add Camera test mode.
+
+7) Backend CORS allowlist for local dev
+- Accepts common localhost/127.0.0.1 origins to prevent CORS network errors in the UI.
+
+8) Dev CORS relax + import description truncation
+- Non-production now allows all origins to prevent dev CORS blocks.
+- Shinobi monitor import truncates long descriptions to avoid validation errors.
+
+## Key Endpoints (Backend)
+
+VMS servers:
+- `GET /api/vms/servers`
+- `POST /api/vms/servers`
+- `PATCH /api/vms/servers/:id`
+- `DELETE /api/vms/servers/:id`
+- `GET /api/vms/servers/:id/monitors` (Shinobi)
+- `POST /api/vms/servers/:id/monitors/import` (Shinobi batch import)
+
+Cameras:
+- `POST /api/cameras/:id/vms/connect`
+- `POST /api/cameras/:id/vms/disconnect`
+- `GET /api/cameras/:id/vms/streams`
+- `POST /api/cameras/test-connection`
+- `DELETE /api/cameras/source/:source` (demo cleanup)
+
+## Important Code Blocks
+
+HLS playback (Live View):
+- File: `frontend/src/pages/LiveView.tsx`
+- Logic: use `hls.js` when `liveHlsUrl` is available, otherwise fallback to iframe.
+
+VMS monitor discovery + import:
+- File: `backend/src/controllers/vmsController.ts`
+- Shinobi API: `GET {baseUrl}/{apiKey}/monitor/{groupKey}`
+- Import maps monitors into cameras with `camera.vms` and `metadata.source`.
+
+RTSP/VMS connectivity test:
+- File: `backend/src/controllers/cameraController.ts`
+- `mode: "rtsp"` uses TCP/HTTP check.
+- `mode: "vms"` uses Shinobi HLS/snapshot check.
+
+## Frontend Components Updated
+
+- `frontend/src/pages/Cameras.tsx`
+  - Split Demo/Test and Production actions.
+  - Added monitor discovery, batch import, and demo cleanup.
+  - VMS server edit/delete actions.
+
+- `frontend/src/pages/AddCamera.tsx`
+  - Uses backend reachability test.
+  - Prevents auto-submit outside final step.
+  - Optional VMS test mode (Shinobi).
+
+- `frontend/src/pages/LiveView.tsx`
+  - HLS playback with `hls.js`.
+
+## Test-Only Markers (Camera-Related Files)
+
+These indicate demo-only UI or dev-branch access:
+- `backend/src/routes/vms.ts`
+- `backend/src/routes/cameras.ts`
+- `backend/src/models/Camera.ts`
+- `frontend/src/pages/Cameras.tsx`
+- `frontend/src/pages/LiveView.tsx`
+- `frontend/src/pages/AddCamera.tsx`
+
+## Notes and Caveats
+
+- Shinobi HLS playback is used for in-browser viewing (RTSP is not directly playable).
+- Batch import uses a default location if none is provided; update later if needed.
+- Demo cameras are tagged with `metadata.source` for easy bulk deletion.
+
+## Next Phases (If Needed)
+
+Phase 8: Playback (recordings)
+- Add playback endpoints and UI.
+
+Phase 9: FFmpeg fallback
+- Only needed if VMS is not available.
diff --git a/event-monitoring-mvp/DAILY_COMMANDS.md b/event-monitoring-mvp/DAILY_COMMANDS.md
index 6f4dae4..80f0015 100644
--- a/event-monitoring-mvp/DAILY_COMMANDS.md
+++ b/event-monitoring-mvp/DAILY_COMMANDS.md
@@ -1,259 +1,259 @@
-# ğŸš€ Event Monitoring MVP - Daily Commands Reference
-
-## Copy-Paste Quick Start (WSL from project root)
-
-### 1. Navigate to Project
-```bash
-cd /mnt/c/Users/$USER/Documents/event-monitoring-mvp  # Windows Documents
-# OR
-cd ~/event-monitoring-mvp  # If cloned in Ubuntu home
-```
-
-### 2. Start Backend
-```bash
-cd backend && npm run dev
-```
-
-### 3. Start Frontend (in new terminal)
-```bash
-cd frontend && npm start
-```
-
-### 4. Start AI Service (optional, in new terminal)
-```bash
-cd ai-service && python3 app.py
-```
-
-### 5. Login Credentials
-- **Email**: admin@example.com
-- **Password**: password123
-
----
-
-## ğŸ”§ Development Commands
-
-### Check Services Status
-```bash
-# Check running processes
-ps aux | grep -E "(node|mongod|python)"
-
-# Check ports
-netstat -tulpn | grep -E ":(3000|5000|27017|8000)"
-
-# Check MongoDB status
-sudo systemctl status mongod
-```
-
-### Install/Update Dependencies
-```bash
-# Backend
-cd backend && npm install
-
-# Frontend  
-cd frontend && npm install
-
-# AI Service
-cd ai-service && pip3 install -r requirements.txt
-```
-
-### Quick Restart All Services
-```bash
-# Stop all Node.js processes
-pkill -f node
-
-# Restart MongoDB
-sudo systemctl restart mongod
-
-# Start backend & frontend again
-cd backend && npm run dev &
-cd frontend && npm start &
-```
-
----
-
-## ğŸ—„ï¸ MongoDB Commands
-
-### Connect to MongoDB
-```bash
-mongosh
-```
-
-### Basic Database Operations (in mongosh)
-```javascript
-// Switch to project database
-use event_monitoring
-
-// Show collections
-show collections
-
-// View users
-db.users.find().pretty()
-db.users.find({}, {email: 1, username: 1, role: 1})
-
-// View cameras
-db.cameras.find().pretty()
-
-// View events  
-db.events.find().pretty()
-
-// Count documents
-db.users.countDocuments()
-db.cameras.countDocuments()  
-db.events.countDocuments()
-```
-
-### User Management (in mongosh)
-```javascript
-// Delete all users
-db.users.deleteMany({})
-
-// Delete specific user
-db.users.deleteOne({email: "user@example.com"})
-
-// Update user role
-db.users.updateOne({email: "admin@example.com"}, {$set: {role: "admin"}})
-
-// Find user by email
-db.users.findOne({email: "admin@example.com"})
-```
-
-### Create Default Users (from project root)
-```bash
-# Make sure backend is running first, then:
-node setup_default_users.js
-```
-
----
-
-## ğŸ” Debugging Commands
-
-### Backend Logs
-```bash
-cd backend && npm run dev
-# Look for error messages in console output
-```
-
-### MongoDB Logs
-```bash
-# View recent MongoDB logs
-sudo journalctl -u mongod --no-pager --lines 50
-
-# Follow MongoDB logs in real-time
-sudo journalctl -u mongod -f
-```
-
-### Check Application Health
-```bash
-# Test backend health endpoint
-curl http://localhost:5000/health
-
-# Test frontend
-curl http://localhost:3000
-
-# Test MongoDB connection
-mongosh --eval "db.runCommand('ping')"
-```
-
-### Kill Stuck Processes
-```bash
-# Kill all Node.js processes
-pkill -f node
-
-# Kill specific ports
-sudo lsof -ti:3000 | xargs sudo kill -9
-sudo lsof -ti:5000 | xargs sudo kill -9
-
-# Kill Python processes
-pkill -f python3
-```
-
----
-
-## ğŸ› ï¸ Quick Fixes
-
-### Reset Everything
-```bash
-# Stop all services
-pkill -f node
-pkill -f python3
-
-# Restart MongoDB
-sudo systemctl restart mongod
-
-# Clear users and recreate
-mongosh --eval "use event_monitoring; db.users.deleteMany({})"
-node setup_default_users.js
-
-# Start services fresh
-cd backend && npm run dev &
-cd frontend && npm start &
-```
-
-### Clean Dependencies
-```bash
-# Clean backend
-cd backend
-rm -rf node_modules package-lock.json
-npm install
-
-# Clean frontend
-cd frontend
-rm -rf node_modules package-lock.json
-npm install
-
-# Clean AI service
-cd ai-service
-pip3 install --force-reinstall -r requirements.txt
-```
-```bash
-docker exec -it event-monitoring-mongodb mongosh --username admin --password password123 --authenticationDatabase admin --eval "use event_monitoring; db.users.find().pretty()"
-```
-
-### Create Admin User (if missing)
-```bash
-docker exec -it event-monitoring-mongodb mongosh --username admin --password password123 --authenticationDatabase admin --eval "use event_monitoring; db.users.insertOne({username: 'admin', email: 'admin@example.com', password: '\$2a\$12\$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj0HIMU.Gsva', role: 'admin', isActive: true, createdAt: new Date(), updatedAt: new Date()})"
-```
-
----
-
-## ğŸ”§ Fix Common Issues
-
-### Node.js version errors (NVM conflicts):
-```bash
-# If you have NVM (most common solution):
-nvm install --lts          # Install latest LTS
-nvm use --lts              # Use latest LTS  
-nvm alias default lts/*    # Set as permanent default
-node --version             # Should be v20+ or v22+
-
-# If npm still has issues:
-npm install -g npm@latest
-```
-
-### Kill stuck processes:
-```bash
-pkill -f "ts-node-dev"
-pkill -f "react-scripts"
-```
-
-### Reset everything:
-```bash
-docker-compose down
-docker-compose up -d mongodb
-# Then restart backend & frontend
-```
-
----
-
-## ğŸ“ URLs
-- Frontend: http://localhost:3000
-- Backend: http://localhost:5000
-- Health: http://localhost:5000/health
-
-## ğŸ“Š Check Status
-```bash
-docker ps  # See running containers
-netstat -tulpn | grep :3000  # Frontend port
-netstat -tulpn | grep :5000  # Backend port  
-netstat -tulpn | grep :27017 # MongoDB port
+# ğŸš€ Event Monitoring MVP - Daily Commands Reference
+
+## Copy-Paste Quick Start (WSL from project root)
+
+### 1. Navigate to Project
+```bash
+cd /mnt/c/Users/$USER/Documents/event-monitoring-mvp  # Windows Documents
+# OR
+cd ~/event-monitoring-mvp  # If cloned in Ubuntu home
+```
+
+### 2. Start Backend
+```bash
+cd backend && npm run dev
+```
+
+### 3. Start Frontend (in new terminal)
+```bash
+cd frontend && npm start
+```
+
+### 4. Start AI Service (optional, in new terminal)
+```bash
+cd ai-service && python3 app.py
+```
+
+### 5. Login Credentials
+- **Email**: admin@example.com
+- **Password**: password123
+
+---
+
+## ğŸ”§ Development Commands
+
+### Check Services Status
+```bash
+# Check running processes
+ps aux | grep -E "(node|mongod|python)"
+
+# Check ports
+netstat -tulpn | grep -E ":(3000|5000|27017|8000)"
+
+# Check MongoDB status
+sudo systemctl status mongod
+```
+
+### Install/Update Dependencies
+```bash
+# Backend
+cd backend && npm install
+
+# Frontend  
+cd frontend && npm install
+
+# AI Service
+cd ai-service && pip3 install -r requirements.txt
+```
+
+### Quick Restart All Services
+```bash
+# Stop all Node.js processes
+pkill -f node
+
+# Restart MongoDB
+sudo systemctl restart mongod
+
+# Start backend & frontend again
+cd backend && npm run dev &
+cd frontend && npm start &
+```
+
+---
+
+## ğŸ—„ï¸ MongoDB Commands
+
+### Connect to MongoDB
+```bash
+mongosh
+```
+
+### Basic Database Operations (in mongosh)
+```javascript
+// Switch to project database
+use event_monitoring
+
+// Show collections
+show collections
+
+// View users
+db.users.find().pretty()
+db.users.find({}, {email: 1, username: 1, role: 1})
+
+// View cameras
+db.cameras.find().pretty()
+
+// View events  
+db.events.find().pretty()
+
+// Count documents
+db.users.countDocuments()
+db.cameras.countDocuments()  
+db.events.countDocuments()
+```
+
+### User Management (in mongosh)
+```javascript
+// Delete all users
+db.users.deleteMany({})
+
+// Delete specific user
+db.users.deleteOne({email: "user@example.com"})
+
+// Update user role
+db.users.updateOne({email: "admin@example.com"}, {$set: {role: "admin"}})
+
+// Find user by email
+db.users.findOne({email: "admin@example.com"})
+```
+
+### Create Default Users (from project root)
+```bash
+# Make sure backend is running first, then:
+node setup_default_users.js
+```
+
+---
+
+## ğŸ” Debugging Commands
+
+### Backend Logs
+```bash
+cd backend && npm run dev
+# Look for error messages in console output
+```
+
+### MongoDB Logs
+```bash
+# View recent MongoDB logs
+sudo journalctl -u mongod --no-pager --lines 50
+
+# Follow MongoDB logs in real-time
+sudo journalctl -u mongod -f
+```
+
+### Check Application Health
+```bash
+# Test backend health endpoint
+curl http://localhost:5000/health
+
+# Test frontend
+curl http://localhost:3000
+
+# Test MongoDB connection
+mongosh --eval "db.runCommand('ping')"
+```
+
+### Kill Stuck Processes
+```bash
+# Kill all Node.js processes
+pkill -f node
+
+# Kill specific ports
+sudo lsof -ti:3000 | xargs sudo kill -9
+sudo lsof -ti:5000 | xargs sudo kill -9
+
+# Kill Python processes
+pkill -f python3
+```
+
+---
+
+## ğŸ› ï¸ Quick Fixes
+
+### Reset Everything
+```bash
+# Stop all services
+pkill -f node
+pkill -f python3
+
+# Restart MongoDB
+sudo systemctl restart mongod
+
+# Clear users and recreate
+mongosh --eval "use event_monitoring; db.users.deleteMany({})"
+node setup_default_users.js
+
+# Start services fresh
+cd backend && npm run dev &
+cd frontend && npm start &
+```
+
+### Clean Dependencies
+```bash
+# Clean backend
+cd backend
+rm -rf node_modules package-lock.json
+npm install
+
+# Clean frontend
+cd frontend
+rm -rf node_modules package-lock.json
+npm install
+
+# Clean AI service
+cd ai-service
+pip3 install --force-reinstall -r requirements.txt
+```
+```bash
+docker exec -it event-monitoring-mongodb mongosh --username admin --password password123 --authenticationDatabase admin --eval "use event_monitoring; db.users.find().pretty()"
+```
+
+### Create Admin User (if missing)
+```bash
+docker exec -it event-monitoring-mongodb mongosh --username admin --password password123 --authenticationDatabase admin --eval "use event_monitoring; db.users.insertOne({username: 'admin', email: 'admin@example.com', password: '\$2a\$12\$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj0HIMU.Gsva', role: 'admin', isActive: true, createdAt: new Date(), updatedAt: new Date()})"
+```
+
+---
+
+## ğŸ”§ Fix Common Issues
+
+### Node.js version errors (NVM conflicts):
+```bash
+# If you have NVM (most common solution):
+nvm install --lts          # Install latest LTS
+nvm use --lts              # Use latest LTS  
+nvm alias default lts/*    # Set as permanent default
+node --version             # Should be v20+ or v22+
+
+# If npm still has issues:
+npm install -g npm@latest
+```
+
+### Kill stuck processes:
+```bash
+pkill -f "ts-node-dev"
+pkill -f "react-scripts"
+```
+
+### Reset everything:
+```bash
+docker-compose down
+docker-compose up -d mongodb
+# Then restart backend & frontend
+```
+
+---
+
+## ğŸ“ URLs
+- Frontend: http://localhost:3000
+- Backend: http://localhost:5000
+- Health: http://localhost:5000/health
+
+## ğŸ“Š Check Status
+```bash
+docker ps  # See running containers
+netstat -tulpn | grep :3000  # Frontend port
+netstat -tulpn | grep :5000  # Backend port  
+netstat -tulpn | grep :27017 # MongoDB port
 ```
\ No newline at end of file
diff --git a/event-monitoring-mvp/README.md b/event-monitoring-mvp/README.md
index 0715b67..d60537e 100644
--- a/event-monitoring-mvp/README.md
+++ b/event-monitoring-mvp/README.md
@@ -1,221 +1,332 @@
-# Event Monitoring MVP
-
-A comprehensive security event monitoring system with real-time video analysis, camera management, and interactive dashboards.
-
-## ğŸš€ Getting Started
-
-### New to this project? â†’ **[SETUP.md](./SETUP.md)** ğŸ“–
-
-**Quick Setup (experienced users):**
-
-### 1. Install Prerequisites
-```bash
-# Install WSL2 (PowerShell as Administrator)
-wsl --install
-
-# In WSL2, install Node.js
-curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
-source ~/.bashrc
-nvm install --lts && nvm use --lts && nvm alias default lts/*
-
-# Install MongoDB
-sudo apt update && sudo apt upgrade -y
-wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -
-echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
-sudo apt update && sudo apt install -y mongodb-org
-sudo systemctl start mongod && sudo systemctl enable mongod
-
-# Install Python & Git
-sudo apt install -y python3.9 python3-pip git
-```
-
-### 2. Setup Project
-```bash
-# Clone and setup
-git clone <your-repository-url>
-cd event-monitoring-mvp
-cp backend/.env.example backend/.env
-cp frontend/.env.example frontend/.env
-cp ai-service/.env.example ai-service/.env
-
-# Install dependencies
-cd backend && npm install && cd ..
-cd frontend && npm install && cd ..
-cd ai-service && pip3 install -r requirements.txt && cd ..
-```
-
-### 3. Start Development
-```bash
-# Terminal 1: Backend
-cd backend && npm run dev
-
-# Terminal 2: Frontend
-cd frontend && npm start
-
-# Create default users
-node setup_default_users.js
-```
-
-### 4. Login
-- **Frontend**: http://localhost:3000
-- **Email**: admin@example.com
-- **Password**: password123
-
-## ğŸ› ï¸ What's This Project?
-
-A full-stack security monitoring system with:
-
-- **ğŸ” Authentication**: JWT-based user management
-- **ğŸ“¹ Camera Management**: Add and monitor security cameras  
-- **ğŸ¤– AI Detection**: YOLOv8-powered object/person detection
-- **ğŸ—ºï¸ Interactive Map**: Mapbox visualization of cameras/events
-- **ğŸ“Š Dashboard**: Real-time metrics and system status
-- **ğŸ”” Real-time Alerts**: WebSocket notifications
-
-## ğŸ“ Architecture
-
-```
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚   React Frontend â”‚    â”‚  Node.js Backendâ”‚    â”‚  Python AI      â”‚
-â”‚   (Port 3000)   â”‚â”€â”€â”€â–ºâ”‚   (Port 5000)   â”‚â”€â”€â”€â–ºâ”‚  (Port 8000)    â”‚
-â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
-â”‚ â€¢ Dashboard     â”‚    â”‚ â€¢ REST API      â”‚    â”‚ â€¢ YOLOv8        â”‚
-â”‚ â€¢ Map View      â”‚    â”‚ â€¢ WebSocket     â”‚    â”‚ â€¢ OpenCV        â”‚
-â”‚ â€¢ Auth & Users  â”‚    â”‚ â€¢ JWT Auth      â”‚    â”‚ â€¢ Real-time     â”‚
-â”‚ â€¢ Camera Mgmt   â”‚    â”‚ â€¢ MongoDB ODM   â”‚    â”‚   Detection     â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-         â”‚                       â”‚                       â”‚
-         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-                                 â–¼
-                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-                    â”‚    MongoDB      â”‚
-                    â”‚   (Port 27017)  â”‚
-                    â”‚                 â”‚
-                    â”‚ â€¢ Users         â”‚
-                    â”‚ â€¢ Cameras       â”‚
-                    â”‚ â€¢ Events        â”‚
-                    â”‚ â€¢ Logs          â”‚
-                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-```
-
-## ğŸ“ Project Structure
-
-```
-event-monitoring-mvp/
-â”œâ”€â”€ README.md                 # This file
-â”œâ”€â”€ docker-compose.yml        # Docker orchestration
-â”œâ”€â”€ SETUP.md                 # Detailed setup instructions
-â”‚
-â”œâ”€â”€ frontend/                # React.js application
-â”‚   â”œâ”€â”€ src/
-â”‚   â”‚   â”œâ”€â”€ components/      # Reusable UI components
-â”‚   â”‚   â”œâ”€â”€ pages/          # Application pages/routes
-â”‚   â”‚   â”œâ”€â”€ store/          # Redux state management
-â”‚   â”‚   â”œâ”€â”€ services/       # API client services
-â”‚   â”‚   â””â”€â”€ types/          # TypeScript type definitions
-â”‚   â”œâ”€â”€ public/             # Static assets
-â”‚   â””â”€â”€ README.md           # Frontend-specific documentation
-â”‚
-â”œâ”€â”€ backend/                # Node.js Express API
-â”‚   â”œâ”€â”€ src/
-â”‚   â”‚   â”œâ”€â”€ controllers/    # Route handlers and business logic
-â”‚   â”‚   â”œâ”€â”€ models/         # MongoDB data models
-â”‚   â”‚   â”œâ”€â”€ routes/         # API route definitions
-â”‚   â”‚   â”œâ”€â”€ middleware/     # Authentication and validation
-â”‚   â”‚   â”œâ”€â”€ services/       # External service integrations
-â”‚   â”‚   â””â”€â”€ utils/          # Utility functions
-â”‚   â””â”€â”€ README.md           # Backend-specific documentation
-â”‚
-â”œâ”€â”€ ai-service/             # Python AI/ML service
-â”‚   â”œâ”€â”€ src/
-â”‚   â”‚   â”œâ”€â”€ models/         # AI model implementations
-â”‚   â”‚   â”œâ”€â”€ services/       # Core AI processing services
-â”‚   â”‚   â””â”€â”€ utils/          # AI utility functions
-â”‚   â”œâ”€â”€ models/             # Pre-trained model files
-â”‚   â””â”€â”€ README.md           # AI service documentation
-â”‚
-â””â”€â”€ docker/                 # Docker configuration files
-    â””â”€â”€ mongo-init.js       # MongoDB initialization script
-```
-
-## ğŸ› ï¸ Technology Stack
-
-### Frontend
-- **React 18** with TypeScript
-- **Material-UI (MUI)** for component library
-- **Redux Toolkit** for state management
-- **React Query** for API state management
-- **React Router** for navigation
-- **Mapbox GL** for interactive maps
-
-### Backend
-- **Node.js 18+** with Express.js
-- **TypeScript** for type safety
-- **MongoDB** with Mongoose ODM
-- **Socket.IO** for real-time communication
-- **JWT** for authentication
-- **bcrypt** for password hashing
-
-### AI Service
-- **Python 3.9+** with FastAPI
-- **YOLOv8** for object detection
-- **OpenCV** for video processing
-- **NumPy** for numerical computing
-- **Pillow** for image processing
-
-### DevOps
-- **Docker** and Docker Compose
-- **MongoDB 6.0+**
-- **Nginx** (production)
-docker-compose up -d
-```
-
-## MVP Features
-
-- âœ… User authentication (JWT-based)
-- âœ… Live video streaming from IP cameras
-- âœ… AI-powered object detection (people/vehicles)
-- âœ… Automatic event creation and management
-- âœ… Interactive map with camera locations
-- âœ… Real-time event visualization
-- âœ… Basic event filtering and details
-
-## Tech Stack
-
-- **Frontend**: React, TypeScript, Mapbox/Google Maps, Material-UI
-- **Backend**: Node.js, Express, TypeScript, MongoDB, JWT
-- **AI Service**: Python, OpenCV, TensorFlow/PyTorch, FastAPI
-- **Database**: MongoDB
-- **Deployment**: Docker, Docker Compose
-
-## Project Structure
-
-```
-â”œâ”€â”€ backend/          # Node.js API server
-â”œâ”€â”€ frontend/         # React web application
-â”œâ”€â”€ ai-service/       # Python AI analytics service
-â”œâ”€â”€ docker/           # Docker configurations
-â”œâ”€â”€ docs/             # Documentation
-â””â”€â”€ docker-compose.yml
-```
-
-## Future Enhancements
-
-- Multiple AI models (face recognition, license plates)
-- Advanced event lifecycle management
-- SMS/Email notifications
-- Comprehensive reporting and analytics
-- Geofencing capabilities
-- CAD system integration
-
-## Contributing
-
-1. Fork the repository
-2. Create a feature branch
-3. Make your changes
-4. Add tests if applicable
-5. Submit a pull request
-
-## License
-
+# Event Monitoring MVP
+
+A comprehensive security event monitoring system with real-time video analysis, camera management, interactive dashboards, and **mobile citizen reporting integration**.
+
+## ğŸš€ Features
+
+- **ğŸ¥ Real-time Camera Monitoring** - Live video feeds with AI detection
+- **ğŸ¤– AI-powered Event Detection** - Automated incident recognition  
+- **ğŸ“± Mobile Citizen Reporting** - Anonymous & authenticated event submission
+- **ğŸ” Multi-role Authentication** - Citizens, operators, admins with flexible permissions
+- **ğŸ“Š Interactive Dashboard** - Real-time event tracking and management
+- **ğŸ—ºï¸ Location-based Events** - GPS tracking and mapping integration
+- **ğŸ“ Phone + OTP Authentication** - Seamless mobile registration
+- **ğŸ·ï¸ Dynamic Event Types** - Flexible, hierarchical event categorization
+
+## ğŸš€ Getting Started
+
+### New to this project? â†’ **[SETUP.md](./SETUP.md)** ğŸ“–
+
+**Quick Setup (experienced users):**
+
+### 1. Install Prerequisites
+```bash
+# Install WSL2 (PowerShell as Administrator)
+wsl --install
+
+# In WSL2, install Node.js
+curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
+source ~/.bashrc
+nvm install --lts && nvm use --lts && nvm alias default lts/*
+
+# Install MongoDB
+sudo apt update && sudo apt upgrade -y
+wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -
+echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
+sudo apt update && sudo apt install -y mongodb-org
+sudo systemctl start mongod && sudo systemctl enable mongod
+
+# Install Python & Git
+sudo apt install -y python3.9 python3-pip git
+```
+
+### 2. Setup Project
+```bash
+# Clone and setup
+git clone <your-repository-url>
+cd event-monitoring-mvp
+cp backend/.env.example backend/.env
+cp frontend/.env.example frontend/.env
+cp ai-service/.env.example ai-service/.env
+
+# Configure environment variables for mobile integration
+echo "# Mobile & Authentication Config" >> backend/.env
+echo "SMS_SERVICE_API_KEY=your_sms_api_key" >> backend/.env
+echo "SMS_SERVICE_URL=your_sms_service_url" >> backend/.env
+echo "REDIS_URL=redis://localhost:6379" >> backend/.env
+echo "ENABLE_PHONE_AUTH=true" >> backend/.env
+
+# Install dependencies
+cd backend && npm install && cd ..
+cd frontend && npm install && cd ..
+cd ai-service && pip3 install -r requirements.txt && cd ..
+```
+
+### 3. Start Development
+```bash
+# Terminal 1: Backend API
+cd backend && npm run dev
+
+# Terminal 2: Frontend Dashboard  
+cd frontend && npm start
+
+# Terminal 3: AI Service
+cd ai-service && python app.py
+
+# Terminal 4: Setup database (wait for backend to start)
+node scripts/setup-database.js
+```
+
+## ğŸ“± Mobile Integration
+
+**Important**: Citizens authenticate through the mobile app. Your web backend only receives event submissions from mobile users - not their authentication data.
+
+### Quick Mobile Setup
+```bash
+# 1. Backend provides EventTypes and receives events from mobile app
+# 2. Test event submission (mobile app handles citizen auth):
+curl -X POST http://localhost:5000/api/mobile/events \
+  -H "Content-Type: application/json" \
+  -H "X-Mobile-Auth-Token: mobile_app_token" \
+  -d '{"eventType": "Security Incident", "description": "Test event", "location": {"lat": 40.7128, "lon": -74.0060}}'
+
+# 3. Get EventTypes for mobile team:
+curl -X GET http://localhost:5000/api/mobile/events/types
+```
+
+### Mobile API Endpoints
+- `GET /api/mobile/events/types` - Get available event types for mobile app
+- `POST /api/mobile/events` - Receive event submissions from mobile app
+
+## ğŸ” Authentication & User Roles
+
+### Web Application Users Only
+| Role | Email | Password | Purpose |
+|------|-------|----------|---------|
+| Super Admin | admin@example.com | password123 | Full system access |
+| Operator | operator1@example.com | password123 | Monitor events, manage cameras |
+| Mobile Admin | mobile@example.com | password123 | Manage EventTypes for mobile team |
+
+**Note**: Citizens authenticate through mobile app - not stored in web database.
+
+### Authentication Methods
+- **ğŸ“§ Email + Password** - Web dashboard users (operators, admins)
+- **ğŸ“± Mobile App Auth** - Citizens authenticate in mobile app (separate system)
+- **ğŸ‘¤ Anonymous Reporting** - Mobile app supports anonymous event submission
+
+### User Permissions System
+- **Dynamic Roles** - flexible role assignments per user
+- **Resource-based** - granular permissions (events, cameras, users, etc.)
+- **Conditional Access** - time/location/ownership-based restrictions
+- **Inheritance** - role permissions + individual grants
+
+## ğŸ“‹ Event Types Management
+
+### Dynamic Event Categories
+```javascript
+// Example EventType structure
+{
+  name: "Security Incidents",
+  category: "security", 
+  parentType: null, // Top-level
+  subTypes: ["Theft", "Vandalism", "Suspicious Activity"],
+  isPublic: true,
+  allowedRoles: ["citizen", "operator", "admin"],
+  customFields: [
+    { name: "severity", type: "select", options: ["low", "medium", "high"] }
+  ]
+}
+```
+
+### Managing Event Types
+- **Mobile Admin Role** - Create/edit event types for mobile team
+- **Hierarchical Structure** - Categories â†’ Subcategories  
+- **Custom Fields** - Flexible form fields per event type
+- **Role Restrictions** - Control which users can report each type
+
+## ğŸ—„ï¸ Database Schema
+
+### New Collections
+- **eventtypes** - Dynamic event type definitions
+- **permissions** - Granular permission grants
+- **users** (enhanced) - Multi-auth, multi-role support
+- **events** (enhanced) - EventType references + backward compatibility
+
+### Migration from Legacy
+```bash
+# Run migration script for existing data
+node scripts/migrate-to-new-schema.js
+
+# Or reset and start fresh
+docker-compose down -v
+docker-compose up -d mongodb
+node setup_default_users.js
+```
+
+# Create default users
+node setup_default_users.js
+```
+
+### 4. Login
+- **Frontend**: http://localhost:3000
+- **Email**: admin@example.com
+- **Password**: password123
+
+## ğŸ› ï¸ What's This Project?
+
+A full-stack security monitoring system with:
+
+- **ğŸ” Authentication**: JWT-based user management
+- **ğŸ“¹ Camera Management**: Add and monitor security cameras  
+- **ğŸ¤– AI Detection**: YOLOv8-powered object/person detection
+- **ğŸ—ºï¸ Interactive Map**: Mapbox visualization of cameras/events
+- **ğŸ“Š Dashboard**: Real-time metrics and system status
+- **ğŸ”” Real-time Alerts**: WebSocket notifications
+
+## ğŸ“ Architecture
+
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   React Frontend â”‚    â”‚  Node.js Backendâ”‚    â”‚  Python AI      â”‚
+â”‚   (Port 3000)   â”‚â”€â”€â”€â–ºâ”‚   (Port 5000)   â”‚â”€â”€â”€â–ºâ”‚  (Port 8000)    â”‚
+â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
+â”‚ â€¢ Dashboard     â”‚    â”‚ â€¢ REST API      â”‚    â”‚ â€¢ YOLOv8        â”‚
+â”‚ â€¢ Map View      â”‚    â”‚ â€¢ WebSocket     â”‚    â”‚ â€¢ OpenCV        â”‚
+â”‚ â€¢ Auth & Users  â”‚    â”‚ â€¢ JWT Auth      â”‚    â”‚ â€¢ Real-time     â”‚
+â”‚ â€¢ Camera Mgmt   â”‚    â”‚ â€¢ MongoDB ODM   â”‚    â”‚   Detection     â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚                       â”‚                       â”‚
+         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                                 â–¼
+                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+                    â”‚    MongoDB      â”‚
+                    â”‚   (Port 27017)  â”‚
+                    â”‚                 â”‚
+                    â”‚ â€¢ Users         â”‚
+                    â”‚ â€¢ Cameras       â”‚
+                    â”‚ â€¢ Events        â”‚
+                    â”‚ â€¢ Logs          â”‚
+                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+## ğŸ“ Project Structure
+
+```
+event-monitoring-mvp/
+â”œâ”€â”€ README.md                 # This file
+â”œâ”€â”€ docker-compose.yml        # Docker orchestration
+â”œâ”€â”€ SETUP.md                 # Detailed setup instructions
+â”‚
+â”œâ”€â”€ frontend/                # React.js application
+â”‚   â”œâ”€â”€ src/
+â”‚   â”‚   â”œâ”€â”€ components/      # Reusable UI components
+â”‚   â”‚   â”œâ”€â”€ pages/          # Application pages/routes
+â”‚   â”‚   â”œâ”€â”€ store/          # Redux state management
+â”‚   â”‚   â”œâ”€â”€ services/       # API client services
+â”‚   â”‚   â””â”€â”€ types/          # TypeScript type definitions
+â”‚   â”œâ”€â”€ public/             # Static assets
+â”‚   â””â”€â”€ README.md           # Frontend-specific documentation
+â”‚
+â”œâ”€â”€ backend/                # Node.js Express API
+â”‚   â”œâ”€â”€ src/
+â”‚   â”‚   â”œâ”€â”€ controllers/    # Route handlers and business logic
+â”‚   â”‚   â”œâ”€â”€ models/         # MongoDB data models
+â”‚   â”‚   â”œâ”€â”€ routes/         # API route definitions
+â”‚   â”‚   â”œâ”€â”€ middleware/     # Authentication and validation
+â”‚   â”‚   â”œâ”€â”€ services/       # External service integrations
+â”‚   â”‚   â””â”€â”€ utils/          # Utility functions
+â”‚   â””â”€â”€ README.md           # Backend-specific documentation
+â”‚
+â”œâ”€â”€ ai-service/             # Python AI/ML service
+â”‚   â”œâ”€â”€ src/
+â”‚   â”‚   â”œâ”€â”€ models/         # AI model implementations
+â”‚   â”‚   â”œâ”€â”€ services/       # Core AI processing services
+â”‚   â”‚   â””â”€â”€ utils/          # AI utility functions
+â”‚   â”œâ”€â”€ models/             # Pre-trained model files
+â”‚   â””â”€â”€ README.md           # AI service documentation
+â”‚
+â””â”€â”€ docker/                 # Docker configuration files
+    â””â”€â”€ mongo-init.js       # MongoDB initialization script
+```
+
+## ğŸ› ï¸ Technology Stack
+
+### Frontend
+- **React 18** with TypeScript
+- **Material-UI (MUI)** for component library
+- **Redux Toolkit** for state management
+- **React Query** for API state management
+- **React Router** for navigation
+- **Mapbox GL** for interactive maps
+
+### Backend
+- **Node.js 18+** with Express.js
+- **TypeScript** for type safety
+- **MongoDB** with Mongoose ODM
+- **Socket.IO** for real-time communication
+- **JWT** for authentication
+- **bcrypt** for password hashing
+
+### AI Service
+- **Python 3.9+** with FastAPI
+- **YOLOv8** for object detection
+- **OpenCV** for video processing
+- **NumPy** for numerical computing
+- **Pillow** for image processing
+
+### DevOps
+- **Docker** and Docker Compose
+- **MongoDB 6.0+**
+- **Nginx** (production)
+docker-compose up -d
+```
+
+## MVP Features
+
+- âœ… User authentication (JWT-based)
+- âœ… Live video streaming from IP cameras
+- âœ… AI-powered object detection (people/vehicles)
+- âœ… Automatic event creation and management
+- âœ… Interactive map with camera locations
+- âœ… Real-time event visualization
+- âœ… Basic event filtering and details
+
+## Tech Stack
+
+- **Frontend**: React, TypeScript, Mapbox/Google Maps, Material-UI
+- **Backend**: Node.js, Express, TypeScript, MongoDB, JWT
+- **AI Service**: Python, OpenCV, TensorFlow/PyTorch, FastAPI
+- **Database**: MongoDB
+- **Deployment**: Docker, Docker Compose
+
+## Project Structure
+
+```
+â”œâ”€â”€ backend/          # Node.js API server
+â”œâ”€â”€ frontend/         # React web application
+â”œâ”€â”€ ai-service/       # Python AI analytics service
+â”œâ”€â”€ docker/           # Docker configurations
+â”œâ”€â”€ docs/             # Documentation
+â””â”€â”€ docker-compose.yml
+```
+
+## Future Enhancements
+
+- Multiple AI models (face recognition, license plates)
+- Advanced event lifecycle management
+- SMS/Email notifications
+- Comprehensive reporting and analytics
+- Geofencing capabilities
+- CAD system integration
+
+## Contributing
+
+1. Fork the repository
+2. Create a feature branch
+3. Make your changes
+4. Add tests if applicable
+5. Submit a pull request
+
+## License
+
 MIT License - see LICENSE file for details
\ No newline at end of file
diff --git a/event-monitoring-mvp/SETUP.md b/event-monitoring-mvp/SETUP.md
index 2023299..4f08176 100644
--- a/event-monitoring-mvp/SETUP.md
+++ b/event-monitoring-mvp/SETUP.md
@@ -1,312 +1,329 @@
-# Setup Guide - Event Monitoring MVP
-
-## ğŸ¯ Prerequisites
-
-This guide assumes you're using **Windows with WSL2** (recommended). For other systems, adapt the commands accordingly.
-
-### Step 1: Install WSL2 (Windows Users)
-
-```powershell
-# Run in PowerShell as Administrator
-wsl --install
-```
-
-This installs WSL2 and Ubuntu by default. **Restart your computer** when prompted.
-
-After restart, launch "Ubuntu" from Start menu and create a username/password.
-
-### Step 2: Update Ubuntu
-
-```bash
-# In WSL2 Ubuntu terminal
-sudo apt update && sudo apt upgrade -y
-```
-
----
-
-## ğŸ“¦ Install Dependencies
-
-### Step 3: Install Node.js (Latest LTS)
-
-```bash
-# Install NVM (Node Version Manager)
-curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
-
-# Restart terminal or reload bash
-source ~/.bashrc
-
-# Install latest Node.js LTS
-nvm install --lts
-nvm use --lts
-nvm alias default lts/*
-
-# Verify installation
-node --version  # Should show v20.x.x or v22.x.x
-npm --version   # Should show 9.x.x or 10.x.x
-```
-
-**Common Issue**: If `nvm` command not found, close and reopen your terminal.
-
-### Step 4: Install MongoDB
-
-```bash
-# Import MongoDB public GPG key
-wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -
-
-# Add MongoDB repository
-echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
-
-# Update package list and install MongoDB
-sudo apt update
-sudo apt install -y mongodb-org
-
-# Start and enable MongoDB service
-sudo systemctl start mongod
-sudo systemctl enable mongod
-
-# Verify MongoDB is running
-sudo systemctl status mongod
-```
-
-**Should see**: `active (running)` in green.
-
-### Step 5: Install Python & Git
-
-```bash
-# Install Python 3.9 and Git
-sudo apt install -y python3.9 python3-pip python3.9-venv git
-
-# Verify installations
-python3 --version  # Should show Python 3.9.x
-git --version      # Should show git version
-```
-
----
-
-## ğŸ—ï¸ Project Setup
-
-### Step 6: Clone Repository
-
-```bash
-# Navigate to your preferred directory
-cd ~  # Ubuntu home directory
-# OR
-cd /mnt/c/Users/$USER/Documents  # Windows Documents folder
-
-# Clone the project
-git clone <your-repository-url>
-cd event-monitoring-mvp
-```
-
-### Step 7: Setup Environment Files
-
-```bash
-# Copy environment templates
-cp backend/.env.example backend/.env
-cp frontend/.env.example frontend/.env
-cp ai-service/.env.example ai-service/.env
-
-# These files contain default settings that work for local development
-# No need to edit them for basic setup
-```
-
-### Step 8: Install Project Dependencies
-
-```bash
-# Install backend dependencies (Node.js)
-cd backend
-npm install
-cd ..
-
-# Install frontend dependencies (React)
-cd frontend
-npm install
-cd ..
-
-# Install AI service dependencies (Python)
-cd ai-service
-pip3 install -r requirements.txt
-cd ..
-```
-
-**This will take a few minutes** - downloads and installs all required packages.
-
----
-
-## ğŸš€ First Run
-
-### Step 9: Start the Backend
-
-```bash
-# Make sure you're in the project root
-cd event-monitoring-mvp
-
-# Start backend in development mode
-cd backend && npm run dev
-```
-
-**You should see**:
-```
-ğŸš€ Event Monitoring System Backend Started
-ğŸ“¡ Server running on port 5000
-ğŸ—„ï¸ MongoDB connected successfully
-```
-
-**Leave this terminal open** - the backend needs to keep running.
-
-### Step 10: Start the Frontend (New Terminal)
-
-Open a **new WSL2 terminal** and run:
-
-```bash
-# Navigate to project
-cd ~/event-monitoring-mvp  # OR your project path
-
-# Start frontend
-cd frontend && npm start
-```
-
-**You should see**:
-```
-Local:            http://localhost:3000
-```
-
-Your **browser should automatically open** to http://localhost:3000
-
-### Step 11: Create Default Users
-
-Open a **third WSL2 terminal** and run:
-
-```bash
-# Navigate to project root
-cd ~/event-monitoring-mvp  # OR your project path
-
-# Create default admin and operator users
-node setup_default_users.js
-```
-
-**You should see**:
-```
-âœ… Created user: admin
-âœ… Created user: operator1
-âœ… Created user: operator2
-ğŸ‰ Default users setup complete!
-```
-
----
-
-## âœ… Verify Everything Works
-
-### Step 12: Login to the Application
-
-1. Go to http://localhost:3000 in your browser
-2. You should see a login page
-3. Login with:
-   - **Email**: `admin@example.com`
-   - **Password**: `password123`
-4. You should see the dashboard
-
-**Success!** ğŸ‰ Your Event Monitoring System is now running.
-
----
-
-## ğŸ”„ Daily Usage
-
-After initial setup, starting the system is simple:
-
-### Quick Start Commands
-```bash
-# Terminal 1: Backend
-cd ~/event-monitoring-mvp/backend && npm run dev
-
-# Terminal 2: Frontend
-cd ~/event-monitoring-mvp/frontend && npm start
-```
-
-### Optional: AI Service
-```bash
-# Terminal 3: AI Service (for object detection)
-cd ~/event-monitoring-mvp/ai-service && python3 app.py
-```
-
-**URLs**:
-- Frontend: http://localhost:3000
-- Backend API: http://localhost:5000/api
-- Health Check: http://localhost:5000/health
-
----
-
-## ğŸ†˜ Common Issues
-
-### MongoDB Won't Start
-```bash
-# Check MongoDB status
-sudo systemctl status mongod
-
-# If not running, start it
-sudo systemctl start mongod
-
-# Check MongoDB logs for errors
-sudo journalctl -u mongod
-```
-
-### Node.js Version Issues
-```bash
-# Check current version
-node --version
-
-# If old version, switch to latest
-nvm use --lts
-
-# Set as default
-nvm alias default lts/*
-```
-
-### Port Already in Use
-```bash
-# Check what's using port 3000 or 5000
-sudo lsof -i :3000
-sudo lsof -i :5000
-
-# Kill the process if needed
-sudo kill -9 <PID>
-```
-
-### Can't Login
-```bash
-# Check if users exist
-mongosh
-use event_monitoring
-db.users.find({}, {email: 1, username: 1})
-
-# If empty, recreate users
-exit
-node setup_default_users.js
-```
-
-### Need to Reset Everything
-```bash
-# Stop all Node.js processes
-pkill -f node
-
-# Restart MongoDB
-sudo systemctl restart mongod
-
-# Clear and recreate users
-mongosh --eval "use event_monitoring; db.users.deleteMany({})"
-node setup_default_users.js
-
-# Restart services
-cd backend && npm run dev &
-cd frontend && npm start &
-```
-
----
-
-## ğŸ“š Next Steps
-
-- See [DAILY_COMMANDS.md](./DAILY_COMMANDS.md) for copy-paste commands
-- Check [TROUBLESHOOTING.md](./TROUBLESHOOTING.md) for detailed problem solving
-- Explore the application features in the dashboard
-
+# Setup Guide - Event Monitoring MVP
+
+## ğŸ¯ Prerequisites
+
+This guide assumes you're using **Windows with WSL2** (recommended). For other systems, adapt the commands accordingly.
+
+### Step 1: Install WSL2 (Windows Users)
+
+```powershell
+# Run in PowerShell as Administrator
+wsl --install
+```
+
+This installs WSL2 and Ubuntu by default. **Restart your computer** when prompted.
+
+After restart, launch "Ubuntu" from Start menu and create a username/password.
+
+### Step 2: Update Ubuntu
+
+```bash
+# In WSL2 Ubuntu terminal
+sudo apt update && sudo apt upgrade -y
+```
+
+---
+
+## ğŸ“¦ Install Dependencies
+
+### Step 3: Install Node.js (Latest LTS)
+
+```bash
+# Install NVM (Node Version Manager)
+curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
+
+# Restart terminal or reload bash
+source ~/.bashrc
+
+# Install latest Node.js LTS
+nvm install --lts
+nvm use --lts
+nvm alias default lts/*
+
+# Verify installation
+node --version  # Should show v20.x.x or v22.x.x
+npm --version   # Should show 9.x.x or 10.x.x
+```
+
+**Common Issue**: If `nvm` command not found, close and reopen your terminal.
+
+### Step 4: Install MongoDB
+
+```bash
+# Import MongoDB public GPG key
+wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -
+
+# Add MongoDB repository
+echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
+
+# Update package list and install MongoDB
+sudo apt update
+sudo apt install -y mongodb-org
+
+# Start and enable MongoDB service
+sudo systemctl start mongod
+sudo systemctl enable mongod
+
+# Verify MongoDB is running
+sudo systemctl status mongod
+```
+
+**Should see**: `active (running)` in green.
+
+### Step 5: Install Python & Git
+
+```bash
+# Install Python 3.9 and Git
+sudo apt install -y python3.9 python3-pip python3.9-venv git
+
+# Verify installations
+python3 --version  # Should show Python 3.9.x
+git --version      # Should show git version
+```
+
+---
+
+## ğŸ—ï¸ Project Setup
+
+### Step 6: Clone Repository
+
+```bash
+# Navigate to your preferred directory
+cd ~  # Ubuntu home directory
+# OR
+cd /mnt/c/Users/$USER/Documents  # Windows Documents folder
+
+# Clone the project
+git clone <your-repository-url>
+cd event-monitoring-mvp
+```
+
+### Step 7: Setup Environment Files
+
+```bash
+# Copy environment templates
+cp backend/.env.example backend/.env
+cp frontend/.env.example frontend/.env
+cp ai-service/.env.example ai-service/.env
+
+# These files contain default settings that work for local development
+# No need to edit them for basic setup
+```
+
+### Step 8: Install Project Dependencies
+
+```bash
+# Install backend dependencies (Node.js)
+cd backend
+npm install
+cd ..
+
+# Install frontend dependencies (React)
+cd frontend
+npm install
+cd ..
+
+# Install AI service dependencies (Python)
+cd ai-service
+pip3 install -r requirements.txt
+cd ..
+```
+
+**This will take a few minutes** - downloads and installs all required packages.
+
+---
+
+## ğŸš€ First Run
+
+### Step 9: Start the Backend
+
+```bash
+# Make sure you're in the project root
+cd event-monitoring-mvp
+
+# Start backend in development mode
+cd backend && npm run dev
+```
+
+**You should see**:
+```
+ğŸš€ Event Monitoring System Backend Started
+ğŸ“¡ Server running on port 5000
+ğŸ—„ï¸ MongoDB connected successfully
+```
+
+**Leave this terminal open** - the backend needs to keep running.
+
+### Step 10: Start the Frontend (New Terminal)
+
+Open a **new WSL2 terminal** and run:
+
+```bash
+# Navigate to project
+cd ~/event-monitoring-mvp  # OR your project path
+
+# Start frontend
+cd frontend && npm start
+```
+
+**You should see**:
+```
+Local:            http://localhost:3000
+```
+
+Your **browser should automatically open** to http://localhost:3000
+
+### Step 11: Setup Database and Users
+
+Open a **third WSL2 terminal** and run:
+
+```bash
+# Navigate to project root
+cd ~/event-monitoring-mvp  # OR your project path
+
+# Complete database setup (creates collections, indexes, EventTypes, and users)
+node scripts/setup-database.js
+```
+
+**You should see**:
+```
+ğŸ—„ï¸ Initializing MongoDB database...
+ğŸ“‚ Creating collections...
+ğŸ—‚ï¸ Creating indexes...
+ğŸŒ± Seeding default data...
+ğŸ‘¥ Creating web application users...
+âœ… Created user: admin
+âœ… Created user: operator1
+âœ… Created user: mobile_admin
+ğŸ‰ Setup complete!
+```
+
+## ğŸ—„ï¸ Database Management
+
+All database scripts are in the `scripts/` folder:
+
+```bash
+# Complete database setup
+node scripts/setup-database.js
+
+# Migrate existing data (if upgrading)
+node scripts/migrate-to-new-schema.js
+
+# View all available scripts
+ls scripts/
+cat scripts/README.md
+```
+
+### Step 12: Login to the Application
+
+1. Go to http://localhost:3000 in your browser
+2. You should see a login page
+3. Login with:
+   - **Email**: `admin@example.com`
+   - **Password**: `password123`
+4. You should see the dashboard
+
+**Success!** ğŸ‰ Your Event Monitoring System is now running.
+
+---
+
+## ğŸ”„ Daily Usage
+
+After initial setup, starting the system is simple:
+
+### Quick Start Commands
+```bash
+# Terminal 1: Backend
+cd ~/event-monitoring-mvp/backend && npm run dev
+
+# Terminal 2: Frontend
+cd ~/event-monitoring-mvp/frontend && npm start
+```
+
+### Optional: AI Service
+```bash
+# Terminal 3: AI Service (for object detection)
+cd ~/event-monitoring-mvp/ai-service && python3 app.py
+```
+
+**URLs**:
+- Frontend: http://localhost:3000
+- Backend API: http://localhost:5000/api
+- Health Check: http://localhost:5000/health
+
+---
+
+## ğŸ†˜ Common Issues
+
+### MongoDB Won't Start
+```bash
+# Check MongoDB status
+sudo systemctl status mongod
+
+# If not running, start it
+sudo systemctl start mongod
+
+# Check MongoDB logs for errors
+sudo journalctl -u mongod
+```
+
+### Node.js Version Issues
+```bash
+# Check current version
+node --version
+
+# If old version, switch to latest
+nvm use --lts
+
+# Set as default
+nvm alias default lts/*
+```
+
+### Port Already in Use
+```bash
+# Check what's using port 3000 or 5000
+sudo lsof -i :3000
+sudo lsof -i :5000
+
+# Kill the process if needed
+sudo kill -9 <PID>
+```
+
+### Can't Login
+```bash
+# Check if users exist
+mongosh
+use event_monitoring
+db.users.find({}, {email: 1, username: 1})
+
+# If empty, recreate users
+exit
+node setup_default_users.js
+```
+
+### Need to Reset Everything
+```bash
+# Stop all Node.js processes
+pkill -f node
+
+# Restart MongoDB
+sudo systemctl restart mongod
+
+# Clear and recreate users
+mongosh --eval "use event_monitoring; db.users.deleteMany({})"
+node setup_default_users.js
+
+# Restart services
+cd backend && npm run dev &
+cd frontend && npm start &
+```
+
+---
+
+## ğŸ“š Next Steps
+
+- See [DAILY_COMMANDS.md](./DAILY_COMMANDS.md) for copy-paste commands
+- Check [TROUBLESHOOTING.md](./TROUBLESHOOTING.md) for detailed problem solving
+- Explore the application features in the dashboard
+
 **Questions?** Check the troubleshooting guide or review the MongoDB commands in the daily commands file.
\ No newline at end of file
diff --git a/event-monitoring-mvp/TROUBLESHOOTING.md b/event-monitoring-mvp/TROUBLESHOOTING.md
index 85c6ac5..c60c57f 100644
--- a/event-monitoring-mvp/TROUBLESHOOTING.md
+++ b/event-monitoring-mvp/TROUBLESHOOTING.md
@@ -1,253 +1,253 @@
-# Troubleshooting Guide
-
-## ğŸ”§ Common Issues and Solutions
-
-### Backend Won't Start
-
-#### Node.js Version Issues
-```bash
-# Check current Node.js version
-node --version
-
-# Should be v18+ (preferably v20+)
-# If using NVM:
-nvm install --lts
-nvm use --lts
-nvm alias default lts/*
-
-# If system Node.js is old:
-curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
-sudo apt install nodejs -y
-```
-
-#### Port 5000 Already in Use
-```bash
-# Check what's using port 5000
-sudo lsof -i :5000
-# OR
-netstat -tulpn | grep :5000
-
-# Kill the process
-sudo kill -9 <PID>
-
-# Or change port in backend/.env
-PORT=5001
-```
-
-#### Missing Dependencies
-```bash
-cd backend
-rm -rf node_modules
-rm package-lock.json
-npm install
-```
-
-### Frontend Won't Start
-
-#### Port 3000 Already in Use
-```bash
-# Check what's using port 3000
-sudo lsof -i :3000
-
-# Kill the process or set different port
-REACT_APP_PORT=3001 npm start
-```
-
-#### React Dependencies Issues
-```bash
-cd frontend
-rm -rf node_modules
-rm package-lock.json
-npm install
-```
-
-### Database Connection Issues
-
-#### MongoDB Not Running
-```bash
-# Check MongoDB status
-sudo systemctl status mongod
-
-# Start MongoDB
-sudo systemctl start mongod
-
-# Enable auto-start
-sudo systemctl enable mongod
-
-# Check MongoDB logs
-sudo journalctl -u mongod --no-pager
-```
-
-#### Wrong Database Connection
-```bash
-# Test MongoDB connection
-mongosh
-
-# If that fails, check if MongoDB is listening
-sudo netstat -tulpn | grep :27017
-
-# Check MongoDB configuration
-sudo cat /etc/mongod.conf
-```
-
-#### Permission Issues
-```bash
-# Fix MongoDB data directory permissions
-sudo chown -R mongodb:mongodb /var/lib/mongodb
-sudo chown mongodb:mongodb /tmp/mongodb-27017.sock
-sudo systemctl restart mongod
-```
-
-### Login/Authentication Issues
-
-#### Cannot Login with Default Credentials
-```bash
-# Check if users exist in database
-mongosh
-use event_monitoring
-db.users.find({}, {email: 1, username: 1})
-
-# If no users found, create them
-cd /path/to/project
-node setup_default_users.js
-```
-
-#### Invalid Credentials Error
-```bash
-# Clear corrupted users and recreate
-mongosh
-use event_monitoring
-db.users.deleteMany({})
-exit
-
-# Recreate users
-node setup_default_users.js
-```
-
-### Environment Variables Issues
-
-#### Missing .env Files
-```bash
-# Copy environment templates
-cp backend/.env.example backend/.env
-cp frontend/.env.example frontend/.env
-cp ai-service/.env.example ai-service/.env
-```
-
-#### Wrong API URLs
-```bash
-# Check backend/.env
-MONGODB_URI=mongodb://localhost:27017/event_monitoring
-
-# Check frontend/.env
-REACT_APP_API_URL=http://localhost:5000/api
-REACT_APP_SOCKET_URL=http://localhost:5000
-```
-
-### Python/AI Service Issues
-
-#### Python Dependencies
-```bash
-cd ai-service
-
-# Create virtual environment
-python3 -m venv venv
-source venv/bin/activate
-
-# Install dependencies
-pip install -r requirements.txt
-```
-
-#### Python Version Issues
-```bash
-# Check Python version
-python3 --version
-
-# Should be 3.9+
-# Install specific version if needed
-sudo apt install python3.9 python3.9-venv python3.9-dev
-```
-
-### Docker Issues
-
-#### Port Conflicts
-```bash
-# Stop conflicting services
-sudo systemctl stop mongod
-sudo systemctl stop nginx
-sudo systemctl stop apache2
-
-# Or change ports in docker-compose.yml
-```
-
-#### Container Build Errors
-```bash
-# Clean rebuild
-docker-compose down -v
-docker system prune -f
-docker-compose build --no-cache
-docker-compose up -d
-```
-
-### Performance Issues
-
-#### High CPU Usage
-```bash
-# Check running processes
-top
-htop
-
-# Restart services
-sudo systemctl restart mongod
-# Restart Node.js services
-```
-
-#### High Memory Usage
-```bash
-# Check memory
-free -h
-
-# Clear Node.js cache
-npm cache clean --force
-
-# Restart services
-```
-
-### Network/Firewall Issues
-
-#### Cannot Access from Other Machines
-```bash
-# Check if ports are bound to localhost only
-netstat -tulpn | grep -E ':(3000|5000|27017)'
-
-# Update bind addresses in configuration files
-# MongoDB: bind_ip = 0.0.0.0
-# Node.js: Listen on 0.0.0.0 instead of localhost
-```
-
-#### WSL2 Networking Issues
-```bash
-# Get WSL2 IP
-ip addr show eth0
-
-# Access from Windows using WSL2 IP
-# http://<wsl2-ip>:3000
-```
-
-## ğŸ†˜ Getting Help
-
-If none of these solutions work:
-
-1. **Check logs** for specific error messages
-2. **Search error messages** in project issues/documentation  
-3. **Restart** your development environment completely
-4. **Check versions** of all dependencies
-5. **Try clean installation** in a new directory
-
-### Log Locations
-```bash
-# Backend logs: Console output from npm run dev
-# MongoDB logs: sudo journalctl -u mongod
-# System logs: sudo journalctl -xe
-# Docker logs: docker-compose logs -f
+# Troubleshooting Guide
+
+## ğŸ”§ Common Issues and Solutions
+
+### Backend Won't Start
+
+#### Node.js Version Issues
+```bash
+# Check current Node.js version
+node --version
+
+# Should be v18+ (preferably v20+)
+# If using NVM:
+nvm install --lts
+nvm use --lts
+nvm alias default lts/*
+
+# If system Node.js is old:
+curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -
+sudo apt install nodejs -y
+```
+
+#### Port 5000 Already in Use
+```bash
+# Check what's using port 5000
+sudo lsof -i :5000
+# OR
+netstat -tulpn | grep :5000
+
+# Kill the process
+sudo kill -9 <PID>
+
+# Or change port in backend/.env
+PORT=5001
+```
+
+#### Missing Dependencies
+```bash
+cd backend
+rm -rf node_modules
+rm package-lock.json
+npm install
+```
+
+### Frontend Won't Start
+
+#### Port 3000 Already in Use
+```bash
+# Check what's using port 3000
+sudo lsof -i :3000
+
+# Kill the process or set different port
+REACT_APP_PORT=3001 npm start
+```
+
+#### React Dependencies Issues
+```bash
+cd frontend
+rm -rf node_modules
+rm package-lock.json
+npm install
+```
+
+### Database Connection Issues
+
+#### MongoDB Not Running
+```bash
+# Check MongoDB status
+sudo systemctl status mongod
+
+# Start MongoDB
+sudo systemctl start mongod
+
+# Enable auto-start
+sudo systemctl enable mongod
+
+# Check MongoDB logs
+sudo journalctl -u mongod --no-pager
+```
+
+#### Wrong Database Connection
+```bash
+# Test MongoDB connection
+mongosh
+
+# If that fails, check if MongoDB is listening
+sudo netstat -tulpn | grep :27017
+
+# Check MongoDB configuration
+sudo cat /etc/mongod.conf
+```
+
+#### Permission Issues
+```bash
+# Fix MongoDB data directory permissions
+sudo chown -R mongodb:mongodb /var/lib/mongodb
+sudo chown mongodb:mongodb /tmp/mongodb-27017.sock
+sudo systemctl restart mongod
+```
+
+### Login/Authentication Issues
+
+#### Cannot Login with Default Credentials
+```bash
+# Check if users exist in database
+mongosh
+use event_monitoring
+db.users.find({}, {email: 1, username: 1})
+
+# If no users found, create them
+cd /path/to/project
+node setup_default_users.js
+```
+
+#### Invalid Credentials Error
+```bash
+# Clear corrupted users and recreate
+mongosh
+use event_monitoring
+db.users.deleteMany({})
+exit
+
+# Recreate users
+node setup_default_users.js
+```
+
+### Environment Variables Issues
+
+#### Missing .env Files
+```bash
+# Copy environment templates
+cp backend/.env.example backend/.env
+cp frontend/.env.example frontend/.env
+cp ai-service/.env.example ai-service/.env
+```
+
+#### Wrong API URLs
+```bash
+# Check backend/.env
+MONGODB_URI=mongodb://localhost:27017/event_monitoring
+
+# Check frontend/.env
+REACT_APP_API_URL=http://localhost:5000/api
+REACT_APP_SOCKET_URL=http://localhost:5000
+```
+
+### Python/AI Service Issues
+
+#### Python Dependencies
+```bash
+cd ai-service
+
+# Create virtual environment
+python3 -m venv venv
+source venv/bin/activate
+
+# Install dependencies
+pip install -r requirements.txt
+```
+
+#### Python Version Issues
+```bash
+# Check Python version
+python3 --version
+
+# Should be 3.9+
+# Install specific version if needed
+sudo apt install python3.9 python3.9-venv python3.9-dev
+```
+
+### Docker Issues
+
+#### Port Conflicts
+```bash
+# Stop conflicting services
+sudo systemctl stop mongod
+sudo systemctl stop nginx
+sudo systemctl stop apache2
+
+# Or change ports in docker-compose.yml
+```
+
+#### Container Build Errors
+```bash
+# Clean rebuild
+docker-compose down -v
+docker system prune -f
+docker-compose build --no-cache
+docker-compose up -d
+```
+
+### Performance Issues
+
+#### High CPU Usage
+```bash
+# Check running processes
+top
+htop
+
+# Restart services
+sudo systemctl restart mongod
+# Restart Node.js services
+```
+
+#### High Memory Usage
+```bash
+# Check memory
+free -h
+
+# Clear Node.js cache
+npm cache clean --force
+
+# Restart services
+```
+
+### Network/Firewall Issues
+
+#### Cannot Access from Other Machines
+```bash
+# Check if ports are bound to localhost only
+netstat -tulpn | grep -E ':(3000|5000|27017)'
+
+# Update bind addresses in configuration files
+# MongoDB: bind_ip = 0.0.0.0
+# Node.js: Listen on 0.0.0.0 instead of localhost
+```
+
+#### WSL2 Networking Issues
+```bash
+# Get WSL2 IP
+ip addr show eth0
+
+# Access from Windows using WSL2 IP
+# http://<wsl2-ip>:3000
+```
+
+## ğŸ†˜ Getting Help
+
+If none of these solutions work:
+
+1. **Check logs** for specific error messages
+2. **Search error messages** in project issues/documentation  
+3. **Restart** your development environment completely
+4. **Check versions** of all dependencies
+5. **Try clean installation** in a new directory
+
+### Log Locations
+```bash
+# Backend logs: Console output from npm run dev
+# MongoDB logs: sudo journalctl -u mongod
+# System logs: sudo journalctl -xe
+# Docker logs: docker-compose logs -f
 ```
\ No newline at end of file
diff --git a/event-monitoring-mvp/ai-service/.env.example b/event-monitoring-mvp/ai-service/.env.example
index 01b58a0..a8b38bf 100644
--- a/event-monitoring-mvp/ai-service/.env.example
+++ b/event-monitoring-mvp/ai-service/.env.example
@@ -1,30 +1,30 @@
-# Environment Variables for AI Service
-PYTHONUNBUFFERED=1
-
-# API Configuration
-API_URL=http://localhost:5000/api
-API_TIMEOUT=30
-
-# Model Configuration
-MODEL_PATH=./models
-DEFAULT_MODEL=yolov8n.pt
-CONFIDENCE_THRESHOLD=0.5
-DEVICE=cpu
-
-# Video Processing
-FRAME_SKIP=5
-MAX_CONCURRENT_STREAMS=3
-PROCESSING_INTERVAL=2
-
-# Detection Configuration
-ENABLE_PERSON_DETECTION=true
-ENABLE_VEHICLE_DETECTION=true
-ENABLE_MOTION_DETECTION=false
-
-# Logging
-LOG_LEVEL=INFO
-LOG_FILE=./logs/ai-service.log
-
-# Performance
-BATCH_SIZE=1
+# Environment Variables for AI Service
+PYTHONUNBUFFERED=1
+
+# API Configuration
+API_URL=http://localhost:5000/api
+API_TIMEOUT=30
+
+# Model Configuration
+MODEL_PATH=./models
+DEFAULT_MODEL=yolov8n.pt
+CONFIDENCE_THRESHOLD=0.5
+DEVICE=cpu
+
+# Video Processing
+FRAME_SKIP=5
+MAX_CONCURRENT_STREAMS=3
+PROCESSING_INTERVAL=2
+
+# Detection Configuration
+ENABLE_PERSON_DETECTION=true
+ENABLE_VEHICLE_DETECTION=true
+ENABLE_MOTION_DETECTION=false
+
+# Logging
+LOG_LEVEL=INFO
+LOG_FILE=./logs/ai-service.log
+
+# Performance
+BATCH_SIZE=1
 MAX_DETECTIONS_PER_FRAME=100
\ No newline at end of file
diff --git a/event-monitoring-mvp/ai-service/Dockerfile b/event-monitoring-mvp/ai-service/Dockerfile
index fac2aa9..c0ebd98 100644
--- a/event-monitoring-mvp/ai-service/Dockerfile
+++ b/event-monitoring-mvp/ai-service/Dockerfile
@@ -1,43 +1,43 @@
-# Python AI Service Dockerfile
-FROM python:3.9-slim
-
-# Set working directory
-WORKDIR /app
-
-# Install system dependencies
-RUN apt-get update && apt-get install -y \
-    gcc \
-    g++ \
-    cmake \
-    libglib2.0-0 \
-    libsm6 \
-    libxext6 \
-    libxrender-dev \
-    libgomp1 \
-    libglib2.0-0 \
-    libgtk-3-0 \
-    curl \
-    && rm -rf /var/lib/apt/lists/*
-
-# Copy requirements first for better caching
-COPY requirements.txt .
-
-# Install Python dependencies
-RUN pip install --no-cache-dir --upgrade pip && \
-    pip install --no-cache-dir -r requirements.txt
-
-# Copy application code
-COPY . .
-
-# Create necessary directories
-RUN mkdir -p models logs
-
-# Expose port
-EXPOSE 8000
-
-# Health check
-HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
-  CMD curl -f http://localhost:8000/health || exit 1
-
-# Start the application
+# Python AI Service Dockerfile
+FROM python:3.9-slim
+
+# Set working directory
+WORKDIR /app
+
+# Install system dependencies
+RUN apt-get update && apt-get install -y \
+    gcc \
+    g++ \
+    cmake \
+    libglib2.0-0 \
+    libsm6 \
+    libxext6 \
+    libxrender-dev \
+    libgomp1 \
+    libglib2.0-0 \
+    libgtk-3-0 \
+    curl \
+    && rm -rf /var/lib/apt/lists/*
+
+# Copy requirements first for better caching
+COPY requirements.txt .
+
+# Install Python dependencies
+RUN pip install --no-cache-dir --upgrade pip && \
+    pip install --no-cache-dir -r requirements.txt
+
+# Copy application code
+COPY . .
+
+# Create necessary directories
+RUN mkdir -p models logs
+
+# Expose port
+EXPOSE 8000
+
+# Health check
+HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
+  CMD curl -f http://localhost:8000/health || exit 1
+
+# Start the application
 CMD ["python", "app.py"]
\ No newline at end of file
diff --git a/event-monitoring-mvp/ai-service/README.md b/event-monitoring-mvp/ai-service/README.md
index 6015093..baccab3 100644
--- a/event-monitoring-mvp/ai-service/README.md
+++ b/event-monitoring-mvp/ai-service/README.md
@@ -1,468 +1,468 @@
-# AI Service - Event Monitoring MVP
-
-Python-based AI/ML service providing real-time video analysis, object detection, and event generation using YOLOv8 and OpenCV.
-
-## ğŸš€ Quick Start
-
-### Prerequisites
-- **Python** 3.9+ with pip
-- **OpenCV** compatible system
-- **CUDA** support (optional, for GPU acceleration)
-
-### Development Setup
-
-1. **Install Dependencies**
-   ```bash
-   cd ai-service
-   pip install -r requirements.txt
-   ```
-
-2. **Download Models**
-   ```bash
-   # YOLOv8 model will download automatically on first run
-   # Or manually download:
-   mkdir -p models
-   wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt -O models/yolov8n.pt
-   ```
-
-3. **Environment Configuration**
-   ```bash
-   # Create environment file
-   cp .env.example .env
-   
-   # Configure your settings
-   nano .env
-   ```
-
-4. **Start AI Service**
-   ```bash
-   python app.py
-   ```
-
-5. **Verify Setup**
-   - API available at: http://localhost:8000
-   - Health check: http://localhost:8000/health
-   - API docs: http://localhost:8000/docsbash
-cd ai-service
-
-# Create virtual environment
-python -m venv venv
-
-# Activate virtual environment
-source venv/bin/activate  # Linux/macOS
-# or
-venv\Scripts\activate     # Windows
-```
-
-### 2. Install Dependencies
-```bash
-# Install Python packages
-pip install -r requirements.txt
-```
-
-### 3. Environment Setup
-```bash
-# Copy the environment template
-cp .env.example .env
-
-# Edit the .env file with your configuration
-nano .env
-```
-
-### 4. Start AI Service
-```bash
-python app.py
-```
-
-The AI service will be available at: http://localhost:8000
-
-## Environment Configuration
-
-Edit the `.env` file with these settings:
-
-```bash
-# Python Configuration
-PYTHONUNBUFFERED=1
-
-# API Configuration
-API_URL=http://localhost:5000/api
-API_TIMEOUT=30
-
-# Model Configuration
-MODEL_PATH=./models
-DEFAULT_MODEL=yolov8n.pt
-CONFIDENCE_THRESHOLD=0.5
-DEVICE=cpu  # or 'cuda' for GPU
-
-# Video Processing
-FRAME_SKIP=5
-MAX_CONCURRENT_STREAMS=3
-PROCESSING_INTERVAL=2
-
-# Detection Configuration
-ENABLE_PERSON_DETECTION=true
-ENABLE_VEHICLE_DETECTION=true
-ENABLE_MOTION_DETECTION=false
-
-# Logging
-LOG_LEVEL=INFO
-LOG_FILE=./logs/ai-service.log
-
-# Performance
-BATCH_SIZE=1
-MAX_DETECTIONS_PER_FRAME=100
-```
-
-## System Dependencies
-
-### Ubuntu/Debian
-```bash
-sudo apt update
-sudo apt install -y \
-    python3-dev \
-    python3-pip \
-    libglib2.0-0 \
-    libsm6 \
-    libxext6 \
-    libxrender-dev \
-    libgomp1 \
-    libglib2.0-0 \
-    libgtk-3-0 \
-    ffmpeg \
-    libopencv-dev
-```
-
-### macOS
-```bash
-# Install with Homebrew
-brew install python@3.9 opencv ffmpeg
-```
-
-### Windows
-```bash
-# Install Visual C++ Build Tools
-# Download from: https://visualstudio.microsoft.com/visual-cpp-build-tools/
-
-# Install with pip (may require additional system libs)
-pip install opencv-python
-```
-
-## GPU Support (Optional)
-
-For faster processing with NVIDIA GPU:
-
-### Install CUDA
-```bash
-# Check GPU compatibility
-nvidia-smi
-
-# Install CUDA toolkit (example for Ubuntu)
-wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin
-sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600
-sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/7fa2af80.pub
-sudo add-apt-repository "deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/ /"
-sudo apt update
-sudo apt install cuda
-```
-
-### Install PyTorch with CUDA
-```bash
-# Replace cpu-only pytorch
-pip uninstall torch torchvision
-pip install torch torchvision --extra-index-url https://download.pytorch.org/whl/cu118
-```
-
-### Update Environment
-```bash
-# In .env file
-DEVICE=cuda
-```
-
-## API Endpoints
-
-### Health Check
-```bash
-GET /health
-```
-
-Response:
-```json
-{
-  "status": "healthy",
-  "timestamp": "2025-12-12T...",
-  "model_loaded": true,
-  "device": "cpu",
-  "active_streams": 0
-}
-```
-
-### Start Detection
-```bash
-POST /start-detection
-Content-Type: application/json
-
-{
-  "camera_id": "camera-123",
-  "stream_url": "rtsp://camera-ip:554/stream",
-  "location": {
-    "coordinates": [-74.0060, 40.7128]
-  }
-}
-```
-
-### Stop Detection
-```bash
-POST /stop-detection/{camera_id}
-```
-
-### Get Active Streams
-```bash
-GET /active-streams
-```
-
-## Supported Detection Types
-
-### Object Classes
-The AI service detects these object types:
-
-**People Detection:**
-- Class ID: 0 (person)
-- Event Type: `person_detected`
-
-**Vehicle Detection:**
-- Class ID: 2 (car)
-- Class ID: 3 (motorcycle) 
-- Class ID: 5 (bus)
-- Class ID: 6 (train)
-- Class ID: 7 (truck)
-- Event Type: `vehicle_detected`
-
-### Confidence Levels
-- **High**: > 90% confidence â†’ High severity
-- **Medium**: 70-90% confidence â†’ Medium severity  
-- **Low**: 50-70% confidence â†’ Low severity
-
-## Stream Processing
-
-### Video Sources
-The AI service supports:
-- RTSP streams (`rtsp://`)
-- HTTP streams (`http://`)
-- HTTPS streams (`https://`)
-- USB cameras (`/dev/video0`)
-- Video files (`.mp4`, `.avi`, etc.)
-
-### Performance Optimization
-```bash
-# Adjust frame processing in .env
-FRAME_SKIP=5              # Process every 5th frame
-PROCESSING_INTERVAL=2     # Process every 2 seconds
-MAX_CONCURRENT_STREAMS=3  # Limit simultaneous streams
-```
-
-## Model Management
-
-### Default Model
-The service downloads YOLOv8 nano model automatically on first run:
-- **File**: `yolov8n.pt` (6MB)
-- **Speed**: ~45 FPS on CPU
-- **Accuracy**: Good for most use cases
-
-### Custom Models
-To use different YOLO models:
-
-```bash
-# Download larger models for better accuracy
-# yolov8s.pt (22MB) - Small model
-# yolov8m.pt (52MB) - Medium model  
-# yolov8l.pt (88MB) - Large model
-# yolov8x.pt (137MB) - Extra large model
-
-# Place in models/ directory
-mkdir -p models
-wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt -O models/yolov8s.pt
-
-# Update .env
-DEFAULT_MODEL=yolov8s.pt
-```
-
-## Troubleshooting
-
-### Common Issues
-
-**1. OpenCV installation fails:**
-```bash
-# Install system dependencies first
-sudo apt install libopencv-dev python3-opencv
-
-# Reinstall opencv-python
-pip uninstall opencv-python
-pip install opencv-python-headless
-```
-
-**2. CUDA out of memory:**
-```bash
-# Switch back to CPU
-# In .env: DEVICE=cpu
-
-# Or reduce batch size
-BATCH_SIZE=1
-```
-
-**3. Model download fails:**
-```bash
-# Manual download
-cd models
-wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt
-
-# Check internet connection and firewall
-curl -I https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt
-```
-
-**4. Stream connection issues:**
-```bash
-# Test stream URL manually
-ffplay rtsp://camera-ip:554/stream
-
-# Check camera accessibility
-ping camera-ip
-telnet camera-ip 554
-```
-
-**5. High CPU usage:**
-```bash
-# Increase frame skip
-FRAME_SKIP=10
-
-# Increase processing interval  
-PROCESSING_INTERVAL=5
-
-# Limit concurrent streams
-MAX_CONCURRENT_STREAMS=1
-```
-
-### Debugging
-
-**Enable debug logging:**
-```bash
-# In .env
-LOG_LEVEL=DEBUG
-```
-
-**Check logs:**
-```bash
-tail -f logs/ai-service.log
-```
-
-**Test detection manually:**
-```bash
-# Upload test image
-curl -X POST http://localhost:8000/detect \
-  -F "file=@test_image.jpg" \
-  -F "detection_types=person,vehicle"
-```
-
-## Development
-
-### Code Structure
-```
-ai-service/
-â”œâ”€â”€ app.py              # Main FastAPI application
-â”œâ”€â”€ src/
-â”‚   â”œâ”€â”€ models/         # AI model wrappers
-â”‚   â”œâ”€â”€ services/       # Detection and processing logic
-â”‚   â””â”€â”€ utils/          # Helper functions
-â”œâ”€â”€ models/             # Model files (auto-downloaded)
-â”œâ”€â”€ logs/               # Log files
-â”œâ”€â”€ requirements.txt    # Python dependencies
-â””â”€â”€ .env.example       # Environment template
-```
-
-### Adding New Detection Types
-```python
-# In app.py, modify class mappings
-self.animal_classes = [15, 16, 17]  # bird, cat, dog
-# Add new event type logic
-elif class_id in self.animal_classes:
-    event_type = 'animal_detected'
-```
-
-### Custom Post-processing
-```python
-# Add filters in process_frame method
-if confidence >= self.confidence_threshold:
-    # Size filter - ignore small detections
-    box_area = (x2 - x1) * (y2 - y1)
-    if box_area < 1000:  # Skip small boxes
-        continue
-        
-    # Location filter - only detect in specific regions
-    center_x = (x1 + x2) / 2
-    if center_x < frame.shape[1] * 0.2:  # Skip left 20%
-        continue
-```
-
-## Integration
-
-### With Backend API
-The AI service automatically sends detected events to:
-```
-POST http://localhost:5000/api/events
-```
-
-### With Frontend
-Start detection from frontend camera management:
-```javascript
-// Start AI detection for camera
-fetch('http://localhost:8000/start-detection', {
-  method: 'POST',
-  headers: { 'Content-Type': 'application/json' },
-  body: JSON.stringify({
-    camera_id: 'cam-123',
-    stream_url: 'rtsp://192.168.1.100:554/stream',
-    location: { coordinates: [-74.0060, 40.7128] }
-  })
-});
-```
-
-## Production Deployment
-
-### Systemd Service
-```bash
-# Create service file
-sudo nano /etc/systemd/system/ai-service.service
-
-[Unit]
-Description=Event Monitoring AI Service
-After=network.target
-
-[Service]
-Type=simple
-User=ai-user
-WorkingDirectory=/opt/event-monitoring/ai-service
-Environment=PATH=/opt/event-monitoring/ai-service/venv/bin
-ExecStart=/opt/event-monitoring/ai-service/venv/bin/python app.py
-Restart=always
-
-[Install]
-WantedBy=multi-user.target
-
-# Enable and start
-sudo systemctl enable ai-service
-sudo systemctl start ai-service
-```
-
-### Docker Deployment
-```bash
-# Build image
-docker build -t event-monitoring-ai .
-
-# Run container
-docker run -d \
-  --name ai-service \
-  --restart unless-stopped \
-  -p 8000:8000 \
-  -v $(pwd)/models:/app/models \
-  -v $(pwd)/logs:/app/logs \
-  event-monitoring-ai
+# AI Service - Event Monitoring MVP
+
+Python-based AI/ML service providing real-time video analysis, object detection, and event generation using YOLOv8 and OpenCV.
+
+## ğŸš€ Quick Start
+
+### Prerequisites
+- **Python** 3.9+ with pip
+- **OpenCV** compatible system
+- **CUDA** support (optional, for GPU acceleration)
+
+### Development Setup
+
+1. **Install Dependencies**
+   ```bash
+   cd ai-service
+   pip install -r requirements.txt
+   ```
+
+2. **Download Models**
+   ```bash
+   # YOLOv8 model will download automatically on first run
+   # Or manually download:
+   mkdir -p models
+   wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt -O models/yolov8n.pt
+   ```
+
+3. **Environment Configuration**
+   ```bash
+   # Create environment file
+   cp .env.example .env
+   
+   # Configure your settings
+   nano .env
+   ```
+
+4. **Start AI Service**
+   ```bash
+   python app.py
+   ```
+
+5. **Verify Setup**
+   - API available at: http://localhost:8000
+   - Health check: http://localhost:8000/health
+   - API docs: http://localhost:8000/docsbash
+cd ai-service
+
+# Create virtual environment
+python -m venv venv
+
+# Activate virtual environment
+source venv/bin/activate  # Linux/macOS
+# or
+venv\Scripts\activate     # Windows
+```
+
+### 2. Install Dependencies
+```bash
+# Install Python packages
+pip install -r requirements.txt
+```
+
+### 3. Environment Setup
+```bash
+# Copy the environment template
+cp .env.example .env
+
+# Edit the .env file with your configuration
+nano .env
+```
+
+### 4. Start AI Service
+```bash
+python app.py
+```
+
+The AI service will be available at: http://localhost:8000
+
+## Environment Configuration
+
+Edit the `.env` file with these settings:
+
+```bash
+# Python Configuration
+PYTHONUNBUFFERED=1
+
+# API Configuration
+API_URL=http://localhost:5000/api
+API_TIMEOUT=30
+
+# Model Configuration
+MODEL_PATH=./models
+DEFAULT_MODEL=yolov8n.pt
+CONFIDENCE_THRESHOLD=0.5
+DEVICE=cpu  # or 'cuda' for GPU
+
+# Video Processing
+FRAME_SKIP=5
+MAX_CONCURRENT_STREAMS=3
+PROCESSING_INTERVAL=2
+
+# Detection Configuration
+ENABLE_PERSON_DETECTION=true
+ENABLE_VEHICLE_DETECTION=true
+ENABLE_MOTION_DETECTION=false
+
+# Logging
+LOG_LEVEL=INFO
+LOG_FILE=./logs/ai-service.log
+
+# Performance
+BATCH_SIZE=1
+MAX_DETECTIONS_PER_FRAME=100
+```
+
+## System Dependencies
+
+### Ubuntu/Debian
+```bash
+sudo apt update
+sudo apt install -y \
+    python3-dev \
+    python3-pip \
+    libglib2.0-0 \
+    libsm6 \
+    libxext6 \
+    libxrender-dev \
+    libgomp1 \
+    libglib2.0-0 \
+    libgtk-3-0 \
+    ffmpeg \
+    libopencv-dev
+```
+
+### macOS
+```bash
+# Install with Homebrew
+brew install python@3.9 opencv ffmpeg
+```
+
+### Windows
+```bash
+# Install Visual C++ Build Tools
+# Download from: https://visualstudio.microsoft.com/visual-cpp-build-tools/
+
+# Install with pip (may require additional system libs)
+pip install opencv-python
+```
+
+## GPU Support (Optional)
+
+For faster processing with NVIDIA GPU:
+
+### Install CUDA
+```bash
+# Check GPU compatibility
+nvidia-smi
+
+# Install CUDA toolkit (example for Ubuntu)
+wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin
+sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600
+sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/7fa2af80.pub
+sudo add-apt-repository "deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/ /"
+sudo apt update
+sudo apt install cuda
+```
+
+### Install PyTorch with CUDA
+```bash
+# Replace cpu-only pytorch
+pip uninstall torch torchvision
+pip install torch torchvision --extra-index-url https://download.pytorch.org/whl/cu118
+```
+
+### Update Environment
+```bash
+# In .env file
+DEVICE=cuda
+```
+
+## API Endpoints
+
+### Health Check
+```bash
+GET /health
+```
+
+Response:
+```json
+{
+  "status": "healthy",
+  "timestamp": "2025-12-12T...",
+  "model_loaded": true,
+  "device": "cpu",
+  "active_streams": 0
+}
+```
+
+### Start Detection
+```bash
+POST /start-detection
+Content-Type: application/json
+
+{
+  "camera_id": "camera-123",
+  "stream_url": "rtsp://camera-ip:554/stream",
+  "location": {
+    "coordinates": [-74.0060, 40.7128]
+  }
+}
+```
+
+### Stop Detection
+```bash
+POST /stop-detection/{camera_id}
+```
+
+### Get Active Streams
+```bash
+GET /active-streams
+```
+
+## Supported Detection Types
+
+### Object Classes
+The AI service detects these object types:
+
+**People Detection:**
+- Class ID: 0 (person)
+- Event Type: `person_detected`
+
+**Vehicle Detection:**
+- Class ID: 2 (car)
+- Class ID: 3 (motorcycle) 
+- Class ID: 5 (bus)
+- Class ID: 6 (train)
+- Class ID: 7 (truck)
+- Event Type: `vehicle_detected`
+
+### Confidence Levels
+- **High**: > 90% confidence â†’ High severity
+- **Medium**: 70-90% confidence â†’ Medium severity  
+- **Low**: 50-70% confidence â†’ Low severity
+
+## Stream Processing
+
+### Video Sources
+The AI service supports:
+- RTSP streams (`rtsp://`)
+- HTTP streams (`http://`)
+- HTTPS streams (`https://`)
+- USB cameras (`/dev/video0`)
+- Video files (`.mp4`, `.avi`, etc.)
+
+### Performance Optimization
+```bash
+# Adjust frame processing in .env
+FRAME_SKIP=5              # Process every 5th frame
+PROCESSING_INTERVAL=2     # Process every 2 seconds
+MAX_CONCURRENT_STREAMS=3  # Limit simultaneous streams
+```
+
+## Model Management
+
+### Default Model
+The service downloads YOLOv8 nano model automatically on first run:
+- **File**: `yolov8n.pt` (6MB)
+- **Speed**: ~45 FPS on CPU
+- **Accuracy**: Good for most use cases
+
+### Custom Models
+To use different YOLO models:
+
+```bash
+# Download larger models for better accuracy
+# yolov8s.pt (22MB) - Small model
+# yolov8m.pt (52MB) - Medium model  
+# yolov8l.pt (88MB) - Large model
+# yolov8x.pt (137MB) - Extra large model
+
+# Place in models/ directory
+mkdir -p models
+wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8s.pt -O models/yolov8s.pt
+
+# Update .env
+DEFAULT_MODEL=yolov8s.pt
+```
+
+## Troubleshooting
+
+### Common Issues
+
+**1. OpenCV installation fails:**
+```bash
+# Install system dependencies first
+sudo apt install libopencv-dev python3-opencv
+
+# Reinstall opencv-python
+pip uninstall opencv-python
+pip install opencv-python-headless
+```
+
+**2. CUDA out of memory:**
+```bash
+# Switch back to CPU
+# In .env: DEVICE=cpu
+
+# Or reduce batch size
+BATCH_SIZE=1
+```
+
+**3. Model download fails:**
+```bash
+# Manual download
+cd models
+wget https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt
+
+# Check internet connection and firewall
+curl -I https://github.com/ultralytics/assets/releases/download/v0.0.0/yolov8n.pt
+```
+
+**4. Stream connection issues:**
+```bash
+# Test stream URL manually
+ffplay rtsp://camera-ip:554/stream
+
+# Check camera accessibility
+ping camera-ip
+telnet camera-ip 554
+```
+
+**5. High CPU usage:**
+```bash
+# Increase frame skip
+FRAME_SKIP=10
+
+# Increase processing interval  
+PROCESSING_INTERVAL=5
+
+# Limit concurrent streams
+MAX_CONCURRENT_STREAMS=1
+```
+
+### Debugging
+
+**Enable debug logging:**
+```bash
+# In .env
+LOG_LEVEL=DEBUG
+```
+
+**Check logs:**
+```bash
+tail -f logs/ai-service.log
+```
+
+**Test detection manually:**
+```bash
+# Upload test image
+curl -X POST http://localhost:8000/detect \
+  -F "file=@test_image.jpg" \
+  -F "detection_types=person,vehicle"
+```
+
+## Development
+
+### Code Structure
+```
+ai-service/
+â”œâ”€â”€ app.py              # Main FastAPI application
+â”œâ”€â”€ src/
+â”‚   â”œâ”€â”€ models/         # AI model wrappers
+â”‚   â”œâ”€â”€ services/       # Detection and processing logic
+â”‚   â””â”€â”€ utils/          # Helper functions
+â”œâ”€â”€ models/             # Model files (auto-downloaded)
+â”œâ”€â”€ logs/               # Log files
+â”œâ”€â”€ requirements.txt    # Python dependencies
+â””â”€â”€ .env.example       # Environment template
+```
+
+### Adding New Detection Types
+```python
+# In app.py, modify class mappings
+self.animal_classes = [15, 16, 17]  # bird, cat, dog
+# Add new event type logic
+elif class_id in self.animal_classes:
+    event_type = 'animal_detected'
+```
+
+### Custom Post-processing
+```python
+# Add filters in process_frame method
+if confidence >= self.confidence_threshold:
+    # Size filter - ignore small detections
+    box_area = (x2 - x1) * (y2 - y1)
+    if box_area < 1000:  # Skip small boxes
+        continue
+        
+    # Location filter - only detect in specific regions
+    center_x = (x1 + x2) / 2
+    if center_x < frame.shape[1] * 0.2:  # Skip left 20%
+        continue
+```
+
+## Integration
+
+### With Backend API
+The AI service automatically sends detected events to:
+```
+POST http://localhost:5000/api/events
+```
+
+### With Frontend
+Start detection from frontend camera management:
+```javascript
+// Start AI detection for camera
+fetch('http://localhost:8000/start-detection', {
+  method: 'POST',
+  headers: { 'Content-Type': 'application/json' },
+  body: JSON.stringify({
+    camera_id: 'cam-123',
+    stream_url: 'rtsp://192.168.1.100:554/stream',
+    location: { coordinates: [-74.0060, 40.7128] }
+  })
+});
+```
+
+## Production Deployment
+
+### Systemd Service
+```bash
+# Create service file
+sudo nano /etc/systemd/system/ai-service.service
+
+[Unit]
+Description=Event Monitoring AI Service
+After=network.target
+
+[Service]
+Type=simple
+User=ai-user
+WorkingDirectory=/opt/event-monitoring/ai-service
+Environment=PATH=/opt/event-monitoring/ai-service/venv/bin
+ExecStart=/opt/event-monitoring/ai-service/venv/bin/python app.py
+Restart=always
+
+[Install]
+WantedBy=multi-user.target
+
+# Enable and start
+sudo systemctl enable ai-service
+sudo systemctl start ai-service
+```
+
+### Docker Deployment
+```bash
+# Build image
+docker build -t event-monitoring-ai .
+
+# Run container
+docker run -d \
+  --name ai-service \
+  --restart unless-stopped \
+  -p 8000:8000 \
+  -v $(pwd)/models:/app/models \
+  -v $(pwd)/logs:/app/logs \
+  event-monitoring-ai
 ```
\ No newline at end of file
diff --git a/event-monitoring-mvp/ai-service/app.py b/event-monitoring-mvp/ai-service/app.py
index ce39d5d..ce53b0f 100644
--- a/event-monitoring-mvp/ai-service/app.py
+++ b/event-monitoring-mvp/ai-service/app.py
@@ -1,289 +1,289 @@
-import asyncio
-import os
-import logging
-from datetime import datetime
-from typing import Dict, List, Optional
-import cv2
-import numpy as np
-from fastapi import FastAPI, BackgroundTasks, HTTPException
-from fastapi.middleware.cors import CORSMiddleware
-from pydantic import BaseModel
-import requests
-from dotenv import load_dotenv
-from ultralytics import YOLO
-
-# Load environment variables
-load_dotenv()
-
-# Configure logging
-logging.basicConfig(
-    level=getattr(logging, os.getenv('LOG_LEVEL', 'INFO')),
-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
-    handlers=[
-        logging.FileHandler(os.getenv('LOG_FILE', './logs/ai-service.log')),
-        logging.StreamHandler()
-    ]
-)
-logger = logging.getLogger(__name__)
-
-# Pydantic models
-class DetectionRequest(BaseModel):
-    camera_id: str
-    stream_url: str
-    location: Dict[str, List[float]]
-
-class DetectionResult(BaseModel):
-    camera_id: str
-    event_type: str
-    confidence: float
-    bounding_box: Optional[Dict[str, float]]
-    object_count: int
-    timestamp: str
-    location: Dict[str, List[float]]
-
-class AIService:
-    def __init__(self):
-        self.model_path = os.getenv('MODEL_PATH', './models')
-        self.confidence_threshold = float(os.getenv('CONFIDENCE_THRESHOLD', '0.5'))
-        self.device = os.getenv('DEVICE', 'cpu')
-        self.api_url = os.getenv('API_URL', 'http://localhost:5000/api')
-        
-        # Load YOLO model
-        self.model = None
-        self.load_model()
-        
-        # Class mappings for COCO dataset
-        self.person_classes = [0]  # person
-        self.vehicle_classes = [2, 3, 5, 6, 7]  # car, motorcycle, bus, train, truck
-        
-        # Active processing streams
-        self.active_streams: Dict[str, bool] = {}
-
-    def load_model(self):
-        """Load the YOLO model"""
-        try:
-            model_file = os.path.join(self.model_path, os.getenv('DEFAULT_MODEL', 'yolov8n.pt'))
-            if not os.path.exists(model_file):
-                logger.info(f"Model file not found at {model_file}, downloading...")
-                os.makedirs(self.model_path, exist_ok=True)
-                
-            self.model = YOLO('yolov8n.pt')  # This will auto-download if needed
-            self.model.to(self.device)
-            logger.info(f"Model loaded successfully on device: {self.device}")
-        except Exception as e:
-            logger.error(f"Failed to load model: {e}")
-            raise
-
-    async def process_frame(self, frame: np.ndarray, camera_id: str, location: Dict) -> List[DetectionResult]:
-        """Process a single frame for detections"""
-        try:
-            # Run inference
-            results = self.model(frame, conf=self.confidence_threshold, verbose=False)
-            detections = []
-            
-            for result in results:
-                if result.boxes is not None:
-                    boxes = result.boxes
-                    
-                    # Process each detection
-                    for i in range(len(boxes)):
-                        class_id = int(boxes.cls[i])
-                        confidence = float(boxes.conf[i])
-                        
-                        # Determine event type
-                        event_type = None
-                        if class_id in self.person_classes:
-                            event_type = 'person_detected'
-                        elif class_id in self.vehicle_classes:
-                            event_type = 'vehicle_detected'
-                        
-                        if event_type and confidence >= self.confidence_threshold:
-                            # Get bounding box
-                            box = boxes.xyxy[i].cpu().numpy()
-                            x1, y1, x2, y2 = box
-                            
-                            detection = DetectionResult(
-                                camera_id=camera_id,
-                                event_type=event_type,
-                                confidence=confidence,
-                                bounding_box={
-                                    'x': float(x1),
-                                    'y': float(y1),
-                                    'width': float(x2 - x1),
-                                    'height': float(y2 - y1)
-                                },
-                                object_count=1,
-                                timestamp=datetime.utcnow().isoformat(),
-                                location=location
-                            )
-                            detections.append(detection)
-            
-            return detections
-            
-        except Exception as e:
-            logger.error(f"Error processing frame: {e}")
-            return []
-
-    async def send_detection_to_backend(self, detection: DetectionResult):
-        """Send detection result to backend API"""
-        try:
-            event_data = {
-                'title': f'{detection.event_type.replace("_", " ").title()} Detected',
-                'description': f'AI detected {detection.event_type.replace("_", " ")} with {detection.confidence:.2%} confidence',
-                'type': detection.event_type,
-                'severity': self.determine_severity(detection),
-                'cameraId': detection.camera_id,
-                'location': detection.location,
-                'detectionData': {
-                    'confidence': detection.confidence,
-                    'boundingBox': detection.bounding_box,
-                    'objectCount': detection.object_count,
-                    'aiModel': 'YOLOv8'
-                }
-            }
-            
-            response = requests.post(
-                f"{self.api_url}/events",
-                json=event_data,
-                timeout=int(os.getenv('API_TIMEOUT', '30'))
-            )
-            
-            if response.status_code == 201:
-                logger.info(f"Successfully sent detection for camera {detection.camera_id}")
-            else:
-                logger.error(f"Failed to send detection: {response.status_code} - {response.text}")
-                
-        except Exception as e:
-            logger.error(f"Error sending detection to backend: {e}")
-
-    def determine_severity(self, detection: DetectionResult) -> str:
-        """Determine event severity based on detection"""
-        if detection.confidence > 0.9:
-            return 'high'
-        elif detection.confidence > 0.7:
-            return 'medium'
-        else:
-            return 'low'
-
-    async def process_video_stream(self, camera_id: str, stream_url: str, location: Dict):
-        """Process video stream from camera"""
-        logger.info(f"Starting video processing for camera {camera_id}")
-        self.active_streams[camera_id] = True
-        
-        frame_skip = int(os.getenv('FRAME_SKIP', '5'))
-        processing_interval = int(os.getenv('PROCESSING_INTERVAL', '2'))
-        
-        cap = None
-        frame_count = 0
-        
-        try:
-            cap = cv2.VideoCapture(stream_url)
-            if not cap.isOpened():
-                logger.error(f"Failed to open stream: {stream_url}")
-                return
-            
-            last_processing_time = 0
-            
-            while self.active_streams.get(camera_id, False):
-                ret, frame = cap.read()
-                if not ret:
-                    logger.warning(f"Failed to read frame from camera {camera_id}")
-                    await asyncio.sleep(1)
-                    continue
-                
-                frame_count += 1
-                current_time = datetime.now().timestamp()
-                
-                # Skip frames for performance
-                if frame_count % frame_skip != 0:
-                    continue
-                
-                # Process at intervals
-                if current_time - last_processing_time < processing_interval:
-                    continue
-                
-                last_processing_time = current_time
-                
-                # Process frame
-                detections = await self.process_frame(frame, camera_id, location)
-                
-                # Send detections to backend
-                for detection in detections:
-                    await self.send_detection_to_backend(detection)
-                
-                await asyncio.sleep(0.1)  # Small delay to prevent overwhelming
-                
-        except Exception as e:
-            logger.error(f"Error in video stream processing: {e}")
-        finally:
-            if cap:
-                cap.release()
-            self.active_streams[camera_id] = False
-            logger.info(f"Stopped processing camera {camera_id}")
-
-# Initialize FastAPI app
-app = FastAPI(title="Event Monitoring AI Service", version="1.0.0")
-
-# Add CORS middleware
-app.add_middleware(
-    CORSMiddleware,
-    allow_origins=["*"],
-    allow_credentials=True,
-    allow_methods=["*"],
-    allow_headers=["*"],
-)
-
-# Initialize AI service
-ai_service = AIService()
-
-@app.get("/health")
-async def health_check():
-    """Health check endpoint"""
-    return {
-        "status": "healthy",
-        "timestamp": datetime.utcnow().isoformat(),
-        "model_loaded": ai_service.model is not None,
-        "device": ai_service.device,
-        "active_streams": len(ai_service.active_streams)
-    }
-
-@app.post("/start-detection")
-async def start_detection(request: DetectionRequest, background_tasks: BackgroundTasks):
-    """Start detection for a camera stream"""
-    if request.camera_id in ai_service.active_streams:
-        raise HTTPException(status_code=400, detail="Detection already active for this camera")
-    
-    background_tasks.add_task(
-        ai_service.process_video_stream,
-        request.camera_id,
-        request.stream_url,
-        request.location
-    )
-    
-    return {"message": f"Detection started for camera {request.camera_id}"}
-
-@app.post("/stop-detection/{camera_id}")
-async def stop_detection(camera_id: str):
-    """Stop detection for a camera"""
-    if camera_id not in ai_service.active_streams:
-        raise HTTPException(status_code=404, detail="No active detection for this camera")
-    
-    ai_service.active_streams[camera_id] = False
-    return {"message": f"Detection stopped for camera {camera_id}"}
-
-@app.get("/active-streams")
-async def get_active_streams():
-    """Get list of active detection streams"""
-    return {
-        "active_streams": list(ai_service.active_streams.keys()),
-        "count": len(ai_service.active_streams)
-    }
-
-if __name__ == "__main__":
-    import uvicorn
-    
-    port = int(os.getenv("PORT", "8000"))
-    host = os.getenv("HOST", "0.0.0.0")
-    
-    logger.info(f"Starting AI Service on {host}:{port}")
+import asyncio
+import os
+import logging
+from datetime import datetime
+from typing import Dict, List, Optional
+import cv2
+import numpy as np
+from fastapi import FastAPI, BackgroundTasks, HTTPException
+from fastapi.middleware.cors import CORSMiddleware
+from pydantic import BaseModel
+import requests
+from dotenv import load_dotenv
+from ultralytics import YOLO
+
+# Load environment variables
+load_dotenv()
+
+# Configure logging
+logging.basicConfig(
+    level=getattr(logging, os.getenv('LOG_LEVEL', 'INFO')),
+    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
+    handlers=[
+        logging.FileHandler(os.getenv('LOG_FILE', './logs/ai-service.log')),
+        logging.StreamHandler()
+    ]
+)
+logger = logging.getLogger(__name__)
+
+# Pydantic models
+class DetectionRequest(BaseModel):
+    camera_id: str
+    stream_url: str
+    location: Dict[str, List[float]]
+
+class DetectionResult(BaseModel):
+    camera_id: str
+    event_type: str
+    confidence: float
+    bounding_box: Optional[Dict[str, float]]
+    object_count: int
+    timestamp: str
+    location: Dict[str, List[float]]
+
+class AIService:
+    def __init__(self):
+        self.model_path = os.getenv('MODEL_PATH', './models')
+        self.confidence_threshold = float(os.getenv('CONFIDENCE_THRESHOLD', '0.5'))
+        self.device = os.getenv('DEVICE', 'cpu')
+        self.api_url = os.getenv('API_URL', 'http://localhost:5000/api')
+        
+        # Load YOLO model
+        self.model = None
+        self.load_model()
+        
+        # Class mappings for COCO dataset
+        self.person_classes = [0]  # person
+        self.vehicle_classes = [2, 3, 5, 6, 7]  # car, motorcycle, bus, train, truck
+        
+        # Active processing streams
+        self.active_streams: Dict[str, bool] = {}
+
+    def load_model(self):
+        """Load the YOLO model"""
+        try:
+            model_file = os.path.join(self.model_path, os.getenv('DEFAULT_MODEL', 'yolov8n.pt'))
+            if not os.path.exists(model_file):
+                logger.info(f"Model file not found at {model_file}, downloading...")
+                os.makedirs(self.model_path, exist_ok=True)
+                
+            self.model = YOLO('yolov8n.pt')  # This will auto-download if needed
+            self.model.to(self.device)
+            logger.info(f"Model loaded successfully on device: {self.device}")
+        except Exception as e:
+            logger.error(f"Failed to load model: {e}")
+            raise
+
+    async def process_frame(self, frame: np.ndarray, camera_id: str, location: Dict) -> List[DetectionResult]:
+        """Process a single frame for detections"""
+        try:
+            # Run inference
+            results = self.model(frame, conf=self.confidence_threshold, verbose=False)
+            detections = []
+            
+            for result in results:
+                if result.boxes is not None:
+                    boxes = result.boxes
+                    
+                    # Process each detection
+                    for i in range(len(boxes)):
+                        class_id = int(boxes.cls[i])
+                        confidence = float(boxes.conf[i])
+                        
+                        # Determine event type
+                        event_type = None
+                        if class_id in self.person_classes:
+                            event_type = 'person_detected'
+                        elif class_id in self.vehicle_classes:
+                            event_type = 'vehicle_detected'
+                        
+                        if event_type and confidence >= self.confidence_threshold:
+                            # Get bounding box
+                            box = boxes.xyxy[i].cpu().numpy()
+                            x1, y1, x2, y2 = box
+                            
+                            detection = DetectionResult(
+                                camera_id=camera_id,
+                                event_type=event_type,
+                                confidence=confidence,
+                                bounding_box={
+                                    'x': float(x1),
+                                    'y': float(y1),
+                                    'width': float(x2 - x1),
+                                    'height': float(y2 - y1)
+                                },
+                                object_count=1,
+                                timestamp=datetime.utcnow().isoformat(),
+                                location=location
+                            )
+                            detections.append(detection)
+            
+            return detections
+            
+        except Exception as e:
+            logger.error(f"Error processing frame: {e}")
+            return []
+
+    async def send_detection_to_backend(self, detection: DetectionResult):
+        """Send detection result to backend API"""
+        try:
+            event_data = {
+                'title': f'{detection.event_type.replace("_", " ").title()} Detected',
+                'description': f'AI detected {detection.event_type.replace("_", " ")} with {detection.confidence:.2%} confidence',
+                'type': detection.event_type,
+                'severity': self.determine_severity(detection),
+                'cameraId': detection.camera_id,
+                'location': detection.location,
+                'detectionData': {
+                    'confidence': detection.confidence,
+                    'boundingBox': detection.bounding_box,
+                    'objectCount': detection.object_count,
+                    'aiModel': 'YOLOv8'
+                }
+            }
+            
+            response = requests.post(
+                f"{self.api_url}/events",
+                json=event_data,
+                timeout=int(os.getenv('API_TIMEOUT', '30'))
+            )
+            
+            if response.status_code == 201:
+                logger.info(f"Successfully sent detection for camera {detection.camera_id}")
+            else:
+                logger.error(f"Failed to send detection: {response.status_code} - {response.text}")
+                
+        except Exception as e:
+            logger.error(f"Error sending detection to backend: {e}")
+
+    def determine_severity(self, detection: DetectionResult) -> str:
+        """Determine event severity based on detection"""
+        if detection.confidence > 0.9:
+            return 'high'
+        elif detection.confidence > 0.7:
+            return 'medium'
+        else:
+            return 'low'
+
+    async def process_video_stream(self, camera_id: str, stream_url: str, location: Dict):
+        """Process video stream from camera"""
+        logger.info(f"Starting video processing for camera {camera_id}")
+        self.active_streams[camera_id] = True
+        
+        frame_skip = int(os.getenv('FRAME_SKIP', '5'))
+        processing_interval = int(os.getenv('PROCESSING_INTERVAL', '2'))
+        
+        cap = None
+        frame_count = 0
+        
+        try:
+            cap = cv2.VideoCapture(stream_url)
+            if not cap.isOpened():
+                logger.error(f"Failed to open stream: {stream_url}")
+                return
+            
+            last_processing_time = 0
+            
+            while self.active_streams.get(camera_id, False):
+                ret, frame = cap.read()
+                if not ret:
+                    logger.warning(f"Failed to read frame from camera {camera_id}")
+                    await asyncio.sleep(1)
+                    continue
+                
+                frame_count += 1
+                current_time = datetime.now().timestamp()
+                
+                # Skip frames for performance
+                if frame_count % frame_skip != 0:
+                    continue
+                
+                # Process at intervals
+                if current_time - last_processing_time < processing_interval:
+                    continue
+                
+                last_processing_time = current_time
+                
+                # Process frame
+                detections = await self.process_frame(frame, camera_id, location)
+                
+                # Send detections to backend
+                for detection in detections:
+                    await self.send_detection_to_backend(detection)
+                
+                await asyncio.sleep(0.1)  # Small delay to prevent overwhelming
+                
+        except Exception as e:
+            logger.error(f"Error in video stream processing: {e}")
+        finally:
+            if cap:
+                cap.release()
+            self.active_streams[camera_id] = False
+            logger.info(f"Stopped processing camera {camera_id}")
+
+# Initialize FastAPI app
+app = FastAPI(title="Event Monitoring AI Service", version="1.0.0")
+
+# Add CORS middleware
+app.add_middleware(
+    CORSMiddleware,
+    allow_origins=["*"],
+    allow_credentials=True,
+    allow_methods=["*"],
+    allow_headers=["*"],
+)
+
+# Initialize AI service
+ai_service = AIService()
+
+@app.get("/health")
+async def health_check():
+    """Health check endpoint"""
+    return {
+        "status": "healthy",
+        "timestamp": datetime.utcnow().isoformat(),
+        "model_loaded": ai_service.model is not None,
+        "device": ai_service.device,
+        "active_streams": len(ai_service.active_streams)
+    }
+
+@app.post("/start-detection")
+async def start_detection(request: DetectionRequest, background_tasks: BackgroundTasks):
+    """Start detection for a camera stream"""
+    if request.camera_id in ai_service.active_streams:
+        raise HTTPException(status_code=400, detail="Detection already active for this camera")
+    
+    background_tasks.add_task(
+        ai_service.process_video_stream,
+        request.camera_id,
+        request.stream_url,
+        request.location
+    )
+    
+    return {"message": f"Detection started for camera {request.camera_id}"}
+
+@app.post("/stop-detection/{camera_id}")
+async def stop_detection(camera_id: str):
+    """Stop detection for a camera"""
+    if camera_id not in ai_service.active_streams:
+        raise HTTPException(status_code=404, detail="No active detection for this camera")
+    
+    ai_service.active_streams[camera_id] = False
+    return {"message": f"Detection stopped for camera {camera_id}"}
+
+@app.get("/active-streams")
+async def get_active_streams():
+    """Get list of active detection streams"""
+    return {
+        "active_streams": list(ai_service.active_streams.keys()),
+        "count": len(ai_service.active_streams)
+    }
+
+if __name__ == "__main__":
+    import uvicorn
+    
+    port = int(os.getenv("PORT", "8000"))
+    host = os.getenv("HOST", "0.0.0.0")
+    
+    logger.info(f"Starting AI Service on {host}:{port}")
     uvicorn.run(app, host=host, port=port, log_level="info")
\ No newline at end of file
diff --git a/event-monitoring-mvp/ai-service/app_old.py b/event-monitoring-mvp/ai-service/app_old.py
index dd5d6cd..b925729 100644
--- a/event-monitoring-mvp/ai-service/app_old.py
+++ b/event-monitoring-mvp/ai-service/app_old.py
@@ -1,477 +1,477 @@
-import asyncio
-import os
-import logging
-from datetime import datetime
-from typing import Dict, List, Optional
-import cv2
-import numpy as np
-from fastapi import FastAPI, BackgroundTasks, HTTPException
-from fastapi.middleware.cors import CORSMiddleware
-from pydantic import BaseModel
-import requests
-from dotenv import load_dotenv
-from ultralytics import YOLO
-import torch
-
-# Load environment variables
-load_dotenv()
-
-# Configure logging
-logging.basicConfig(
-    level=getattr(logging, os.getenv('LOG_LEVEL', 'INFO')),
-    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
-    handlers=[
-        logging.FileHandler(os.getenv('LOG_FILE', './logs/ai-service.log')),
-        logging.StreamHandler()
-    ]
-)
-logger = logging.getLogger(__name__)
-
-# Pydantic models
-class DetectionRequest(BaseModel):
-    camera_id: str
-    stream_url: str
-    location: Dict[str, List[float]]
-
-class DetectionResult(BaseModel):
-    camera_id: str
-    event_type: str
-    confidence: float
-    bounding_box: Optional[Dict[str, float]]
-    object_count: int
-    timestamp: str
-    location: Dict[str, List[float]]
-
-class AIService:
-    def __init__(self):
-        self.model_path = os.getenv('MODEL_PATH', './models')
-        self.confidence_threshold = float(os.getenv('CONFIDENCE_THRESHOLD', '0.5'))
-        self.device = os.getenv('DEVICE', 'cpu')
-        self.api_url = os.getenv('API_URL', 'http://localhost:5000/api')
-        
-        # Load YOLO model
-        self.model = None
-        self.load_model()
-        
-        # Class mappings for COCO dataset
-        self.person_classes = [0]  # person
-        self.vehicle_classes = [2, 3, 5, 6, 7]  # car, motorcycle, bus, train, truck
-        
-        # Active processing streams
-        self.active_streams: Dict[str, bool] = {}
-
-    def load_model(self):
-        """Load the YOLO model"""
-        try:
-            model_file = os.path.join(self.model_path, os.getenv('DEFAULT_MODEL', 'yolov8n.pt'))
-            if not os.path.exists(model_file):
-                logger.info(f"Model file not found at {model_file}, downloading...")
-                os.makedirs(self.model_path, exist_ok=True)
-                
-            self.model = YOLO('yolov8n.pt')  # This will auto-download if needed
-            self.model.to(self.device)
-            logger.info(f"Model loaded successfully on device: {self.device}")
-        except Exception as e:
-            logger.error(f"Failed to load model: {e}")
-            raise
-
-    async def process_frame(self, frame: np.ndarray, camera_id: str, location: Dict) -> List[DetectionResult]:
-        """Process a single frame for detections"""
-        try:
-            # Run inference
-            results = self.model(frame, conf=self.confidence_threshold, verbose=False)
-            detections = []
-            
-            for result in results:
-                if result.boxes is not None:
-                    boxes = result.boxes
-                    
-                    # Process each detection
-                    for i in range(len(boxes)):
-                        class_id = int(boxes.cls[i])
-                        confidence = float(boxes.conf[i])
-                        
-                        # Determine event type
-                        event_type = None
-                        if class_id in self.person_classes:
-                            event_type = 'person_detected'
-                        elif class_id in self.vehicle_classes:
-                            event_type = 'vehicle_detected'
-                        
-                        if event_type and confidence >= self.confidence_threshold:
-                            # Get bounding box
-                            box = boxes.xyxy[i].cpu().numpy()
-                            x1, y1, x2, y2 = box
-                            
-                            detection = DetectionResult(
-                                camera_id=camera_id,
-                                event_type=event_type,
-                                confidence=confidence,
-                                bounding_box={
-                                    'x': float(x1),
-                                    'y': float(y1),
-                                    'width': float(x2 - x1),
-                                    'height': float(y2 - y1)
-                                },
-                                object_count=1,
-                                timestamp=datetime.utcnow().isoformat(),
-                                location=location
-                            )
-                            detections.append(detection)
-            
-            return detections
-            
-        except Exception as e:
-            logger.error(f"Error processing frame: {e}")
-            return []
-
-    async def send_detection_to_backend(self, detection: DetectionResult):
-        """Send detection result to backend API"""
-        try:
-            event_data = {
-                'title': f'{detection.event_type.replace("_", " ").title()} Detected',
-                'description': f'AI detected {detection.event_type.replace("_", " ")} with {detection.confidence:.2%} confidence',
-                'type': detection.event_type,
-                'severity': self.determine_severity(detection),
-                'cameraId': detection.camera_id,
-                'location': detection.location,
-                'detectionData': {
-                    'confidence': detection.confidence,
-                    'boundingBox': detection.bounding_box,
-                    'objectCount': detection.object_count,
-                    'aiModel': 'YOLOv8'
-                }
-            }
-            
-            response = requests.post(
-                f"{self.api_url}/events",
-                json=event_data,
-                timeout=int(os.getenv('API_TIMEOUT', '30'))
-            )
-            
-            if response.status_code == 201:
-                logger.info(f"Successfully sent detection for camera {detection.camera_id}")
-            else:
-                logger.error(f"Failed to send detection: {response.status_code} - {response.text}")
-                
-        except Exception as e:
-            logger.error(f"Error sending detection to backend: {e}")
-
-    def determine_severity(self, detection: DetectionResult) -> str:
-        """Determine event severity based on detection"""
-        if detection.confidence > 0.9:
-            return 'high'
-        elif detection.confidence > 0.7:
-            return 'medium'
-        else:
-            return 'low'
-
-    async def process_video_stream(self, camera_id: str, stream_url: str, location: Dict):
-        """Process video stream from camera"""
-        logger.info(f"Starting video processing for camera {camera_id}")
-        self.active_streams[camera_id] = True
-        
-        frame_skip = int(os.getenv('FRAME_SKIP', '5'))
-        processing_interval = int(os.getenv('PROCESSING_INTERVAL', '2'))
-        
-        cap = None
-        frame_count = 0
-        
-        try:
-            cap = cv2.VideoCapture(stream_url)
-            if not cap.isOpened():
-                logger.error(f"Failed to open stream: {stream_url}")
-                return
-            
-            last_processing_time = 0
-            
-            while self.active_streams.get(camera_id, False):
-                ret, frame = cap.read()
-                if not ret:
-                    logger.warning(f"Failed to read frame from camera {camera_id}")
-                    await asyncio.sleep(1)
-                    continue
-                
-                frame_count += 1
-                current_time = datetime.now().timestamp()
-                
-                # Skip frames for performance
-                if frame_count % frame_skip != 0:
-                    continue
-                
-                # Process at intervals
-                if current_time - last_processing_time < processing_interval:
-                    continue
-                
-                last_processing_time = current_time
-                
-                # Process frame
-                detections = await self.process_frame(frame, camera_id, location)
-                
-                # Send detections to backend
-                for detection in detections:
-                    await self.send_detection_to_backend(detection)
-                
-                await asyncio.sleep(0.1)  # Small delay to prevent overwhelming
-                
-        except Exception as e:
-            logger.error(f"Error in video stream processing: {e}")
-        finally:
-            if cap:
-                cap.release()
-            self.active_streams[camera_id] = False
-            logger.info(f"Stopped processing camera {camera_id}")
-
-# Initialize FastAPI app
-app = FastAPI(title="Event Monitoring AI Service", version="1.0.0")
-
-# Add CORS middleware
-app.add_middleware(
-    CORSMiddleware,
-    allow_origins=["*"],
-    allow_credentials=True,
-    allow_methods=["*"],
-    allow_headers=["*"],
-)
-
-# Initialize AI service
-ai_service = AIService()
-
-@app.get("/health")
-async def health_check():
-    """Health check endpoint"""
-    return {
-        "status": "healthy",
-        "timestamp": datetime.utcnow().isoformat(),
-        "model_loaded": ai_service.model is not None,
-        "device": ai_service.device,
-        "active_streams": len(ai_service.active_streams)
-    }
-
-@app.post("/start-detection")
-async def start_detection(request: DetectionRequest, background_tasks: BackgroundTasks):
-    """Start detection for a camera stream"""
-    if request.camera_id in ai_service.active_streams:
-        raise HTTPException(status_code=400, detail="Detection already active for this camera")
-    
-    background_tasks.add_task(
-        ai_service.process_video_stream,
-        request.camera_id,
-        request.stream_url,
-        request.location
-    )
-    
-    return {"message": f"Detection started for camera {request.camera_id}"}
-
-@app.post("/stop-detection/{camera_id}")
-async def stop_detection(camera_id: str):
-    """Stop detection for a camera"""
-    if camera_id not in ai_service.active_streams:
-        raise HTTPException(status_code=404, detail="No active detection for this camera")
-    
-    ai_service.active_streams[camera_id] = False
-    return {"message": f"Detection stopped for camera {camera_id}"}
-
-@app.get("/active-streams")
-async def get_active_streams():
-    """Get list of active detection streams"""
-    return {
-        "active_streams": list(ai_service.active_streams.keys()),
-        "count": len(ai_service.active_streams)
-    }
-
-if __name__ == "__main__":
-    import uvicorn
-    
-    port = int(os.getenv("PORT", "8000"))
-    host = os.getenv("HOST", "0.0.0.0")
-    
-    logger.info(f"Starting AI Service on {host}:{port}")
-    uvicorn.run(app, host=host, port=port, log_level="info")
-
-import asyncio
-import logging
-import os
-from contextlib import asynccontextmanager
-from fastapi import FastAPI, HTTPException, BackgroundTasks
-from fastapi.middleware.cors import CORSMiddleware
-from pydantic import BaseModel
-from typing import List, Optional, Dict, Any
-import uvicorn
-
-from src.services.detection_service import DetectionService
-from src.services.video_processor import VideoProcessor
-from src.services.api_client import APIClient
-from src.utils.logger import setup_logger
-from src.models.detection import DetectionResult, CameraStream
-
-# Setup logging
-logger = setup_logger()
-
-# Global services
-detection_service: Optional[DetectionService] = None
-video_processor: Optional[VideoProcessor] = None
-api_client: Optional[APIClient] = None
-
-@asynccontextmanager
-async def lifespan(app: FastAPI):
-    """Application lifespan manager"""
-    global detection_service, video_processor, api_client
-    
-    logger.info("ğŸš€ Starting AI Service...")
-    
-    try:
-        # Initialize services
-        detection_service = DetectionService()
-        api_client = APIClient()
-        video_processor = VideoProcessor(detection_service, api_client)
-        
-        # Start video processing
-        await video_processor.start()
-        
-        logger.info("âœ… AI Service initialized successfully")
-        
-        yield
-        
-    except Exception as e:
-        logger.error(f"âŒ Failed to initialize AI Service: {e}")
-        raise
-    finally:
-        # Cleanup
-        if video_processor:
-            await video_processor.stop()
-        logger.info("ğŸ›‘ AI Service stopped")
-
-# FastAPI app
-app = FastAPI(
-    title="Event Monitoring AI Service",
-    description="AI-powered video analytics for event detection",
-    version="1.0.0",
-    lifespan=lifespan
-)
-
-# CORS middleware
-app.add_middleware(
-    CORSMiddleware,
-    allow_origins=["*"],  # Configure appropriately for production
-    allow_credentials=True,
-    allow_methods=["*"],
-    allow_headers=["*"],
-)
-
-# Pydantic models
-class HealthResponse(BaseModel):
-    status: str
-    service: str
-    version: str
-
-class DetectionRequest(BaseModel):
-    camera_id: str
-    image_data: str  # Base64 encoded image
-    timestamp: Optional[str] = None
-
-class StreamRequest(BaseModel):
-    camera_id: str
-    stream_url: str
-    location: Dict[str, Any]
-
-# Health check endpoint
-@app.get("/health", response_model=HealthResponse)
-async def health_check():
-    """Health check endpoint"""
-    return HealthResponse(
-        status="healthy",
-        service="ai-service",
-        version="1.0.0"
-    )
-
-# Detection endpoints
-@app.post("/detect")
-async def detect_objects(request: DetectionRequest):
-    """
-    Detect objects in a single image
-    """
-    if not detection_service:
-        raise HTTPException(status_code=503, detail="Detection service not available")
-    
-    try:
-        result = await detection_service.detect_from_base64(
-            request.image_data,
-            request.camera_id,
-            request.timestamp
-        )
-        return result.dict()
-    except Exception as e:
-        logger.error(f"Detection failed: {e}")
-        raise HTTPException(status_code=500, detail="Detection failed")
-
-@app.post("/streams/start")
-async def start_stream_processing(request: StreamRequest, background_tasks: BackgroundTasks):
-    """
-    Start processing a video stream
-    """
-    if not video_processor:
-        raise HTTPException(status_code=503, detail="Video processor not available")
-    
-    try:
-        stream = CameraStream(
-            camera_id=request.camera_id,
-            stream_url=request.stream_url,
-            location=request.location
-        )
-        
-        background_tasks.add_task(video_processor.process_stream, stream)
-        
-        return {"message": f"Started processing stream for camera {request.camera_id}"}
-    except Exception as e:
-        logger.error(f"Failed to start stream processing: {e}")
-        raise HTTPException(status_code=500, detail="Failed to start stream processing")
-
-@app.post("/streams/{camera_id}/stop")
-async def stop_stream_processing(camera_id: str):
-    """
-    Stop processing a video stream
-    """
-    if not video_processor:
-        raise HTTPException(status_code=503, detail="Video processor not available")
-    
-    try:
-        await video_processor.stop_stream(camera_id)
-        return {"message": f"Stopped processing stream for camera {camera_id}"}
-    except Exception as e:
-        logger.error(f"Failed to stop stream processing: {e}")
-        raise HTTPException(status_code=500, detail="Failed to stop stream processing")
-
-@app.get("/streams")
-async def get_active_streams():
-    """
-    Get list of active streams being processed
-    """
-    if not video_processor:
-        raise HTTPException(status_code=503, detail="Video processor not available")
-    
-    return {"active_streams": video_processor.get_active_streams()}
-
-@app.get("/models")
-async def get_available_models():
-    """
-    Get list of available AI models
-    """
-    if not detection_service:
-        raise HTTPException(status_code=503, detail="Detection service not available")
-    
-    return {"models": detection_service.get_available_models()}
-
-if __name__ == "__main__":
-    # Configuration
-    host = os.getenv("HOST", "0.0.0.0")
-    port = int(os.getenv("PORT", "8000"))
-    
-    # Run the service
-    uvicorn.run(
-        "app:app",
-        host=host,
-        port=port,
-        reload=False,
-        log_level="info"
+import asyncio
+import os
+import logging
+from datetime import datetime
+from typing import Dict, List, Optional
+import cv2
+import numpy as np
+from fastapi import FastAPI, BackgroundTasks, HTTPException
+from fastapi.middleware.cors import CORSMiddleware
+from pydantic import BaseModel
+import requests
+from dotenv import load_dotenv
+from ultralytics import YOLO
+import torch
+
+# Load environment variables
+load_dotenv()
+
+# Configure logging
+logging.basicConfig(
+    level=getattr(logging, os.getenv('LOG_LEVEL', 'INFO')),
+    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
+    handlers=[
+        logging.FileHandler(os.getenv('LOG_FILE', './logs/ai-service.log')),
+        logging.StreamHandler()
+    ]
+)
+logger = logging.getLogger(__name__)
+
+# Pydantic models
+class DetectionRequest(BaseModel):
+    camera_id: str
+    stream_url: str
+    location: Dict[str, List[float]]
+
+class DetectionResult(BaseModel):
+    camera_id: str
+    event_type: str
+    confidence: float
+    bounding_box: Optional[Dict[str, float]]
+    object_count: int
+    timestamp: str
+    location: Dict[str, List[float]]
+
+class AIService:
+    def __init__(self):
+        self.model_path = os.getenv('MODEL_PATH', './models')
+        self.confidence_threshold = float(os.getenv('CONFIDENCE_THRESHOLD', '0.5'))
+        self.device = os.getenv('DEVICE', 'cpu')
+        self.api_url = os.getenv('API_URL', 'http://localhost:5000/api')
+        
+        # Load YOLO model
+        self.model = None
+        self.load_model()
+        
+        # Class mappings for COCO dataset
+        self.person_classes = [0]  # person
+        self.vehicle_classes = [2, 3, 5, 6, 7]  # car, motorcycle, bus, train, truck
+        
+        # Active processing streams
+        self.active_streams: Dict[str, bool] = {}
+
+    def load_model(self):
+        """Load the YOLO model"""
+        try:
+            model_file = os.path.join(self.model_path, os.getenv('DEFAULT_MODEL', 'yolov8n.pt'))
+            if not os.path.exists(model_file):
+                logger.info(f"Model file not found at {model_file}, downloading...")
+                os.makedirs(self.model_path, exist_ok=True)
+                
+            self.model = YOLO('yolov8n.pt')  # This will auto-download if needed
+            self.model.to(self.device)
+            logger.info(f"Model loaded successfully on device: {self.device}")
+        except Exception as e:
+            logger.error(f"Failed to load model: {e}")
+            raise
+
+    async def process_frame(self, frame: np.ndarray, camera_id: str, location: Dict) -> List[DetectionResult]:
+        """Process a single frame for detections"""
+        try:
+            # Run inference
+            results = self.model(frame, conf=self.confidence_threshold, verbose=False)
+            detections = []
+            
+            for result in results:
+                if result.boxes is not None:
+                    boxes = result.boxes
+                    
+                    # Process each detection
+                    for i in range(len(boxes)):
+                        class_id = int(boxes.cls[i])
+                        confidence = float(boxes.conf[i])
+                        
+                        # Determine event type
+                        event_type = None
+                        if class_id in self.person_classes:
+                            event_type = 'person_detected'
+                        elif class_id in self.vehicle_classes:
+                            event_type = 'vehicle_detected'
+                        
+                        if event_type and confidence >= self.confidence_threshold:
+                            # Get bounding box
+                            box = boxes.xyxy[i].cpu().numpy()
+                            x1, y1, x2, y2 = box
+                            
+                            detection = DetectionResult(
+                                camera_id=camera_id,
+                                event_type=event_type,
+                                confidence=confidence,
+                                bounding_box={
+                                    'x': float(x1),
+                                    'y': float(y1),
+                                    'width': float(x2 - x1),
+                                    'height': float(y2 - y1)
+                                },
+                                object_count=1,
+                                timestamp=datetime.utcnow().isoformat(),
+                                location=location
+                            )
+                            detections.append(detection)
+            
+            return detections
+            
+        except Exception as e:
+            logger.error(f"Error processing frame: {e}")
+            return []
+
+    async def send_detection_to_backend(self, detection: DetectionResult):
+        """Send detection result to backend API"""
+        try:
+            event_data = {
+                'title': f'{detection.event_type.replace("_", " ").title()} Detected',
+                'description': f'AI detected {detection.event_type.replace("_", " ")} with {detection.confidence:.2%} confidence',
+                'type': detection.event_type,
+                'severity': self.determine_severity(detection),
+                'cameraId': detection.camera_id,
+                'location': detection.location,
+                'detectionData': {
+                    'confidence': detection.confidence,
+                    'boundingBox': detection.bounding_box,
+                    'objectCount': detection.object_count,
+                    'aiModel': 'YOLOv8'
+                }
+            }
+            
+            response = requests.post(
+                f"{self.api_url}/events",
+                json=event_data,
+                timeout=int(os.getenv('API_TIMEOUT', '30'))
+            )
+            
+            if response.status_code == 201:
+                logger.info(f"Successfully sent detection for camera {detection.camera_id}")
+            else:
+                logger.error(f"Failed to send detection: {response.status_code} - {response.text}")
+                
+        except Exception as e:
+            logger.error(f"Error sending detection to backend: {e}")
+
+    def determine_severity(self, detection: DetectionResult) -> str:
+        """Determine event severity based on detection"""
+        if detection.confidence > 0.9:
+            return 'high'
+        elif detection.confidence > 0.7:
+            return 'medium'
+        else:
+            return 'low'
+
+    async def process_video_stream(self, camera_id: str, stream_url: str, location: Dict):
+        """Process video stream from camera"""
+        logger.info(f"Starting video processing for camera {camera_id}")
+        self.active_streams[camera_id] = True
+        
+        frame_skip = int(os.getenv('FRAME_SKIP', '5'))
+        processing_interval = int(os.getenv('PROCESSING_INTERVAL', '2'))
+        
+        cap = None
+        frame_count = 0
+        
+        try:
+            cap = cv2.VideoCapture(stream_url)
+            if not cap.isOpened():
+                logger.error(f"Failed to open stream: {stream_url}")
+                return
+            
+            last_processing_time = 0
+            
+            while self.active_streams.get(camera_id, False):
+                ret, frame = cap.read()
+                if not ret:
+                    logger.warning(f"Failed to read frame from camera {camera_id}")
+                    await asyncio.sleep(1)
+                    continue
+                
+                frame_count += 1
+                current_time = datetime.now().timestamp()
+                
+                # Skip frames for performance
+                if frame_count % frame_skip != 0:
+                    continue
+                
+                # Process at intervals
+                if current_time - last_processing_time < processing_interval:
+                    continue
+                
+                last_processing_time = current_time
+                
+                # Process frame
+                detections = await self.process_frame(frame, camera_id, location)
+                
+                # Send detections to backend
+                for detection in detections:
+                    await self.send_detection_to_backend(detection)
+                
+                await asyncio.sleep(0.1)  # Small delay to prevent overwhelming
+                
+        except Exception as e:
+            logger.error(f"Error in video stream processing: {e}")
+        finally:
+            if cap:
+                cap.release()
+            self.active_streams[camera_id] = False
+            logger.info(f"Stopped processing camera {camera_id}")
+
+# Initialize FastAPI app
+app = FastAPI(title="Event Monitoring AI Service", version="1.0.0")
+
+# Add CORS middleware
+app.add_middleware(
+    CORSMiddleware,
+    allow_origins=["*"],
+    allow_credentials=True,
+    allow_methods=["*"],
+    allow_headers=["*"],
+)
+
+# Initialize AI service
+ai_service = AIService()
+
+@app.get("/health")
+async def health_check():
+    """Health check endpoint"""
+    return {
+        "status": "healthy",
+        "timestamp": datetime.utcnow().isoformat(),
+        "model_loaded": ai_service.model is not None,
+        "device": ai_service.device,
+        "active_streams": len(ai_service.active_streams)
+    }
+
+@app.post("/start-detection")
+async def start_detection(request: DetectionRequest, background_tasks: BackgroundTasks):
+    """Start detection for a camera stream"""
+    if request.camera_id in ai_service.active_streams:
+        raise HTTPException(status_code=400, detail="Detection already active for this camera")
+    
+    background_tasks.add_task(
+        ai_service.process_video_stream,
+        request.camera_id,
+        request.stream_url,
+        request.location
+    )
+    
+    return {"message": f"Detection started for camera {request.camera_id}"}
+
+@app.post("/stop-detection/{camera_id}")
+async def stop_detection(camera_id: str):
+    """Stop detection for a camera"""
+    if camera_id not in ai_service.active_streams:
+        raise HTTPException(status_code=404, detail="No active detection for this camera")
+    
+    ai_service.active_streams[camera_id] = False
+    return {"message": f"Detection stopped for camera {camera_id}"}
+
+@app.get("/active-streams")
+async def get_active_streams():
+    """Get list of active detection streams"""
+    return {
+        "active_streams": list(ai_service.active_streams.keys()),
+        "count": len(ai_service.active_streams)
+    }
+
+if __name__ == "__main__":
+    import uvicorn
+    
+    port = int(os.getenv("PORT", "8000"))
+    host = os.getenv("HOST", "0.0.0.0")
+    
+    logger.info(f"Starting AI Service on {host}:{port}")
+    uvicorn.run(app, host=host, port=port, log_level="info")
+
+import asyncio
+import logging
+import os
+from contextlib import asynccontextmanager
+from fastapi import FastAPI, HTTPException, BackgroundTasks
+from fastapi.middleware.cors import CORSMiddleware
+from pydantic import BaseModel
+from typing import List, Optional, Dict, Any
+import uvicorn
+
+from src.services.detection_service import DetectionService
+from src.services.video_processor import VideoProcessor
+from src.services.api_client import APIClient
+from src.utils.logger import setup_logger
+from src.models.detection import DetectionResult, CameraStream
+
+# Setup logging
+logger = setup_logger()
+
+# Global services
+detection_service: Optional[DetectionService] = None
+video_processor: Optional[VideoProcessor] = None
+api_client: Optional[APIClient] = None
+
+@asynccontextmanager
+async def lifespan(app: FastAPI):
+    """Application lifespan manager"""
+    global detection_service, video_processor, api_client
+    
+    logger.info("ğŸš€ Starting AI Service...")
+    
+    try:
+        # Initialize services
+        detection_service = DetectionService()
+        api_client = APIClient()
+        video_processor = VideoProcessor(detection_service, api_client)
+        
+        # Start video processing
+        await video_processor.start()
+        
+        logger.info("âœ… AI Service initialized successfully")
+        
+        yield
+        
+    except Exception as e:
+        logger.error(f"âŒ Failed to initialize AI Service: {e}")
+        raise
+    finally:
+        # Cleanup
+        if video_processor:
+            await video_processor.stop()
+        logger.info("ğŸ›‘ AI Service stopped")
+
+# FastAPI app
+app = FastAPI(
+    title="Event Monitoring AI Service",
+    description="AI-powered video analytics for event detection",
+    version="1.0.0",
+    lifespan=lifespan
+)
+
+# CORS middleware
+app.add_middleware(
+    CORSMiddleware,
+    allow_origins=["*"],  # Configure appropriately for production
+    allow_credentials=True,
+    allow_methods=["*"],
+    allow_headers=["*"],
+)
+
+# Pydantic models
+class HealthResponse(BaseModel):
+    status: str
+    service: str
+    version: str
+
+class DetectionRequest(BaseModel):
+    camera_id: str
+    image_data: str  # Base64 encoded image
+    timestamp: Optional[str] = None
+
+class StreamRequest(BaseModel):
+    camera_id: str
+    stream_url: str
+    location: Dict[str, Any]
+
+# Health check endpoint
+@app.get("/health", response_model=HealthResponse)
+async def health_check():
+    """Health check endpoint"""
+    return HealthResponse(
+        status="healthy",
+        service="ai-service",
+        version="1.0.0"
+    )
+
+# Detection endpoints
+@app.post("/detect")
+async def detect_objects(request: DetectionRequest):
+    """
+    Detect objects in a single image
+    """
+    if not detection_service:
+        raise HTTPException(status_code=503, detail="Detection service not available")
+    
+    try:
+        result = await detection_service.detect_from_base64(
+            request.image_data,
+            request.camera_id,
+            request.timestamp
+        )
+        return result.dict()
+    except Exception as e:
+        logger.error(f"Detection failed: {e}")
+        raise HTTPException(status_code=500, detail="Detection failed")
+
+@app.post("/streams/start")
+async def start_stream_processing(request: StreamRequest, background_tasks: BackgroundTasks):
+    """
+    Start processing a video stream
+    """
+    if not video_processor:
+        raise HTTPException(status_code=503, detail="Video processor not available")
+    
+    try:
+        stream = CameraStream(
+            camera_id=request.camera_id,
+            stream_url=request.stream_url,
+            location=request.location
+        )
+        
+        background_tasks.add_task(video_processor.process_stream, stream)
+        
+        return {"message": f"Started processing stream for camera {request.camera_id}"}
+    except Exception as e:
+        logger.error(f"Failed to start stream processing: {e}")
+        raise HTTPException(status_code=500, detail="Failed to start stream processing")
+
+@app.post("/streams/{camera_id}/stop")
+async def stop_stream_processing(camera_id: str):
+    """
+    Stop processing a video stream
+    """
+    if not video_processor:
+        raise HTTPException(status_code=503, detail="Video processor not available")
+    
+    try:
+        await video_processor.stop_stream(camera_id)
+        return {"message": f"Stopped processing stream for camera {camera_id}"}
+    except Exception as e:
+        logger.error(f"Failed to stop stream processing: {e}")
+        raise HTTPException(status_code=500, detail="Failed to stop stream processing")
+
+@app.get("/streams")
+async def get_active_streams():
+    """
+    Get list of active streams being processed
+    """
+    if not video_processor:
+        raise HTTPException(status_code=503, detail="Video processor not available")
+    
+    return {"active_streams": video_processor.get_active_streams()}
+
+@app.get("/models")
+async def get_available_models():
+    """
+    Get list of available AI models
+    """
+    if not detection_service:
+        raise HTTPException(status_code=503, detail="Detection service not available")
+    
+    return {"models": detection_service.get_available_models()}
+
+if __name__ == "__main__":
+    # Configuration
+    host = os.getenv("HOST", "0.0.0.0")
+    port = int(os.getenv("PORT", "8000"))
+    
+    # Run the service
+    uvicorn.run(
+        "app:app",
+        host=host,
+        port=port,
+        reload=False,
+        log_level="info"
     )
\ No newline at end of file
diff --git a/event-monitoring-mvp/ai-service/requirements.txt b/event-monitoring-mvp/ai-service/requirements.txt
index 015ffbf..3219abd 100644
--- a/event-monitoring-mvp/ai-service/requirements.txt
+++ b/event-monitoring-mvp/ai-service/requirements.txt
@@ -1,16 +1,16 @@
-fastapi==0.95.2
-uvicorn==0.22.0
-opencv-python==4.7.1.72
-numpy==1.24.3
-torch==2.0.1
-torchvision==0.15.2
-Pillow==9.5.0
-python-multipart==0.0.6
-aiofiles==23.1.0
-requests==2.31.0
-python-dotenv==1.0.0
-pydantic==1.10.8
-asyncio-mqtt==0.13.0
-websockets==11.0.3
-ultralytics==8.0.120
+fastapi==0.95.2
+uvicorn==0.22.0
+opencv-python==4.7.1.72
+numpy==1.24.3
+torch==2.0.1
+torchvision==0.15.2
+Pillow==9.5.0
+python-multipart==0.0.6
+aiofiles==23.1.0
+requests==2.31.0
+python-dotenv==1.0.0
+pydantic==1.10.8
+asyncio-mqtt==0.13.0
+websockets==11.0.3
+ultralytics==8.0.120
 supervision==0.11.1
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/.env.example b/event-monitoring-mvp/backend/.env.example
index ab2d1c1..3c5e2a9 100644
--- a/event-monitoring-mvp/backend/.env.example
+++ b/event-monitoring-mvp/backend/.env.example
@@ -1,28 +1,28 @@
-# Environment Variables
-NODE_ENV=development
-PORT=5000
-
-# Database
-MONGODB_URI=mongodb://localhost:27017/event_monitoring
-
-# JWT
-JWT_SECRET=your-super-secret-jwt-key-change-in-production
-JWT_EXPIRES_IN=24h
-
-# AI Service
-AI_SERVICE_URL=http://localhost:8000
-
-# CORS
-FRONTEND_URL=http://localhost:3000
-
-# Rate Limiting
-RATE_LIMIT_WINDOW_MS=900000
-RATE_LIMIT_MAX_REQUESTS=100
-
-# Video Streaming
-MAX_CAMERAS=5
-VIDEO_CHUNK_SIZE=1024
-
-# File Upload
-MAX_FILE_SIZE=10485760
+# Environment Variables
+NODE_ENV=development
+PORT=5000
+
+# Database
+MONGODB_URI=mongodb://localhost:27017/event_monitoring
+
+# JWT
+JWT_SECRET=your-super-secret-jwt-key-change-in-production
+JWT_EXPIRES_IN=24h
+
+# AI Service
+AI_SERVICE_URL=http://localhost:8000
+
+# CORS
+FRONTEND_URL=http://localhost:3000
+
+# Rate Limiting
+RATE_LIMIT_WINDOW_MS=900000
+RATE_LIMIT_MAX_REQUESTS=100
+
+# Video Streaming
+MAX_CAMERAS=5
+VIDEO_CHUNK_SIZE=1024
+
+# File Upload
+MAX_FILE_SIZE=10485760
 UPLOAD_PATH=./uploads
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/Dockerfile b/event-monitoring-mvp/backend/Dockerfile
index c125c22..153cd6f 100644
--- a/event-monitoring-mvp/backend/Dockerfile
+++ b/event-monitoring-mvp/backend/Dockerfile
@@ -1,27 +1,27 @@
-# Node.js Backend Dockerfile
-FROM node:18-alpine
-
-# Set working directory
-WORKDIR /app
-
-# Copy package files
-COPY package*.json ./
-
-# Install dependencies
-RUN npm ci --only=production
-
-# Copy source code
-COPY . .
-
-# Build the application
-RUN npm run build
-
-# Expose port
-EXPOSE 5000
-
-# Health check
-HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
-  CMD curl -f http://localhost:5000/health || exit 1
-
-# Start the application
+# Node.js Backend Dockerfile
+FROM node:18-alpine
+
+# Set working directory
+WORKDIR /app
+
+# Copy package files
+COPY package*.json ./
+
+# Install dependencies
+RUN npm ci --only=production
+
+# Copy source code
+COPY . .
+
+# Build the application
+RUN npm run build
+
+# Expose port
+EXPOSE 5000
+
+# Health check
+HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
+  CMD curl -f http://localhost:5000/health || exit 1
+
+# Start the application
 CMD ["npm", "start"]
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/README.md b/event-monitoring-mvp/backend/README.md
index c5fa0e7..a3fe4eb 100644
--- a/event-monitoring-mvp/backend/README.md
+++ b/event-monitoring-mvp/backend/README.md
@@ -1,373 +1,373 @@
-# Backend - Event Monitoring MVP
-
-Node.js/Express backend API providing authentication, camera management, event processing, and real-time communication for the Event Monitoring system.
-
-## ğŸš€ Quick Start
-
-### Prerequisites
-- **Node.js** 18+ and npm
-- **MongoDB** 6.0+ running locally or via Docker
-- **TypeScript** knowledge recommended
-
-### Development Setup
-
-1. **Install Dependencies**
-   ```bash
-   cd backend
-   npm install
-   ```
-
-2. **Environment Configuration**
-   ```bash
-   # Create environment file
-   cp .env.example .env
-   
-   # Configure your settings
-   nano .env
-   ```
-
-3. **Start MongoDB**
-   ```bash
-   # Option 1: Local MongoDB
-   mongod --dbpath ./data
-   
-   # Option 2: Docker MongoDB
-   docker run -d -p 27017:27017 --name mongodb mongo:latest
-   ```
-
-4. **Start Development Server**
-   ```bash
-   npm run dev
-   ```
-
-5. **Verify Setup**
-   - API available at: http://localhost:5000
-   - Health check: http://localhost:5000/api/health
-cd backend
-npm install
-```
-
-### 2. Environment Setup
-```bash
-# Copy the environment template
-cp .env.example .env
-
-# Edit the .env file with your configuration
-nano .env
-```
-
-### 3. Start Development Server
-```bash
-npm run dev
-```
-
-The backend API will be available at: http://localhost:5000
-
-## Environment Configuration
-
-Edit the `.env` file with these settings:
-
-```bash
-# Environment
-NODE_ENV=development
-PORT=5000
-
-# Database
-MONGODB_URI=mongodb://localhost:27017/event_monitoring
-
-# JWT Configuration
-JWT_SECRET=your-super-secret-jwt-key-change-in-production
-JWT_EXPIRES_IN=24h
-
-# External Services
-AI_SERVICE_URL=http://localhost:8000
-FRONTEND_URL=http://localhost:3000
-
-# Rate Limiting
-RATE_LIMIT_WINDOW_MS=900000
-RATE_LIMIT_MAX_REQUESTS=100
-
-# Video Streaming
-MAX_CAMERAS=5
-VIDEO_CHUNK_SIZE=1024
-
-# File Upload
-MAX_FILE_SIZE=10485760
-UPLOAD_PATH=./uploads
-```
-
-## Available Scripts
-
-### Development
-```bash
-npm run dev        # Start with hot reload (recommended)
-npm run build      # Build TypeScript to JavaScript
-npm start          # Start production server
-npm test           # Run tests
-npm run lint       # Run ESLint
-npm run lint:fix   # Fix ESLint issues
-```
-
-## Database Setup
-
-### MongoDB Installation
-```bash
-# Ubuntu/Debian
-sudo apt update
-sudo apt install mongodb
-
-# macOS with Homebrew
-brew tap mongodb/brew
-brew install mongodb-community
-
-# Start MongoDB
-sudo systemctl start mongod  # Linux
-brew services start mongodb/brew/mongodb-community  # macOS
-```
-
-### Initialize Database
-```bash
-# Import initial data (creates admin user)
-mongosh event_monitoring < ../docker/mongo-init.js
-```
-
-Default admin user:
-- **Email**: admin@example.com
-- **Password**: password123
-
-## API Documentation
-
-### Authentication Endpoints
-```bash
-# Login
-POST /api/auth/login
-{
-  "email": "admin@example.com",
-  "password": "password123"
-}
-
-# Register new user
-POST /api/auth/register
-{
-  "username": "operator1",
-  "email": "operator@example.com", 
-  "password": "password123",
-  "role": "operator"
-}
-
-# Get user profile
-GET /api/auth/profile
-Headers: Authorization: Bearer <jwt-token>
-```
-
-### Camera Endpoints
-```bash
-# List all cameras
-GET /api/cameras
-Headers: Authorization: Bearer <jwt-token>
-
-# Create new camera
-POST /api/cameras
-Headers: Authorization: Bearer <jwt-token>
-{
-  "name": "Front Gate Camera",
-  "description": "Main entrance monitoring",
-  "streamUrl": "rtsp://camera-ip:554/stream",
-  "location": {
-    "coordinates": [-74.0060, 40.7128],
-    "address": "123 Main St, New York, NY"
-  },
-  "type": "ip",
-  "settings": {
-    "resolution": "1920x1080",
-    "fps": 30,
-    "recordingEnabled": true
-  }
-}
-```
-
-### Event Endpoints
-```bash
-# List events with filtering
-GET /api/events?status=open&type=person_detected&page=1&limit=20
-Headers: Authorization: Bearer <jwt-token>
-
-# Create new event (usually from AI service)
-POST /api/events
-Headers: Authorization: Bearer <jwt-token>
-{
-  "title": "Person Detected",
-  "description": "AI detected person with 85% confidence",
-  "type": "person_detected",
-  "severity": "medium",
-  "cameraId": "camera-object-id",
-  "location": {
-    "coordinates": [-74.0060, 40.7128]
-  },
-  "detectionData": {
-    "confidence": 0.85,
-    "boundingBox": {"x": 100, "y": 150, "width": 200, "height": 300},
-    "objectCount": 1,
-    "aiModel": "YOLOv8"
-  }
-}
-```
-
-## Project Structure
-
-```
-backend/
-â”œâ”€â”€ src/
-â”‚   â”œâ”€â”€ app.ts              # Main application file
-â”‚   â”œâ”€â”€ controllers/        # Route handlers
-â”‚   â”‚   â”œâ”€â”€ authController.ts
-â”‚   â”‚   â”œâ”€â”€ cameraController.ts
-â”‚   â”‚   â”œâ”€â”€ eventController.ts
-â”‚   â”‚   â””â”€â”€ userController.ts
-â”‚   â”œâ”€â”€ models/             # MongoDB schemas
-â”‚   â”‚   â”œâ”€â”€ User.ts
-â”‚   â”‚   â”œâ”€â”€ Camera.ts
-â”‚   â”‚   â””â”€â”€ Event.ts
-â”‚   â”œâ”€â”€ routes/             # API route definitions
-â”‚   â”‚   â”œâ”€â”€ auth.ts
-â”‚   â”‚   â”œâ”€â”€ cameras.ts
-â”‚   â”‚   â”œâ”€â”€ events.ts
-â”‚   â”‚   â””â”€â”€ users.ts
-â”‚   â”œâ”€â”€ middleware/         # Custom middleware
-â”‚   â”‚   â”œâ”€â”€ auth.ts
-â”‚   â”‚   â”œâ”€â”€ errorHandler.ts
-â”‚   â”‚   â””â”€â”€ validation.ts
-â”‚   â”œâ”€â”€ services/           # Business logic
-â”‚   â””â”€â”€ utils/              # Utility functions
-â”‚       â””â”€â”€ database.ts
-â”œâ”€â”€ dist/                   # Compiled JavaScript (generated)
-â”œâ”€â”€ package.json
-â”œâ”€â”€ tsconfig.json
-â””â”€â”€ .env.example
-```
-
-## Security Features
-
-- **JWT Authentication**: Secure token-based auth
-- **Password Hashing**: bcrypt with salt rounds
-- **Rate Limiting**: Prevent API abuse
-- **CORS Protection**: Configured origins
-- **Helmet**: Security headers
-- **Input Validation**: Joi schema validation
-- **Role-based Access**: Admin/operator permissions
-
-## Socket.IO Real-time Features
-
-The backend includes Socket.IO for real-time updates:
-
-```javascript
-// Client connection
-const socket = io('http://localhost:5000');
-
-// Join room for updates
-socket.emit('join-room', 'events');
-
-// Listen for new events
-socket.on('new-event', (event) => {
-  console.log('New event:', event);
-});
-```
-
-## Troubleshooting
-
-### Common Issues
-
-**1. MongoDB connection failed:**
-```bash
-# Check MongoDB status
-sudo systemctl status mongod
-sudo systemctl start mongod
-
-# Check connection string in .env
-MONGODB_URI=mongodb://localhost:27017/event_monitoring
-```
-
-**2. TypeScript compilation errors:**
-```bash
-# Clean build
-rm -rf dist
-npm run build
-
-# Install missing types
-npm install --save-dev @types/missing-package
-```
-
-**3. JWT token issues:**
-```bash
-# Generate new secret
-node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
-# Update JWT_SECRET in .env
-```
-
-**4. Port already in use:**
-```bash
-# Kill process on port 5000
-sudo lsof -t -i:5000 | xargs kill -9
-# Or change port in .env
-PORT=5001
-```
-
-### Development Tips
-
-1. **Hot Reload**: Use `npm run dev` for automatic restarts
-2. **Logging**: Check terminal output for request logs
-3. **Database Inspection**: Use MongoDB Compass or `mongosh`
-4. **API Testing**: Use Postman, curl, or browser dev tools
-
-### Health Check
-
-Test if the backend is running:
-```bash
-curl http://localhost:5000/health
-```
-
-Expected response:
-```json
-{
-  "status": "OK",
-  "timestamp": "2025-12-12T...",
-  "service": "event-monitoring-backend"
-}
-```
-
-## Integration with Other Services
-
-### AI Service Integration
-The backend automatically receives events from the AI service at:
-```
-POST /api/events
-```
-
-### Frontend Integration
-Configure frontend to use this backend:
-```bash
-# In frontend/.env
-REACT_APP_API_URL=http://localhost:5000/api
-REACT_APP_SOCKET_URL=http://localhost:5000
-```
-
-## Production Deployment
-
-### Environment Variables
-```bash
-NODE_ENV=production
-PORT=5000
-MONGODB_URI=mongodb://prod-host:27017/event_monitoring
-JWT_SECRET=super-long-random-production-secret
-```
-
-### Process Management
-```bash
-# Using PM2
-npm install -g pm2
-pm2 start dist/app.js --name "event-monitoring-backend"
-
-# Using systemd
-sudo systemctl enable event-monitoring-backend
-sudo systemctl start event-monitoring-backend
+# Backend - Event Monitoring MVP
+
+Node.js/Express backend API providing authentication, camera management, event processing, and real-time communication for the Event Monitoring system.
+
+## ğŸš€ Quick Start
+
+### Prerequisites
+- **Node.js** 18+ and npm
+- **MongoDB** 6.0+ running locally or via Docker
+- **TypeScript** knowledge recommended
+
+### Development Setup
+
+1. **Install Dependencies**
+   ```bash
+   cd backend
+   npm install
+   ```
+
+2. **Environment Configuration**
+   ```bash
+   # Create environment file
+   cp .env.example .env
+   
+   # Configure your settings
+   nano .env
+   ```
+
+3. **Start MongoDB**
+   ```bash
+   # Option 1: Local MongoDB
+   mongod --dbpath ./data
+   
+   # Option 2: Docker MongoDB
+   docker run -d -p 27017:27017 --name mongodb mongo:latest
+   ```
+
+4. **Start Development Server**
+   ```bash
+   npm run dev
+   ```
+
+5. **Verify Setup**
+   - API available at: http://localhost:5000
+   - Health check: http://localhost:5000/api/health
+cd backend
+npm install
+```
+
+### 2. Environment Setup
+```bash
+# Copy the environment template
+cp .env.example .env
+
+# Edit the .env file with your configuration
+nano .env
+```
+
+### 3. Start Development Server
+```bash
+npm run dev
+```
+
+The backend API will be available at: http://localhost:5000
+
+## Environment Configuration
+
+Edit the `.env` file with these settings:
+
+```bash
+# Environment
+NODE_ENV=development
+PORT=5000
+
+# Database
+MONGODB_URI=mongodb://localhost:27017/event_monitoring
+
+# JWT Configuration
+JWT_SECRET=your-super-secret-jwt-key-change-in-production
+JWT_EXPIRES_IN=24h
+
+# External Services
+AI_SERVICE_URL=http://localhost:8000
+FRONTEND_URL=http://localhost:3000
+
+# Rate Limiting
+RATE_LIMIT_WINDOW_MS=900000
+RATE_LIMIT_MAX_REQUESTS=100
+
+# Video Streaming
+MAX_CAMERAS=5
+VIDEO_CHUNK_SIZE=1024
+
+# File Upload
+MAX_FILE_SIZE=10485760
+UPLOAD_PATH=./uploads
+```
+
+## Available Scripts
+
+### Development
+```bash
+npm run dev        # Start with hot reload (recommended)
+npm run build      # Build TypeScript to JavaScript
+npm start          # Start production server
+npm test           # Run tests
+npm run lint       # Run ESLint
+npm run lint:fix   # Fix ESLint issues
+```
+
+## Database Setup
+
+### MongoDB Installation
+```bash
+# Ubuntu/Debian
+sudo apt update
+sudo apt install mongodb
+
+# macOS with Homebrew
+brew tap mongodb/brew
+brew install mongodb-community
+
+# Start MongoDB
+sudo systemctl start mongod  # Linux
+brew services start mongodb/brew/mongodb-community  # macOS
+```
+
+### Initialize Database
+```bash
+# Import initial data (creates admin user)
+mongosh event_monitoring < ../docker/mongo-init.js
+```
+
+Default admin user:
+- **Email**: admin@example.com
+- **Password**: password123
+
+## API Documentation
+
+### Authentication Endpoints
+```bash
+# Login
+POST /api/auth/login
+{
+  "email": "admin@example.com",
+  "password": "password123"
+}
+
+# Register new user
+POST /api/auth/register
+{
+  "username": "operator1",
+  "email": "operator@example.com", 
+  "password": "password123",
+  "role": "operator"
+}
+
+# Get user profile
+GET /api/auth/profile
+Headers: Authorization: Bearer <jwt-token>
+```
+
+### Camera Endpoints
+```bash
+# List all cameras
+GET /api/cameras
+Headers: Authorization: Bearer <jwt-token>
+
+# Create new camera
+POST /api/cameras
+Headers: Authorization: Bearer <jwt-token>
+{
+  "name": "Front Gate Camera",
+  "description": "Main entrance monitoring",
+  "streamUrl": "rtsp://camera-ip:554/stream",
+  "location": {
+    "coordinates": [-74.0060, 40.7128],
+    "address": "123 Main St, New York, NY"
+  },
+  "type": "ip",
+  "settings": {
+    "resolution": "1920x1080",
+    "fps": 30,
+    "recordingEnabled": true
+  }
+}
+```
+
+### Event Endpoints
+```bash
+# List events with filtering
+GET /api/events?status=open&type=person_detected&page=1&limit=20
+Headers: Authorization: Bearer <jwt-token>
+
+# Create new event (usually from AI service)
+POST /api/events
+Headers: Authorization: Bearer <jwt-token>
+{
+  "title": "Person Detected",
+  "description": "AI detected person with 85% confidence",
+  "type": "person_detected",
+  "severity": "medium",
+  "cameraId": "camera-object-id",
+  "location": {
+    "coordinates": [-74.0060, 40.7128]
+  },
+  "detectionData": {
+    "confidence": 0.85,
+    "boundingBox": {"x": 100, "y": 150, "width": 200, "height": 300},
+    "objectCount": 1,
+    "aiModel": "YOLOv8"
+  }
+}
+```
+
+## Project Structure
+
+```
+backend/
+â”œâ”€â”€ src/
+â”‚   â”œâ”€â”€ app.ts              # Main application file
+â”‚   â”œâ”€â”€ controllers/        # Route handlers
+â”‚   â”‚   â”œâ”€â”€ authController.ts
+â”‚   â”‚   â”œâ”€â”€ cameraController.ts
+â”‚   â”‚   â”œâ”€â”€ eventController.ts
+â”‚   â”‚   â””â”€â”€ userController.ts
+â”‚   â”œâ”€â”€ models/             # MongoDB schemas
+â”‚   â”‚   â”œâ”€â”€ User.ts
+â”‚   â”‚   â”œâ”€â”€ Camera.ts
+â”‚   â”‚   â””â”€â”€ Event.ts
+â”‚   â”œâ”€â”€ routes/             # API route definitions
+â”‚   â”‚   â”œâ”€â”€ auth.ts
+â”‚   â”‚   â”œâ”€â”€ cameras.ts
+â”‚   â”‚   â”œâ”€â”€ events.ts
+â”‚   â”‚   â””â”€â”€ users.ts
+â”‚   â”œâ”€â”€ middleware/         # Custom middleware
+â”‚   â”‚   â”œâ”€â”€ auth.ts
+â”‚   â”‚   â”œâ”€â”€ errorHandler.ts
+â”‚   â”‚   â””â”€â”€ validation.ts
+â”‚   â”œâ”€â”€ services/           # Business logic
+â”‚   â””â”€â”€ utils/              # Utility functions
+â”‚       â””â”€â”€ database.ts
+â”œâ”€â”€ dist/                   # Compiled JavaScript (generated)
+â”œâ”€â”€ package.json
+â”œâ”€â”€ tsconfig.json
+â””â”€â”€ .env.example
+```
+
+## Security Features
+
+- **JWT Authentication**: Secure token-based auth
+- **Password Hashing**: bcrypt with salt rounds
+- **Rate Limiting**: Prevent API abuse
+- **CORS Protection**: Configured origins
+- **Helmet**: Security headers
+- **Input Validation**: Joi schema validation
+- **Role-based Access**: Admin/operator permissions
+
+## Socket.IO Real-time Features
+
+The backend includes Socket.IO for real-time updates:
+
+```javascript
+// Client connection
+const socket = io('http://localhost:5000');
+
+// Join room for updates
+socket.emit('join-room', 'events');
+
+// Listen for new events
+socket.on('new-event', (event) => {
+  console.log('New event:', event);
+});
+```
+
+## Troubleshooting
+
+### Common Issues
+
+**1. MongoDB connection failed:**
+```bash
+# Check MongoDB status
+sudo systemctl status mongod
+sudo systemctl start mongod
+
+# Check connection string in .env
+MONGODB_URI=mongodb://localhost:27017/event_monitoring
+```
+
+**2. TypeScript compilation errors:**
+```bash
+# Clean build
+rm -rf dist
+npm run build
+
+# Install missing types
+npm install --save-dev @types/missing-package
+```
+
+**3. JWT token issues:**
+```bash
+# Generate new secret
+node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
+# Update JWT_SECRET in .env
+```
+
+**4. Port already in use:**
+```bash
+# Kill process on port 5000
+sudo lsof -t -i:5000 | xargs kill -9
+# Or change port in .env
+PORT=5001
+```
+
+### Development Tips
+
+1. **Hot Reload**: Use `npm run dev` for automatic restarts
+2. **Logging**: Check terminal output for request logs
+3. **Database Inspection**: Use MongoDB Compass or `mongosh`
+4. **API Testing**: Use Postman, curl, or browser dev tools
+
+### Health Check
+
+Test if the backend is running:
+```bash
+curl http://localhost:5000/health
+```
+
+Expected response:
+```json
+{
+  "status": "OK",
+  "timestamp": "2025-12-12T...",
+  "service": "event-monitoring-backend"
+}
+```
+
+## Integration with Other Services
+
+### AI Service Integration
+The backend automatically receives events from the AI service at:
+```
+POST /api/events
+```
+
+### Frontend Integration
+Configure frontend to use this backend:
+```bash
+# In frontend/.env
+REACT_APP_API_URL=http://localhost:5000/api
+REACT_APP_SOCKET_URL=http://localhost:5000
+```
+
+## Production Deployment
+
+### Environment Variables
+```bash
+NODE_ENV=production
+PORT=5000
+MONGODB_URI=mongodb://prod-host:27017/event_monitoring
+JWT_SECRET=super-long-random-production-secret
+```
+
+### Process Management
+```bash
+# Using PM2
+npm install -g pm2
+pm2 start dist/app.js --name "event-monitoring-backend"
+
+# Using systemd
+sudo systemctl enable event-monitoring-backend
+sudo systemctl start event-monitoring-backend
 ```
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/docs/MOBILE_API.md b/event-monitoring-mvp/backend/docs/MOBILE_API.md
new file mode 100644
index 0000000..bfba1bf
--- /dev/null
+++ b/event-monitoring-mvp/backend/docs/MOBILE_API.md
@@ -0,0 +1,679 @@
+# Mobile App Integration API Documentation
+
+This document describes the APIs available for mobile app integration with the Event Monitoring Platform.
+
+---
+
+## Table of Contents
+
+1. [Authentication](#authentication)
+2. [Base URL](#base-url)
+3. [Endpoints](#endpoints)
+   - [Validate Company API Key](#1-validate-company-api-key)
+   - [Verify First Responder](#2-verify-first-responder)
+   - [Get Event Types](#3-get-event-types)
+   - [Submit Report](#4-submit-report)
+   - [Get My Reports](#5-get-my-reports)
+   - [Get Report by ID](#6-get-report-by-id)
+4. [Error Codes](#error-codes)
+5. [Integration Flows](#integration-flows)
+
+---
+
+## Authentication
+
+All API requests require authentication using an API Key provided by the WEB team.
+
+### Required Headers
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your unique company API key |
+| `Content-Type` | Yes (for POST) | `application/json` |
+
+### Example Headers
+
+```
+X-API-Key: your_company_api_key_here
+Content-Type: application/json
+```
+
+---
+
+## Base URL
+
+```
+Development: http://localhost:5000/api/mobile
+Production:  https://api.yourserver.com/api/mobile
+```
+
+---
+
+## Endpoints
+
+### 1. Validate Company API Key
+
+Validates that your API credentials are correct. Use this to verify your integration is working.
+
+**Endpoint:** `POST /api/mobile/auth/company-validate`
+
+**Headers:**
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your company API key |
+
+**Request Body:** None required
+
+**Success Response (200):**
+
+```json
+{
+  "valid": true,
+  "company": {
+    "id": "company_001",
+    "name": "Demo Company",
+    "settings": {}
+  }
+}
+```
+
+**Error Response (401):**
+
+```json
+{
+  "success": false,
+  "message": "Missing X-API-Key header"
+}
+```
+
+**cURL Example:**
+
+```bash
+curl -X POST http://localhost:5000/api/mobile/auth/company-validate \
+  -H "X-API-Key: your_api_key"
+```
+
+**JavaScript Example:**
+
+```javascript
+const response = await fetch('http://localhost:5000/api/mobile/auth/company-validate', {
+  method: 'POST',
+  headers: {
+    'X-API-Key': 'your_api_key'
+  }
+});
+
+const data = await response.json();
+console.log(data);
+// { valid: true, company: { id: "company_001", name: "Demo Company" } }
+```
+
+---
+
+### 2. Verify First Responder
+
+Checks if a phone number belongs to a registered First Responder in our system.
+
+**Use Case:** When a user logs in to your app, first check your own database. If user not found, call this API to check if they are a First Responder managed by our system.
+
+**Endpoint:** `POST /api/mobile/auth/verify-fr`
+
+**Headers:**
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your company API key |
+| `Content-Type` | Yes | `application/json` |
+
+**Request Body:**
+
+| Field | Type | Required | Description |
+|-------|------|----------|-------------|
+| `phone` | string | Yes | Phone number with country code |
+
+**Request Example:**
+
+```json
+{
+  "phone": "+972-50-123-4567"
+}
+```
+
+**Success Response - FR Found (200):**
+
+```json
+{
+  "isFR": true,
+  "frId": "fr_001",
+  "name": "David Cohen",
+  "role": "Paramedic"
+}
+```
+
+**Success Response - FR Not Found (200):**
+
+```json
+{
+  "isFR": false
+}
+```
+
+**Error Response (400):**
+
+```json
+{
+  "success": false,
+  "message": "Phone number is required"
+}
+```
+
+**cURL Example:**
+
+```bash
+curl -X POST http://localhost:5000/api/mobile/auth/verify-fr \
+  -H "X-API-Key: your_api_key" \
+  -H "Content-Type: application/json" \
+  -d '{"phone": "+972-50-123-4567"}'
+```
+
+**JavaScript Example:**
+
+```javascript
+const response = await fetch('http://localhost:5000/api/mobile/auth/verify-fr', {
+  method: 'POST',
+  headers: {
+    'X-API-Key': 'your_api_key',
+    'Content-Type': 'application/json'
+  },
+  body: JSON.stringify({
+    phone: '+972-50-123-4567'
+  })
+});
+
+const data = await response.json();
+
+if (data.isFR) {
+  console.log(`First Responder: ${data.name}, Role: ${data.role}`);
+} else {
+  console.log('Not a First Responder');
+}
+```
+
+---
+
+### 3. Get Event Types
+
+Returns available event types for report submission. Use this to populate dropdown menus in your app.
+
+**Endpoint:** `GET /api/mobile/event-types`
+
+**Headers:**
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your company API key |
+
+**Request Body:** None
+
+**Success Response (200):**
+
+```json
+{
+  "eventTypes": [
+    { "id": "et_001", "name": "Fire", "severity": "critical" },
+    { "id": "et_002", "name": "Medical Emergency", "severity": "high" },
+    { "id": "et_003", "name": "Security Incident", "severity": "medium" },
+    { "id": "et_004", "name": "Traffic Accident", "severity": "high" },
+    { "id": "et_005", "name": "Suspicious Activity", "severity": "low" }
+  ]
+}
+```
+
+**cURL Example:**
+
+```bash
+curl -X GET http://localhost:5000/api/mobile/event-types \
+  -H "X-API-Key: your_api_key"
+```
+
+**JavaScript Example:**
+
+```javascript
+const response = await fetch('http://localhost:5000/api/mobile/event-types', {
+  method: 'GET',
+  headers: {
+    'X-API-Key': 'your_api_key'
+  }
+});
+
+const data = await response.json();
+console.log(data.eventTypes);
+// Use to populate dropdown in your app
+```
+
+---
+
+### 4. Submit Report
+
+Submits an incident report from the mobile app. The system automatically identifies the reporter as First Responder (FR) or Civilian based on their phone number.
+
+**Endpoint:** `POST /api/mobile/reports`
+
+**Headers:**
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your company API key |
+| `Content-Type` | Yes | `application/json` |
+
+**Request Body:**
+
+| Field | Type | Required | Description |
+|-------|------|----------|-------------|
+| `phone` | string | Yes | Reporter's phone number |
+| `type` | string | Yes | Event type (English only) |
+| `subType` | string | No | Event sub-type (English only) |
+| `severity` | string | Yes | Severity level (English only) |
+| `description` | string | No | Description of the incident |
+| `location` | object | Yes | GPS coordinates |
+| `location.latitude` | number | Yes | Latitude (-90 to 90) |
+| `location.longitude` | number | Yes | Longitude (-180 to 180) |
+| `media` | object | No | Attached media files |
+| `media.images` | string[] | No | Array of image URLs |
+| `media.videos` | string[] | No | Array of video URLs |
+
+**Taxonomy Values (type, subType, severity):**
+
+- Send values as English strings
+- If you send an unknown value, our system will auto-add it (no error)
+- Common examples:
+
+| Field | Example Values |
+|-------|----------------|
+| `type` | `Fire`, `Medical Emergency`, `Security Incident`, `Traffic Accident` |
+| `subType` | `Building Fire`, `Car Accident`, `Theft`, `Assault` |
+| `severity` | `low`, `medium`, `high`, `critical`, `emergency` |
+
+**Request Example:**
+
+```json
+{
+  "phone": "+972-50-123-4567",
+  "type": "Fire",
+  "subType": "Building Fire",
+  "severity": "critical",
+  "description": "Smoke coming from 3rd floor window",
+  "location": {
+    "latitude": 32.0853,
+    "longitude": 34.7818
+  },
+  "media": {
+    "images": [
+      "https://storage.example.com/img1.jpg",
+      "https://storage.example.com/img2.jpg"
+    ],
+    "videos": []
+  }
+}
+```
+
+**Success Response (201):**
+
+```json
+{
+  "success": true,
+  "reportId": "rpt_1703520000000",
+  "reporterType": "FR"
+}
+```
+
+| Field | Description |
+|-------|-------------|
+| `success` | `true` if report was saved |
+| `reportId` | Unique ID for this report |
+| `reporterType` | `"FR"` (First Responder) or `"CIVILIAN"` |
+
+**Error Response (400):**
+
+```json
+{
+  "success": false,
+  "message": "Missing required fields: phone, type, and location are required"
+}
+```
+
+**cURL Example:**
+
+```bash
+curl -X POST http://localhost:5000/api/mobile/reports \
+  -H "X-API-Key: your_api_key" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "phone": "+972-50-123-4567",
+    "type": "Fire",
+    "subType": "Building Fire",
+    "severity": "critical",
+    "description": "Smoke coming from 3rd floor window",
+    "location": {
+      "latitude": 32.0853,
+      "longitude": 34.7818
+    }
+  }'
+```
+
+**JavaScript Example:**
+
+```javascript
+const report = {
+  phone: '+972-50-123-4567',
+  type: 'Fire',
+  subType: 'Building Fire',
+  severity: 'critical',
+  description: 'Smoke coming from 3rd floor window',
+  location: {
+    latitude: 32.0853,
+    longitude: 34.7818
+  },
+  media: {
+    images: ['https://storage.example.com/img1.jpg'],
+    videos: []
+  }
+};
+
+const response = await fetch('http://localhost:5000/api/mobile/reports', {
+  method: 'POST',
+  headers: {
+    'X-API-Key': 'your_api_key',
+    'Content-Type': 'application/json'
+  },
+  body: JSON.stringify(report)
+});
+
+const data = await response.json();
+
+if (data.success) {
+  console.log(`Report created: ${data.reportId}`);
+  console.log(`Reporter type: ${data.reporterType}`);
+} else {
+  console.error(`Error: ${data.message}`);
+}
+```
+
+---
+
+### 5. Get My Reports
+
+Returns the user's own submitted reports with optional filtering and pagination.
+
+**Endpoint:** `GET /api/mobile/reports/my`
+
+**Headers:**
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your company API key |
+
+**Query Parameters:**
+
+| Parameter | Type | Required | Description |
+|-----------|------|----------|-------------|
+| `date` | string | No | Filter by date (YYYY-MM-DD) |
+| `status` | string | No | Filter by status (pending, acknowledged, resolved, etc.) |
+| `type` | string | No | Filter by event type |
+| `severity` | string | No | Filter by severity |
+| `limit` | number | No | Number of results (default: 50) |
+| `offset` | number | No | Offset for pagination (default: 0) |
+
+**Request Example:**
+
+```
+GET /api/mobile/reports/my?status=pending&severity=high&limit=20
+```
+
+**Success Response (200):**
+
+```json
+{
+  "reports": [
+    {
+      "id": "rpt_001",
+      "type": "Fire",
+      "subType": "Building Fire",
+      "severity": "critical",
+      "status": "pending",
+      "description": "Smoke coming from building",
+      "location": {
+        "latitude": 32.0853,
+        "longitude": 34.7818
+      },
+      "createdAt": "2024-12-26T10:30:00.000Z"
+    },
+    {
+      "id": "rpt_002",
+      "type": "Medical Emergency",
+      "severity": "high",
+      "status": "acknowledged",
+      "description": "Person collapsed on street",
+      "location": {
+        "latitude": 32.0900,
+        "longitude": 34.7750
+      },
+      "createdAt": "2024-12-26T09:30:00.000Z"
+    }
+  ],
+  "pagination": {
+    "total": 2,
+    "limit": 50,
+    "offset": 0,
+    "hasMore": false
+  }
+}
+```
+
+**cURL Example:**
+
+```bash
+curl -X GET "http://localhost:5000/api/mobile/reports/my?status=pending&limit=20" \
+  -H "X-API-Key: your_api_key"
+```
+
+**JavaScript Example:**
+
+```javascript
+const params = new URLSearchParams({
+  status: 'pending',
+  limit: '20'
+});
+
+const response = await fetch(`http://localhost:5000/api/mobile/reports/my?${params}`, {
+  method: 'GET',
+  headers: {
+    'X-API-Key': 'your_api_key'
+  }
+});
+
+const data = await response.json();
+console.log(`Found ${data.pagination.total} reports`);
+data.reports.forEach(report => {
+  console.log(`${report.id}: ${report.type} - ${report.status}`);
+});
+```
+
+---
+
+### 6. Get Report by ID
+
+Returns detailed information for a specific report. Users can only view their own reports.
+
+**Endpoint:** `GET /api/mobile/reports/:id`
+
+**Headers:**
+
+| Header | Required | Description |
+|--------|----------|-------------|
+| `X-API-Key` | Yes | Your company API key |
+
+**URL Parameters:**
+
+| Parameter | Type | Required | Description |
+|-----------|------|----------|-------------|
+| `id` | string | Yes | The report ID |
+
+**Success Response (200):**
+
+```json
+{
+  "report": {
+    "id": "rpt_001",
+    "type": "Fire",
+    "subType": "Building Fire",
+    "severity": "critical",
+    "status": "pending",
+    "description": "Smoke coming from building on 3rd floor",
+    "location": {
+      "latitude": 32.0853,
+      "longitude": 34.7818
+    },
+    "media": {
+      "images": ["https://example.com/img1.jpg"],
+      "videos": []
+    },
+    "reporterType": "FR",
+    "createdAt": "2024-12-26T10:30:00.000Z",
+    "updatedAt": "2024-12-26T10:30:00.000Z"
+  }
+}
+```
+
+**Error Response (400):**
+
+```json
+{
+  "success": false,
+  "message": "Report ID is required"
+}
+```
+
+**Error Response (404):**
+
+```json
+{
+  "success": false,
+  "message": "Report not found"
+}
+```
+
+**cURL Example:**
+
+```bash
+curl -X GET http://localhost:5000/api/mobile/reports/rpt_001 \
+  -H "X-API-Key: your_api_key"
+```
+
+**JavaScript Example:**
+
+```javascript
+const reportId = 'rpt_001';
+
+const response = await fetch(`http://localhost:5000/api/mobile/reports/${reportId}`, {
+  method: 'GET',
+  headers: {
+    'X-API-Key': 'your_api_key'
+  }
+});
+
+const data = await response.json();
+console.log(data.report);
+```
+
+---
+
+## Error Codes
+
+| Code | Meaning | When It Happens |
+|------|---------|-----------------|
+| `200` | Success | Request completed successfully |
+| `201` | Created | Report was created successfully |
+| `400` | Bad Request | Missing or invalid fields in request body |
+| `401` | Unauthorized | Missing or invalid API key |
+| `403` | Forbidden | User doesn't have permission to access resource |
+| `404` | Not Found | Resource not found |
+| `500` | Server Error | Internal server error |
+
+### Common Error Responses
+
+**Missing API Key (401):**
+
+```json
+{
+  "success": false,
+  "message": "Missing X-API-Key header"
+}
+```
+
+**Invalid API Key (401):**
+
+```json
+{
+  "success": false,
+  "message": "Invalid API key"
+}
+```
+
+**Missing Required Fields (400):**
+
+```json
+{
+  "success": false,
+  "message": "Missing required fields: phone, type, and location are required"
+}
+```
+
+---
+
+## Integration Flows
+
+### Login Flow
+
+```
+1. User enters phone number in your app
+2. Check your own database for the user
+3. If NOT found â†’ Call POST /api/mobile/auth/verify-fr
+4. If isFR: true â†’ User is a First Responder, show FR features
+5. If isFR: false â†’ User is a Civilian, show civilian features
+```
+
+### Report Submission Flow
+
+```
+1. User fills out incident report in your app
+2. Get GPS location from device
+3. Upload any media to your storage (get URLs)
+4. Call POST /api/mobile/reports with all data
+5. Save the reportId for reference
+6. Show confirmation to user with reportId
+```
+
+### Viewing Reports Flow
+
+```
+1. Call GET /api/mobile/reports/my to get list
+2. Display reports in a list view
+3. User taps on a report â†’ Call GET /api/mobile/reports/:id
+4. Display full report details
+```
+
+---
+
+## Support
+
+For API key requests or technical issues, contact the WEB team.
+
+---
+
+## Changelog
+
+| Version | Date | Changes |
+|---------|------|---------|
+| 1.0.0 | 2024-12-26 | Initial API documentation (DEV-14) |
diff --git a/event-monitoring-mvp/backend/package.json b/event-monitoring-mvp/backend/package.json
index 6740abf..f67e92c 100644
--- a/event-monitoring-mvp/backend/package.json
+++ b/event-monitoring-mvp/backend/package.json
@@ -1,61 +1,62 @@
-{
-  "name": "event-monitoring-backend",
-  "version": "1.0.0",
-  "description": "Backend API for Event Monitoring MVP",
-  "main": "dist/app.js",
-  "scripts": {
-    "build": "tsc",
-    "start": "node dist/app.js",
-    "dev": "ts-node-dev --respawn --transpile-only src/app.ts",
-    "test": "jest",
-    "lint": "eslint src/**/*.ts",
-    "lint:fix": "eslint src/**/*.ts --fix"
-  },
-  "keywords": [
-    "event-monitoring",
-    "security",
-    "ai",
-    "video-analytics"
-  ],
-  "author": "Your Team",
-  "license": "MIT",
-  "dependencies": {
-    "bcryptjs": "^2.4.3",
-    "compression": "^1.7.4",
-    "cors": "^2.8.5",
-    "dotenv": "^16.0.3",
-    "express": "^4.18.2",
-    "express-rate-limit": "^6.7.0",
-    "express-validator": "^7.3.1",
-    "helmet": "^6.1.5",
-    "joi": "^17.9.1",
-    "jsonwebtoken": "^9.0.0",
-    "mongoose": "^7.0.3",
-    "morgan": "^1.10.0",
-    "multer": "^1.4.5-lts.1",
-    "socket.io": "^4.6.1"
-  },
-  "devDependencies": {
-    "@types/bcryptjs": "^2.4.2",
-    "@types/compression": "^1.7.2",
-    "@types/cors": "^2.8.13",
-    "@types/express": "^4.17.17",
-    "@types/express-validator": "^2.20.33",
-    "@types/jest": "^29.5.0",
-    "@types/jsonwebtoken": "^9.0.1",
-    "@types/morgan": "^1.9.4",
-    "@types/multer": "^1.4.7",
-    "@types/node": "^18.15.11",
-    "@typescript-eslint/eslint-plugin": "^5.57.1",
-    "@typescript-eslint/parser": "^5.57.1",
-    "eslint": "^8.37.0",
-    "jest": "^29.5.0",
-    "ts-jest": "^29.1.0",
-    "ts-node-dev": "^2.0.0",
-    "typescript": "^5.0.2"
-  },
-  "engines": {
-    "node": ">=18.0.0",
-    "npm": ">=8.0.0"
-  }
-}
+{
+  "name": "event-monitoring-backend",
+  "version": "1.0.0",
+  "description": "Backend API for Event Monitoring MVP",
+  "main": "dist/app.js",
+  "scripts": {
+    "build": "tsc",
+    "start": "node dist/app.js",
+    "dev": "ts-node-dev --respawn --transpile-only src/app.ts",
+    "test": "jest",
+    "lint": "eslint src/**/*.ts",
+    "lint:fix": "eslint src/**/*.ts --fix"
+  },
+  "keywords": [
+    "event-monitoring",
+    "security",
+    "ai",
+    "video-analytics"
+  ],
+  "author": "Your Team",
+  "license": "MIT",
+  "dependencies": {
+    "@types/validator": "^13.15.10",
+    "bcryptjs": "^2.4.3",
+    "compression": "^1.7.4",
+    "cors": "^2.8.5",
+    "dotenv": "^16.0.3",
+    "express": "^4.18.2",
+    "express-rate-limit": "^6.7.0",
+    "express-validator": "^7.3.1",
+    "helmet": "^6.1.5",
+    "joi": "^17.9.1",
+    "jsonwebtoken": "^9.0.0",
+    "mongoose": "^7.0.3",
+    "morgan": "^1.10.0",
+    "multer": "^1.4.5-lts.1",
+    "socket.io": "^4.6.1",
+    "validator": "^13.15.26"
+  },
+  "devDependencies": {
+    "@types/bcryptjs": "^2.4.2",
+    "@types/compression": "^1.7.2",
+    "@types/cors": "^2.8.13",
+    "@types/express": "^4.17.17",
+    "@types/jest": "^29.5.0",
+    "@types/jsonwebtoken": "^9.0.1",
+    "@types/morgan": "^1.9.4",
+    "@types/multer": "^1.4.7",
+    "@types/node": "^18.15.11",
+    "@typescript-eslint/eslint-plugin": "^5.57.1",
+    "@typescript-eslint/parser": "^5.57.1",
+    "eslint": "^8.37.0",
+    "jest": "^29.5.0",
+    "ts-jest": "^29.1.0",
+    "ts-node-dev": "^2.0.0",
+    "typescript": "^5.0.2"
+  },
+  "engines": {
+    "node": ">=18.0.0",
+    "npm": ">=8.0.0"
+  }
+}
diff --git a/event-monitoring-mvp/backend/src/app.ts b/event-monitoring-mvp/backend/src/app.ts
index 16bc592..4567bc4 100644
--- a/event-monitoring-mvp/backend/src/app.ts
+++ b/event-monitoring-mvp/backend/src/app.ts
@@ -1,184 +1,213 @@
-/**
- * Event Monitoring System - Backend Server
- * 
- * This is the main Express.js application server for the Event Monitoring MVP.
- * It provides RESTful APIs for authentication, camera management, event handling,
- * and user management, along with real-time WebSocket communication.
- * 
- * Features:
- * - RESTful API endpoints for all core functionality
- * - Real-time WebSocket communication via Socket.IO
- * - JWT-based authentication and authorization
- * - Rate limiting and security middleware
- * - MongoDB database integration
- * - Comprehensive error handling
- * - Request logging and monitoring
- */
+/**
+ * Event Monitoring System - Backend Server
+ * 
+ * This is the main Express.js application server for the Event Monitoring MVP.
+ * It provides RESTful APIs for authentication, camera management, event handling,
+ * and user management, along with real-time WebSocket communication.
+ * 
+ * Features:
+ * - RESTful API endpoints for all core functionality
+ * - Real-time WebSocket communication via Socket.IO
+ * - JWT-based authentication and authorization
+ * - Rate limiting and security middleware
+ * - MongoDB database integration
+ * - Comprehensive error handling
+ * - Request logging and monitoring
+ */
+
+import express from 'express';
+import cors from 'cors';
+import helmet from 'helmet';
+import morgan from 'morgan';
+import compression from 'compression';
+import rateLimit from 'express-rate-limit';
+import { createServer } from 'http';
+import { Server } from 'socket.io';
+import dotenv from 'dotenv';
+
+// Import database connection utility
+import { connectDB } from './utils/database';
+
+// Import middleware
+import { errorHandler } from './middleware/errorHandler';
+
+// Import route handlers
+import authRoutes from './routes/auth';
+import cameraRoutes from './routes/cameras';
+import eventRoutes from './routes/events';
+import userRoutes from './routes/users';
+import aiDetectionRoutes from './routes/aiDetections';
+import vmsRoutes from './routes/vms'; // VMS server registry + future cameraâ†”VMS integration endpoints
+
+
+// Load environment variables from .env file
+dotenv.config();
+
+// Create Express application instance
+const app = express();
+
+// Create HTTP server for both Express and Socket.IO
+const server = createServer(app);
+
+// Initialize Socket.IO for real-time communication
+const io = new Server(server, {
+  cors: {
+    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
+    methods: ['GET', 'POST']
+  }
+});
+
+// Connect to MongoDB database
+connectDB();
+
+/**
+ * Rate Limiting Configuration
+ * Protects against DoS attacks and abuse by limiting request frequency
+ */
+const limiter = rateLimit({
+  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000'), // 15 minutes default
+  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100'),     // 100 requests per window
+  message: 'Too many requests from this IP, please try again later.',
+  standardHeaders: true,  // Return rate limit info in headers
+  legacyHeaders: false,   // Disable legacy headers
+});
+
+/**
+ * Security and Performance Middleware Stack
+ */
+app.use(helmet());         // Security headers protection
+// TEST-ONLY: Relax CORS in non-production to avoid dev network errors.
+const allowedOrigins = [
+  process.env.FRONTEND_URL,
+  'http://localhost:3000',
+  'http://127.0.0.1:3000',
+  'http://localhost:5173',
+  'http://127.0.0.1:5173',
+].filter(Boolean);
+
+const isProd = process.env.NODE_ENV === 'production';
 
-import express from 'express';
-import cors from 'cors';
-import helmet from 'helmet';
-import morgan from 'morgan';
-import compression from 'compression';
-import rateLimit from 'express-rate-limit';
-import { createServer } from 'http';
-import { Server } from 'socket.io';
-import dotenv from 'dotenv';
-
-// Import database connection utility
-import { connectDB } from './utils/database';
-
-// Import middleware
-import { errorHandler } from './middleware/errorHandler';
-
-// Import route handlers
-import authRoutes from './routes/auth';
-import cameraRoutes from './routes/cameras';
-import eventRoutes from './routes/events';
-import userRoutes from './routes/users';
-import aiDetectionRoutes from './routes/aiDetections';
-
-// Load environment variables from .env file
-dotenv.config();
-
-// Create Express application instance
-const app = express();
-
-// Create HTTP server for both Express and Socket.IO
-const server = createServer(app);
-
-// Initialize Socket.IO for real-time communication
-const io = new Server(server, {
-  cors: {
-    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
-    methods: ['GET', 'POST']
-  }
-});
+app.use(cors({             // Cross-Origin Resource Sharing configuration
+  origin: (origin, callback) => {
+    if (!origin) {
+      return callback(null, true);
+    }
 
-// Connect to MongoDB database
-connectDB();
+    if (!isProd) {
+      return callback(null, true);
+    }
 
-/**
- * Rate Limiting Configuration
- * Protects against DoS attacks and abuse by limiting request frequency
- */
-const limiter = rateLimit({
-  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000'), // 15 minutes default
-  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100'),     // 100 requests per window
-  message: 'Too many requests from this IP, please try again later.',
-  standardHeaders: true,  // Return rate limit info in headers
-  legacyHeaders: false,   // Disable legacy headers
-});
+    if (allowedOrigins.includes(origin)) {
+      return callback(null, true);
+    }
 
-/**
- * Security and Performance Middleware Stack
- */
-app.use(helmet());         // Security headers protection
-app.use(cors({             // Cross-Origin Resource Sharing configuration
-  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
+    return callback(new Error(`CORS blocked for origin: ${origin}`));
+  },
   credentials: true        // Allow credentials (cookies, authorization headers)
 }));
-app.use(compression());    // Gzip compression for responses
-app.use(morgan('combined')); // HTTP request logging in Apache format
-app.use(limiter);          // Apply rate limiting
-app.use(express.json({ limit: '10mb' }));                        // Parse JSON bodies (10MB limit)
-app.use(express.urlencoded({ extended: true, limit: '10mb' }));  // Parse URL-encoded bodies
-
-/**
- * Health Check Endpoint
- * Provides a simple endpoint to check if the service is running
- * Used by load balancers and monitoring systems
- */
-app.get('/health', (req, res) => {
-  res.status(200).json({ 
-    status: 'OK', 
-    timestamp: new Date().toISOString(),
-    service: 'event-monitoring-backend',
-    version: process.env.npm_package_version || '1.0.0'
-  });
-});
-
-/**
- * API Route Handlers
- * Mount all API routes under their respective prefixes
- */
-app.use('/api/auth', authRoutes);           // Authentication and authorization routes
-app.use('/api/cameras', cameraRoutes);      // Camera management routes  
-app.use('/api/events', eventRoutes);        // Event management routes
-app.use('/api/users', userRoutes);          // User management routes
-app.use('/api/detections', aiDetectionRoutes); // AI detection management routes
-
-/**
- * Socket.IO Real-Time Communication Setup
- * Handles WebSocket connections for real-time features like:
- * - Live event notifications
- * - Real-time camera status updates  
- * - Live video stream coordination
- */
-io.on('connection', (socket) => {
-  console.log(`ğŸ”Œ WebSocket client connected: ${socket.id}`);
-
-  // Handle joining specific rooms for targeted updates
-  socket.on('join-room', (room) => {
-    socket.join(room);
-    console.log(`ğŸ“¡ Client ${socket.id} joined room: ${room}`);
-  });
-
-  // Handle leaving rooms
-  socket.on('leave-room', (room) => {
-    socket.leave(room);
-    console.log(`ğŸ“´ Client ${socket.id} left room: ${room}`);
-  });
-
-  // Handle client disconnection
-  socket.on('disconnect', () => {
-    console.log(`âŒ WebSocket client disconnected: ${socket.id}`);
-  });
-});
-
-/**
- * Make Socket.IO instance accessible to other modules
- * This allows controllers and services to emit real-time updates
- */
-app.set('io', io);
-
-/**
- * Error Handling Middleware
- * Must be registered after all routes and middleware
- * Catches and processes any unhandled errors
- */
-app.use(errorHandler);
-
-/**
- * 404 Not Found Handler
- * Catches all requests to undefined routes
- * Must be the last middleware
- */
-app.use('*', (req, res) => {
-  res.status(404).json({ 
-    success: false,
-    message: 'Route not found',
-    path: req.originalUrl 
-  });
-});
-
-/**
- * Server Configuration and Startup
- */
-const PORT = process.env.PORT || 5000;
-
-// Start the HTTP server with Socket.IO support
-server.listen(PORT, () => {
-  console.log('ğŸš€ Event Monitoring System Backend Started');
-  console.log(`ğŸ“¡ Server running on port ${PORT}`);
-  console.log(`ğŸ”— API endpoints: http://localhost:${PORT}/api`);
-  console.log(`ğŸ“Š Health check: http://localhost:${PORT}/health`);
-  console.log(`âš¡ WebSocket server ready for real-time connections`);
-  console.log(`ğŸ—„ï¸ MongoDB connection: ${process.env.NODE_ENV === 'production' ? 'Production DB' : 'Development DB'}`);
-});
-
-/**
- * Export Socket.IO instance for use in other modules
- * This allows other parts of the application to emit real-time events
- */
-export { io };
\ No newline at end of file
+app.use(compression());    // Gzip compression for responses
+app.use(morgan('combined')); // HTTP request logging in Apache format
+app.use(limiter);          // Apply rate limiting
+app.use(express.json({ limit: '10mb' }));                        // Parse JSON bodies (10MB limit)
+app.use(express.urlencoded({ extended: true, limit: '10mb' }));  // Parse URL-encoded bodies
+
+/**
+ * Health Check Endpoint
+ * Provides a simple endpoint to check if the service is running
+ * Used by load balancers and monitoring systems
+ */
+app.get('/health', (req, res) => {
+  res.status(200).json({ 
+    status: 'OK', 
+    timestamp: new Date().toISOString(),
+    service: 'event-monitoring-backend',
+    version: process.env.npm_package_version || '1.0.0'
+  });
+});
+
+/**
+ * API Route Handlers
+ * Mount all API routes under their respective prefixes
+ */
+app.use('/api/auth', authRoutes);           // Authentication and authorization routes
+app.use('/api/cameras', cameraRoutes);      // Camera management routes  
+app.use('/api/events', eventRoutes);        // Event management routes
+app.use('/api/users', userRoutes);          // User management routes
+app.use('/api/detections', aiDetectionRoutes); // AI detection management routes
+app.use('/api/vms', vmsRoutes);             // VMS server management + VMS integration routes
+
+
+/**
+ * Socket.IO Real-Time Communication Setup
+ * Handles WebSocket connections for real-time features like:
+ * - Live event notifications
+ * - Real-time camera status updates  
+ * - Live video stream coordination
+ */
+io.on('connection', (socket) => {
+  console.log(`ğŸ”Œ WebSocket client connected: ${socket.id}`);
+
+  // Handle joining specific rooms for targeted updates
+  socket.on('join-room', (room) => {
+    socket.join(room);
+    console.log(`ğŸ“¡ Client ${socket.id} joined room: ${room}`);
+  });
+
+  // Handle leaving rooms
+  socket.on('leave-room', (room) => {
+    socket.leave(room);
+    console.log(`ğŸ“´ Client ${socket.id} left room: ${room}`);
+  });
+
+  // Handle client disconnection
+  socket.on('disconnect', () => {
+    console.log(`âŒ WebSocket client disconnected: ${socket.id}`);
+  });
+});
+
+/**
+ * Make Socket.IO instance accessible to other modules
+ * This allows controllers and services to emit real-time updates
+ */
+app.set('io', io);
+
+/**
+ * Error Handling Middleware
+ * Must be registered after all routes and middleware
+ * Catches and processes any unhandled errors
+ */
+app.use(errorHandler);
+
+/**
+ * 404 Not Found Handler
+ * Catches all requests to undefined routes
+ * Must be the last middleware
+ */
+app.use('*', (req, res) => {
+  res.status(404).json({ 
+    success: false,
+    message: 'Route not found',
+    path: req.originalUrl 
+  });
+});
+
+/**
+ * Server Configuration and Startup
+ */
+const PORT = process.env.PORT || 5000;
+
+// Start the HTTP server with Socket.IO support
+server.listen(PORT, () => {
+  console.log('ğŸš€ Event Monitoring System Backend Started');
+  console.log(`ğŸ“¡ Server running on port ${PORT}`);
+  console.log(`ğŸ”— API endpoints: http://localhost:${PORT}/api`);
+  console.log(`ğŸ“Š Health check: http://localhost:${PORT}/health`);
+  console.log(`âš¡ WebSocket server ready for real-time connections`);
+  console.log(`ğŸ—„ï¸ MongoDB connection: ${process.env.NODE_ENV === 'production' ? 'Production DB' : 'Development DB'}`);
+});
+
+/**
+ * Export Socket.IO instance for use in other modules
+ * This allows other parts of the application to emit real-time events
+ */
+export { io };
diff --git a/event-monitoring-mvp/backend/src/controllers/README.md b/event-monitoring-mvp/backend/src/controllers/README.md
index 2001bb3..0b3abb2 100644
--- a/event-monitoring-mvp/backend/src/controllers/README.md
+++ b/event-monitoring-mvp/backend/src/controllers/README.md
@@ -1,200 +1,200 @@
-# Backend Controllers
-
-This directory contains all the controller modules that handle HTTP request processing for the Event Monitoring System API. Controllers act as the interface between HTTP routes and business logic, handling request validation, calling appropriate services, and formatting responses.
-
-## Architecture Overview
-
-Controllers follow the **MVC (Model-View-Controller)** pattern where:
-- **Models**: Handle data structure and database operations
-- **Views**: JSON API responses (no traditional views in REST API)
-- **Controllers**: Process requests, validate input, coordinate with models, return responses
-
-## Controller Structure
-
-Each controller module exports functions that:
-1. **Receive** Express Request and Response objects
-2. **Validate** incoming data and authentication
-3. **Process** business logic using models and services
-4. **Return** standardized JSON responses
-5. **Handle** errors gracefully
-
-## Available Controllers
-
-### ğŸ“ Authentication Controller (`authController.ts`)
-Handles user authentication and authorization operations.
-
-**Endpoints:**
-- `POST /api/auth/register` - User registration
-- `POST /api/auth/login` - User login
-- `GET /api/auth/profile` - Get current user profile
-- `PUT /api/auth/profile` - Update user profile
-
-**Features:**
-- JWT token generation and validation
-- Password hashing with bcrypt
-- User session management
-- Role-based access control setup
-
-### ğŸ“¹ Camera Controller (`cameraController.ts`)
-Manages camera devices and their configurations.
-
-**Endpoints:**
-- `GET /api/cameras` - List all cameras with filtering
-- `POST /api/cameras` - Create new camera
-- `GET /api/cameras/:id` - Get specific camera details
-- `PUT /api/cameras/:id` - Update camera settings
-- `DELETE /api/cameras/:id` - Delete camera
-- `POST /api/cameras/:id/status` - Update camera status
-
-**Features:**
-- Camera CRUD operations
-- Stream URL validation
-- Location data handling
-- Status monitoring integration
-
-### ğŸš¨ Event Controller (`eventController.ts`)
-Handles security events and incident management.
-
-**Endpoints:**
-- `GET /api/events` - List events with advanced filtering
-- `POST /api/events` - Create new event (typically from AI service)
-- `GET /api/events/:id` - Get detailed event information
-- `PUT /api/events/:id` - Update event status/details
-- `POST /api/events/:id/acknowledge` - Acknowledge event
-- `POST /api/events/:id/resolve` - Mark event as resolved
-- `POST /api/events/:id/notes` - Add investigation notes
-
-**Features:**
-- Event lifecycle management
-- Severity-based filtering
-- Real-time event notifications
-- Investigation workflow support
-
-### ğŸ‘¥ User Controller (`userController.ts`)
-Manages user accounts and administrative operations.
-
-**Endpoints:**
-- `GET /api/users` - List all users (admin only)
-- `POST /api/users` - Create new user (admin only)
-- `GET /api/users/:id` - Get specific user details
-- `PUT /api/users/:id` - Update user information
-- `DELETE /api/users/:id` - Deactivate user account
-- `POST /api/users/:id/activate` - Activate user account
-
-**Features:**
-- User management CRUD operations
-- Role-based authorization
-- Account activation/deactivation
-- User activity tracking
-
-## Response Format Standards
-
-All controllers return responses in a consistent JSON format:
-
-```typescript
-// Success Response
-{
-  "success": true,
-  "message": "Operation completed successfully",
-  "data": { /* response data */ },
-  "pagination": { /* pagination info for lists */ }
-}
-
-// Error Response
-{
-  "success": false,
-  "message": "Error description",
-  "error": "Detailed error information",
-  "code": "ERROR_CODE"
-}
-```
-
-## Error Handling
-
-Controllers implement comprehensive error handling:
-
-1. **Validation Errors**: Input validation and sanitization
-2. **Authentication Errors**: JWT verification and user authorization
-3. **Database Errors**: MongoDB operation failures
-4. **Business Logic Errors**: Domain-specific validation failures
-5. **Server Errors**: Unexpected application errors
-
-All errors are caught and processed by the global error handler middleware.
-
-## Authentication & Authorization
-
-Controllers use middleware for:
-- **Authentication**: Verify JWT tokens (`auth` middleware)
-- **Authorization**: Check user roles and permissions
-- **Rate Limiting**: Prevent abuse and DoS attacks
-- **Input Validation**: Sanitize and validate request data
-
-## Real-Time Features
-
-Controllers integrate with Socket.IO for real-time updates:
-- Event notifications broadcast to connected clients
-- Camera status updates pushed to monitoring dashboards
-- User activity logs for administrative oversight
-
-## Database Integration
-
-Controllers interact with MongoDB through Mongoose models:
-- **User Model**: User account and profile data
-- **Camera Model**: Camera device information and settings
-- **Event Model**: Security events and incident data
-
-## Security Considerations
-
-- **Password Security**: bcrypt hashing with salt
-- **JWT Security**: Signed tokens with expiration
-- **Input Sanitization**: Prevent injection attacks
-- **Rate Limiting**: API abuse prevention
-- **CORS Configuration**: Cross-origin request control
-- **Helmet Integration**: Security header protection
-
-## Development Guidelines
-
-### Adding New Controllers
-
-1. Create new controller file in this directory
-2. Follow naming convention: `{resource}Controller.ts`
-3. Implement standard CRUD operations
-4. Add comprehensive error handling
-5. Include TypeScript type definitions
-6. Add JSDoc comments for all functions
-7. Create corresponding route file
-8. Update this README
-
-### Best Practices
-
-- **Single Responsibility**: Each controller handles one resource type
-- **Error Handling**: Always use try-catch blocks
-- **Response Consistency**: Follow standard response format
-- **Input Validation**: Validate all incoming data
-- **Security First**: Implement proper authentication/authorization
-- **Documentation**: Add clear comments and JSDoc
-
-### Testing
-
-Controllers should be tested with:
-- Unit tests for individual functions
-- Integration tests for complete request flows
-- Authentication and authorization tests
-- Error handling validation
-- Performance testing for high-load scenarios
-
-## Dependencies
-
-- **Express**: Web framework for HTTP handling
-- **Mongoose**: MongoDB object modeling
-- **bcryptjs**: Password hashing
-- **jsonwebtoken**: JWT token handling
-- **express-validator**: Input validation
-- **helmet**: Security middleware
-
-## Related Documentation
-
-- [API Documentation](../../docs/api/)
-- [Database Models](../models/README.md)
-- [Route Definitions](../routes/README.md)
+# Backend Controllers
+
+This directory contains all the controller modules that handle HTTP request processing for the Event Monitoring System API. Controllers act as the interface between HTTP routes and business logic, handling request validation, calling appropriate services, and formatting responses.
+
+## Architecture Overview
+
+Controllers follow the **MVC (Model-View-Controller)** pattern where:
+- **Models**: Handle data structure and database operations
+- **Views**: JSON API responses (no traditional views in REST API)
+- **Controllers**: Process requests, validate input, coordinate with models, return responses
+
+## Controller Structure
+
+Each controller module exports functions that:
+1. **Receive** Express Request and Response objects
+2. **Validate** incoming data and authentication
+3. **Process** business logic using models and services
+4. **Return** standardized JSON responses
+5. **Handle** errors gracefully
+
+## Available Controllers
+
+### ğŸ“ Authentication Controller (`authController.ts`)
+Handles user authentication and authorization operations.
+
+**Endpoints:**
+- `POST /api/auth/register` - User registration
+- `POST /api/auth/login` - User login
+- `GET /api/auth/profile` - Get current user profile
+- `PUT /api/auth/profile` - Update user profile
+
+**Features:**
+- JWT token generation and validation
+- Password hashing with bcrypt
+- User session management
+- Role-based access control setup
+
+### ğŸ“¹ Camera Controller (`cameraController.ts`)
+Manages camera devices and their configurations.
+
+**Endpoints:**
+- `GET /api/cameras` - List all cameras with filtering
+- `POST /api/cameras` - Create new camera
+- `GET /api/cameras/:id` - Get specific camera details
+- `PUT /api/cameras/:id` - Update camera settings
+- `DELETE /api/cameras/:id` - Delete camera
+- `POST /api/cameras/:id/status` - Update camera status
+
+**Features:**
+- Camera CRUD operations
+- Stream URL validation
+- Location data handling
+- Status monitoring integration
+
+### ğŸš¨ Event Controller (`eventController.ts`)
+Handles security events and incident management.
+
+**Endpoints:**
+- `GET /api/events` - List events with advanced filtering
+- `POST /api/events` - Create new event (typically from AI service)
+- `GET /api/events/:id` - Get detailed event information
+- `PUT /api/events/:id` - Update event status/details
+- `POST /api/events/:id/acknowledge` - Acknowledge event
+- `POST /api/events/:id/resolve` - Mark event as resolved
+- `POST /api/events/:id/notes` - Add investigation notes
+
+**Features:**
+- Event lifecycle management
+- Severity-based filtering
+- Real-time event notifications
+- Investigation workflow support
+
+### ğŸ‘¥ User Controller (`userController.ts`)
+Manages user accounts and administrative operations.
+
+**Endpoints:**
+- `GET /api/users` - List all users (admin only)
+- `POST /api/users` - Create new user (admin only)
+- `GET /api/users/:id` - Get specific user details
+- `PUT /api/users/:id` - Update user information
+- `DELETE /api/users/:id` - Deactivate user account
+- `POST /api/users/:id/activate` - Activate user account
+
+**Features:**
+- User management CRUD operations
+- Role-based authorization
+- Account activation/deactivation
+- User activity tracking
+
+## Response Format Standards
+
+All controllers return responses in a consistent JSON format:
+
+```typescript
+// Success Response
+{
+  "success": true,
+  "message": "Operation completed successfully",
+  "data": { /* response data */ },
+  "pagination": { /* pagination info for lists */ }
+}
+
+// Error Response
+{
+  "success": false,
+  "message": "Error description",
+  "error": "Detailed error information",
+  "code": "ERROR_CODE"
+}
+```
+
+## Error Handling
+
+Controllers implement comprehensive error handling:
+
+1. **Validation Errors**: Input validation and sanitization
+2. **Authentication Errors**: JWT verification and user authorization
+3. **Database Errors**: MongoDB operation failures
+4. **Business Logic Errors**: Domain-specific validation failures
+5. **Server Errors**: Unexpected application errors
+
+All errors are caught and processed by the global error handler middleware.
+
+## Authentication & Authorization
+
+Controllers use middleware for:
+- **Authentication**: Verify JWT tokens (`auth` middleware)
+- **Authorization**: Check user roles and permissions
+- **Rate Limiting**: Prevent abuse and DoS attacks
+- **Input Validation**: Sanitize and validate request data
+
+## Real-Time Features
+
+Controllers integrate with Socket.IO for real-time updates:
+- Event notifications broadcast to connected clients
+- Camera status updates pushed to monitoring dashboards
+- User activity logs for administrative oversight
+
+## Database Integration
+
+Controllers interact with MongoDB through Mongoose models:
+- **User Model**: User account and profile data
+- **Camera Model**: Camera device information and settings
+- **Event Model**: Security events and incident data
+
+## Security Considerations
+
+- **Password Security**: bcrypt hashing with salt
+- **JWT Security**: Signed tokens with expiration
+- **Input Sanitization**: Prevent injection attacks
+- **Rate Limiting**: API abuse prevention
+- **CORS Configuration**: Cross-origin request control
+- **Helmet Integration**: Security header protection
+
+## Development Guidelines
+
+### Adding New Controllers
+
+1. Create new controller file in this directory
+2. Follow naming convention: `{resource}Controller.ts`
+3. Implement standard CRUD operations
+4. Add comprehensive error handling
+5. Include TypeScript type definitions
+6. Add JSDoc comments for all functions
+7. Create corresponding route file
+8. Update this README
+
+### Best Practices
+
+- **Single Responsibility**: Each controller handles one resource type
+- **Error Handling**: Always use try-catch blocks
+- **Response Consistency**: Follow standard response format
+- **Input Validation**: Validate all incoming data
+- **Security First**: Implement proper authentication/authorization
+- **Documentation**: Add clear comments and JSDoc
+
+### Testing
+
+Controllers should be tested with:
+- Unit tests for individual functions
+- Integration tests for complete request flows
+- Authentication and authorization tests
+- Error handling validation
+- Performance testing for high-load scenarios
+
+## Dependencies
+
+- **Express**: Web framework for HTTP handling
+- **Mongoose**: MongoDB object modeling
+- **bcryptjs**: Password hashing
+- **jsonwebtoken**: JWT token handling
+- **express-validator**: Input validation
+- **helmet**: Security middleware
+
+## Related Documentation
+
+- [API Documentation](../../docs/api/)
+- [Database Models](../models/README.md)
+- [Route Definitions](../routes/README.md)
 - [Middleware Documentation](../middleware/README.md)
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/controllers/aiDetectionController.ts b/event-monitoring-mvp/backend/src/controllers/aiDetectionController.ts
index 206c756..033bea6 100644
--- a/event-monitoring-mvp/backend/src/controllers/aiDetectionController.ts
+++ b/event-monitoring-mvp/backend/src/controllers/aiDetectionController.ts
@@ -1,458 +1,458 @@
-import { Request, Response } from 'express';
-import { AIDetection, IAIDetection } from '../models/AIDetection';
-import { Event } from '../models/Event';
-import { Camera } from '../models/Camera';
-import mongoose from 'mongoose';
-
-export class AIDetectionController {
-  
-  // Get all detections with filtering and pagination
-  static async getDetections(req: Request, res: Response) {
-    try {
-      const {
-        status,
-        type,
-        cameraId,
-        minConfidence,
-        maxConfidence,
-        startDate,
-        endDate,
-        page = 1,
-        limit = 50,
-        sortBy = 'timestamp',
-        sortOrder = 'desc'
-      } = req.query;
-
-      // Build filter query
-      const filter: any = {};
-      
-      if (status) {
-        filter.status = status;
-      }
-      
-      if (type) {
-        filter.type = type;
-      }
-      
-      if (cameraId) {
-        filter.cameraId = cameraId;
-      }
-      
-      if (minConfidence || maxConfidence) {
-        filter.confidence = {};
-        if (minConfidence) filter.confidence.$gte = parseFloat(minConfidence as string);
-        if (maxConfidence) filter.confidence.$lte = parseFloat(maxConfidence as string);
-      }
-      
-      if (startDate || endDate) {
-        filter.timestamp = {};
-        if (startDate) filter.timestamp.$gte = new Date(startDate as string);
-        if (endDate) filter.timestamp.$lte = new Date(endDate as string);
-      }
-
-      // Calculate pagination
-      const pageNum = parseInt(page as string);
-      const limitNum = parseInt(limit as string);
-      const skip = (pageNum - 1) * limitNum;
-
-      // Build sort object
-      const sort: any = {};
-      sort[sortBy as string] = sortOrder === 'desc' ? -1 : 1;
-
-      // Execute query with population
-      const detections = await AIDetection.find(filter)
-        .populate('cameraId', 'name location streamUrl')
-        .populate('reviewedBy', 'username')
-        .populate('promotedEventId', 'type severity')
-        .sort(sort)
-        .skip(skip)
-        .limit(limitNum);
-
-      const total = await AIDetection.countDocuments(filter);
-
-      res.json({
-        success: true,
-        data: detections,
-        pagination: {
-          current: pageNum,
-          pages: Math.ceil(total / limitNum),
-          total,
-          limit: limitNum
-        }
-      });
-
-    } catch (error: any) {
-      console.error('Error fetching detections:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to fetch detections',
-        error: error.message
-      });
-    }
-  }
-
-  // Get detections within radius of a point
-  static async getDetectionsInRadius(req: Request, res: Response) {
-    try {
-      const { lat, lng, radius = 1000 } = req.query;
-      const { status, type, minConfidence } = req.query;
-
-      if (!lat || !lng) {
-        return res.status(400).json({
-          success: false,
-          message: 'Latitude and longitude are required'
-        });
-      }
-
-      const coordinates: [number, number] = [
-        parseFloat(lng as string),
-        parseFloat(lat as string)
-      ];
-
-      const filters: any = {};
-      if (status) filters.status = status;
-      if (type) filters.type = type;
-      if (minConfidence) filters.confidence = { $gte: parseFloat(minConfidence as string) };
-
-      const detections = await AIDetection.findInRadius(
-        coordinates,
-        parseInt(radius as string),
-        filters
-      ).populate('cameraId', 'name location');
-
-      res.json({
-        success: true,
-        data: detections,
-        center: { lat: parseFloat(lat as string), lng: parseFloat(lng as string) },
-        radius: parseInt(radius as string)
-      });
-
-    } catch (error: any) {
-      console.error('Error fetching detections in radius:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to fetch detections in radius',
-        error: error.message
-      });
-    }
-  }
-
-  // Get single detection by ID
-  static async getDetectionById(req: Request, res: Response) {
-    try {
-      const { id } = req.params;
-
-      if (!mongoose.Types.ObjectId.isValid(id)) {
-        return res.status(400).json({
-          success: false,
-          message: 'Invalid detection ID'
-        });
-      }
-
-      const detection = await AIDetection.findById(id)
-        .populate('cameraId', 'name location streamUrl')
-        .populate('reviewedBy', 'username')
-        .populate('promotedEventId');
-
-      if (!detection) {
-        return res.status(404).json({
-          success: false,
-          message: 'Detection not found'
-        });
-      }
-
-      res.json({
-        success: true,
-        data: detection
-      });
-
-    } catch (error: any) {
-      console.error('Error fetching detection:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to fetch detection',
-        error: error.message
-      });
-    }
-  }
-
-  // Promote detection to event
-  static async promoteToEvent(req: Request, res: Response) {
-    try {
-      const { id } = req.params;
-      const { eventData } = req.body;
-      const userId = (req as any).user.id;
-
-      if (!mongoose.Types.ObjectId.isValid(id)) {
-        return res.status(400).json({
-          success: false,
-          message: 'Invalid detection ID'
-        });
-      }
-
-      const detection = await AIDetection.findById(id).populate('cameraId');
-
-      if (!detection) {
-        return res.status(404).json({
-          success: false,
-          message: 'Detection not found'
-        });
-      }
-
-      if (detection.status !== 'pending_review') {
-        return res.status(400).json({
-          success: false,
-          message: 'Only pending detections can be promoted'
-        });
-      }
-
-      // Create new event from detection
-      const newEventData = {
-        type: eventData?.type || detection.type,
-        severity: eventData?.severity || 'medium',
-        location: detection.location,
-        camera: detection.cameraId._id,
-        timestamp: detection.timestamp,
-        description: eventData?.description || `AI detected ${detection.type} with ${Math.round(detection.confidence * 100)}% confidence`,
-        resolved: false,
-        metadata: {
-          aiDetectionId: detection._id,
-          confidence: detection.confidence,
-          boundingBox: detection.boundingBox,
-          aiModel: detection.metadata.aiModel,
-          ...eventData?.metadata
-        },
-        createdBy: userId
-      };
-
-      const event = new Event(newEventData);
-      await event.save();
-
-      // Update detection status
-      detection.status = 'promoted_to_event';
-      detection.reviewedBy = userId;
-      detection.reviewedAt = new Date();
-      detection.promotedEventId = event._id;
-      await detection.save();
-
-      res.status(201).json({
-        success: true,
-        message: 'Detection promoted to event successfully',
-        data: {
-          detection,
-          event
-        }
-      });
-
-    } catch (error: any) {
-      console.error('Error promoting detection:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to promote detection',
-        error: error.message
-      });
-    }
-  }
-
-  // Dismiss detection as false positive
-  static async dismissDetection(req: Request, res: Response) {
-    try {
-      const { id } = req.params;
-      const { reason } = req.body;
-      const userId = (req as any).user.id;
-
-      if (!mongoose.Types.ObjectId.isValid(id)) {
-        return res.status(400).json({
-          success: false,
-          message: 'Invalid detection ID'
-        });
-      }
-
-      const detection = await AIDetection.findById(id);
-
-      if (!detection) {
-        return res.status(404).json({
-          success: false,
-          message: 'Detection not found'
-        });
-      }
-
-      if (detection.status !== 'pending_review') {
-        return res.status(400).json({
-          success: false,
-          message: 'Only pending detections can be dismissed'
-        });
-      }
-
-      await detection.dismiss(userId, reason);
-
-      res.json({
-        success: true,
-        message: 'Detection dismissed successfully',
-        data: detection
-      });
-
-    } catch (error: any) {
-      console.error('Error dismissing detection:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to dismiss detection',
-        error: error.message
-      });
-    }
-  }
-
-  // Get detection statistics
-  static async getDetectionStats(req: Request, res: Response) {
-    try {
-      const { startDate, endDate, cameraId } = req.query;
-
-      let dateRange;
-      if (startDate && endDate) {
-        dateRange = {
-          start: new Date(startDate as string),
-          end: new Date(endDate as string)
-        };
-      }
-
-      // Build match stage for aggregation
-      const matchStage: any = {};
-      if (dateRange) {
-        matchStage.timestamp = {
-          $gte: dateRange.start,
-          $lte: dateRange.end
-        };
-      }
-      if (cameraId) {
-        matchStage.cameraId = new mongoose.Types.ObjectId(cameraId as string);
-      }
-
-      const [statusStats, typeStats, confidenceStats, timelineStats] = await Promise.all([
-        // Status distribution
-        AIDetection.aggregate([
-          { $match: matchStage },
-          {
-            $group: {
-              _id: '$status',
-              count: { $sum: 1 },
-              avgConfidence: { $avg: '$confidence' }
-            }
-          }
-        ]),
-
-        // Type distribution
-        AIDetection.aggregate([
-          { $match: matchStage },
-          {
-            $group: {
-              _id: '$type',
-              count: { $sum: 1 },
-              avgConfidence: { $avg: '$confidence' }
-            }
-          }
-        ]),
-
-        // Confidence distribution
-        AIDetection.aggregate([
-          { $match: matchStage },
-          {
-            $bucket: {
-              groupBy: '$confidence',
-              boundaries: [0, 0.3, 0.5, 0.7, 0.8, 0.9, 1.0],
-              default: 'other',
-              output: {
-                count: { $sum: 1 },
-                types: { $addToSet: '$type' }
-              }
-            }
-          }
-        ]),
-
-        // Timeline data (by hour for last 24h, by day for longer periods)
-        AIDetection.aggregate([
-          { $match: matchStage },
-          {
-            $group: {
-              _id: {
-                $dateToString: {
-                  format: dateRange && 
-                    (dateRange.end.getTime() - dateRange.start.getTime()) > 7 * 24 * 60 * 60 * 1000 
-                    ? '%Y-%m-%d' : '%Y-%m-%d %H:00',
-                  date: '$timestamp'
-                }
-              },
-              count: { $sum: 1 },
-              types: { $addToSet: '$type' }
-            }
-          },
-          { $sort: { '_id': 1 } }
-        ])
-      ]);
-
-      res.json({
-        success: true,
-        data: {
-          statusDistribution: statusStats,
-          typeDistribution: typeStats,
-          confidenceDistribution: confidenceStats,
-          timeline: timelineStats,
-          dateRange: dateRange || { start: null, end: null }
-        }
-      });
-
-    } catch (error: any) {
-      console.error('Error fetching detection stats:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to fetch detection statistics',
-        error: error.message
-      });
-    }
-  }
-
-  // Create detection (for AI service)
-  static async createDetection(req: Request, res: Response) {
-    try {
-      const detectionData = req.body;
-
-      // Validate camera exists
-      const camera = await Camera.findById(detectionData.cameraId);
-      if (!camera) {
-        return res.status(400).json({
-          success: false,
-          message: 'Invalid camera ID'
-        });
-      }
-
-      // Use camera location if detection location not provided
-      if (!detectionData.location) {
-        detectionData.location = {
-          coordinates: camera.location.coordinates,
-          address: camera.location.address
-        };
-      }
-
-      const detection = new AIDetection(detectionData);
-      await detection.save();
-
-      // Populate camera data for response
-      await detection.populate('cameraId', 'name location');
-
-      res.status(201).json({
-        success: true,
-        message: 'Detection created successfully',
-        data: detection
-      });
-
-    } catch (error: any) {
-      console.error('Error creating detection:', error);
-      res.status(500).json({
-        success: false,
-        message: 'Failed to create detection',
-        error: error.message
-      });
-    }
-  }
-}
-
+import { Request, Response } from 'express';
+import { AIDetection, IAIDetection } from '../models/AIDetection';
+import { Event } from '../models/Event';
+import { Camera } from '../models/Camera';
+import mongoose from 'mongoose';
+
+export class AIDetectionController {
+  
+  // Get all detections with filtering and pagination
+  static async getDetections(req: Request, res: Response) {
+    try {
+      const {
+        status,
+        type,
+        cameraId,
+        minConfidence,
+        maxConfidence,
+        startDate,
+        endDate,
+        page = 1,
+        limit = 50,
+        sortBy = 'timestamp',
+        sortOrder = 'desc'
+      } = req.query;
+
+      // Build filter query
+      const filter: any = {};
+      
+      if (status) {
+        filter.status = status;
+      }
+      
+      if (type) {
+        filter.type = type;
+      }
+      
+      if (cameraId) {
+        filter.cameraId = cameraId;
+      }
+      
+      if (minConfidence || maxConfidence) {
+        filter.confidence = {};
+        if (minConfidence) filter.confidence.$gte = parseFloat(minConfidence as string);
+        if (maxConfidence) filter.confidence.$lte = parseFloat(maxConfidence as string);
+      }
+      
+      if (startDate || endDate) {
+        filter.timestamp = {};
+        if (startDate) filter.timestamp.$gte = new Date(startDate as string);
+        if (endDate) filter.timestamp.$lte = new Date(endDate as string);
+      }
+
+      // Calculate pagination
+      const pageNum = parseInt(page as string);
+      const limitNum = parseInt(limit as string);
+      const skip = (pageNum - 1) * limitNum;
+
+      // Build sort object
+      const sort: any = {};
+      sort[sortBy as string] = sortOrder === 'desc' ? -1 : 1;
+
+      // Execute query with population
+      const detections = await AIDetection.find(filter)
+        .populate('cameraId', 'name location streamUrl')
+        .populate('reviewedBy', 'username')
+        .populate('promotedEventId', 'type severity')
+        .sort(sort)
+        .skip(skip)
+        .limit(limitNum);
+
+      const total = await AIDetection.countDocuments(filter);
+
+      res.json({
+        success: true,
+        data: detections,
+        pagination: {
+          current: pageNum,
+          pages: Math.ceil(total / limitNum),
+          total,
+          limit: limitNum
+        }
+      });
+
+    } catch (error: any) {
+      console.error('Error fetching detections:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to fetch detections',
+        error: error.message
+      });
+    }
+  }
+
+  // Get detections within radius of a point
+  static async getDetectionsInRadius(req: Request, res: Response) {
+    try {
+      const { lat, lng, radius = 1000 } = req.query;
+      const { status, type, minConfidence } = req.query;
+
+      if (!lat || !lng) {
+        return res.status(400).json({
+          success: false,
+          message: 'Latitude and longitude are required'
+        });
+      }
+
+      const coordinates: [number, number] = [
+        parseFloat(lng as string),
+        parseFloat(lat as string)
+      ];
+
+      const filters: any = {};
+      if (status) filters.status = status;
+      if (type) filters.type = type;
+      if (minConfidence) filters.confidence = { $gte: parseFloat(minConfidence as string) };
+
+      const detections = await AIDetection.findInRadius(
+        coordinates,
+        parseInt(radius as string),
+        filters
+      ).populate('cameraId', 'name location');
+
+      res.json({
+        success: true,
+        data: detections,
+        center: { lat: parseFloat(lat as string), lng: parseFloat(lng as string) },
+        radius: parseInt(radius as string)
+      });
+
+    } catch (error: any) {
+      console.error('Error fetching detections in radius:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to fetch detections in radius',
+        error: error.message
+      });
+    }
+  }
+
+  // Get single detection by ID
+  static async getDetectionById(req: Request, res: Response) {
+    try {
+      const { id } = req.params;
+
+      if (!mongoose.Types.ObjectId.isValid(id)) {
+        return res.status(400).json({
+          success: false,
+          message: 'Invalid detection ID'
+        });
+      }
+
+      const detection = await AIDetection.findById(id)
+        .populate('cameraId', 'name location streamUrl')
+        .populate('reviewedBy', 'username')
+        .populate('promotedEventId');
+
+      if (!detection) {
+        return res.status(404).json({
+          success: false,
+          message: 'Detection not found'
+        });
+      }
+
+      res.json({
+        success: true,
+        data: detection
+      });
+
+    } catch (error: any) {
+      console.error('Error fetching detection:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to fetch detection',
+        error: error.message
+      });
+    }
+  }
+
+  // Promote detection to event
+  static async promoteToEvent(req: Request, res: Response) {
+    try {
+      const { id } = req.params;
+      const { eventData } = req.body;
+      const userId = (req as any).user.id;
+
+      if (!mongoose.Types.ObjectId.isValid(id)) {
+        return res.status(400).json({
+          success: false,
+          message: 'Invalid detection ID'
+        });
+      }
+
+      const detection = await AIDetection.findById(id).populate('cameraId');
+
+      if (!detection) {
+        return res.status(404).json({
+          success: false,
+          message: 'Detection not found'
+        });
+      }
+
+      if (detection.status !== 'pending_review') {
+        return res.status(400).json({
+          success: false,
+          message: 'Only pending detections can be promoted'
+        });
+      }
+
+      // Create new event from detection
+      const newEventData = {
+        type: eventData?.type || detection.type,
+        severity: eventData?.severity || 'medium',
+        location: detection.location,
+        camera: detection.cameraId._id,
+        timestamp: detection.timestamp,
+        description: eventData?.description || `AI detected ${detection.type} with ${Math.round(detection.confidence * 100)}% confidence`,
+        resolved: false,
+        metadata: {
+          aiDetectionId: detection._id,
+          confidence: detection.confidence,
+          boundingBox: detection.boundingBox,
+          aiModel: detection.metadata.aiModel,
+          ...eventData?.metadata
+        },
+        createdBy: userId
+      };
+
+      const event = new Event(newEventData);
+      await event.save();
+
+      // Update detection status
+      detection.status = 'promoted_to_event';
+      detection.reviewedBy = userId;
+      detection.reviewedAt = new Date();
+      detection.promotedEventId = event._id;
+      await detection.save();
+
+      res.status(201).json({
+        success: true,
+        message: 'Detection promoted to event successfully',
+        data: {
+          detection,
+          event
+        }
+      });
+
+    } catch (error: any) {
+      console.error('Error promoting detection:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to promote detection',
+        error: error.message
+      });
+    }
+  }
+
+  // Dismiss detection as false positive
+  static async dismissDetection(req: Request, res: Response) {
+    try {
+      const { id } = req.params;
+      const { reason } = req.body;
+      const userId = (req as any).user.id;
+
+      if (!mongoose.Types.ObjectId.isValid(id)) {
+        return res.status(400).json({
+          success: false,
+          message: 'Invalid detection ID'
+        });
+      }
+
+      const detection = await AIDetection.findById(id);
+
+      if (!detection) {
+        return res.status(404).json({
+          success: false,
+          message: 'Detection not found'
+        });
+      }
+
+      if (detection.status !== 'pending_review') {
+        return res.status(400).json({
+          success: false,
+          message: 'Only pending detections can be dismissed'
+        });
+      }
+
+      await detection.dismiss(userId, reason);
+
+      res.json({
+        success: true,
+        message: 'Detection dismissed successfully',
+        data: detection
+      });
+
+    } catch (error: any) {
+      console.error('Error dismissing detection:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to dismiss detection',
+        error: error.message
+      });
+    }
+  }
+
+  // Get detection statistics
+  static async getDetectionStats(req: Request, res: Response) {
+    try {
+      const { startDate, endDate, cameraId } = req.query;
+
+      let dateRange;
+      if (startDate && endDate) {
+        dateRange = {
+          start: new Date(startDate as string),
+          end: new Date(endDate as string)
+        };
+      }
+
+      // Build match stage for aggregation
+      const matchStage: any = {};
+      if (dateRange) {
+        matchStage.timestamp = {
+          $gte: dateRange.start,
+          $lte: dateRange.end
+        };
+      }
+      if (cameraId) {
+        matchStage.cameraId = new mongoose.Types.ObjectId(cameraId as string);
+      }
+
+      const [statusStats, typeStats, confidenceStats, timelineStats] = await Promise.all([
+        // Status distribution
+        AIDetection.aggregate([
+          { $match: matchStage },
+          {
+            $group: {
+              _id: '$status',
+              count: { $sum: 1 },
+              avgConfidence: { $avg: '$confidence' }
+            }
+          }
+        ]),
+
+        // Type distribution
+        AIDetection.aggregate([
+          { $match: matchStage },
+          {
+            $group: {
+              _id: '$type',
+              count: { $sum: 1 },
+              avgConfidence: { $avg: '$confidence' }
+            }
+          }
+        ]),
+
+        // Confidence distribution
+        AIDetection.aggregate([
+          { $match: matchStage },
+          {
+            $bucket: {
+              groupBy: '$confidence',
+              boundaries: [0, 0.3, 0.5, 0.7, 0.8, 0.9, 1.0],
+              default: 'other',
+              output: {
+                count: { $sum: 1 },
+                types: { $addToSet: '$type' }
+              }
+            }
+          }
+        ]),
+
+        // Timeline data (by hour for last 24h, by day for longer periods)
+        AIDetection.aggregate([
+          { $match: matchStage },
+          {
+            $group: {
+              _id: {
+                $dateToString: {
+                  format: dateRange && 
+                    (dateRange.end.getTime() - dateRange.start.getTime()) > 7 * 24 * 60 * 60 * 1000 
+                    ? '%Y-%m-%d' : '%Y-%m-%d %H:00',
+                  date: '$timestamp'
+                }
+              },
+              count: { $sum: 1 },
+              types: { $addToSet: '$type' }
+            }
+          },
+          { $sort: { '_id': 1 } }
+        ])
+      ]);
+
+      res.json({
+        success: true,
+        data: {
+          statusDistribution: statusStats,
+          typeDistribution: typeStats,
+          confidenceDistribution: confidenceStats,
+          timeline: timelineStats,
+          dateRange: dateRange || { start: null, end: null }
+        }
+      });
+
+    } catch (error: any) {
+      console.error('Error fetching detection stats:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to fetch detection statistics',
+        error: error.message
+      });
+    }
+  }
+
+  // Create detection (for AI service)
+  static async createDetection(req: Request, res: Response) {
+    try {
+      const detectionData = req.body;
+
+      // Validate camera exists
+      const camera = await Camera.findById(detectionData.cameraId);
+      if (!camera) {
+        return res.status(400).json({
+          success: false,
+          message: 'Invalid camera ID'
+        });
+      }
+
+      // Use camera location if detection location not provided
+      if (!detectionData.location) {
+        detectionData.location = {
+          coordinates: camera.location.coordinates,
+          address: camera.location.address
+        };
+      }
+
+      const detection = new AIDetection(detectionData);
+      await detection.save();
+
+      // Populate camera data for response
+      await detection.populate('cameraId', 'name location');
+
+      res.status(201).json({
+        success: true,
+        message: 'Detection created successfully',
+        data: detection
+      });
+
+    } catch (error: any) {
+      console.error('Error creating detection:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Failed to create detection',
+        error: error.message
+      });
+    }
+  }
+}
+
 export default AIDetectionController;
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/controllers/authController.ts b/event-monitoring-mvp/backend/src/controllers/authController.ts
index c8c5729..3872b92 100644
--- a/event-monitoring-mvp/backend/src/controllers/authController.ts
+++ b/event-monitoring-mvp/backend/src/controllers/authController.ts
@@ -1,286 +1,680 @@
-/**
- * Authentication Controller
- * 
- * Handles all authentication-related operations including user registration,
- * login, token generation, and user profile management. Implements JWT-based
- * authentication with bcrypt password hashing for security.
- * 
- * Security Features:
- * - Password hashing with bcrypt and salt
- * - JWT token generation with configurable expiration
- * - Input validation and sanitization
- * - Duplicate user detection
- * - Secure password comparison
- */
-
-import { Request, Response } from 'express';
-import jwt from 'jsonwebtoken';
-import bcrypt from 'bcryptjs';
-import { User } from '../models/User';
-
-/**
- * JWT Token Generation Utility
- * Creates a signed JWT token for authenticated users
- * 
- * @param userId - MongoDB ObjectId of the user
- * @returns Signed JWT token string
- */
-const generateToken = (userId: string): string => {
-  const secret = process.env.JWT_SECRET || 'fallback-secret';
-  const expiresIn = process.env.JWT_EXPIRES_IN || '7d';
-  
-  return jwt.sign(
-    { userId }, 
-    secret, 
-    { expiresIn }
-  );
-};
-
-/**
- * User Registration Controller
- * Creates a new user account with hashed password and returns JWT token
- * 
- * @route   POST /api/auth/register
- * @access  Public
- * @param   req.body.username - Unique username for the account
- * @param   req.body.email - User's email address
- * @param   req.body.password - Plain text password (will be hashed)
- * @param   req.body.role - Optional role assignment ('admin' | 'operator')
- */
-export const register = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { username, email, password, role } = req.body;
-
-    // Validate required fields
-    if (!username || !email || !password) {
-      res.status(400).json({
-        success: false,
-        message: 'Username, email, and password are required',
-      });
-      return;
-    }
-
-    // Check if user already exists (email or username)
-    const existingUser = await User.findOne({
-      $or: [{ email }, { username }],
-    });
-
-    if (existingUser) {
-      res.status(400).json({
-        success: false,
-        message: 'User already exists with this email or username',
-      });
-      return;
-    }
-
-    // Create new user document - password will be hashed by the model's pre-save hook
-    const user = await User.create({
-      username,
-      email,
-      password: password, // Raw password - will be hashed automatically by User model
-      role: role || 'operator', // Default role is 'operator'
-      isActive: true,
-    });
-
-    // Generate JWT authentication token
-    const token = generateToken(user._id.toString());
-
-    // Return success response with token and user data (excluding password)
-    res.status(201).json({
-      success: true,
-      message: 'User registered successfully',
-      data: {
-        token,
-        user: {
-          id: user._id,
-          username: user.username,
-          email: user.email,
-          role: user.role,
-        },
-      },
-    });
-  } catch (error) {
-    console.error('Register error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Login user
-// @route   POST /api/auth/login
-// @access  Public
-export const login = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { email, password } = req.body;
-
-    // Check if user exists
-    const user = await User.findOne({ email }).select('+password');
-    if (!user) {
-      res.status(401).json({
-        success: false,
-        message: 'Invalid credentials',
-      });
-      return;
-    }
-
-    // Check password
-    const isMatch = await bcrypt.compare(password, user.password);
-    if (!isMatch) {
-      res.status(401).json({
-        success: false,
-        message: 'Invalid credentials',
-      });
-      return;
-    }
-
-    // Generate token
-    const token = generateToken(user._id.toString());
-
-    // Update last login
-    user.lastLogin = new Date();
-    await user.save();
-
-    res.json({
-      success: true,
-      data: {
-        token,
-        user: {
-          id: user._id,
-          username: user.username,
-          email: user.email,
-          role: user.role,
-          lastLogin: user.lastLogin,
-        },
-      },
-    });
-  } catch (error) {
-    console.error('Login error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Get user profile
-// @route   GET /api/auth/profile
-// @access  Private
-export const getProfile = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const user = await User.findById(req.user?.userId).select('-password');
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    res.json({
-      success: true,
-      user: {
-        id: user._id,
-        username: user.username,
-        email: user.email,
-        role: user.role,
-        preferences: user.preferences,
-        lastLogin: user.lastLogin,
-        createdAt: user.createdAt,
-      },
-    });
-  } catch (error) {
-    console.error('Get profile error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Update user profile
-// @route   PUT /api/auth/profile
-// @access  Private
-export const updateProfile = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { username, email, preferences } = req.body;
-    const user = await User.findById(req.user?.userId);
-
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    // Update fields
-    if (username) user.username = username;
-    if (email) user.email = email;
-    if (preferences) user.preferences = { ...user.preferences, ...preferences };
-
-    await user.save();
-
-    res.json({
-      success: true,
-      user: {
-        id: user._id,
-        username: user.username,
-        email: user.email,
-        role: user.role,
-        preferences: user.preferences,
-      },
-    });
-  } catch (error) {
-    console.error('Update profile error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Change password
-// @route   PUT /api/auth/password
-// @access  Private
-export const changePassword = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { currentPassword, newPassword } = req.body;
-    const user = await User.findById(req.user?.userId).select('+password');
-
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    // Check current password
-    const isMatch = await bcrypt.compare(currentPassword, user.password);
-    if (!isMatch) {
-      res.status(400).json({
-        success: false,
-        message: 'Current password is incorrect',
-      });
-      return;
-    }
-
-    // Hash new password
-    const salt = await bcrypt.genSalt(10);
-    user.password = await bcrypt.hash(newPassword, salt);
-    await user.save();
-
-    res.json({
-      success: true,
-      message: 'Password updated successfully',
-    });
-  } catch (error) {
-    console.error('Change password error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
+/**
+ * Enhanced Authentication Controller
+ * 
+ * Handles all authentication-related operations including user registration,
+ * login, token generation, and user profile management. Supports multiple
+ * authentication methods: email+password, phone+OTP, and social OAuth.
+ * 
+ * Security Features:
+ * - Password hashing with bcrypt and salt
+ * - JWT token generation with configurable expiration
+ * - Phone-based OTP authentication
+ * - Permission-based access control
+ * - Account lockout protection
+ * - Input validation and sanitization
+ * - Duplicate user detection
+ */
+
+import { Request, Response } from 'express';
+import jwt from 'jsonwebtoken';
+import bcrypt from 'bcryptjs';
+import { User } from '../models/User';
+import { RolePermission } from '../models/Permission';
+import crypto from 'crypto';
+
+// Simple OTP validation function (in production, use Redis/database)
+const validateOTP = async (phone: string, otp: string): Promise<boolean> => {
+  // For demo purposes, accept any 6-digit OTP or '123456'
+  // In production, verify against stored OTP in cache/database
+  return /^\d{6}$/.test(otp) || otp === '123456';
+};
+
+/**
+ * Enhanced JWT Token Generation Utility
+ * Creates a signed JWT token for authenticated users with role and device info
+ * 
+ * @param userId - MongoDB ObjectId of the user
+ * @param role - User's role for permission checking
+ * @param authMethod - Authentication method used
+ * @param deviceInfo - Optional device information for mobile users
+ * @returns Signed JWT token string
+ */
+const generateToken = (userId: string, role: string, authMethod: string, deviceInfo?: any): string => {
+  const secret = process.env.JWT_SECRET || 'fallback-secret';
+  const expiresIn = authMethod === 'phone_otp' ? '30d' : '7d'; // Longer for mobile
+  
+  return jwt.sign(
+    { 
+      userId, 
+      role,
+      authMethod,
+      deviceInfo: deviceInfo?.platform || 'web',
+      iat: Math.floor(Date.now() / 1000)
+    }, 
+    secret, 
+    { expiresIn }
+  );
+};
+
+/**
+ * Generate OTP for phone verification
+ * @returns 6-digit OTP code
+ */
+const generateOTP = (): string => {
+  return crypto.randomInt(100000, 999999).toString();
+};
+
+/**
+ * Update user permissions based on role
+ * @param user - User document to update
+ */
+const updateUserPermissions = async (user: any): Promise<void> => {
+  try {
+    const rolePermissions = await RolePermission.find({ 
+      role: user.roles[0] || 'operator', 
+      isActive: true 
+    }).populate('permission');
+    
+    user.permissions.inherited = rolePermissions.map(rp => rp.permission._id);
+    user.permissions.lastUpdated = new Date();
+    await user.save({ validateBeforeSave: false });
+  } catch (error) {
+    console.error('Error updating user permissions:', error);
+  }
+};
+
+/**
+ * Enhanced User Registration Controller
+ * Creates a new user account with support for different authentication methods
+ * 
+ * @route   POST /api/auth/register
+ * @access  Public (for operators/admins) or Admin-only (for creating other roles)
+ * @param   req.body.username - Optional username (required for email auth)
+ * @param   req.body.email - Optional email (required for email auth)
+ * @param   req.body.password - Optional password (required for email auth)
+ * @param   req.body.phone - Optional phone (required for phone auth)
+ * @param   req.body.authMethod - Authentication method ('email_password', 'phone_otp')
+ * @param   req.body.role - Role assignment ('citizen', 'operator', 'admin', 'mobile_admin', 'super_admin')
+ * @param   req.body.profile - Optional profile information
+ */
+export const register = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { 
+      username, 
+      email, 
+      password, 
+      phone, 
+      authMethod, 
+      role,
+      roles,
+      profile,
+      deviceInfo 
+    } = req.body;
+      
+    const authType = authMethod || 'email_password';
+    // normalize: accept roles[] or role, always store roles as array
+    const normalizedRoles =
+    Array.isArray(roles) && roles.length ? roles :
+    typeof role === 'string' && role ? [role] :
+    ['operator'];
+
+
+    // Validate required fields based on auth method
+    if (authType === 'email_password') {
+      if (!email || !password) {
+        res.status(400).json({
+          success: false,
+          message: 'Email and password are required for email authentication',
+        });
+        return;
+      }
+    } else if (authType === 'phone_otp') {
+      if (!phone) {
+        res.status(400).json({
+          success: false,
+          message: 'Phone number is required for phone authentication',
+        });
+        return;
+      }
+    }
+
+    // Check for existing users
+    const existingUserQuery: any = {};
+    if (email) existingUserQuery.email = email;
+    if (username) existingUserQuery.username = username;
+    if (phone) existingUserQuery.phone = phone;
+
+    const existingUser = await User.findOne({
+      $or: Object.keys(existingUserQuery).map(key => ({ [key]: existingUserQuery[key] }))
+    });
+
+    if (existingUser) {
+      res.status(400).json({
+        success: false,
+        message: 'User already exists with this email, username, or phone number',
+      });
+      return;
+    }
+
+    // Create user data object
+    const userData: any = {
+      roles: normalizedRoles,
+      authMethod: authType,
+      isActive: true,
+      metadata: {
+        source: 'admin_created'
+      }
+    };
+
+
+    // Add authentication-specific fields
+    if (authType === 'email_password') {
+      userData.email = email;
+      userData.password = password;
+      userData.username = username || email.split('@')[0];
+    } else if (authType === 'phone_otp') {
+      userData.phone = phone;
+      userData.authentication = {
+        phoneVerified: false
+      };
+    }
+
+    // Add profile information
+    if (profile) {
+      userData.profile = {
+        firstName: profile.firstName,
+        lastName: profile.lastName,
+        department: profile.department,
+        timezone: profile.timezone || 'UTC',
+        preferredLanguage: profile.preferredLanguage || 'en'
+      };
+    }
+
+    // Add mobile device info if provided
+    if (deviceInfo && authType === 'phone_otp') {
+      userData.mobileSettings = {
+        deviceTokens: deviceInfo.deviceToken ? [deviceInfo.deviceToken] : []
+      };
+    }
+
+    // Create new user
+    const user = await User.create(userData);
+
+    // Update user permissions based on role
+    await updateUserPermissions(user);
+
+    // Generate JWT token
+    const token = generateToken(
+      user._id.toString(), 
+      user.roles?.[0] || 'operator',
+      user.authMethod, 
+      deviceInfo
+    );
+
+
+    // Return appropriate response based on auth method
+    const response: any = {
+      success: true,
+      message: authType === 'phone_otp' ? 
+        'User registered successfully. Please verify your phone number.' :
+        'User registered successfully',
+      data: {
+        token,
+        user: {
+          id: user._id,
+          username: user.username,
+          email: user.email,
+          phone: user.phone,
+          role: user.roles?.[0] || 'operator',
+          roles: user.roles || [],
+          authMethod: user.authMethod,
+          fullName: user.fullName,
+          isVerified: user.isVerified
+        },
+      },
+    };
+
+    // Add verification steps for phone auth
+    if (authType === 'phone_otp') {
+      response.nextSteps = {
+        requiresPhoneVerification: true,
+        verificationEndpoint: '/api/auth/verify-phone'
+      };
+    }
+
+    res.status(201).json(response);
+  } catch (error) {
+    console.error('Register error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error during registration',
+    });
+  }
+};
+
+/**
+ * Enhanced Login Controller
+ * Supports multiple authentication methods and improved security
+ * 
+ * @route   POST /api/auth/login
+ * @access  Public
+ * @param   req.body.credential - Email, username, or phone number
+ * @param   req.body.password - Password (for email/username login)
+ * @param   req.body.otp - OTP code (for phone login)
+ * @param   req.body.authMethod - Optional: specify auth method
+ */
+export const login = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { credential, email, password, otp, authMethod, deviceInfo } = req.body;
+
+    // Support both 'credential' (new format) and 'email' (legacy format)
+    const loginCredential = credential || email;
+
+    if (!loginCredential) {
+      res.status(400).json({
+        success: false,
+        message: 'Email, username, or phone number is required',
+      });
+      return;
+    }
+
+    // Find user by credential (email, username, or phone)
+    const user = await User.findByCredential(loginCredential);
+    if (!user) {
+      res.status(401).json({
+        success: false,
+        message: 'Invalid credentials',
+      });
+      return;
+    }
+
+    // Check if account is locked
+    if (user.isLocked) {
+      res.status(423).json({
+        success: false,
+        message: 'Account is temporarily locked due to too many failed attempts',
+        lockoutUntil: user.authentication.lockoutUntil
+      });
+      return;
+    }
+
+    let isValid = false;
+
+    // Validate based on authentication method
+    if (user.authMethod === 'email_password') {
+      if (!password) {
+        res.status(400).json({
+          success: false,
+          message: 'Password is required for email/username login',
+        });
+        return;
+      }
+      isValid = await user.comparePassword(password);
+    } else if (user.authMethod === 'phone_otp') {
+      if (!otp) {
+        res.status(400).json({
+          success: false,
+          message: 'OTP code is required for phone login',
+        });
+        return;
+      }
+      // In a real implementation, you'd validate the OTP from cache/database
+      // For now, we'll assume OTP validation logic exists
+      isValid = await validateOTP(user.phone, otp);
+    }
+
+    if (!isValid) {
+      // Increment failed attempts
+      user.authentication.failedAttempts += 1;
+      
+      // Lock account after 5 failed attempts for 30 minutes
+      if (user.authentication.failedAttempts >= 5) {
+        user.authentication.lockoutUntil = new Date(Date.now() + 30 * 60 * 1000);
+      }
+      
+      await user.save({ validateBeforeSave: false });
+      
+      res.status(401).json({
+        success: false,
+        message: 'Invalid credentials',
+        attemptsRemaining: Math.max(0, 5 - user.authentication.failedAttempts)
+      });
+      return;
+    }
+
+    // Reset failed attempts on successful login
+    user.authentication.failedAttempts = 0;
+    user.authentication.lockoutUntil = undefined;
+    user.authentication.lastLoginAt = new Date();
+    
+    await user.save({ validateBeforeSave: false });
+
+    // Generate new token
+    const token = generateToken(
+      user._id.toString(), 
+      user.roles[0] || 'operator', // Use first role
+      user.authMethod, 
+      deviceInfo
+    );
+
+    res.json({
+      success: true,
+      message: 'Login successful',
+      data: {
+        token,
+        user: {
+          id: user._id,
+          username: user.username,
+          email: user.email,
+          phone: user.phone,
+          role: user.roles[0] || 'operator',
+          authMethod: user.authMethod,
+          isActive: user.isActive,
+          profile: user.profile
+        },
+      },
+    });
+  } catch (error) {
+    console.error('Login error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error during login',
+    });
+  }
+};
+
+/**
+ * Phone Verification Controller
+ * Verify phone number with OTP code
+ * 
+ * @route   POST /api/auth/verify-phone
+ * @access  Public
+ */
+export const verifyPhone = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { phone, otp } = req.body;
+
+    if (!phone || !otp) {
+      res.status(400).json({
+        success: false,
+        message: 'Phone number and OTP code are required',
+      });
+      return;
+    }
+
+    // Find user by phone
+    const user = await User.findOne({ phone });
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    // Validate OTP (implement actual OTP validation logic)
+    const isValidOTP = await validateOTP(phone, otp);
+    if (!isValidOTP) {
+      res.status(400).json({
+        success: false,
+        message: 'Invalid or expired OTP code',
+      });
+      return;
+    }
+
+    // Mark phone as verified
+    user.authentication.phoneVerified = true;
+    user.isVerified = true;
+    await user.save();
+
+    res.json({
+      success: true,
+      message: 'Phone number verified successfully',
+      data: {
+        user: {
+          id: user._id,
+          phone: user.phone,
+          isVerified: user.isVerified
+        }
+      }
+    });
+  } catch (error) {
+    console.error('Phone verification error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error during phone verification',
+    });
+  }
+};
+
+/**
+ * Send OTP Controller
+ * Send OTP code to phone number
+ * 
+ * @route   POST /api/auth/send-otp
+ * @access  Public
+ */
+export const sendOTP = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { phone } = req.body;
+
+    if (!phone) {
+      res.status(400).json({
+        success: false,
+        message: 'Phone number is required',
+      });
+      return;
+    }
+
+    // Generate and send OTP (implement actual SMS service integration)
+    const otpCode = generateOTP();
+    await storeOTP(phone, otpCode); // Store in Redis/cache with expiration
+    await sendSMS(phone, `Your verification code is: ${otpCode}`);
+
+    res.json({
+      success: true,
+      message: 'OTP sent successfully',
+      data: {
+        phone: phone.replace(/(\d{3})\d{4}(\d{3})/, '$1****$2'), // Masked phone
+        expiresIn: 300 // 5 minutes
+      }
+    });
+  } catch (error) {
+    console.error('Send OTP error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Failed to send OTP',
+    });
+  }
+};
+
+// Placeholder functions - implement with actual services
+const storeOTP = async (phone: string, otp: string): Promise<void> => {
+  // Implement OTP storage in Redis with 5-minute expiration
+  console.log(`Storing OTP ${otp} for phone ${phone}`);
+};
+
+const sendSMS = async (phone: string, message: string): Promise<void> => {
+  // Implement actual SMS service (Twilio, AWS SNS, etc.)
+  console.log(`SMS to ${phone}: ${message}`);
+};
+
+/**
+ * Enhanced Get Profile Controller
+ * Returns comprehensive user profile with permissions
+ * 
+ * @route   GET /api/auth/profile
+ * @access  Private
+ */
+export const getProfile = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const user = await User.findById(req.user?.userId)
+      .populate('permissions.granted', 'name description resource actions')
+      .populate('permissions.inherited', 'name description resource actions')
+      .select('-password -authentication.otpSecret -authentication.recoveryTokens');
+      
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    res.json({
+      success: true,
+      data: {
+        user: {
+          id: user._id,
+          username: user.username,
+          email: user.email,
+          phone: user.phone,
+          role: user.roles?.[0] || 'operator',
+          roles: user.roles || [],
+          authMethod: user.authMethod,
+          fullName: user.fullName,
+          isActive: user.isActive,
+          isVerified: user.isVerified,
+          profile: user.profile,
+          permissions: {
+            granted: user.permissions.granted,
+            inherited: user.permissions.inherited,
+            lastUpdated: user.permissions.lastUpdated
+          },
+          usage: user.usage,
+          lastLogin: user.lastLogin,
+          createdAt: user.createdAt,
+        },
+      }
+    });
+  } catch (error) {
+    console.error('Get profile error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error while fetching profile',
+    });
+  }
+};
+
+/**
+ * Enhanced Update Profile Controller
+ * Updates user profile information
+ * 
+ * @route   PUT /api/auth/profile
+ * @access  Private
+ */
+export const updateProfile = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const userId = req.user?.userId;
+    const { profile, mobileSettings } = req.body;
+
+    const user = await User.findById(userId);
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    // Update profile fields
+    if (profile) {
+      if (profile.firstName !== undefined) user.profile.firstName = profile.firstName;
+      if (profile.lastName !== undefined) user.profile.lastName = profile.lastName;
+      if (profile.department !== undefined) user.profile.department = profile.department;
+      if (profile.timezone !== undefined) user.profile.timezone = profile.timezone;
+      if (profile.preferredLanguage !== undefined) user.profile.preferredLanguage = profile.preferredLanguage;
+      
+      if (profile.location) {
+        user.profile.location = {
+          coordinates: profile.location.coordinates,
+          address: profile.location.address,
+          accuracy: profile.location.accuracy
+        };
+      }
+    }
+
+    // Update mobile settings for mobile users
+    if (mobileSettings && user.authMethod === 'phone_otp') {
+      if (mobileSettings.deviceTokens) {
+        user.mobileSettings.deviceTokens = mobileSettings.deviceTokens;
+      }
+    }
+
+    await user.save();
+    res.json({
+      success: true,
+      message: 'Profile updated successfully',
+      data: {
+        user: {
+          id: user._id,
+          fullName: user.fullName,
+          profile: user.profile,
+          mobileSettings: user.mobileSettings
+        }
+      }
+    });
+  } catch (error) {
+    console.error('Update profile error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error while updating profile',
+    });
+  }
+};
+
+/**
+ * Change Password Controller
+ * Allows users to change their password
+ * 
+ * @route   PUT /api/auth/change-password
+ * @access  Private
+ */
+export const changePassword = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const userId = req.user?.userId;
+    const { currentPassword, newPassword } = req.body;
+
+    if (!currentPassword || !newPassword) {
+      res.status(400).json({
+        success: false,
+        message: 'Current password and new password are required',
+      });
+      return;
+    }
+
+    const user = await User.findById(userId).select('+password');
+    if (!user || user.authMethod !== 'email_password') {
+      res.status(400).json({
+        success: false,
+        message: 'Password change not available for this authentication method',
+      });
+      return;
+    }
+
+    // Verify current password
+    const isValidPassword = await user.comparePassword(currentPassword);
+    if (!isValidPassword) {
+      res.status(400).json({
+        success: false,
+        message: 'Current password is incorrect',
+      });
+      return;
+    }
+
+    // Update password (will be hashed by pre-save middleware)
+    user.password = newPassword;
+    await user.save();
+
+    res.json({
+      success: true,
+      message: 'Password changed successfully'
+    });
+  } catch (error) {
+    console.error('Change password error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error while changing password',
+    });
+  }
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/controllers/cameraController.ts b/event-monitoring-mvp/backend/src/controllers/cameraController.ts
index 2016b9e..abe099f 100644
--- a/event-monitoring-mvp/backend/src/controllers/cameraController.ts
+++ b/event-monitoring-mvp/backend/src/controllers/cameraController.ts
@@ -1,63 +1,72 @@
 import { Request, Response } from 'express';
-import { Camera, ICamera } from '../models/Camera';
-
-// @desc    Get all cameras
-// @route   GET /api/cameras
-// @access  Private
-export const getCameras = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const cameras = await Camera.find({ isDeleted: false }).sort({ createdAt: -1 });
-    
-    res.json({
-      success: true,
-      count: cameras.length,
-      data: cameras,
-    });
-  } catch (error) {
-    console.error('Get cameras error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Get single camera
-// @route   GET /api/cameras/:id
-// @access  Private
-export const getCamera = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const camera = await Camera.findOne({ 
-      _id: req.params.id, 
-      isDeleted: false 
-    });
-
-    if (!camera) {
-      res.status(404).json({
-        success: false,
-        message: 'Camera not found',
-      });
-      return;
-    }
-
-    res.json({
-      success: true,
-      data: camera,
-    });
-  } catch (error) {
-    console.error('Get camera error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Create camera
-// @route   POST /api/cameras
-// @access  Private (Admin/Manager)
-export const createCamera = async (req: Request, res: Response): Promise<void> => {
-  try {
+import { Camera } from '../models/Camera';
+import { VmsServer } from '../models/VmsServer';
+import net from 'net';
+import http from 'http';
+import https from 'https';
+
+
+type AuthReq = Request & { user?: { userId?: string } };
+
+// @desc    Get all cameras
+// @route   GET /api/cameras
+// @access  Private
+export const getCameras = async (_req: Request, res: Response): Promise<void> => {
+  try {
+    const cameras = await Camera.find({ isDeleted: false }).sort({ createdAt: -1 });
+    
+    res.json({
+      success: true,
+      count: cameras.length,
+      data: cameras,
+    });
+  } catch (error) {
+    console.error('Get cameras error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Get single camera
+// @route   GET /api/cameras/:id
+// @access  Private
+export const getCamera = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const camera = await Camera.findOne({ 
+      _id: req.params.id, 
+      isDeleted: false 
+    });
+
+    if (!camera) {
+      res.status(404).json({
+        success: false,
+        message: 'Camera not found',
+      });
+      return;
+    }
+
+    res.json({
+      success: true,
+      data: camera,
+    });
+  } catch (error) {
+    console.error('Get camera error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+
+
+// @desc    Create camera
+// @route   POST /api/cameras
+// @access  Private (Admin/Manager)
+export const createCamera = async (req: AuthReq, res: Response): Promise<void> => {
+  try {
     const {
       name,
       description,
@@ -65,77 +74,276 @@ export const createCamera = async (req: Request, res: Response): Promise<void> =
       type,
       location,
       settings,
+      metadata,
     } = req.body;
-
-    // Check if camera with same name exists
-    const existingCamera = await Camera.findOne({ name, isDeleted: false });
-    if (existingCamera) {
-      res.status(400).json({
-        success: false,
-        message: 'Camera with this name already exists',
-      });
-      return;
-    }
-
+
+    // Check if camera with same name exists
+    const existingCamera = await Camera.findOne({ name, isDeleted: false });
+    if (existingCamera) {
+      res.status(400).json({
+        success: false,
+        message: 'Camera with this name already exists',
+      });
+      return;
+    }
+
+    if (!req.user?.userId) {
+        res.status(401).json({ success: false, message: 'Authentication required' });
+        return;
+    }
+
+    const normalizedLocation = {
+      type: location?.type || 'Point',
+      coordinates: location?.coordinates,
+      address: location?.address,
+    };
+
+
     const camera = await Camera.create({
       name,
       description,
       streamUrl,
       type: type || 'ip',
-      location,
+      location : normalizedLocation,
       settings: {
         resolution: settings?.resolution || '1920x1080',
         fps: settings?.fps || 30,
         recordingEnabled: settings?.recordingEnabled || false,
         ...settings,
       },
+      metadata,
       createdBy: req.user?.userId,
     });
-
-    res.status(201).json({
-      success: true,
-      data: camera,
-    });
-  } catch (error) {
-    console.error('Create camera error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
+
+    res.status(201).json({
+      success: true,
+      data: camera,
+    });
+  } catch (error) {
+    console.error('Create camera error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Update camera
+// @route   PUT /api/cameras/:id
+// @access  Private (Admin/Manager)
+export const updateCamera = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const camera = await Camera.findOne({ 
+      _id: req.params.id, 
+      isDeleted: false 
+    });
+
+    if (!camera) {
+      res.status(404).json({
+        success: false,
+        message: 'Camera not found',
+      });
+      return;
+    }
+
+    // Update fields
+    const updatedCamera = await Camera.findByIdAndUpdate(
+      req.params.id,
+      { ...req.body, lastModified: new Date() },
+      { new: true, runValidators: true }
+    );
+
+    res.json({
+      success: true,
+      data: updatedCamera,
+    });
+  } catch (error) {
+    console.error('Update camera error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Delete camera
+// @route   DELETE /api/cameras/:id
+// @access  Private (Admin/Manager)
+export const deleteCamera = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const camera = await Camera.findOne({ 
+      _id: req.params.id, 
+      isDeleted: false 
+    });
+
+    if (!camera) {
+      res.status(404).json({
+        success: false,
+        message: 'Camera not found',
+      });
+      return;
+    }
+
+    // Soft delete
+    camera.isDeleted = true;
+    camera.lastModified = new Date();
+    await camera.save();
+
+    res.json({
+      success: true,
+      message: 'Camera deleted successfully',
+    });
+  } catch (error) {
+    console.error('Delete camera error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Update camera status
+// @route   PATCH /api/cameras/:id/status
+// @access  Private
+export const updateCameraStatus = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { status } = req.body;
+    const camera = await Camera.findOne({ 
+      _id: req.params.id, 
+      isDeleted: false 
+    });
+
+    if (!camera) {
+      res.status(404).json({
+        success: false,
+        message: 'Camera not found',
+      });
+      return;
+    }
+
+    camera.status = status;
+    camera.lastSeen = status === 'online' ? new Date() : camera.lastSeen;
+    camera.lastModified = new Date();
+    await camera.save();
+
+    res.json({
+      success: true,
+      data: camera,
+    });
+  } catch (error) {
+    console.error('Update camera status error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Start AI processing for camera
+// @route   POST /api/cameras/:id/ai/start
+// @access  Private
+export const startAIProcessing = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const camera = await Camera.findOne({ 
+      _id: req.params.id, 
+      isDeleted: false 
+    });
+
+    if (!camera) {
+      res.status(404).json({
+        success: false,
+        message: 'Camera not found',
+      });
+      return;
+    }
+
+    if (camera.status !== 'online') {
+      res.status(400).json({
+        success: false,
+        message: 'Camera must be online to start AI processing',
+      });
+      return;
+    }
+
+    // TODO: Start AI processing via AI service
+    // For now, just update the status
+    camera.lastModified = new Date();
+    await camera.save();
+
+    res.json({
+      success: true,
+      message: 'AI processing started',
+      data: camera,
+    });
+  } catch (error) {
+    console.error('Start AI processing error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Stop AI processing for camera
+// @route   POST /api/cameras/:id/ai/stop
+// @access  Private
+export const stopAIProcessing = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const camera = await Camera.findOne({ 
+      _id: req.params.id, 
+      isDeleted: false 
+    });
+
+    if (!camera) {
+      res.status(404).json({
+        success: false,
+        message: 'Camera not found',
+      });
+      return;
+    }
+
+    // TODO: Stop AI processing via AI service
+    // For now, just update the status
+    camera.lastModified = new Date();
+    await camera.save();
+
+    res.json({
+      success: true,
+      message: 'AI processing stopped',
+      data: camera,
+    });
+  } catch (error) {
+    console.error('Stop AI processing error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
   }
 };
 
-// @desc    Update camera
-// @route   PUT /api/cameras/:id
-// @access  Private (Admin/Manager)
-export const updateCamera = async (req: Request, res: Response): Promise<void> => {
+// @desc    Bulk delete cameras by metadata.source (soft delete)
+// @route   DELETE /api/cameras/source/:source
+// @access  Private (dev branch use)
+export const deleteCamerasBySource = async (req: Request, res: Response): Promise<void> => {
   try {
-    const camera = await Camera.findOne({ 
-      _id: req.params.id, 
-      isDeleted: false 
-    });
+    const { source } = req.params;
 
-    if (!camera) {
-      res.status(404).json({
-        success: false,
-        message: 'Camera not found',
-      });
+    if (!source) {
+      res.status(400).json({ success: false, message: 'source is required' });
       return;
     }
 
-    // Update fields
-    const updatedCamera = await Camera.findByIdAndUpdate(
-      req.params.id,
-      { ...req.body, lastModified: new Date() },
-      { new: true, runValidators: true }
+    const result = await Camera.updateMany(
+      { isDeleted: false, 'metadata.source': source },
+      { $set: { isDeleted: true, lastModified: new Date() } }
     );
 
     res.json({
       success: true,
-      data: updatedCamera,
+      message: `Deleted ${result.modifiedCount} cameras`,
     });
   } catch (error) {
-    console.error('Update camera error:', error);
+    console.error('Bulk delete cameras error:', error);
     res.status(500).json({
       success: false,
       message: 'Server error',
@@ -143,157 +351,125 @@ export const updateCamera = async (req: Request, res: Response): Promise<void> =
   }
 };
 
-// @desc    Delete camera
-// @route   DELETE /api/cameras/:id
-// @access  Private (Admin/Manager)
-export const deleteCamera = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const camera = await Camera.findOne({ 
-      _id: req.params.id, 
-      isDeleted: false 
-    });
-
-    if (!camera) {
-      res.status(404).json({
-        success: false,
-        message: 'Camera not found',
-      });
-      return;
-    }
-
-    // Soft delete
-    camera.isDeleted = true;
-    camera.lastModified = new Date();
-    await camera.save();
+// @desc    Test camera stream connectivity (RTSP/HTTP)
+// @route   POST /api/cameras/test-connection
+// @access  Private
+export const testCameraConnection = async (req: Request, res: Response): Promise<void> => {
+  const { streamUrl, mode, vmsServerId, monitorId } = req.body as {
+    streamUrl?: string;
+    mode?: 'rtsp' | 'vms';
+    vmsServerId?: string;
+    monitorId?: string;
+  };
 
-    res.json({
-      success: true,
-      message: 'Camera deleted successfully',
-    });
-  } catch (error) {
-    console.error('Delete camera error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
+  if (!streamUrl) {
+    res.status(400).json({ success: false, message: 'streamUrl is required' });
+    return;
   }
-};
 
-// @desc    Update camera status
-// @route   PATCH /api/cameras/:id/status
-// @access  Private
-export const updateCameraStatus = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { status } = req.body;
-    const camera = await Camera.findOne({ 
-      _id: req.params.id, 
-      isDeleted: false 
-    });
+  const timeoutMs = 4000;
 
-    if (!camera) {
-      res.status(404).json({
-        success: false,
-        message: 'Camera not found',
-      });
-      return;
-    }
+  // Helper: TCP check for RTSP (port open)
+  const testTcp = (host: string, port: number) =>
+    new Promise<{ ok: boolean; message: string }>((resolve) => {
+      const socket = new net.Socket();
+      let done = false;
 
-    camera.status = status;
-    camera.lastSeen = status === 'online' ? new Date() : camera.lastSeen;
-    camera.lastModified = new Date();
-    await camera.save();
+      const finish = (ok: boolean, message: string) => {
+        if (done) return;
+        done = true;
+        socket.destroy();
+        resolve({ ok, message });
+      };
 
-    res.json({
-      success: true,
-      data: camera,
+      socket.setTimeout(timeoutMs);
+      socket.once('connect', () => finish(true, 'TCP connection successful'));
+      socket.once('timeout', () => finish(false, 'Connection timed out'));
+      socket.once('error', (err) => finish(false, err.message));
+      socket.connect(port, host);
     });
-  } catch (error) {
-    console.error('Update camera status error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
 
-// @desc    Start AI processing for camera
-// @route   POST /api/cameras/:id/ai/start
-// @access  Private
-export const startAIProcessing = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const camera = await Camera.findOne({ 
-      _id: req.params.id, 
-      isDeleted: false 
-    });
+  // Helper: HTTP(S) reachability check (any response is "reachable")
+  const testHttp = (targetUrl: URL, method: 'HEAD' | 'GET' = 'HEAD') =>
+    new Promise<{ ok: boolean; message: string }>((resolve) => {
+      const client = targetUrl.protocol === 'https:' ? https : http;
+      const req = client.request(
+        targetUrl,
+        { method, timeout: timeoutMs },
+        (resp) => {
+          resp.resume();
+          resolve({ ok: true, message: `HTTP reachable (${resp.statusCode})` });
+        }
+      );
 
-    if (!camera) {
-      res.status(404).json({
-        success: false,
-        message: 'Camera not found',
+      req.on('timeout', () => {
+        req.destroy();
+        resolve({ ok: false, message: 'Connection timed out' });
       });
+      req.on('error', (err) => resolve({ ok: false, message: err.message }));
+      req.end();
+    });
+
+  const selectedMode = mode || 'rtsp';
+  let result: { ok: boolean; message: string };
+
+  if (selectedMode === 'vms') {
+    if (!vmsServerId || !monitorId) {
+      res.status(400).json({ success: false, message: 'vmsServerId and monitorId are required for VMS test' });
       return;
     }
 
-    if (camera.status !== 'online') {
-      res.status(400).json({
-        success: false,
-        message: 'Camera must be online to start AI processing',
-      });
+    const vmsServer = await VmsServer.findById(vmsServerId);
+    if (!vmsServer || !vmsServer.isActive) {
+      res.status(404).json({ success: false, message: 'VMS server not found or inactive' });
       return;
     }
 
-    // TODO: Start AI processing via AI service
-    // For now, just update the status
-    camera.lastModified = new Date();
-    await camera.save();
-
-    res.json({
-      success: true,
-      message: 'AI processing started',
-      data: camera,
-    });
-  } catch (error) {
-    console.error('Start AI processing error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
+    if (vmsServer.provider !== 'shinobi') {
+      res.status(400).json({ success: false, message: 'VMS test currently supports Shinobi only' });
+      return;
+    }
 
-// @desc    Stop AI processing for camera
-// @route   POST /api/cameras/:id/ai/stop
-// @access  Private
-export const stopAIProcessing = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const camera = await Camera.findOne({ 
-      _id: req.params.id, 
-      isDeleted: false 
-    });
+    const baseUrl = String(vmsServer.baseUrl).replace(/\/+$/, '');
+    const apiKey = vmsServer.auth?.apiKey;
+    const groupKey = vmsServer.auth?.groupKey;
 
-    if (!camera) {
-      res.status(404).json({
-        success: false,
-        message: 'Camera not found',
-      });
+    if (!apiKey || !groupKey) {
+      res.status(400).json({ success: false, message: 'VMS server missing Shinobi auth keys' });
       return;
     }
 
-    // TODO: Stop AI processing via AI service
-    // For now, just update the status
-    camera.lastModified = new Date();
-    await camera.save();
+    // TEST-ONLY: VMS reachability check uses Shinobi HLS/snapshot instead of direct RTSP.
+    const hlsUrl = new URL(`${baseUrl}/${apiKey}/hls/${groupKey}/${monitorId}/s.m3u8`);
+    const snapshotUrl = new URL(`${baseUrl}/${apiKey}/jpeg/${groupKey}/${monitorId}/s.jpg`);
 
-    res.json({
-      success: true,
-      message: 'AI processing stopped',
-      data: camera,
-    });
-  } catch (error) {
-    console.error('Stop AI processing error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
+    result = await testHttp(hlsUrl, 'GET');
+    if (!result.ok) {
+      result = await testHttp(snapshotUrl, 'GET');
+    }
+  } else {
+    let url: URL;
+    try {
+      url = new URL(streamUrl);
+    } catch (error) {
+      res.status(400).json({ success: false, message: 'Invalid streamUrl format' });
+      return;
+    }
+
+    if (url.protocol === 'rtsp:') {
+      const port = Number(url.port) || 554;
+      result = await testTcp(url.hostname, port);
+    } else if (url.protocol === 'http:' || url.protocol === 'https:') {
+      result = await testHttp(url);
+    } else {
+      res.status(400).json({ success: false, message: 'Unsupported protocol' });
+      return;
+    }
   }
-};
\ No newline at end of file
+
+  res.status(200).json({
+    success: true,
+    ok: result.ok,
+    message: result.message,
+  });
+};
diff --git a/event-monitoring-mvp/backend/src/controllers/cameraVmsController.ts b/event-monitoring-mvp/backend/src/controllers/cameraVmsController.ts
new file mode 100644
index 0000000..4f8a4ec
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/controllers/cameraVmsController.ts
@@ -0,0 +1,200 @@
+import { Request, Response } from 'express';
+import mongoose from 'mongoose';
+import { Camera } from '../models/Camera';
+import { VmsServer } from '../models/VmsServer';
+
+/**
+ * Camera â†” VMS Controller
+ *
+ * What this controller does:
+ * - "Connect" a camera record to a specific VMS server by saving a mapping:
+ *   camera.vms.serverId + camera.vms.provider + camera.vms.monitorId
+ * - "Disconnect" clears that mapping
+ * - "Streams" returns information that the frontend can use:
+ *   - always includes the stored RTSP URL (camera.streamUrl)
+ *   - can later return browser-playable URLs coming from the VMS (HLS/WebRTC)
+ *
+ * What it does NOT do yet:
+ * - It does not actually call the VMS provider API to create a monitor/channel.
+ *   For now, it stores the mapping and provides a stable contract for the frontend.
+ *   Provider API calls come later via adapter clients (Shinobi/ZoneMinder/etc.).
+ */
+
+/**
+ * POST /api/cameras/:id/vms/connect
+ * Body: { serverId: string, monitorId?: string }
+ *
+ * Saves a mapping between our camera and a VMS server.
+ * monitorId is optional for now because:
+ * - Some flows may create monitorId later (after we implement provider API calls).
+ */
+export const connectCameraToVms = async (req: Request, res: Response) => {
+  const cameraId = req.params.id;
+  const { serverId, monitorId } = req.body as { serverId?: string; monitorId?: string };
+  const normalizedMonitorId = typeof monitorId === 'string' ? monitorId.trim() : monitorId;
+
+  if (!serverId) {
+    return res.status(400).json({ success: false, message: 'serverId is required' });
+  }
+
+  if (!mongoose.Types.ObjectId.isValid(cameraId)) {
+    return res.status(400).json({ success: false, message: 'Invalid camera id' });
+  }
+
+  if (!mongoose.Types.ObjectId.isValid(serverId)) {
+    return res.status(400).json({ success: false, message: 'Invalid serverId' });
+  }
+
+  const [camera, vmsServer] = await Promise.all([
+    Camera.findById(cameraId),
+    VmsServer.findById(serverId),
+  ]);
+
+  if (!camera) {
+    return res.status(404).json({ success: false, message: 'Camera not found' });
+  }
+
+  if (!vmsServer || !vmsServer.isActive) {
+    return res.status(404).json({ success: false, message: 'VMS server not found or inactive' });
+  }
+
+  // Store mapping (provider comes from the VMS server record)
+  camera.vms = {
+    provider: vmsServer.provider,
+    serverId: vmsServer._id,
+    monitorId: normalizedMonitorId || camera.vms?.monitorId, // keep existing if already set
+    lastSyncAt: new Date(),
+  };
+
+  await camera.save();
+
+  return res.status(200).json({
+    success: true,
+    message: 'Camera connected to VMS (mapping saved)',
+    data: camera,
+  });
+};
+
+/**
+ * POST /api/cameras/:id/vms/disconnect
+ *
+ * Clears the VMS mapping on the camera record.
+ */
+export const disconnectCameraFromVms = async (req: Request, res: Response) => {
+  const cameraId = req.params.id;
+
+  if (!mongoose.Types.ObjectId.isValid(cameraId)) {
+    return res.status(400).json({ success: false, message: 'Invalid camera id' });
+  }
+
+  const camera = await Camera.findById(cameraId);
+
+  if (!camera) {
+    return res.status(404).json({ success: false, message: 'Camera not found' });
+  }
+
+  camera.vms = {
+    provider: 'other',   // reset provider to default-ish
+    serverId: undefined,
+    monitorId: undefined,
+    lastSyncAt: new Date(),
+  };
+
+  await camera.save();
+
+  return res.status(200).json({
+    success: true,
+    message: 'Camera disconnected from VMS (mapping cleared)',
+    data: camera,
+  });
+};
+
+/**
+ * GET /api/cameras/:id/vms/streams
+ *
+ * Returns stream info for the camera.
+ * For now:
+ * - Always returns the stored RTSP URL
+ * - Returns VMS mapping info
+ *
+ * Later:
+ * - We will query the VMS provider and return browser-playable URLs:
+ *   { liveHlsUrl, liveWebrtcUrl, playbackUrl, ... }
+ */
+export const getCameraVmsStreams = async (req: Request, res: Response) => {
+  const cameraId = req.params.id;
+
+  if (!mongoose.Types.ObjectId.isValid(cameraId)) {
+    return res.status(400).json({ success: false, message: 'Invalid camera id' });
+  }
+
+  const camera = await Camera.findById(cameraId);
+
+  if (!camera) {
+    return res.status(404).json({ success: false, message: 'Camera not found' });
+  }
+
+  /**
+   * Streams contract
+   * - Always returns the stored RTSP URL and the current VMS mapping (if any)
+   * - If the camera is connected to a supported VMS provider (Shinobi for now),
+   *   returns browser-usable URLs computed from the stored VMS credentials + monitor id.
+   *
+   * Security note:
+   * - We NEVER return VMS credentials (apiKey/groupKey) directly.
+   * - Only derived stream URLs are returned to the frontend.
+   */
+  const baseResponse = {
+    cameraId: camera._id,
+    rtspUrl: camera.streamUrl,
+    vms: camera.vms || null,
+
+    // Browser-usable URLs (provider-dependent)
+    liveEmbedUrl: null as string | null,
+    liveHlsUrl: null as string | null,
+    snapshotUrl: null as string | null,
+
+    // Placeholders for next iteration
+    playbackUrl: null as string | null,
+  };
+
+  // If not connected to any VMS server/monitor, return the base contract.
+  const serverId = camera.vms?.serverId;
+  const monitorId = camera.vms?.monitorId;
+  const provider = camera.vms?.provider;
+
+  if (!serverId || !monitorId || !provider || provider === 'other') {
+    return res.status(200).json({ success: true, data: baseResponse });
+  }
+
+  const vmsServer = await VmsServer.findById(serverId);
+
+  if (!vmsServer || !vmsServer.isActive) {
+    return res.status(404).json({ success: false, message: 'VMS server not found or inactive' });
+  }
+
+  // Provider-specific URL generation
+  if (vmsServer.provider === 'shinobi') {
+    const baseUrl = String(vmsServer.baseUrl).replace(/\/+$/, '');
+    const apiKey = vmsServer.auth?.apiKey;
+    const groupKey = vmsServer.auth?.groupKey;
+
+    /**
+     * Shinobi URL format
+     * - embed:   {baseUrl}/{API_KEY}/embed/{GROUP_KEY}/{MONITOR_ID}
+     * - hls:     {baseUrl}/{API_KEY}/hls/{GROUP_KEY}/{MONITOR_ID}/s.m3u8
+     * - snapshot:{baseUrl}/{API_KEY}/jpeg/{GROUP_KEY}/{MONITOR_ID}/s.jpg
+     */
+    if (apiKey && groupKey) {
+      baseResponse.liveEmbedUrl = `${baseUrl}/${apiKey}/embed/${groupKey}/${monitorId}`;
+      baseResponse.liveHlsUrl = `${baseUrl}/${apiKey}/hls/${groupKey}/${monitorId}/s.m3u8`;
+      baseResponse.snapshotUrl = `${baseUrl}/${apiKey}/jpeg/${groupKey}/${monitorId}/s.jpg`;
+    }
+
+    return res.status(200).json({ success: true, data: baseResponse });
+  }
+
+  // Other providers not implemented yet: keep the base contract.
+  return res.status(200).json({ success: true, data: baseResponse });
+};
+
diff --git a/event-monitoring-mvp/backend/src/controllers/eventController.ts b/event-monitoring-mvp/backend/src/controllers/eventController.ts
index 8663def..48748e8 100644
--- a/event-monitoring-mvp/backend/src/controllers/eventController.ts
+++ b/event-monitoring-mvp/backend/src/controllers/eventController.ts
@@ -1,469 +1,469 @@
-import { Request, Response } from 'express';
-import { body, query, validationResult } from 'express-validator';
-import { Event, IEvent } from '../models/Event';
-import mongoose from 'mongoose';
-
-// Validation rules for creating events
-export const createEventValidation = [
-  body('title')
-    .trim()
-    .notEmpty()
-    .withMessage('Event title is required')
-    .isLength({ min: 3, max: 200 })
-    .withMessage('Title must be between 3 and 200 characters'),
-
-  body('description')
-    .optional()
-    .trim()
-    .isLength({ max: 2000 })
-    .withMessage('Description must be less than 2000 characters'),
-
-  body('type')
-    .isIn(['security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 'user_report', 'system_alert', 'motion_detected', 'person_detected', 'vehicle_detected', 'unauthorized_access', 'suspicious_activity', 'other'])
-    .withMessage('Invalid event type'),
-
-  body('severity')
-    .isIn(['low', 'medium', 'high', 'critical', 'emergency'])
-    .withMessage('Invalid severity level'),
-
-  body('priority')
-    .optional()
-    .isInt({ min: 1, max: 5 })
-    .withMessage('Priority must be between 1 and 5'),
-
-  body('location.coordinates')
-    .isArray({ min: 2, max: 2 })
-    .withMessage('Coordinates must be an array of [longitude, latitude]')
-    .custom((value) => {
-      const [lng, lat] = value;
-      if (typeof lng !== 'number' || typeof lat !== 'number') {
-        throw new Error('Coordinates must be numbers');
-      }
-      if (lng < -180 || lng > 180 || lat < -90 || lat > 90) {
-        throw new Error('Invalid coordinate ranges');
-      }
-      return true;
-    }),
-
-  body('location.address')
-    .optional()
-    .trim()
-    .isLength({ max: 500 })
-    .withMessage('Address must be less than 500 characters'),
-
-  body('cameraId')
-    .optional()
-    .isMongoId()
-    .withMessage('Invalid camera ID'),
-
-  body('detectionId')
-    .optional()
-    .isMongoId()
-    .withMessage('Invalid detection ID'),
-
-  body('reporter.name')
-    .optional()
-    .trim()
-    .isLength({ max: 100 })
-    .withMessage('Reporter name must be less than 100 characters'),
-
-  body('reporter.email')
-    .optional()
-    .isEmail()
-    .withMessage('Invalid email address'),
-
-  body('tags')
-    .optional()
-    .isArray()
-    .withMessage('Tags must be an array'),
-
-  body('source')
-    .optional()
-    .isIn(['camera_system', 'user_report', 'ai_detection', 'sensor_alert', 'manual_entry', 'mobile_app'])
-    .withMessage('Invalid source'),
-];
-
-// Create a new event
-export const createEvent = async (req: Request, res: Response) => {
-  try {
-    // Check validation errors
-    const errors = validationResult(req);
-    if (!errors.isEmpty()) {
-      return res.status(400).json({
-        success: false,
-        message: 'Validation failed',
-        errors: errors.array()
-      });
-    }
-
-    const {
-      title,
-      description,
-      type,
-      severity,
-      priority = 3,
-      location,
-      cameraId,
-      detectionId,
-      detectionData,
-      media,
-      reporter,
-      tags = [],
-      source = 'user_report',
-      publiclyVisible = false,
-      customFields
-    } = req.body;
-
-    // Set reporter information
-    const reporterData = {
-      userId: req.user?.id, // From auth middleware
-      name: reporter?.name,
-      email: reporter?.email,
-      phone: reporter?.phone,
-      isAnonymous: reporter?.isAnonymous || false
-    };
-
-    const eventData: Partial<IEvent> = {
-      title,
-      description,
-      type,
-      severity,
-      priority,
-      location,
-      cameraId: cameraId ? new mongoose.Types.ObjectId(cameraId) : undefined,
-      detectionId: detectionId ? new mongoose.Types.ObjectId(detectionId) : undefined,
-      detectionData,
-      media: {
-        images: media?.images || [],
-        videos: media?.videos || [],
-        thumbnails: media?.thumbnails || [],
-        attachments: media?.attachments || []
-      },
-      reporter: reporterData,
-      tags,
-      source,
-      publiclyVisible,
-      customFields: customFields ? new Map(Object.entries(customFields)) : new Map(),
-      status: 'pending',
-      verified: false
-    };
-
-    const event = new Event(eventData);
-    const savedEvent = await event.save();
-
-    // Populate references for response
-    await savedEvent.populate([
-      { path: 'cameraId', select: 'name location' },
-      { path: 'assignedTo', select: 'username email' },
-      { path: 'reporter.userId', select: 'username email' }
-    ]);
-
-    res.status(201).json({
-      success: true,
-      message: 'Event created successfully',
-      data: savedEvent
-    });
-
-  } catch (error: any) {
-    console.error('Create event error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Failed to create event',
-      error: error.message
-    });
-  }
-};
-
-// @desc    Get all events with filtering, pagination, and search
-// @route   GET /api/events
-// @access  Private
-export const getEvents = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const page = parseInt(req.query.page as string) || 1;
-    const limit = parseInt(req.query.limit as string) || 10;
-    const skip = (page - 1) * limit;
-
-    // Build query filters
-    const filter: any = {};
-
-    // Add other filters as needed
-    if (req.query.status) {
-      filter.status = req.query.status;
-    }
-
-    if (req.query.severity) {
-      filter.severity = req.query.severity;
-    }
-
-    const events = await Event.find(filter)
-      .populate('cameraId', 'name location')
-      .populate('assignedTo', 'username email')
-      .sort({ createdAt: -1 })
-      .skip(skip)
-      .limit(limit);
-
-    const total = await Event.countDocuments(filter);
-    const pageNum = page;
-    const limitNum = limit;
-
-    res.json({
-      success: true,
-      count: events.length,
-      total,
-      page: pageNum,
-      pages: Math.ceil(total / limitNum),
-      data: events,
-    });
-  } catch (error) {
-    console.error('Get events error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Get single event
-// @route   GET /api/events/:id
-// @access  Private
-export const getEvent = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const event = await Event.findById(req.params.id).populate('camera', 'name description');
-
-    if (!event) {
-      res.status(404).json({
-        success: false,
-        message: 'Event not found',
-      });
-      return;
-    }
-
-    res.json({
-      success: true,
-      data: event,
-    });
-  } catch (error) {
-    console.error('Get event error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Update event
-// @route   PUT /api/events/:id
-// @access  Private
-export const updateEvent = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const event = await Event.findById(req.params.id);
-
-    if (!event) {
-      res.status(404).json({
-        success: false,
-        message: 'Event not found',
-      });
-      return;
-    }
-
-    const updatedEvent = await Event.findByIdAndUpdate(
-      req.params.id,
-      req.body,
-      { new: true, runValidators: true }
-    ).populate('camera', 'name');
-
-    res.json({
-      success: true,
-      data: updatedEvent,
-    });
-  } catch (error) {
-    console.error('Update event error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Delete event
-// @route   DELETE /api/events/:id
-// @access  Private (Admin only)
-export const deleteEvent = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const event = await Event.findById(req.params.id);
-
-    if (!event) {
-      res.status(404).json({
-        success: false,
-        message: 'Event not found',
-      });
-      return;
-    }
-
-    await Event.findByIdAndDelete(req.params.id);
-
-    res.json({
-      success: true,
-      message: 'Event deleted successfully',
-    });
-  } catch (error) {
-    console.error('Delete event error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Update event status
-// @route   PATCH /api/events/:id/status
-// @access  Private
-export const updateEventStatus = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { status, notes } = req.body;
-    const event = await Event.findById(req.params.id);
-
-    if (!event) {
-      res.status(404).json({
-        success: false,
-        message: 'Event not found',
-      });
-      return;
-    }
-
-    // Update status and related fields
-    event.status = status;
-    if (notes) event.notes = notes;
-    
-    // Set timestamps based on status
-    switch (status) {
-      case 'acknowledged':
-        event.acknowledgedAt = new Date();
-        event.acknowledgedBy = req.user?.userId;
-        break;
-      case 'investigating':
-        if (!event.acknowledgedAt) {
-          event.acknowledgedAt = new Date();
-          event.acknowledgedBy = req.user?.userId;
-        }
-        break;
-      case 'resolved':
-        event.resolvedAt = new Date();
-        event.resolvedBy = req.user?.userId;
-        break;
-      case 'closed':
-        if (!event.resolvedAt) {
-          event.resolvedAt = new Date();
-          event.resolvedBy = req.user?.userId;
-        }
-        break;
-    }
-
-    await event.save();
-
-    const updatedEvent = await Event.findById(event._id).populate('camera', 'name');
-
-    res.json({
-      success: true,
-      data: updatedEvent,
-    });
-  } catch (error) {
-    console.error('Update event status error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Get event statistics
-// @route   GET /api/events/stats
-// @access  Private
-export const getEventStats = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { period = '24h' } = req.query;
-
-    // Calculate date range
-    let startDate = new Date();
-    switch (period) {
-      case '1h':
-        startDate.setHours(startDate.getHours() - 1);
-        break;
-      case '24h':
-        startDate.setDate(startDate.getDate() - 1);
-        break;
-      case '7d':
-        startDate.setDate(startDate.getDate() - 7);
-        break;
-      case '30d':
-        startDate.setDate(startDate.getDate() - 30);
-        break;
-      default:
-        startDate.setDate(startDate.getDate() - 1);
-    }
-
-    // Aggregate statistics
-    const stats = await Event.aggregate([
-      {
-        $match: {
-          timestamp: { $gte: startDate },
-        },
-      },
-      {
-        $group: {
-          _id: null,
-          total: { $sum: 1 },
-          byStatus: {
-            $push: '$status',
-          },
-          bySeverity: {
-            $push: '$severity',
-          },
-          byType: {
-            $push: '$type',
-          },
-        },
-      },
-    ]);
-
-    const result = stats[0] || {
-      total: 0,
-      byStatus: [],
-      bySeverity: [],
-      byType: [],
-    };
-
-    // Count by categories
-    const statusCounts = result.byStatus.reduce((acc: any, status: string) => {
-      acc[status] = (acc[status] || 0) + 1;
-      return acc;
-    }, {});
-
-    const severityCounts = result.bySeverity.reduce((acc: any, severity: string) => {
-      acc[severity] = (acc[severity] || 0) + 1;
-      return acc;
-    }, {});
-
-    const typeCounts = result.byType.reduce((acc: any, type: string) => {
-      acc[type] = (acc[type] || 0) + 1;
-      return acc;
-    }, {});
-
-    res.json({
-      success: true,
-      data: {
-        period,
-        total: result.total,
-        byStatus: statusCounts,
-        bySeverity: severityCounts,
-        byType: typeCounts,
-      },
-    });
-  } catch (error) {
-    console.error('Get event stats error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
+import { Request, Response } from 'express';
+import { body, query, validationResult } from 'express-validator';
+import { Event, IEvent } from '../models/Event';
+import mongoose from 'mongoose';
+
+// Validation rules for creating events
+export const createEventValidation = [
+  body('title')
+    .trim()
+    .notEmpty()
+    .withMessage('Event title is required')
+    .isLength({ min: 3, max: 200 })
+    .withMessage('Title must be between 3 and 200 characters'),
+
+  body('description')
+    .optional()
+    .trim()
+    .isLength({ max: 2000 })
+    .withMessage('Description must be less than 2000 characters'),
+
+  body('type')
+    .isIn(['security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 'user_report', 'system_alert', 'motion_detected', 'person_detected', 'vehicle_detected', 'unauthorized_access', 'suspicious_activity', 'other'])
+    .withMessage('Invalid event type'),
+
+  body('severity')
+    .isIn(['low', 'medium', 'high', 'critical', 'emergency'])
+    .withMessage('Invalid severity level'),
+
+  body('priority')
+    .optional()
+    .isInt({ min: 1, max: 5 })
+    .withMessage('Priority must be between 1 and 5'),
+
+  body('location.coordinates')
+    .isArray({ min: 2, max: 2 })
+    .withMessage('Coordinates must be an array of [longitude, latitude]')
+    .custom((value) => {
+      const [lng, lat] = value;
+      if (typeof lng !== 'number' || typeof lat !== 'number') {
+        throw new Error('Coordinates must be numbers');
+      }
+      if (lng < -180 || lng > 180 || lat < -90 || lat > 90) {
+        throw new Error('Invalid coordinate ranges');
+      }
+      return true;
+    }),
+
+  body('location.address')
+    .optional()
+    .trim()
+    .isLength({ max: 500 })
+    .withMessage('Address must be less than 500 characters'),
+
+  body('cameraId')
+    .optional()
+    .isMongoId()
+    .withMessage('Invalid camera ID'),
+
+  body('detectionId')
+    .optional()
+    .isMongoId()
+    .withMessage('Invalid detection ID'),
+
+  body('reporter.name')
+    .optional()
+    .trim()
+    .isLength({ max: 100 })
+    .withMessage('Reporter name must be less than 100 characters'),
+
+  body('reporter.email')
+    .optional()
+    .isEmail()
+    .withMessage('Invalid email address'),
+
+  body('tags')
+    .optional()
+    .isArray()
+    .withMessage('Tags must be an array'),
+
+  body('source')
+    .optional()
+    .isIn(['camera_system', 'user_report', 'ai_detection', 'sensor_alert', 'manual_entry', 'mobile_app'])
+    .withMessage('Invalid source'),
+];
+
+// Create a new event
+export const createEvent = async (req: Request, res: Response) => {
+  try {
+    // Check validation errors
+    const errors = validationResult(req);
+    if (!errors.isEmpty()) {
+      return res.status(400).json({
+        success: false,
+        message: 'Validation failed',
+        errors: errors.array()
+      });
+    }
+
+    const {
+      title,
+      description,
+      type,
+      severity,
+      priority = 3,
+      location,
+      cameraId,
+      detectionId,
+      detectionData,
+      media,
+      reporter,
+      tags = [],
+      source = 'user_report',
+      publiclyVisible = false,
+      customFields
+    } = req.body;
+
+    // Set reporter information
+    const reporterData = {
+      userId: req.user?.id, // From auth middleware
+      name: reporter?.name,
+      email: reporter?.email,
+      phone: reporter?.phone,
+      isAnonymous: reporter?.isAnonymous || false
+    };
+
+    const eventData: Partial<IEvent> = {
+      title,
+      description,
+      type,
+      severity,
+      priority,
+      location,
+      cameraId: cameraId ? new mongoose.Types.ObjectId(cameraId) : undefined,
+      detectionId: detectionId ? new mongoose.Types.ObjectId(detectionId) : undefined,
+      detectionData,
+      media: {
+        images: media?.images || [],
+        videos: media?.videos || [],
+        thumbnails: media?.thumbnails || [],
+        attachments: media?.attachments || []
+      },
+      reporter: reporterData,
+      tags,
+      source,
+      publiclyVisible,
+      customFields: customFields ? new Map(Object.entries(customFields)) : new Map(),
+      status: 'pending',
+      verified: false
+    };
+
+    const event = new Event(eventData);
+    const savedEvent = await event.save();
+
+    // Populate references for response
+    await savedEvent.populate([
+      { path: 'cameraId', select: 'name location' },
+      { path: 'assignedTo', select: 'username email' },
+      { path: 'reporter.userId', select: 'username email' }
+    ]);
+
+    res.status(201).json({
+      success: true,
+      message: 'Event created successfully',
+      data: savedEvent
+    });
+
+  } catch (error: any) {
+    console.error('Create event error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Failed to create event',
+      error: error.message
+    });
+  }
+};
+
+// @desc    Get all events with filtering, pagination, and search
+// @route   GET /api/events
+// @access  Private
+export const getEvents = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const page = parseInt(req.query.page as string) || 1;
+    const limit = parseInt(req.query.limit as string) || 10;
+    const skip = (page - 1) * limit;
+
+    // Build query filters
+    const filter: any = {};
+
+    // Add other filters as needed
+    if (req.query.status) {
+      filter.status = req.query.status;
+    }
+
+    if (req.query.severity) {
+      filter.severity = req.query.severity;
+    }
+
+    const events = await Event.find(filter)
+      .populate('cameraId', 'name location')
+      .populate('assignedTo', 'username email')
+      .sort({ createdAt: -1 })
+      .skip(skip)
+      .limit(limit);
+
+    const total = await Event.countDocuments(filter);
+    const pageNum = page;
+    const limitNum = limit;
+
+    res.json({
+      success: true,
+      count: events.length,
+      total,
+      page: pageNum,
+      pages: Math.ceil(total / limitNum),
+      data: events,
+    });
+  } catch (error) {
+    console.error('Get events error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Get single event
+// @route   GET /api/events/:id
+// @access  Private
+export const getEvent = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const event = await Event.findById(req.params.id).populate('camera', 'name description');
+
+    if (!event) {
+      res.status(404).json({
+        success: false,
+        message: 'Event not found',
+      });
+      return;
+    }
+
+    res.json({
+      success: true,
+      data: event,
+    });
+  } catch (error) {
+    console.error('Get event error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Update event
+// @route   PUT /api/events/:id
+// @access  Private
+export const updateEvent = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const event = await Event.findById(req.params.id);
+
+    if (!event) {
+      res.status(404).json({
+        success: false,
+        message: 'Event not found',
+      });
+      return;
+    }
+
+    const updatedEvent = await Event.findByIdAndUpdate(
+      req.params.id,
+      req.body,
+      { new: true, runValidators: true }
+    ).populate('camera', 'name');
+
+    res.json({
+      success: true,
+      data: updatedEvent,
+    });
+  } catch (error) {
+    console.error('Update event error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Delete event
+// @route   DELETE /api/events/:id
+// @access  Private (Admin only)
+export const deleteEvent = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const event = await Event.findById(req.params.id);
+
+    if (!event) {
+      res.status(404).json({
+        success: false,
+        message: 'Event not found',
+      });
+      return;
+    }
+
+    await Event.findByIdAndDelete(req.params.id);
+
+    res.json({
+      success: true,
+      message: 'Event deleted successfully',
+    });
+  } catch (error) {
+    console.error('Delete event error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Update event status
+// @route   PATCH /api/events/:id/status
+// @access  Private
+export const updateEventStatus = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { status, notes } = req.body;
+    const event = await Event.findById(req.params.id);
+
+    if (!event) {
+      res.status(404).json({
+        success: false,
+        message: 'Event not found',
+      });
+      return;
+    }
+
+    // Update status and related fields
+    event.status = status;
+    if (notes) event.notes = notes;
+    
+    // Set timestamps based on status
+    switch (status) {
+      case 'acknowledged':
+        event.acknowledgedAt = new Date();
+        event.acknowledgedBy = req.user?.userId;
+        break;
+      case 'investigating':
+        if (!event.acknowledgedAt) {
+          event.acknowledgedAt = new Date();
+          event.acknowledgedBy = req.user?.userId;
+        }
+        break;
+      case 'resolved':
+        event.resolvedAt = new Date();
+        event.resolvedBy = req.user?.userId;
+        break;
+      case 'closed':
+        if (!event.resolvedAt) {
+          event.resolvedAt = new Date();
+          event.resolvedBy = req.user?.userId;
+        }
+        break;
+    }
+
+    await event.save();
+
+    const updatedEvent = await Event.findById(event._id).populate('camera', 'name');
+
+    res.json({
+      success: true,
+      data: updatedEvent,
+    });
+  } catch (error) {
+    console.error('Update event status error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Get event statistics
+// @route   GET /api/events/stats
+// @access  Private
+export const getEventStats = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { period = '24h' } = req.query;
+
+    // Calculate date range
+    let startDate = new Date();
+    switch (period) {
+      case '1h':
+        startDate.setHours(startDate.getHours() - 1);
+        break;
+      case '24h':
+        startDate.setDate(startDate.getDate() - 1);
+        break;
+      case '7d':
+        startDate.setDate(startDate.getDate() - 7);
+        break;
+      case '30d':
+        startDate.setDate(startDate.getDate() - 30);
+        break;
+      default:
+        startDate.setDate(startDate.getDate() - 1);
+    }
+
+    // Aggregate statistics
+    const stats = await Event.aggregate([
+      {
+        $match: {
+          timestamp: { $gte: startDate },
+        },
+      },
+      {
+        $group: {
+          _id: null,
+          total: { $sum: 1 },
+          byStatus: {
+            $push: '$status',
+          },
+          bySeverity: {
+            $push: '$severity',
+          },
+          byType: {
+            $push: '$type',
+          },
+        },
+      },
+    ]);
+
+    const result = stats[0] || {
+      total: 0,
+      byStatus: [],
+      bySeverity: [],
+      byType: [],
+    };
+
+    // Count by categories
+    const statusCounts = result.byStatus.reduce((acc: any, status: string) => {
+      acc[status] = (acc[status] || 0) + 1;
+      return acc;
+    }, {});
+
+    const severityCounts = result.bySeverity.reduce((acc: any, severity: string) => {
+      acc[severity] = (acc[severity] || 0) + 1;
+      return acc;
+    }, {});
+
+    const typeCounts = result.byType.reduce((acc: any, type: string) => {
+      acc[type] = (acc[type] || 0) + 1;
+      return acc;
+    }, {});
+
+    res.json({
+      success: true,
+      data: {
+        period,
+        total: result.total,
+        byStatus: statusCounts,
+        bySeverity: severityCounts,
+        byType: typeCounts,
+      },
+    });
+  } catch (error) {
+    console.error('Get event stats error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/controllers/mobileController.ts b/event-monitoring-mvp/backend/src/controllers/mobileController.ts
new file mode 100644
index 0000000..b0b1da4
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/controllers/mobileController.ts
@@ -0,0 +1,438 @@
+import { Response } from 'express';
+import mongoose from 'mongoose';
+import {
+  MobileAuthenticatedRequest,
+  CompanyValidateResponse,
+  VerifyFRRequest,
+  VerifyFRResponse,
+  EventTypesResponse,
+  CreateReportRequest,
+  CreateReportResponse,
+  GetReportsQuery,
+  GetReportsResponse,
+  ReportDetailResponse
+} from '../types/mobile';
+import { FirstResponder } from '../models/FirstResponder';
+import { EventType } from '../models/EventType';
+import { Event } from '../models/Event';
+import { Company } from '../models/Company';
+
+/**
+ * POST /api/mobile/auth/company-validate
+ * Validates company API credentials
+ */
+export const validateCompany = async (
+  req: MobileAuthenticatedRequest,
+  res: Response
+): Promise<void> => {
+  // Company already validated by middleware
+  const response: CompanyValidateResponse = {
+    valid: true,
+    company: req.company
+  };
+
+  res.status(200).json(response);
+};
+
+/**
+ * POST /api/mobile/auth/verify-fr
+ * Checks if phone number belongs to a First Responder
+ */
+export const verifyFR = async (
+  req: MobileAuthenticatedRequest,
+  res: Response
+): Promise<void> => {
+  try {
+    const { phone } = req.body as VerifyFRRequest;
+
+    if (!phone) {
+      res.status(400).json({
+        success: false,
+        message: 'Phone number is required'
+      });
+      return;
+    }
+
+    // Query FirstResponder by phone
+    const fr = await FirstResponder.findOne({ phone, isActive: true });
+
+    if (!fr) {
+      const response: VerifyFRResponse = {
+        isFR: false
+      };
+      res.status(200).json(response);
+      return;
+    }
+
+    const response: VerifyFRResponse = {
+      isFR: true,
+      frId: fr.frId,
+      name: fr.name,
+      role: fr.role
+    };
+
+    res.status(200).json(response);
+  } catch (error) {
+    console.error('Verify FR error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Error verifying first responder'
+    });
+  }
+};
+
+/**
+ * GET /api/mobile/event-types
+ * Returns available event types for the company
+ */
+export const getEventTypes = async (
+  req: MobileAuthenticatedRequest,
+  res: Response
+): Promise<void> => {
+  try {
+    // Get company from middleware
+    const companyId = req.company?.id;
+
+    // Find company ObjectId
+    const company = await Company.findOne({ companyId });
+
+    // Query event types (global or company-specific)
+    const eventTypes = await EventType.find({
+      isActive: true,
+      $or: [
+        { isGlobal: true },
+        { companyId: company?._id }
+      ]
+    }).select('typeId name severity');
+
+    const response: EventTypesResponse = {
+      eventTypes: eventTypes.map(et => ({
+        id: et.typeId,
+        name: et.name,
+        severity: et.severity
+      }))
+    };
+
+    res.status(200).json(response);
+  } catch (error) {
+    console.error('Get event types error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Error fetching event types'
+    });
+  }
+};
+
+/**
+ * Helper function to auto-add unknown taxonomy values
+ */
+const ensureEventTypeExists = async (
+  typeName: string,
+  severity: string,
+  companyId?: mongoose.Types.ObjectId
+): Promise<void> => {
+  const existing = await EventType.findOne({ name: typeName });
+  if (!existing) {
+    const newEventType = new EventType({
+      typeId: 'et_' + Date.now(),
+      name: typeName,
+      severity: severity || 'medium',
+      companyId,
+      isGlobal: false,
+      isActive: true
+    });
+    await newEventType.save();
+  }
+};
+
+/**
+ * Helper function to map severity to priority
+ */
+const severityToPriority = (severity: string): 1 | 2 | 3 | 4 | 5 => {
+  const mapping: Record<string, 1 | 2 | 3 | 4 | 5> = {
+    'emergency': 1,
+    'critical': 1,
+    'high': 2,
+    'medium': 3,
+    'low': 4
+  };
+  return mapping[severity.toLowerCase()] || 3;
+};
+
+/**
+ * POST /api/mobile/reports
+ * Creates a new incident report
+ */
+export const createReport = async (
+  req: MobileAuthenticatedRequest,
+  res: Response
+): Promise<void> => {
+  try {
+    const reportData = req.body as CreateReportRequest;
+
+    // Basic validation
+    if (!reportData.phone || !reportData.type || !reportData.location) {
+      res.status(400).json({
+        success: false,
+        message: 'Missing required fields: phone, type, and location are required'
+      });
+      return;
+    }
+
+    if (reportData.location.latitude === undefined || reportData.location.longitude === undefined) {
+      res.status(400).json({
+        success: false,
+        message: 'Location must include latitude and longitude'
+      });
+      return;
+    }
+
+    // Check if phone belongs to FR
+    const fr = await FirstResponder.findOne({ phone: reportData.phone, isActive: true });
+    const reporterType: 'FR' | 'CIVILIAN' = fr ? 'FR' : 'CIVILIAN';
+
+    // Get company ObjectId
+    const company = await Company.findOne({ companyId: req.company?.id });
+
+    // Auto-add unknown taxonomy values
+    await ensureEventTypeExists(reportData.type, reportData.severity || 'medium', company?._id);
+
+    // Validate severity
+    const validSeverities = ['low', 'medium', 'high', 'critical', 'emergency'];
+    const severity = validSeverities.includes(reportData.severity?.toLowerCase())
+      ? reportData.severity.toLowerCase() as 'low' | 'medium' | 'high' | 'critical' | 'emergency'
+      : 'medium';
+
+    // Create Event
+    const event = new Event({
+      title: `${reportData.type} - Mobile Report`,
+      description: reportData.description || '',
+      type: reportData.type,
+      subType: reportData.subType,
+      severity,
+      priority: severityToPriority(severity),
+      status: 'pending',
+      location: {
+        coordinates: [reportData.location.longitude, reportData.location.latitude]
+      },
+      media: {
+        images: reportData.media?.images || [],
+        videos: reportData.media?.videos || [],
+        thumbnails: [],
+        attachments: []
+      },
+      reporter: {
+        phone: reportData.phone,
+        name: fr?.name,
+        isAnonymous: false,
+        reporterType
+      },
+      source: 'mobile_app',
+      companyId: company?._id,
+      verified: false,
+      publiclyVisible: false,
+      tags: [],
+      notes: [],
+      workflow: [{
+        status: 'pending',
+        timestamp: new Date()
+      }],
+      resolution: {
+        actions: [],
+        preventiveMeasures: [],
+        followUpRequired: false
+      }
+    });
+
+    const savedEvent = await event.save();
+
+    const response: CreateReportResponse = {
+      success: true,
+      reportId: savedEvent._id.toString(),
+      reporterType
+    };
+
+    res.status(201).json(response);
+  } catch (error) {
+    console.error('Create report error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Error creating report'
+    });
+  }
+};
+
+/**
+ * GET /api/mobile/reports/my
+ * Returns user's own submitted reports
+ */
+export const getMyReports = async (
+  req: MobileAuthenticatedRequest,
+  res: Response
+): Promise<void> => {
+  try {
+    const query = req.query as unknown as GetReportsQuery;
+    const limit = Math.min(Number(query.limit) || 50, 100);
+    const offset = Number(query.offset) || 0;
+
+    // Get phone from query (required for filtering user's reports)
+    const phone = req.query.phone as string;
+
+    if (!phone) {
+      res.status(400).json({
+        success: false,
+        message: 'Phone number is required to fetch reports'
+      });
+      return;
+    }
+
+    // Build filter
+    const filter: Record<string, any> = {
+      source: 'mobile_app',
+      'reporter.phone': phone
+    };
+
+    // Add optional filters
+    if (query.status) {
+      filter.status = query.status;
+    }
+    if (query.type) {
+      filter.type = query.type;
+    }
+    if (query.severity) {
+      filter.severity = query.severity.toLowerCase();
+    }
+    if (query.date) {
+      const date = new Date(query.date);
+      const nextDay = new Date(date);
+      nextDay.setDate(nextDay.getDate() + 1);
+      filter.createdAt = {
+        $gte: date,
+        $lt: nextDay
+      };
+    }
+
+    // Get total count
+    const total = await Event.countDocuments(filter);
+
+    // Get reports
+    const events = await Event.find(filter)
+      .sort({ createdAt: -1 })
+      .skip(offset)
+      .limit(limit)
+      .select('type subType severity status description location createdAt');
+
+    const reports = events.map(event => ({
+      id: event._id.toString(),
+      type: event.type,
+      subType: event.subType,
+      severity: event.severity,
+      status: event.status,
+      description: event.description,
+      location: {
+        latitude: event.location.coordinates[1],
+        longitude: event.location.coordinates[0]
+      },
+      createdAt: event.createdAt.toISOString()
+    }));
+
+    const response: GetReportsResponse = {
+      reports,
+      pagination: {
+        total,
+        limit,
+        offset,
+        hasMore: offset + reports.length < total
+      }
+    };
+
+    res.status(200).json(response);
+  } catch (error) {
+    console.error('Get my reports error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Error fetching reports'
+    });
+  }
+};
+
+/**
+ * GET /api/mobile/reports/:id
+ * Returns specific report details (own reports only)
+ */
+export const getReportById = async (
+  req: MobileAuthenticatedRequest,
+  res: Response
+): Promise<void> => {
+  try {
+    const { id } = req.params;
+    const phone = req.query.phone as string;
+
+    if (!id) {
+      res.status(400).json({
+        success: false,
+        message: 'Report ID is required'
+      });
+      return;
+    }
+
+    // Validate ObjectId
+    if (!mongoose.Types.ObjectId.isValid(id)) {
+      res.status(400).json({
+        success: false,
+        message: 'Invalid report ID format'
+      });
+      return;
+    }
+
+    // Find event
+    const event = await Event.findById(id);
+
+    if (!event) {
+      res.status(404).json({
+        success: false,
+        message: 'Report not found'
+      });
+      return;
+    }
+
+    // Verify ownership (only allow access to own reports)
+    if (phone && event.reporter.phone !== phone) {
+      res.status(403).json({
+        success: false,
+        message: 'Access denied. You can only view your own reports.'
+      });
+      return;
+    }
+
+    const response: ReportDetailResponse = {
+      report: {
+        id: event._id.toString(),
+        type: event.type,
+        subType: event.subType,
+        severity: event.severity,
+        status: event.status,
+        description: event.description,
+        location: {
+          latitude: event.location.coordinates[1],
+          longitude: event.location.coordinates[0]
+        },
+        media: {
+          images: event.media?.images || [],
+          videos: event.media?.videos || []
+        },
+        reporterType: event.reporter.reporterType || 'CIVILIAN',
+        createdAt: event.createdAt.toISOString(),
+        updatedAt: event.updatedAt.toISOString()
+      }
+    };
+
+    res.status(200).json(response);
+  } catch (error) {
+    console.error('Get report by ID error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Error fetching report'
+    });
+  }
+};
diff --git a/event-monitoring-mvp/backend/src/controllers/userController.ts b/event-monitoring-mvp/backend/src/controllers/userController.ts
index c03bc94..5fcd761 100644
--- a/event-monitoring-mvp/backend/src/controllers/userController.ts
+++ b/event-monitoring-mvp/backend/src/controllers/userController.ts
@@ -1,216 +1,216 @@
-import { Request, Response } from 'express';
-import { User } from '../models/User';
-
-// @desc    Get all users
-// @route   GET /api/users
-// @access  Private (Admin only)
-export const getUsers = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const users = await User.find().select('-password').sort({ createdAt: -1 });
-    
-    res.json({
-      success: true,
-      count: users.length,
-      data: users,
-    });
-  } catch (error) {
-    console.error('Get users error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Get single user
-// @route   GET /api/users/:id
-// @access  Private (Admin only)
-export const getUser = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const user = await User.findById(req.params.id).select('-password');
-
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    res.json({
-      success: true,
-      data: user,
-    });
-  } catch (error) {
-    console.error('Get user error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Create user
-// @route   POST /api/users
-// @access  Private (Admin only)
-export const createUser = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { username, email, password, role } = req.body;
-
-    // Check if user exists
-    const existingUser = await User.findOne({
-      $or: [{ email }, { username }],
-    });
-
-    if (existingUser) {
-      res.status(400).json({
-        success: false,
-        message: 'User already exists',
-      });
-      return;
-    }
-
-    const user = await User.create({
-      username,
-      email,
-      password, // Will be hashed by pre-save hook
-      role: role || 'operator',
-    });
-
-    res.status(201).json({
-      success: true,
-      data: {
-        id: user._id,
-        username: user.username,
-        email: user.email,
-        role: user.role,
-        createdAt: user.createdAt,
-      },
-    });
-  } catch (error) {
-    console.error('Create user error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Update user
-// @route   PUT /api/users/:id
-// @access  Private (Admin only)
-export const updateUser = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const user = await User.findById(req.params.id);
-
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    const updatedUser = await User.findByIdAndUpdate(
-      req.params.id,
-      req.body,
-      { new: true, runValidators: true }
-    ).select('-password');
-
-    res.json({
-      success: true,
-      data: updatedUser,
-    });
-  } catch (error) {
-    console.error('Update user error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Delete user
-// @route   DELETE /api/users/:id
-// @access  Private (Admin only)
-export const deleteUser = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const user = await User.findById(req.params.id);
-
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    // Prevent self-deletion
-    if (req.user?.userId === req.params.id) {
-      res.status(400).json({
-        success: false,
-        message: 'Cannot delete your own account',
-      });
-      return;
-    }
-
-    await User.findByIdAndDelete(req.params.id);
-
-    res.json({
-      success: true,
-      message: 'User deleted successfully',
-    });
-  } catch (error) {
-    console.error('Delete user error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
-};
-
-// @desc    Update user role
-// @route   PATCH /api/users/:id/role
-// @access  Private (Admin only)
-export const updateUserRole = async (req: Request, res: Response): Promise<void> => {
-  try {
-    const { role } = req.body;
-    const user = await User.findById(req.params.id);
-
-    if (!user) {
-      res.status(404).json({
-        success: false,
-        message: 'User not found',
-      });
-      return;
-    }
-
-    // Prevent changing own role
-    if (req.user?.userId === req.params.id) {
-      res.status(400).json({
-        success: false,
-        message: 'Cannot change your own role',
-      });
-      return;
-    }
-
-    user.role = role;
-    await user.save();
-
-    res.json({
-      success: true,
-      data: {
-        id: user._id,
-        username: user.username,
-        email: user.email,
-        role: user.role,
-      },
-    });
-  } catch (error) {
-    console.error('Update user role error:', error);
-    res.status(500).json({
-      success: false,
-      message: 'Server error',
-    });
-  }
+import { Request, Response } from 'express';
+import { User } from '../models/User';
+
+// @desc    Get all users
+// @route   GET /api/users
+// @access  Private (Admin only)
+export const getUsers = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const users = await User.find().select('-password').sort({ createdAt: -1 });
+    
+    res.json({
+      success: true,
+      count: users.length,
+      data: users,
+    });
+  } catch (error) {
+    console.error('Get users error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Get single user
+// @route   GET /api/users/:id
+// @access  Private (Admin only)
+export const getUser = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const user = await User.findById(req.params.id).select('-password');
+
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    res.json({
+      success: true,
+      data: user,
+    });
+  } catch (error) {
+    console.error('Get user error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Create user
+// @route   POST /api/users
+// @access  Private (Admin only)
+export const createUser = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { username, email, password, role } = req.body;
+
+    // Check if user exists
+    const existingUser = await User.findOne({
+      $or: [{ email }, { username }],
+    });
+
+    if (existingUser) {
+      res.status(400).json({
+        success: false,
+        message: 'User already exists',
+      });
+      return;
+    }
+
+    const user = await User.create({
+      username,
+      email,
+      password, // Will be hashed by pre-save hook
+      role: role || 'operator',
+    });
+
+    res.status(201).json({
+      success: true,
+      data: {
+        id: user._id,
+        username: user.username,
+        email: user.email,
+        role: user.role,
+        createdAt: user.createdAt,
+      },
+    });
+  } catch (error) {
+    console.error('Create user error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Update user
+// @route   PUT /api/users/:id
+// @access  Private (Admin only)
+export const updateUser = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const user = await User.findById(req.params.id);
+
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    const updatedUser = await User.findByIdAndUpdate(
+      req.params.id,
+      req.body,
+      { new: true, runValidators: true }
+    ).select('-password');
+
+    res.json({
+      success: true,
+      data: updatedUser,
+    });
+  } catch (error) {
+    console.error('Update user error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Delete user
+// @route   DELETE /api/users/:id
+// @access  Private (Admin only)
+export const deleteUser = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const user = await User.findById(req.params.id);
+
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    // Prevent self-deletion
+    if (req.user?.userId === req.params.id) {
+      res.status(400).json({
+        success: false,
+        message: 'Cannot delete your own account',
+      });
+      return;
+    }
+
+    await User.findByIdAndDelete(req.params.id);
+
+    res.json({
+      success: true,
+      message: 'User deleted successfully',
+    });
+  } catch (error) {
+    console.error('Delete user error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
+};
+
+// @desc    Update user role
+// @route   PATCH /api/users/:id/role
+// @access  Private (Admin only)
+export const updateUserRole = async (req: Request, res: Response): Promise<void> => {
+  try {
+    const { role } = req.body;
+    const user = await User.findById(req.params.id);
+
+    if (!user) {
+      res.status(404).json({
+        success: false,
+        message: 'User not found',
+      });
+      return;
+    }
+
+    // Prevent changing own role
+    if (req.user?.userId === req.params.id) {
+      res.status(400).json({
+        success: false,
+        message: 'Cannot change your own role',
+      });
+      return;
+    }
+
+    user.role = role;
+    await user.save();
+
+    res.json({
+      success: true,
+      data: {
+        id: user._id,
+        username: user.username,
+        email: user.email,
+        role: user.role,
+      },
+    });
+  } catch (error) {
+    console.error('Update user role error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Server error',
+    });
+  }
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/controllers/vmsController.ts b/event-monitoring-mvp/backend/src/controllers/vmsController.ts
new file mode 100644
index 0000000..48ea0f2
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/controllers/vmsController.ts
@@ -0,0 +1,323 @@
+import { Request, Response } from 'express';
+import http from 'http';
+import https from 'https';
+import { VmsServer } from '../models/VmsServer';
+import { Camera } from '../models/Camera';
+
+/**
+ * VMS Controller
+ *
+ * What this controller does:
+ * - Stores VMS server connection metadata in MongoDB.
+ * - This is the foundation for later:
+ *   - connecting cameras to a VMS (monitor/channel creation)
+ *   - fetching live/playback URLs from the VMS
+ *
+ * What it does NOT do yet:
+ * - It does not call Shinobi/ZoneMinder/etc. APIs yet.
+ *   That will come later via a provider-specific client/adaptor layer.
+ */
+
+// Helper to fetch JSON from a VMS endpoint without extra dependencies.
+const fetchJson = (url: URL, timeoutMs = 5000): Promise<any> =>
+  new Promise((resolve, reject) => {
+    const client = url.protocol === 'https:' ? https : http;
+    const req = client.request(url, { method: 'GET', timeout: timeoutMs }, (resp) => {
+      let data = '';
+      resp.on('data', (chunk) => {
+        data += chunk;
+      });
+      resp.on('end', () => {
+        try {
+          resolve(JSON.parse(data));
+        } catch (error) {
+          reject(new Error('Failed to parse VMS response'));
+        }
+      });
+    });
+
+    req.on('timeout', () => {
+      req.destroy();
+      reject(new Error('VMS request timed out'));
+    });
+    req.on('error', (err) => reject(err));
+    req.end();
+  });
+
+// Normalize Shinobi monitor payloads into a simple array.
+const normalizeMonitors = (data: any[]): any[] => {
+  if (Array.isArray(data)) {
+    return data;
+  }
+
+  if (data && typeof data === 'object') {
+    if (Array.isArray((data as any).monitors)) {
+      return (data as any).monitors;
+    }
+
+    return Object.values(data);
+  }
+
+  return [];
+};
+
+/**
+ * POST /api/vms/servers
+ * Registers a VMS server (Shinobi/ZoneMinder/AgentDVR/etc.)
+ */
+export const createVmsServer = async (req: Request, res: Response) => {
+  const { name, provider, baseUrl, auth } = req.body;
+
+  // Normalize string inputs to avoid invisible whitespace breaking auth URLs.
+  const normalizedBaseUrl = typeof baseUrl === 'string' ? baseUrl.trim() : baseUrl;
+  const normalizedAuth = auth ? {
+    apiKey: typeof auth.apiKey === 'string' ? auth.apiKey.trim() : auth.apiKey,
+    groupKey: typeof auth.groupKey === 'string' ? auth.groupKey.trim() : auth.groupKey,
+    username: typeof auth.username === 'string' ? auth.username.trim() : auth.username,
+    password: typeof auth.password === 'string' ? auth.password.trim() : auth.password,
+  } : auth;
+
+  // Minimal validation (we can expand later / add middleware validation)
+  if (!name || !provider || !normalizedBaseUrl) {
+    return res.status(400).json({
+      success: false,
+      message: 'name, provider and baseUrl are required',
+    });
+  }
+
+  // Provider-specific auth validation (Shinobi requires apiKey + groupKey)
+  if (provider === 'shinobi') {
+    if (!normalizedAuth?.apiKey || !normalizedAuth?.groupKey) {
+      return res.status(400).json({
+        success: false,
+        message: 'Shinobi requires auth.apiKey and auth.groupKey',
+      });
+    }
+  }
+
+  const server = await VmsServer.create({
+    name,
+    provider,
+    baseUrl: normalizedBaseUrl,
+    auth: normalizedAuth,
+    isActive: true,
+  });
+
+  return res.status(201).json({ success: true, data: server });
+};
+
+/**
+ * GET /api/vms/servers
+ * Lists all active VMS servers
+ */
+export const listVmsServers = async (_req: Request, res: Response) => {
+  const servers = await VmsServer.find({ isActive: true }).sort({ createdAt: -1 });
+  return res.status(200).json({ success: true, data: servers });
+};
+
+/**
+ * PATCH /api/vms/servers/:id
+ * Updates VMS server details (including auth for providers like Shinobi)
+ */
+export const updateVmsServer = async (req: Request, res: Response) => {
+  const { id } = req.params;
+  const { name, provider, baseUrl, auth, isActive } = req.body;
+
+  // Normalize string inputs to avoid invisible whitespace breaking auth URLs.
+  const normalizedBaseUrl = typeof baseUrl === 'string' ? baseUrl.trim() : baseUrl;
+  const normalizedAuth = auth ? {
+    apiKey: typeof auth.apiKey === 'string' ? auth.apiKey.trim() : auth.apiKey,
+    groupKey: typeof auth.groupKey === 'string' ? auth.groupKey.trim() : auth.groupKey,
+    username: typeof auth.username === 'string' ? auth.username.trim() : auth.username,
+    password: typeof auth.password === 'string' ? auth.password.trim() : auth.password,
+  } : auth;
+
+  const server = await VmsServer.findById(id);
+
+  if (!server) {
+    return res.status(404).json({ success: false, message: 'VMS server not found' });
+  }
+
+  // Provider-specific auth validation (Shinobi requires apiKey + groupKey)
+  const nextProvider = provider || server.provider;
+  const nextAuth = normalizedAuth || server.auth;
+  if (nextProvider === 'shinobi') {
+    if (!nextAuth?.apiKey || !nextAuth?.groupKey) {
+      return res.status(400).json({
+        success: false,
+        message: 'Shinobi requires auth.apiKey and auth.groupKey',
+      });
+    }
+  }
+
+  // Apply updates (only provided fields)
+  if (name !== undefined) server.name = name;
+  if (provider !== undefined) server.provider = provider;
+  if (normalizedBaseUrl !== undefined) server.baseUrl = normalizedBaseUrl;
+  if (normalizedAuth !== undefined) server.auth = normalizedAuth;
+  if (isActive !== undefined) server.isActive = isActive;
+
+  await server.save();
+
+  return res.status(200).json({ success: true, data: server });
+};
+
+/**
+ * DELETE /api/vms/servers/:id
+ * Soft-removes a VMS server by marking it inactive (preserves history)
+ */
+export const deleteVmsServer = async (req: Request, res: Response) => {
+  const { id } = req.params;
+
+  const server = await VmsServer.findById(id);
+
+  if (!server) {
+    return res.status(404).json({ success: false, message: 'VMS server not found' });
+  }
+
+  // Keep record but disable it so it won't be used for streams.
+  server.isActive = false;
+  await server.save();
+
+  return res.status(200).json({ success: true, data: server });
+};
+
+/**
+ * GET /api/vms/servers/:id/monitors
+ * Lists monitors for a VMS server (Shinobi only for now)
+ */
+export const listVmsMonitors = async (req: Request, res: Response) => {
+  const { id } = req.params;
+
+  const server = await VmsServer.findById(id);
+  if (!server || !server.isActive) {
+    return res.status(404).json({ success: false, message: 'VMS server not found or inactive' });
+  }
+
+  if (server.provider !== 'shinobi') {
+    return res.status(400).json({ success: false, message: 'Monitor discovery supports Shinobi only' });
+  }
+
+  const apiKey = server.auth?.apiKey;
+  const groupKey = server.auth?.groupKey;
+  if (!apiKey || !groupKey) {
+    return res.status(400).json({ success: false, message: 'VMS server missing Shinobi auth keys' });
+  }
+
+  const baseUrl = String(server.baseUrl).replace(/\/+$/, '');
+  const url = new URL(`${baseUrl}/${apiKey}/monitor/${groupKey}`);
+
+  try {
+    const data = await fetchJson(url);
+    const monitors = normalizeMonitors(data);
+    return res.status(200).json({ success: true, data: monitors });
+  } catch (error: any) {
+    return res.status(500).json({ success: false, message: error.message || 'Failed to fetch monitors' });
+  }
+};
+
+/**
+ * POST /api/vms/servers/:id/monitors/import
+ * Batch-import monitors into cameras (maps to camera.vms)
+ */
+export const importVmsMonitors = async (req: Request, res: Response) => {
+  const { id } = req.params;
+  const {
+    monitorIds,
+    defaultLocation,
+    source,
+  } = req.body as {
+    monitorIds?: string[];
+    defaultLocation?: { coordinates: [number, number]; address?: string };
+    source?: string;
+  };
+
+  const userId = (req as any).user?.userId;
+  if (!userId) {
+    return res.status(401).json({ success: false, message: 'Authentication required' });
+  }
+
+  const server = await VmsServer.findById(id);
+  if (!server || !server.isActive) {
+    return res.status(404).json({ success: false, message: 'VMS server not found or inactive' });
+  }
+
+  if (server.provider !== 'shinobi') {
+    return res.status(400).json({ success: false, message: 'Monitor import supports Shinobi only' });
+  }
+
+  const apiKey = server.auth?.apiKey;
+  const groupKey = server.auth?.groupKey;
+  if (!apiKey || !groupKey) {
+    return res.status(400).json({ success: false, message: 'VMS server missing Shinobi auth keys' });
+  }
+
+  const baseUrl = String(server.baseUrl).replace(/\/+$/, '');
+  const url = new URL(`${baseUrl}/${apiKey}/monitor/${groupKey}`);
+
+  let monitors: any[] = [];
+  try {
+    const data = await fetchJson(url);
+    monitors = normalizeMonitors(data);
+  } catch (error: any) {
+    return res.status(500).json({ success: false, message: error.message || 'Failed to fetch monitors' });
+  }
+
+  const selected = monitorIds && monitorIds.length
+    ? monitors.filter((m) => monitorIds.includes(String(m.mid || m.id)))
+    : monitors;
+
+  const existing = await Camera.find({
+    isDeleted: false,
+    'vms.serverId': server._id,
+    'vms.monitorId': { $in: selected.map((m) => String(m.mid || m.id)) },
+  }).select('vms.monitorId');
+
+  const existingIds = new Set(existing.map((c) => String(c.vms?.monitorId)));
+
+  const location = defaultLocation?.coordinates?.length === 2
+    ? defaultLocation
+    : { coordinates: [0, 0] as [number, number], address: 'Imported from VMS' };
+
+  const hlsBase = `${baseUrl}/${apiKey}/hls/${groupKey}`;
+  const payload = selected
+    .filter((m) => !existingIds.has(String(m.mid || m.id)))
+    .map((m) => {
+      const monitorId = String(m.mid || m.id);
+      const rawDescription = String(m.details || 'Imported from VMS');
+      return {
+        name: String(m.name || m.title || `Monitor ${monitorId}`),
+        // TEST-ONLY: truncate to satisfy camera description length validation.
+        description: rawDescription.slice(0, 500),
+        streamUrl: `${hlsBase}/${monitorId}/s.m3u8`,
+        type: 'ip',
+        location: {
+          type: 'Point',
+          coordinates: location.coordinates,
+          address: location.address,
+        },
+        settings: {
+          resolution: '1920x1080',
+          fps: 30,
+          recordingEnabled: false,
+        },
+        metadata: {
+          source: source || 'vms-import',
+        },
+        vms: {
+          provider: server.provider,
+          serverId: server._id,
+          monitorId,
+          lastSyncAt: new Date(),
+        },
+        createdBy: userId,
+      };
+    });
+
+  if (!payload.length) {
+    return res.status(200).json({ success: true, data: [], message: 'No new monitors to import' });
+  }
+
+  const created = await Camera.insertMany(payload);
+  return res.status(201).json({ success: true, data: created });
+};
diff --git a/event-monitoring-mvp/backend/src/middleware/auth.ts b/event-monitoring-mvp/backend/src/middleware/auth.ts
index f3bc6d6..2097312 100644
--- a/event-monitoring-mvp/backend/src/middleware/auth.ts
+++ b/event-monitoring-mvp/backend/src/middleware/auth.ts
@@ -1,48 +1,242 @@
-import { Request, Response, NextFunction } from 'express';
-import jwt from 'jsonwebtoken';
-import { User, IUser } from '../models/User';
-
-interface AuthenticatedRequest extends Request {
-  user?: IUser;
-}
-
-export const auth = async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
-  try {
-    const token = req.header('Authorization')?.replace('Bearer ', '');
-
-    if (!token) {
-      res.status(401).json({ message: 'No token, authorization denied' });
-      return;
-    }
-
-    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as any;
-    const user = await User.findById(decoded.id).select('-password');
-
-    if (!user || !user.isActive) {
-      res.status(401).json({ message: 'Token is not valid' });
-      return;
-    }
-
-    req.user = user;
-    next();
-  } catch (error) {
-    console.error('Auth middleware error:', error);
-    res.status(401).json({ message: 'Token is not valid' });
-  }
-};
-
-export const adminOnly = (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
-  if (req.user?.role !== 'admin') {
-    res.status(403).json({ message: 'Access denied. Admin only.' });
-    return;
-  }
-  next();
-};
-
-export const operatorOrAdmin = (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
-  if (req.user?.role !== 'admin' && req.user?.role !== 'operator') {
-    res.status(403).json({ message: 'Access denied. Insufficient permissions.' });
-    return;
-  }
-  next();
+import { Request, Response, NextFunction } from 'express';
+import jwt from 'jsonwebtoken';
+import { User, IUser } from '../models/User';
+
+interface AuthenticatedRequest extends Request {
+  user?: (IUser & { userId?: string }) | any;
+}
+
+
+/**
+ * Enhanced Authentication Middleware
+ * Validates JWT tokens and loads user with permissions
+ */
+export const auth = async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
+  try {
+    const token = req.header('Authorization')?.replace('Bearer ', '');
+
+    if (!token) {
+      res.status(401).json({ 
+        success: false,
+        message: 'No token provided, authorization denied',
+        requiresAuth: true
+      });
+      return;
+    }
+
+    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as any;
+    const user = await User.findById(decoded.userId)
+      // .populate('permissions.granted', 'name resource actions scope')
+      // .populate('permissions.inherited', 'name resource actions scope')
+      .select('-password -authentication.otpSecret -authentication.recoveryTokens');
+
+    if (!user || !user.isActive) {
+      res.status(401).json({ 
+        success: false,
+        message: 'Token is not valid or user is inactive',
+        requiresAuth: true
+      });
+      return;
+    }
+
+    // Check if account is locked
+    if (user.isLocked) {
+      res.status(423).json({
+        success: false,
+        message: 'Account is temporarily locked',
+        lockoutUntil: user.authentication.lockoutUntil
+      });
+      return;
+    }
+
+    // Add userId for backward compatibility
+    req.user = { ...user.toObject(), userId: user._id.toString() };
+    next();
+  } catch (error) {
+    console.error('Auth middleware error:', error);
+    res.status(401).json({ 
+      success: false,
+      message: 'Token is not valid',
+      requiresAuth: true
+    });
+  }
+};
+
+/**
+ * Role-based authorization middleware
+ */
+export const requireRole = (allowedRoles: string[]) => {
+  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
+    const rawRoles = (req.user?.roles ?? (req.user as any)?.role ?? []);
+    const userRoles: string[] = Array.isArray(rawRoles) ? rawRoles : [rawRoles];
+
+    const allowed = userRoles.some(r => allowedRoles.includes(r));
+    if (!req.user || !allowed) {
+      res.status(403).json({
+        success: false,
+        message: 'Access denied. Insufficient role permissions.',
+        requiredRoles: allowedRoles,
+        userRoles,
+      });
+      return;
+    }
+
+    next();
+  };
+};
+
+
+/**
+ * Permission-based authorization middleware
+ */
+export const requirePermission = (permissionName: string, options: {
+  resource?: string;
+  action?: string;
+  allowSelfAccess?: boolean;
+} = {}) => {
+  return async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
+    try {
+      if (!req.user) {
+        res.status(401).json({ 
+          success: false,
+          message: 'Authentication required',
+          requiresAuth: true
+        });
+        return;
+      }
+
+      // Super admin has all permissions
+      if ((req.user.roles ?? []).includes('super_admin'))  {
+        return next();
+      }
+
+      // Check self-access for certain operations
+      if (options.allowSelfAccess) {
+        const targetUserId = req.params.userId || req.params.id || req.body.userId;
+        if (targetUserId && targetUserId === req.user._id.toString()) {
+          return next();
+        }
+      }
+
+      // Context for permission checking
+      const context = {
+        location: req.body?.location || req.query?.location,
+        severity: req.body?.severity || req.query?.severity,
+        currentTime: new Date(),
+        userIp: req.ip
+      };
+
+      const [resource, action] = permissionName.includes(':')
+      ? permissionName.split(':', 2)
+      : [permissionName, '*'];
+
+      const hasPermission = (req.user.permissions || []).some((p: any) =>
+        p.granted &&
+        p.resource === resource &&
+        (p.action === action || p.action === '*')
+      );
+
+      
+      if (!hasPermission) {
+       res.status(403).json({
+       success: false,
+       message: 'Insufficient permissions for this operation',
+       requiredPermission: permissionName,
+      });
+  return;
+}
+
+      next();
+    } catch (error) {
+      console.error('Permission check error:', error);
+      res.status(500).json({
+        success: false,
+        message: 'Permission validation failed'
+      });
+    }
+  };
+};
+
+/**
+ * Legacy middleware for backward compatibility
+ */
+export const adminOnly = requireRole(['admin', 'super_admin']);
+export const operatorOrAdmin = requireRole(['operator', 'admin', 'mobile_admin', 'super_admin']);
+
+/**
+ * Mobile-optimized auth middleware (more lenient error handling)
+ */
+export const mobileAuth = async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
+  try {
+    const token = req.header('Authorization')?.replace('Bearer ', '') ||
+                 req.header('X-Mobile-Token'); // Alternative header for mobile apps
+
+    if (!token) {
+      res.status(401).json({ 
+        success: false,
+        message: 'Authentication required',
+        requiresAuth: true,
+        mobileOptimized: true
+      });
+      return;
+    }
+
+    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as any;
+    const user = await User.findById(decoded.userId)
+      .select('-password -authentication.otpSecret -authentication.recoveryTokens');
+
+    if (!user || !user.isActive) {
+      res.status(401).json({ 
+        success: false,
+        message: 'Invalid session. Please log in again.',
+        requiresAuth: true,
+        mobileOptimized: true
+      });
+      return;
+    }
+
+    // Update last activity for mobile users
+    if (user.authMethod === 'phone_otp') {
+      user.authentication.lastLoginAt = new Date();
+      await user.save();
+    }
+
+
+    req.user = { ...user.toObject(), userId: user._id.toString() };
+    next();
+  } catch (error) {
+    console.error('Mobile auth error:', error);
+    res.status(401).json({ 
+      success: false,
+      message: 'Session expired. Please log in again.',
+      requiresAuth: true,
+      mobileOptimized: true
+    });
+  }
+};
+
+/**
+ * Optional auth middleware - doesn't require authentication but loads user if token is present
+ */
+export const optionalAuth = async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
+  try {
+    const token = req.header('Authorization')?.replace('Bearer ', '');
+
+    if (!token) {
+      return next(); // Continue without authentication
+    }
+
+    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret') as any;
+    const user = await User.findById(decoded.userId)
+      .select('-password -authentication.otpSecret -authentication.recoveryTokens');
+
+    if (user && user.isActive) {
+      req.user = { ...user.toObject(), userId: user._id.toString() };
+    }
+
+    next();
+  } catch (error) {
+    // Ignore token errors for optional auth
+    next();
+  }
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/middleware/errorHandler.ts b/event-monitoring-mvp/backend/src/middleware/errorHandler.ts
index 58d5d17..4e3d56f 100644
--- a/event-monitoring-mvp/backend/src/middleware/errorHandler.ts
+++ b/event-monitoring-mvp/backend/src/middleware/errorHandler.ts
@@ -1,57 +1,57 @@
-import { Request, Response, NextFunction } from 'express';
-
-interface CustomError extends Error {
-  statusCode?: number;
-  status?: string;
-  isOperational?: boolean;
-}
-
-export const errorHandler = (
-  err: CustomError,
-  req: Request,
-  res: Response,
-  next: NextFunction
-): void => {
-  let { statusCode = 500, message } = err;
-
-  // Mongoose validation error
-  if (err.name === 'ValidationError') {
-    statusCode = 400;
-    message = Object.values((err as any).errors).map((val: any) => val.message).join(', ');
-  }
-
-  // Mongoose duplicate key error
-  if ((err as any).code === 11000) {
-    statusCode = 400;
-    const field = Object.keys((err as any).keyValue)[0];
-    message = `${field} already exists`;
-  }
-
-  // JWT errors
-  if (err.name === 'JsonWebTokenError') {
-    statusCode = 401;
-    message = 'Invalid token';
-  }
-
-  if (err.name === 'TokenExpiredError') {
-    statusCode = 401;
-    message = 'Token expired';
-  }
-
-  // Log error in development
-  if (process.env.NODE_ENV === 'development') {
-    console.error('Error Stack:', err.stack);
-  }
-
-  res.status(statusCode).json({
-    success: false,
-    message,
-    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
-  });
-};
-
-export const asyncHandler = (fn: Function) => {
-  return (req: Request, res: Response, next: NextFunction) => {
-    Promise.resolve(fn(req, res, next)).catch(next);
-  };
+import { Request, Response, NextFunction } from 'express';
+
+interface CustomError extends Error {
+  statusCode?: number;
+  status?: string;
+  isOperational?: boolean;
+}
+
+export const errorHandler = (
+  err: CustomError,
+  req: Request,
+  res: Response,
+  next: NextFunction
+): void => {
+  let { statusCode = 500, message } = err;
+
+  // Mongoose validation error
+  if (err.name === 'ValidationError') {
+    statusCode = 400;
+    message = Object.values((err as any).errors).map((val: any) => val.message).join(', ');
+  }
+
+  // Mongoose duplicate key error
+  if ((err as any).code === 11000) {
+    statusCode = 400;
+    const field = Object.keys((err as any).keyValue)[0];
+    message = `${field} already exists`;
+  }
+
+  // JWT errors
+  if (err.name === 'JsonWebTokenError') {
+    statusCode = 401;
+    message = 'Invalid token';
+  }
+
+  if (err.name === 'TokenExpiredError') {
+    statusCode = 401;
+    message = 'Token expired';
+  }
+
+  // Log error in development
+  if (process.env.NODE_ENV === 'development') {
+    console.error('Error Stack:', err.stack);
+  }
+
+  res.status(statusCode).json({
+    success: false,
+    message,
+    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
+  });
+};
+
+export const asyncHandler = (fn: Function) => {
+  return (req: Request, res: Response, next: NextFunction) => {
+    Promise.resolve(fn(req, res, next)).catch(next);
+  };
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/middleware/mobileAuth.ts b/event-monitoring-mvp/backend/src/middleware/mobileAuth.ts
new file mode 100644
index 0000000..c42f74e
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/middleware/mobileAuth.ts
@@ -0,0 +1,65 @@
+import { Response, NextFunction } from 'express';
+import { MobileAuthenticatedRequest } from '../types/mobile';
+import { Company } from '../models/Company';
+
+/**
+ * Validates X-API-Key header for mobile app requests
+ * Queries Company collection and validates the API key
+ */
+export const validateMobileApiKey = async (
+  req: MobileAuthenticatedRequest,
+  res: Response,
+  next: NextFunction
+): Promise<void> => {
+  try {
+    const apiKey = req.header('X-API-Key');
+
+    if (!apiKey) {
+      res.status(401).json({
+        success: false,
+        message: 'Missing X-API-Key header'
+      });
+      return;
+    }
+
+    // Query Company by apiKey
+    const company = await Company.findOne({ apiKey, isActive: true });
+
+    if (!company) {
+      res.status(401).json({
+        success: false,
+        message: 'Invalid API key or company is inactive'
+      });
+      return;
+    }
+
+    // Attach company info to request
+    req.company = {
+      id: company.companyId,
+      name: company.name,
+      settings: company.settings || {}
+    };
+
+    next();
+  } catch (error) {
+    console.error('Mobile API key validation error:', error);
+    res.status(500).json({
+      success: false,
+      message: 'Error validating API key'
+    });
+  }
+};
+
+/**
+ * Validates that user can only access their own reports
+ * Checks report ownership based on phone number
+ */
+export const validateMobileUserAccess = async (
+  req: MobileAuthenticatedRequest,
+  res: Response,
+  next: NextFunction
+): Promise<void> => {
+  // For now, pass through - ownership check is done in controller
+  // This middleware can be extended for more complex access control
+  next();
+};
diff --git a/event-monitoring-mvp/backend/src/middleware/validation.ts b/event-monitoring-mvp/backend/src/middleware/validation.ts
index f764ae9..75318e0 100644
--- a/event-monitoring-mvp/backend/src/middleware/validation.ts
+++ b/event-monitoring-mvp/backend/src/middleware/validation.ts
@@ -1,137 +1,260 @@
-import { Request, Response, NextFunction } from 'express';
-import Joi from 'joi';
-import { validationResult } from 'express-validator';
-
-// User registration validation
-export const validateRegistration = (req: Request, res: Response, next: NextFunction): void => {
-  const schema = Joi.object({
-    username: Joi.string().min(3).max(30).required(),
-    email: Joi.string().email().required(),
-    password: Joi.string().min(6).required(),
-    role: Joi.string().valid('admin', 'operator').default('operator')
-  });
-
-  const { error } = schema.validate(req.body);
-  if (error) {
-    res.status(400).json({ message: error.details[0].message });
-    return;
-  }
-  next();
-};
-
-// User login validation
-export const validateLogin = (req: Request, res: Response, next: NextFunction): void => {
-  const schema = Joi.object({
-    email: Joi.string().email().required(),
-    password: Joi.string().required()
-  });
-
-  const { error } = schema.validate(req.body);
-  if (error) {
-    res.status(400).json({ message: error.details[0].message });
-    return;
-  }
-  next();
-};
-
-// Camera validation
-export const validateCamera = (req: Request, res: Response, next: NextFunction): void => {
-  const schema = Joi.object({
-    name: Joi.string().max(100).required(),
-    description: Joi.string().max(500).optional(),
-    streamUrl: Joi.string().uri({ scheme: ['http', 'https', 'rtsp'] }).required(),
-    location: Joi.object({
-      coordinates: Joi.array().items(Joi.number()).length(2).required(),
-      address: Joi.string().optional()
-    }).required(),
-    type: Joi.string().valid('ip', 'analog', 'usb').default('ip'),
-    settings: Joi.object({
-      resolution: Joi.string().default('1920x1080'),
-      fps: Joi.number().min(1).max(60).default(30),
-      recordingEnabled: Joi.boolean().default(false)
-    }).optional()
-  });
-
-  const { error } = schema.validate(req.body);
-  if (error) {
-    res.status(400).json({ message: error.details[0].message });
-    return;
-  }
-  next();
-};
-
-// Event validation
-export const validateEvent = (req: Request, res: Response, next: NextFunction): void => {
-  const schema = Joi.object({
-    title: Joi.string().max(200).required(),
-    description: Joi.string().max(1000).optional(),
-    type: Joi.string().valid(
-      'person_detected',
-      'vehicle_detected',
-      'motion_detected',
-      'unauthorized_access',
-      'other'
-    ).required(),
-    severity: Joi.string().valid('low', 'medium', 'high', 'critical').default('medium'),
-    cameraId: Joi.string().pattern(/^[0-9a-fA-F]{24}$/).required(),
-    location: Joi.object({
-      coordinates: Joi.array().items(Joi.number()).length(2).required(),
-      address: Joi.string().optional()
-    }).required(),
-    detectionData: Joi.object({
-      confidence: Joi.number().min(0).max(1).required(),
-      boundingBox: Joi.object({
-        x: Joi.number().required(),
-        y: Joi.number().required(),
-        width: Joi.number().required(),
-        height: Joi.number().required()
-      }).optional(),
-      objectCount: Joi.number().min(0).optional(),
-      aiModel: Joi.string().optional()
-    }).required(),
-    media: Joi.object({
-      imageUrl: Joi.string().uri().optional(),
-      videoUrl: Joi.string().uri().optional(),
-      thumbnailUrl: Joi.string().uri().optional()
-    }).optional(),
-    tags: Joi.array().items(Joi.string().max(50)).optional()
-  });
-
-  const { error } = schema.validate(req.body);
-  if (error) {
-    res.status(400).json({ message: error.details[0].message });
-    return;
-  }
-  next();
-};
-
-// User validation (for admin creating users)
-export const validateUser = (req: Request, res: Response, next: NextFunction): void => {
-  const schema = Joi.object({
-    username: Joi.string().min(3).max(30).required(),
-    email: Joi.string().email().required(),
-    password: Joi.string().min(6).required(),
-    role: Joi.string().valid('admin', 'operator').required(),
-    isActive: Joi.boolean().optional()
-  });
-
-  const { error } = schema.validate(req.body);
-  if (error) {
-    res.status(400).json({ message: error.details[0].message });
-    return;
-  }
-  next();
-};
-
-// General validation middleware for express-validator
-export const validation = (req: Request, res: Response, next: NextFunction): void => {
-  const errors = validationResult(req);
-  if (!errors.isEmpty()) {
-    res.status(400).json({
-      message: 'Validation failed',
-      errors: errors.array()
-    });
-    return;
-  }
-  next();
+import { Request, Response, NextFunction } from 'express';
+import Joi from 'joi';
+import { validationResult } from 'express-validator';
+
+// Enhanced user registration validation supporting multiple auth methods
+export const validateRegistration = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    username: Joi.string().min(3).max(30).optional(),
+    email: Joi.string().email().optional(),
+    password: Joi.string().min(6).optional(),
+    phone: Joi.string().pattern(/^\+?[1-9]\d{1,14}$/).optional(),
+    authMethod: Joi.string().valid('email_password', 'phone_otp', 'social_oauth').default('email_password'),
+    role: Joi.string().valid('citizen', 'operator', 'admin', 'mobile_admin', 'super_admin').default('operator'),
+    profile: Joi.object({
+      firstName: Joi.string().max(50).optional(),
+      lastName: Joi.string().max(50).optional(),
+      department: Joi.string().max(100).optional(),
+      timezone: Joi.string().default('UTC'),
+      preferredLanguage: Joi.string().pattern(/^[a-z]{2}(-[A-Z]{2})?$/).default('en')
+    }).optional(),
+    deviceInfo: Joi.object({
+      platform: Joi.string().valid('ios', 'android', 'web').optional(),
+      version: Joi.string().optional(),
+      deviceToken: Joi.string().optional()
+    }).optional()
+  }).custom((value, helpers) => {
+    // Validation based on auth method
+    if (value.authMethod === 'email_password') {
+      if (!value.email || !value.password) {
+        return helpers.error('custom.emailPasswordRequired');
+      }
+    } else if (value.authMethod === 'phone_otp') {
+      if (!value.phone) {
+        return helpers.error('custom.phoneRequired');
+      }
+    }
+    return value;
+  }).messages({
+    'custom.emailPasswordRequired': 'Email and password are required for email authentication',
+    'custom.phoneRequired': 'Phone number is required for phone authentication'
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ 
+      success: false,
+      message: error.details[0].message 
+    });
+    return;
+  }
+  next();
+};
+
+// Enhanced user login validation supporting multiple auth methods
+export const validateLogin = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    // Accept both 'credential' (new) and 'email' (legacy) for backward compatibility
+    credential: Joi.string().optional(),
+    email: Joi.string().email().optional(), 
+    password: Joi.string().optional(),
+    otp: Joi.string().length(6).pattern(/^\d+$/).optional(),
+    authMethod: Joi.string().valid('email_password', 'phone_otp').optional(),
+    deviceInfo: Joi.object({
+      platform: Joi.string().valid('ios', 'android', 'web').optional(),
+      version: Joi.string().optional(),
+      deviceToken: Joi.string().optional()
+    }).optional()
+  }).custom((value, helpers) => {
+    // Require either credential or email
+    if (!value.credential && !value.email) {
+      return helpers.error('custom.credentialRequired');
+    }
+    // At least password or OTP must be provided
+    if (!value.password && !value.otp) {
+      return helpers.error('custom.authRequired');
+    }
+    return value;
+  }).messages({
+    'custom.credentialRequired': 'Email, username, or phone number is required',
+    'custom.authRequired': 'Either password or OTP code is required'
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ 
+      success: false,
+      message: error.details[0].message 
+    });
+    return;
+  }
+  next();
+};
+
+// Phone verification validation
+export const validatePhoneVerification = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    phone: Joi.string().pattern(/^\+?[1-9]\d{1,14}$/).required().messages({
+      'string.pattern.base': 'Please provide a valid phone number with country code'
+    }),
+    otp: Joi.string().length(6).pattern(/^\d+$/).required().messages({
+      'string.length': 'OTP must be 6 digits',
+      'string.pattern.base': 'OTP must contain only numbers'
+    })
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ 
+      success: false,
+      message: error.details[0].message 
+    });
+    return;
+  }
+  next();
+};
+
+// Send OTP validation
+export const validateSendOTP = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    phone: Joi.string().pattern(/^\+?[1-9]\d{1,14}$/).required().messages({
+      'string.pattern.base': 'Please provide a valid phone number with country code'
+    })
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ 
+      success: false,
+      message: error.details[0].message 
+    });
+    return;
+  }
+  next();
+};
+
+// Change password validation
+export const validateChangePassword = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    currentPassword: Joi.string().required().messages({
+      'any.required': 'Current password is required'
+    }),
+    newPassword: Joi.string().min(6).required().messages({
+      'string.min': 'New password must be at least 6 characters long',
+      'any.required': 'New password is required'
+    })
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ 
+      success: false,
+      message: error.details[0].message 
+    });
+    return;
+  }
+  next();
+};
+
+// Camera validation
+export const validateCamera = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    name: Joi.string().max(100).required(),
+    description: Joi.string().max(500).optional(),
+    streamUrl: Joi.string().uri({ scheme: ['http', 'https', 'rtsp'] }).required(),
+    location: Joi.object({
+      type: Joi.string().valid('Point').default('Point'),
+      coordinates: Joi.array().items(Joi.number()).length(2).required(),
+      address: Joi.string().optional(),
+    }).required(),
+    type: Joi.string().valid('ip', 'analog', 'usb').default('ip'),
+    settings: Joi.object({
+      resolution: Joi.string().default('1920x1080'),
+      fps: Joi.number().min(1).max(60).default(30),
+      recordingEnabled: Joi.boolean().default(false)
+    }).optional()
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ message: error.details[0].message });
+    return;
+  }
+  next();
+};
+
+// Event validation
+export const validateEvent = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    title: Joi.string().max(200).required(),
+    description: Joi.string().max(1000).optional(),
+    type: Joi.string().valid(
+      'person_detected',
+      'vehicle_detected',
+      'motion_detected',
+      'unauthorized_access',
+      'other'
+    ).required(),
+    severity: Joi.string().valid('low', 'medium', 'high', 'critical').default('medium'),
+    cameraId: Joi.string().pattern(/^[0-9a-fA-F]{24}$/).required(),
+    location: Joi.object({
+      coordinates: Joi.array().items(Joi.number()).length(2).required(),
+      address: Joi.string().optional()
+    }).required(),
+    detectionData: Joi.object({
+      confidence: Joi.number().min(0).max(1).required(),
+      boundingBox: Joi.object({
+        x: Joi.number().required(),
+        y: Joi.number().required(),
+        width: Joi.number().required(),
+        height: Joi.number().required()
+      }).optional(),
+      objectCount: Joi.number().min(0).optional(),
+      aiModel: Joi.string().optional()
+    }).required(),
+    media: Joi.object({
+      imageUrl: Joi.string().uri().optional(),
+      videoUrl: Joi.string().uri().optional(),
+      thumbnailUrl: Joi.string().uri().optional()
+    }).optional(),
+    tags: Joi.array().items(Joi.string().max(50)).optional()
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ message: error.details[0].message });
+    return;
+  }
+  next();
+};
+
+// User validation (for admin creating users)
+export const validateUser = (req: Request, res: Response, next: NextFunction): void => {
+  const schema = Joi.object({
+    username: Joi.string().min(3).max(30).required(),
+    email: Joi.string().email().required(),
+    password: Joi.string().min(6).required(),
+    role: Joi.string().valid('admin', 'operator').required(),
+    isActive: Joi.boolean().optional()
+  });
+
+  const { error } = schema.validate(req.body);
+  if (error) {
+    res.status(400).json({ message: error.details[0].message });
+    return;
+  }
+  next();
+};
+
+// General validation middleware for express-validator
+export const validation = (req: Request, res: Response, next: NextFunction): void => {
+  const errors = validationResult(req);
+  if (!errors.isEmpty()) {
+    res.status(400).json({
+      message: 'Validation failed',
+      errors: errors.array()
+    });
+    return;
+  }
+  next();
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/models/AIDetection.ts b/event-monitoring-mvp/backend/src/models/AIDetection.ts
index 9e085e2..01c2e7c 100644
--- a/event-monitoring-mvp/backend/src/models/AIDetection.ts
+++ b/event-monitoring-mvp/backend/src/models/AIDetection.ts
@@ -1,298 +1,298 @@
-import mongoose, { Document, Schema } from 'mongoose';
-
-// Interface for AI Detection
-export interface IAIDetection extends Document {
-  _id: string;
-  cameraId: mongoose.Types.ObjectId;
-  detectionId: string; // Unique AI detection ID
-  timestamp: Date;
-  type: 'person' | 'vehicle' | 'unknown_object' | 'motion';
-  confidence: number;
-  boundingBox: {
-    x: number;
-    y: number;
-    width: number;
-    height: number;
-  };
-  location: {
-    coordinates: [number, number]; // [longitude, latitude] - Camera location
-    estimatedPosition?: [number, number]; // Estimated object position if available
-    address?: string;
-  };
-  metadata: {
-    aiModel: string;
-    processingTime: number;
-    frameNumber: number;
-    objectProperties?: {
-      color?: string;
-      size?: string;
-      direction?: string;
-      speed?: number;
-    };
-  };
-  status: 'pending_review' | 'dismissed' | 'promoted_to_event';
-  reviewedBy?: mongoose.Types.ObjectId;
-  reviewedAt?: Date;
-  promotedEventId?: mongoose.Types.ObjectId;
-  snapshots: {
-    fullFrame: string; // Image URL
-    croppedObject: string; // Cropped detection URL
-    thumbnail: string;
-  };
-  createdAt: Date;
-  updatedAt: Date;
-}
-
-// Mongoose schema for AI Detection
-const aiDetectionSchema = new Schema<IAIDetection>({
-  cameraId: {
-    type: Schema.Types.ObjectId,
-    ref: 'Camera',
-    required: true,
-    index: true
-  },
-  detectionId: {
-    type: String,
-    required: true,
-    unique: true,
-    index: true
-  },
-  timestamp: {
-    type: Date,
-    required: true,
-    index: true
-  },
-  type: {
-    type: String,
-    enum: ['person', 'vehicle', 'unknown_object', 'motion'],
-    required: true,
-    index: true
-  },
-  confidence: {
-    type: Number,
-    required: true,
-    min: 0,
-    max: 1,
-    index: true
-  },
-  boundingBox: {
-    x: {
-      type: Number,
-      required: true,
-      min: 0
-    },
-    y: {
-      type: Number,
-      required: true,
-      min: 0
-    },
-    width: {
-      type: Number,
-      required: true,
-      min: 0
-    },
-    height: {
-      type: Number,
-      required: true,
-      min: 0
-    }
-  },
-  location: {
-    coordinates: {
-      type: [Number], // [longitude, latitude]
-      required: true,
-      index: '2dsphere', // Enable geospatial queries
-      validate: {
-        validator: (v: number[]) => v.length === 2,
-        message: 'Coordinates must be [longitude, latitude]'
-      }
-    },
-    estimatedPosition: {
-      type: [Number], // [longitude, latitude]
-      validate: {
-        validator: (v: number[]) => v.length === 2,
-        message: 'Estimated position must be [longitude, latitude]'
-      }
-    },
-    address: {
-      type: String,
-      trim: true
-    }
-  },
-  metadata: {
-    aiModel: {
-      type: String,
-      required: true,
-      trim: true
-    },
-    processingTime: {
-      type: Number,
-      required: true,
-      min: 0
-    },
-    frameNumber: {
-      type: Number,
-      required: true,
-      min: 0
-    },
-    objectProperties: {
-      color: {
-        type: String,
-        trim: true
-      },
-      size: {
-        type: String,
-        trim: true
-      },
-      direction: {
-        type: String,
-        trim: true
-      },
-      speed: {
-        type: Number,
-        min: 0
-      }
-    }
-  },
-  status: {
-    type: String,
-    enum: ['pending_review', 'dismissed', 'promoted_to_event'],
-    default: 'pending_review',
-    required: true,
-    index: true
-  },
-  reviewedBy: {
-    type: Schema.Types.ObjectId,
-    ref: 'User'
-  },
-  reviewedAt: {
-    type: Date
-  },
-  promotedEventId: {
-    type: Schema.Types.ObjectId,
-    ref: 'Event'
-  },
-  snapshots: {
-    fullFrame: {
-      type: String,
-      required: true,
-      trim: true
-    },
-    croppedObject: {
-      type: String,
-      required: true,
-      trim: true
-    },
-    thumbnail: {
-      type: String,
-      required: true,
-      trim: true
-    }
-  }
-}, {
-  timestamps: true,
-  collection: 'ai_detections'
-});
-
-// Indexes for efficient querying
-aiDetectionSchema.index({ cameraId: 1, timestamp: -1 });
-aiDetectionSchema.index({ status: 1, timestamp: -1 });
-aiDetectionSchema.index({ type: 1, confidence: -1 });
-aiDetectionSchema.index({ 'location.coordinates': '2dsphere' });
-
-// Compound index for common queries
-aiDetectionSchema.index({ 
-  status: 1, 
-  type: 1, 
-  confidence: -1, 
-  timestamp: -1 
-});
-
-// Pre-save middleware to validate review data
-aiDetectionSchema.pre('save', function(next) {
-  if (this.status === 'dismissed' || this.status === 'promoted_to_event') {
-    if (!this.reviewedBy || !this.reviewedAt) {
-      return next(new Error('Reviewed detections must have reviewedBy and reviewedAt fields'));
-    }
-  }
-  
-  if (this.status === 'promoted_to_event' && !this.promotedEventId) {
-    return next(new Error('Promoted detections must have promotedEventId'));
-  }
-  
-  next();
-});
-
-// Instance methods
-aiDetectionSchema.methods.promoteToEvent = function(eventData: any, reviewerId: string) {
-  this.status = 'promoted_to_event';
-  this.reviewedBy = reviewerId;
-  this.reviewedAt = new Date();
-  // promotedEventId will be set after event creation
-  return this.save();
-};
-
-aiDetectionSchema.methods.dismiss = function(reviewerId: string, reason?: string) {
-  this.status = 'dismissed';
-  this.reviewedBy = reviewerId;
-  this.reviewedAt = new Date();
-  if (reason) {
-    this.metadata.dismissReason = reason;
-  }
-  return this.save();
-};
-
-// Static methods for common queries
-aiDetectionSchema.statics.findPendingByCamera = function(cameraId: string) {
-  return this.find({ 
-    cameraId, 
-    status: 'pending_review' 
-  }).sort({ timestamp: -1 });
-};
-
-aiDetectionSchema.statics.findInRadius = function(
-  coordinates: [number, number], 
-  radiusMeters: number,
-  filters: any = {}
-) {
-  const query = {
-    'location.coordinates': {
-      $nearSphere: {
-        $geometry: {
-          type: 'Point',
-          coordinates: coordinates
-        },
-        $maxDistance: radiusMeters
-      }
-    },
-    ...filters
-  };
-  
-  return this.find(query).sort({ timestamp: -1 });
-};
-
-aiDetectionSchema.statics.getDetectionStats = function(dateRange?: { start: Date; end: Date }) {
-  const matchStage: any = {};
-  
-  if (dateRange) {
-    matchStage.timestamp = {
-      $gte: dateRange.start,
-      $lte: dateRange.end
-    };
-  }
-  
-  return this.aggregate([
-    { $match: matchStage },
-    {
-      $group: {
-        _id: '$status',
-        count: { $sum: 1 },
-        avgConfidence: { $avg: '$confidence' },
-        types: { $addToSet: '$type' }
-      }
-    }
-  ]);
-};
-
-export const AIDetection = mongoose.model<IAIDetection>('AIDetection', aiDetectionSchema);
+import mongoose, { Document, Schema } from 'mongoose';
+
+// Interface for AI Detection
+export interface IAIDetection extends Document {
+  _id: string;
+  cameraId: mongoose.Types.ObjectId;
+  detectionId: string; // Unique AI detection ID
+  timestamp: Date;
+  type: 'person' | 'vehicle' | 'unknown_object' | 'motion';
+  confidence: number;
+  boundingBox: {
+    x: number;
+    y: number;
+    width: number;
+    height: number;
+  };
+  location: {
+    coordinates: [number, number]; // [longitude, latitude] - Camera location
+    estimatedPosition?: [number, number]; // Estimated object position if available
+    address?: string;
+  };
+  metadata: {
+    aiModel: string;
+    processingTime: number;
+    frameNumber: number;
+    objectProperties?: {
+      color?: string;
+      size?: string;
+      direction?: string;
+      speed?: number;
+    };
+  };
+  status: 'pending_review' | 'dismissed' | 'promoted_to_event';
+  reviewedBy?: mongoose.Types.ObjectId;
+  reviewedAt?: Date;
+  promotedEventId?: mongoose.Types.ObjectId;
+  snapshots: {
+    fullFrame: string; // Image URL
+    croppedObject: string; // Cropped detection URL
+    thumbnail: string;
+  };
+  createdAt: Date;
+  updatedAt: Date;
+}
+
+// Mongoose schema for AI Detection
+const aiDetectionSchema = new Schema<IAIDetection>({
+  cameraId: {
+    type: Schema.Types.ObjectId,
+    ref: 'Camera',
+    required: true,
+    index: true
+  },
+  detectionId: {
+    type: String,
+    required: true,
+    unique: true,
+    index: true
+  },
+  timestamp: {
+    type: Date,
+    required: true,
+    index: true
+  },
+  type: {
+    type: String,
+    enum: ['person', 'vehicle', 'unknown_object', 'motion'],
+    required: true,
+    index: true
+  },
+  confidence: {
+    type: Number,
+    required: true,
+    min: 0,
+    max: 1,
+    index: true
+  },
+  boundingBox: {
+    x: {
+      type: Number,
+      required: true,
+      min: 0
+    },
+    y: {
+      type: Number,
+      required: true,
+      min: 0
+    },
+    width: {
+      type: Number,
+      required: true,
+      min: 0
+    },
+    height: {
+      type: Number,
+      required: true,
+      min: 0
+    }
+  },
+  location: {
+    coordinates: {
+      type: [Number], // [longitude, latitude]
+      required: true,
+      index: '2dsphere', // Enable geospatial queries
+      validate: {
+        validator: (v: number[]) => v.length === 2,
+        message: 'Coordinates must be [longitude, latitude]'
+      }
+    },
+    estimatedPosition: {
+      type: [Number], // [longitude, latitude]
+      validate: {
+        validator: (v: number[]) => v.length === 2,
+        message: 'Estimated position must be [longitude, latitude]'
+      }
+    },
+    address: {
+      type: String,
+      trim: true
+    }
+  },
+  metadata: {
+    aiModel: {
+      type: String,
+      required: true,
+      trim: true
+    },
+    processingTime: {
+      type: Number,
+      required: true,
+      min: 0
+    },
+    frameNumber: {
+      type: Number,
+      required: true,
+      min: 0
+    },
+    objectProperties: {
+      color: {
+        type: String,
+        trim: true
+      },
+      size: {
+        type: String,
+        trim: true
+      },
+      direction: {
+        type: String,
+        trim: true
+      },
+      speed: {
+        type: Number,
+        min: 0
+      }
+    }
+  },
+  status: {
+    type: String,
+    enum: ['pending_review', 'dismissed', 'promoted_to_event'],
+    default: 'pending_review',
+    required: true,
+    index: true
+  },
+  reviewedBy: {
+    type: Schema.Types.ObjectId,
+    ref: 'User'
+  },
+  reviewedAt: {
+    type: Date
+  },
+  promotedEventId: {
+    type: Schema.Types.ObjectId,
+    ref: 'Event'
+  },
+  snapshots: {
+    fullFrame: {
+      type: String,
+      required: true,
+      trim: true
+    },
+    croppedObject: {
+      type: String,
+      required: true,
+      trim: true
+    },
+    thumbnail: {
+      type: String,
+      required: true,
+      trim: true
+    }
+  }
+}, {
+  timestamps: true,
+  collection: 'ai_detections'
+});
+
+// Indexes for efficient querying
+aiDetectionSchema.index({ cameraId: 1, timestamp: -1 });
+aiDetectionSchema.index({ status: 1, timestamp: -1 });
+aiDetectionSchema.index({ type: 1, confidence: -1 });
+aiDetectionSchema.index({ 'location.coordinates': '2dsphere' });
+
+// Compound index for common queries
+aiDetectionSchema.index({ 
+  status: 1, 
+  type: 1, 
+  confidence: -1, 
+  timestamp: -1 
+});
+
+// Pre-save middleware to validate review data
+aiDetectionSchema.pre('save', function(next) {
+  if (this.status === 'dismissed' || this.status === 'promoted_to_event') {
+    if (!this.reviewedBy || !this.reviewedAt) {
+      return next(new Error('Reviewed detections must have reviewedBy and reviewedAt fields'));
+    }
+  }
+  
+  if (this.status === 'promoted_to_event' && !this.promotedEventId) {
+    return next(new Error('Promoted detections must have promotedEventId'));
+  }
+  
+  next();
+});
+
+// Instance methods
+aiDetectionSchema.methods.promoteToEvent = function(eventData: any, reviewerId: string) {
+  this.status = 'promoted_to_event';
+  this.reviewedBy = reviewerId;
+  this.reviewedAt = new Date();
+  // promotedEventId will be set after event creation
+  return this.save();
+};
+
+aiDetectionSchema.methods.dismiss = function(reviewerId: string, reason?: string) {
+  this.status = 'dismissed';
+  this.reviewedBy = reviewerId;
+  this.reviewedAt = new Date();
+  if (reason) {
+    this.metadata.dismissReason = reason;
+  }
+  return this.save();
+};
+
+// Static methods for common queries
+aiDetectionSchema.statics.findPendingByCamera = function(cameraId: string) {
+  return this.find({ 
+    cameraId, 
+    status: 'pending_review' 
+  }).sort({ timestamp: -1 });
+};
+
+aiDetectionSchema.statics.findInRadius = function(
+  coordinates: [number, number], 
+  radiusMeters: number,
+  filters: any = {}
+) {
+  const query = {
+    'location.coordinates': {
+      $nearSphere: {
+        $geometry: {
+          type: 'Point',
+          coordinates: coordinates
+        },
+        $maxDistance: radiusMeters
+      }
+    },
+    ...filters
+  };
+  
+  return this.find(query).sort({ timestamp: -1 });
+};
+
+aiDetectionSchema.statics.getDetectionStats = function(dateRange?: { start: Date; end: Date }) {
+  const matchStage: any = {};
+  
+  if (dateRange) {
+    matchStage.timestamp = {
+      $gte: dateRange.start,
+      $lte: dateRange.end
+    };
+  }
+  
+  return this.aggregate([
+    { $match: matchStage },
+    {
+      $group: {
+        _id: '$status',
+        count: { $sum: 1 },
+        avgConfidence: { $avg: '$confidence' },
+        types: { $addToSet: '$type' }
+      }
+    }
+  ]);
+};
+
+export const AIDetection = mongoose.model<IAIDetection>('AIDetection', aiDetectionSchema);
 export default AIDetection;
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/models/Camera.ts b/event-monitoring-mvp/backend/src/models/Camera.ts
index 7faedcd..265ede0 100644
--- a/event-monitoring-mvp/backend/src/models/Camera.ts
+++ b/event-monitoring-mvp/backend/src/models/Camera.ts
@@ -1,110 +1,176 @@
-import mongoose, { Document, Schema } from 'mongoose';
-
+import mongoose, { Document, Schema } from 'mongoose';
+
 export interface ICamera extends Document {
   name: string;
   description?: string;
   streamUrl: string;
-  location: {
-    coordinates: [number, number]; // [longitude, latitude]
-    address?: string;
-  };
-  status: 'online' | 'offline' | 'maintenance';
-  type: 'ip' | 'analog' | 'usb';
+  location: {
+  type: 'Point';
+  coordinates: [number, number]; // [lng, lat]
+  address?: string;
+  };
+
+  status: 'online' | 'offline' | 'maintenance';
+  type: 'ip' | 'analog' | 'usb';
   settings: {
     resolution: string;
     fps: number;
     recordingEnabled: boolean;
   };
-  isActive: boolean;
-  createdBy: mongoose.Types.ObjectId;
-  createdAt: Date;
-  updatedAt: Date;
-}
 
-const cameraSchema = new Schema<ICamera>(
-  {
-    name: {
-      type: String,
-      required: [true, 'Camera name is required'],
-      trim: true,
-      maxlength: [100, 'Camera name must be less than 100 characters']
-    },
-    description: {
-      type: String,
-      maxlength: [500, 'Description must be less than 500 characters']
-    },
-    streamUrl: {
-      type: String,
-      required: [true, 'Stream URL is required'],
-      match: [
-        /^(rtsp|http|https):\/\/.+/,
-        'Stream URL must be a valid RTSP, HTTP, or HTTPS URL'
-      ]
-    },
-    location: {
-      type: {
-        coordinates: {
-          type: [Number],
-          required: true,
-          validate: {
-            validator: function(coordinates: number[]) {
-              return coordinates.length === 2 && 
-                     coordinates[0] >= -180 && coordinates[0] <= 180 &&
-                     coordinates[1] >= -90 && coordinates[1] <= 90;
-            },
-            message: 'Coordinates must be [longitude, latitude] with valid ranges'
-          }
-        },
-        address: String
-      },
-      required: true,
-      index: '2dsphere'
-    },
+  metadata?: {
+    source?: string; // optional label for grouping/import source
+  };
+
+   vms?: {
+    provider: 'shinobi' | 'zoneminder' | 'agentdvr' | 'other';
+    serverId?: mongoose.Types.ObjectId; // ref: VmsServer
+    monitorId?: string; // provider-specific id for the camera/monitor inside the VMS
+    lastSyncAt?: Date;  // last time we synced/connected this camera to the VMS
+  };
+
+   isDeleted: boolean;
+   lastModified?: Date;
+   lastSeen?: Date;
+   isActive: boolean;
+   createdBy: mongoose.Types.ObjectId;
+   createdAt: Date;
+   updatedAt: Date;
+}
+
+const cameraSchema = new Schema<ICamera>(
+  {
+    name: {
+      type: String,
+      required: [true, 'Camera name is required'],
+      trim: true,
+      maxlength: [100, 'Camera name must be less than 100 characters']
+    },
+    description: {
+      type: String,
+      maxlength: [500, 'Description must be less than 500 characters']
+    },
+    streamUrl: {
+      type: String,
+      required: [true, 'Stream URL is required'],
+      match: [
+        /^(rtsp|http|https):\/\/.+/,
+        'Stream URL must be a valid RTSP, HTTP, or HTTPS URL'
+      ]
+    },
+    location: {
+        type: {
+          type: String,
+          enum: ['Point'],
+          default: 'Point',
+          required: true,
+        },
+        coordinates: {
+        type: [Number],
+        required: true,
+        validate: {
+          validator: function (coordinates: number[]) {
+            return (
+              coordinates.length === 2 &&
+              coordinates[0] >= -180 && coordinates[0] <= 180 &&
+              coordinates[1] >= -90 && coordinates[1] <= 90
+            );
+          },
+          message: 'Coordinates must be [longitude, latitude] with valid ranges',
+        },
+      },
+      address: { type: String },
+    },
+
     status: {
       type: String,
       enum: ['online', 'offline', 'maintenance'],
-      default: 'offline'
-    },
-    type: {
-      type: String,
-      enum: ['ip', 'analog', 'usb'],
-      default: 'ip'
+      default: 'online' // New cameras should be ON by default
     },
+    type: {
+      type: String,
+      enum: ['ip', 'analog', 'usb'],
+      default: 'ip'
+    },
     settings: {
       resolution: {
         type: String,
         default: '1920x1080'
       },
-      fps: {
-        type: Number,
-        default: 30,
-        min: 1,
-        max: 60
-      },
+      fps: {
+        type: Number,
+        default: 30,
+        min: 1,
+        max: 60
+      },
       recordingEnabled: {
         type: Boolean,
         default: false
       }
     },
-    isActive: {
-      type: Boolean,
-      default: true
+    // TEST-ONLY: metadata.source labels demo/import cameras for easier cleanup.
+    metadata: {
+      source: {
+        type: String,
+      },
     },
-    createdBy: {
-      type: mongoose.Schema.Types.ObjectId,
-      ref: 'User',
-      required: true
-    }
-  },
-  {
-    timestamps: true
-  }
-);
-
-// Indexes for better query performance
-cameraSchema.index({ location: '2dsphere' });
-cameraSchema.index({ status: 1 });
-cameraSchema.index({ isActive: 1 });
-cameraSchema.index({ createdBy: 1 });
-
-export const Camera = mongoose.model<ICamera>('Camera', cameraSchema);
\ No newline at end of file
+             /**
+     * VMS mapping block
+     * Why: allows attaching a camera to a specific VMS server instance + monitor id,
+     * so later we can request live/playback URLs from the VMS instead of trying to play RTSP directly in-browser.
+     */
+    vms: {
+      provider: {
+        type: String,
+        enum: ['shinobi', 'zoneminder', 'agentdvr', 'other'],
+        default: 'other',
+      },
+      serverId: {
+        type: mongoose.Schema.Types.ObjectId,
+        ref: 'VmsServer',
+      },
+      monitorId: {
+        type: String,
+      },
+      lastSyncAt: {
+        type: Date,
+      },
+    },
+
+    isActive: {
+      type: Boolean,
+      default: true
+    },
+
+    isDeleted: {
+      type: Boolean,
+      default: false
+    },
+    lastModified: {
+      type: Date
+    },
+    lastSeen: {
+      type: Date
+    },
+    
+    createdBy: {
+      type: mongoose.Schema.Types.ObjectId,
+      ref: 'User',
+      required: true
+    }
+  },
+  {
+    timestamps: true
+  }
+);
+
+// Indexes for better query performance
+cameraSchema.index({ location: '2dsphere' });
+cameraSchema.index({ status: 1 });
+cameraSchema.index({ isActive: 1 });
+cameraSchema.index({ createdBy: 1 });
+cameraSchema.index({ 'vms.serverId': 1 });
+cameraSchema.index({ 'vms.provider': 1 });
+
+
+export const Camera = mongoose.model<ICamera>('Camera', cameraSchema);
diff --git a/event-monitoring-mvp/backend/src/models/Company.ts b/event-monitoring-mvp/backend/src/models/Company.ts
new file mode 100644
index 0000000..88602b3
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/models/Company.ts
@@ -0,0 +1,48 @@
+import mongoose, { Document, Schema } from 'mongoose';
+
+export interface ICompany extends Document {
+  companyId: string;
+  name: string;
+  apiKey: string;
+  isActive: boolean;
+  settings: Record<string, any>;
+  createdAt: Date;
+  updatedAt: Date;
+}
+
+const companySchema = new Schema<ICompany>(
+  {
+    companyId: {
+      type: String,
+      required: true,
+      unique: true,
+      trim: true
+    },
+    name: {
+      type: String,
+      required: true,
+      trim: true
+    },
+    apiKey: {
+      type: String,
+      required: true,
+      unique: true
+    },
+    isActive: {
+      type: Boolean,
+      default: true
+    },
+    settings: {
+      type: Schema.Types.Mixed,
+      default: {}
+    }
+  },
+  {
+    timestamps: true
+  }
+);
+
+companySchema.index({ apiKey: 1 });
+companySchema.index({ isActive: 1 });
+
+export const Company = mongoose.model<ICompany>('Company', companySchema);
diff --git a/event-monitoring-mvp/backend/src/models/Event.ts b/event-monitoring-mvp/backend/src/models/Event.ts
index adaf6a4..5e0cf43 100644
--- a/event-monitoring-mvp/backend/src/models/Event.ts
+++ b/event-monitoring-mvp/backend/src/models/Event.ts
@@ -1,219 +1,473 @@
-import mongoose, { Document, Schema } from 'mongoose';
-
-export interface IEvent extends Document {
-  title: string;
-  description?: string;
-  type: 'security_incident' | 'traffic_violation' | 'emergency' | 'maintenance_needed' | 'user_report' | 'system_alert' | 'motion_detected' | 'person_detected' | 'vehicle_detected' | 'unauthorized_access' | 'suspicious_activity' | 'other';
-  severity: 'low' | 'medium' | 'high' | 'critical' | 'emergency';
-  priority: 1 | 2 | 3 | 4 | 5; // 1 = highest, 5 = lowest
-  status: 'pending' | 'acknowledged' | 'investigating' | 'resolved' | 'closed' | 'dismissed';
-  cameraId?: mongoose.Types.ObjectId; // Optional for user reports
-  detectionId?: mongoose.Types.ObjectId; // Link to original detection if promoted
-  location: {
-    coordinates: [number, number]; // [longitude, latitude]
-    address?: string;
-    accuracy?: number; // GPS accuracy in meters
-  };
-  detectionData?: {
-    confidence?: number;
-    boundingBox?: {
-      x: number;
-      y: number;
-      width: number;
-      height: number;
-    };
-    objectCount?: number;
-    aiModel?: string;
-    detectionTimestamp?: Date;
-  };
-  media: {
-    images: string[]; // Array of image URLs
-    videos: string[]; // Array of video URLs
-    thumbnails: string[]; // Array of thumbnail URLs
-    attachments: Array<{
-      fileName: string;
-      fileUrl: string;
-      fileType: string;
-      fileSize: number;
-      uploadedAt: Date;
-    }>;
-  };
-  reporter: {
-    userId?: mongoose.Types.ObjectId; // If reported by registered user
-    name?: string; // For anonymous reports
-    email?: string;
-    phone?: string;
-    isAnonymous: boolean;
-  };
-  assignedTo?: mongoose.Types.ObjectId;
-  acknowledgedBy?: mongoose.Types.ObjectId;
-  acknowledgedAt?: Date;
-  resolvedBy?: mongoose.Types.ObjectId;
-  resolvedAt?: Date;
-  estimatedResolutionTime?: Date;
-  actualResolutionTime?: Date;
-  notes: Array<{
-    content: string;
-    createdBy: mongoose.Types.ObjectId;
-    createdAt: Date;
-    noteType: 'general' | 'investigation' | 'resolution' | 'escalation';
-  }>;
-  tags: string[];
-  customFields: Map<string, any>; // Flexible custom data
-  source: 'camera_system' | 'user_report' | 'ai_detection' | 'sensor_alert' | 'manual_entry' | 'mobile_app';
-  verified: boolean; // Whether the event has been verified by an operator
-  publiclyVisible: boolean; // Whether visible in public feeds
-  resolution: {
-    summary?: string;
-    actions: string[];
-    preventiveMeasures?: string[];
-    followUpRequired: boolean;
-    satisfactionRating?: number; // 1-5 if applicable
-  };
-  workflow: Array<{
-    status: string;
-    timestamp: Date;
-    userId: mongoose.Types.ObjectId;
-    notes?: string;
-  }>;
-  createdAt: Date;
-  updatedAt: Date;
-}
-
-const eventSchema = new Schema<IEvent>(
-  {
-    title: {
-      type: String,
-      required: [true, 'Event title is required'],
-      trim: true,
-      maxlength: [200, 'Title must be less than 200 characters']
-    },
-    description: {
-      type: String,
-      maxlength: [1000, 'Description must be less than 1000 characters']
-    },
-    type: {
-      type: String,
-      required: true,
-      enum: ['security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 'user_report', 'system_alert', 'motion_detected', 'person_detected', 'vehicle_detected', 'unauthorized_access', 'suspicious_activity', 'other']
-    },
-    severity: {
-      type: String,
-      required: true,
-      enum: ['low', 'medium', 'high', 'critical', 'emergency'],
-      default: 'medium'
-    },
-    priority: {
-      type: Number,
-      required: true,
-      enum: [1, 2, 3, 4, 5],
-      default: 3
-    },
-    status: {
-      type: String,
-      required: true,
-      enum: ['pending', 'acknowledged', 'investigating', 'resolved', 'closed', 'dismissed'],
-      default: 'pending'
-    },
-    cameraId: {
-      type: mongoose.Schema.Types.ObjectId,
-      ref: 'Camera',
-      required: false // Optional for user reports
-    },
-    detectionId: {
-      type: mongoose.Schema.Types.ObjectId,
-      ref: 'Detection',
-      required: false
-    },
-    location: {
-      type: {
-        coordinates: {
-          type: [Number],
-          required: true
-        },
-        address: String
-      },
-      required: true,
-      index: '2dsphere'
-    },
-    detectionData: {
-      confidence: {
-        type: Number,
-        required: true,
-        min: 0,
-        max: 1
-      },
-      boundingBox: {
-        x: Number,
-        y: Number,
-        width: Number,
-        height: Number
-      },
-      objectCount: {
-        type: Number,
-        default: 1,
-        min: 0
-      },
-      aiModel: String
-    },
-    media: {
-      imageUrl: String,
-      videoUrl: String,
-      thumbnailUrl: String
-    },
-    assignedTo: {
-      type: mongoose.Schema.Types.ObjectId,
-      ref: 'User'
-    },
-    acknowledgedBy: {
-      type: mongoose.Schema.Types.ObjectId,
-      ref: 'User'
-    },
-    acknowledgedAt: Date,
-    resolvedBy: {
-      type: mongoose.Schema.Types.ObjectId,
-      ref: 'User'
-    },
-    resolvedAt: Date,
-    notes: [{
-      content: {
-        type: String,
-        required: true,
-        maxlength: [500, 'Note content must be less than 500 characters']
-      },
-      createdBy: {
-        type: mongoose.Schema.Types.ObjectId,
-        ref: 'User',
-        required: true
-      },
-      createdAt: {
-        type: Date,
-        default: Date.now
-      }
-    }],
-    tags: [{
-      type: String,
-      trim: true,
-      maxlength: [50, 'Tag must be less than 50 characters']
-    }]
-  },
-  {
-    timestamps: true
-  }
-);
-
-// Indexes for better query performance
-eventSchema.index({ cameraId: 1 });
-eventSchema.index({ type: 1 });
-eventSchema.index({ severity: 1 });
-eventSchema.index({ status: 1 });
-eventSchema.index({ location: '2dsphere' });
-eventSchema.index({ createdAt: -1 });
-eventSchema.index({ assignedTo: 1 });
-
-// Compound indexes for common queries
-eventSchema.index({ status: 1, createdAt: -1 });
-eventSchema.index({ type: 1, status: 1 });
-eventSchema.index({ cameraId: 1, createdAt: -1 });
-
+import mongoose, { Document, Schema } from 'mongoose';
+
+/**
+ * Enhanced Event interface with mobile support and EventType integration
+ */
+export interface IEvent extends Document {
+  title: string;
+  description?: string;
+  type: string; // Legacy field for backward compatibility  
+  severity: 'low' | 'medium' | 'high' | 'critical' | 'emergency';
+  priority: 1 | 2 | 3 | 4 | 5;
+  status: 'pending' | 'acknowledged' | 'investigating' | 'resolved' | 'closed' | 'dismissed';
+  cameraId?: mongoose.Types.ObjectId;
+  detectionId?: mongoose.Types.ObjectId;
+  location: {
+    coordinates: [number, number]; // [longitude, latitude]
+    address?: string;
+    accuracy?: number;
+  };
+  detectionData?: {
+    confidence?: number;
+    boundingBox?: {
+      x: number;
+      y: number;
+      width: number;
+      height: number;
+    };
+    objectCount?: number;
+    aiModel?: string;
+    detectionTimestamp?: Date;
+  };
+  media: {
+    images: string[];
+    videos: string[];
+    thumbnails: string[];
+    attachments: Array<{
+      fileName: string;
+      fileUrl: string;
+      fileType: string;
+      fileSize: number;
+      uploadedAt: Date;
+    }>;
+  };
+  reporter: {
+    userId?: mongoose.Types.ObjectId;
+    name?: string;
+    email?: string;
+    phone?: string;
+    isAnonymous: boolean;
+  };
+  assignedTo?: mongoose.Types.ObjectId;
+  acknowledgedBy?: mongoose.Types.ObjectId;
+  acknowledgedAt?: Date;
+  resolvedBy?: mongoose.Types.ObjectId;
+  resolvedAt?: Date;
+  estimatedResolutionTime?: Date;
+  actualResolutionTime?: Date;
+  notes: Array<{
+    content: string;
+    author: mongoose.Types.ObjectId;
+    timestamp: Date;
+    noteType: 'general' | 'investigation' | 'resolution' | 'escalation';
+    isInternal: boolean;
+  }>;
+  tags: string[];
+  customFields: Map<string, any>;
+  source: 'camera_system' | 'user_report' | 'ai_detection' | 'sensor_alert' | 'manual_entry' | 'mobile_app';
+  verified: boolean;
+  publiclyVisible: boolean;
+  resolution: {
+    summary?: string;
+    actions: string[];
+    preventiveMeasures?: string[];
+    followUpRequired: boolean;
+    satisfactionRating?: number;
+  };
+  workflow: Array<{
+    status: string;
+    timestamp: Date;
+    userId: mongoose.Types.ObjectId;
+    notes?: string;
+  }>;
+  createdAt: Date;
+  updatedAt: Date;
+}
+
+/**
+ * Enhanced Event Schema with mobile support and backward compatibility
+ */
+const eventSchema = new Schema<IEvent>({
+  title: {
+    type: String,
+    required: [true, 'Event title is required'],
+    trim: true,
+    maxlength: [200, 'Title must be less than 200 characters'],
+    minlength: [3, 'Title must be at least 3 characters']
+  },
+  description: {
+    type: String,
+    trim: true,
+    maxlength: [2000, 'Description must be less than 2000 characters']
+  },
+  type: {
+    type: String,
+    required: [true, 'Event type is required'],
+    enum: {
+      values: [
+        'security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 
+        'user_report', 'system_alert', 'motion_detected', 'person_detected', 
+        'vehicle_detected', 'unauthorized_access', 'suspicious_activity', 'other'
+      ],
+      message: 'Invalid event type'
+    }
+  },
+  severity: {
+    type: String,
+    required: [true, 'Event severity is required'],
+    enum: {
+      values: ['low', 'medium', 'high', 'critical', 'emergency'],
+      message: 'Invalid severity level'
+    },
+    default: 'medium'
+  },
+  priority: {
+    type: Number,
+    required: [true, 'Event priority is required'],
+    enum: [1, 2, 3, 4, 5],
+    default: 3
+  },
+  status: {
+    type: String,
+    required: [true, 'Event status is required'],
+    enum: {
+      values: ['pending', 'acknowledged', 'investigating', 'resolved', 'closed', 'dismissed'],
+      message: 'Invalid event status'
+    },
+    default: 'pending'
+  },
+  cameraId: {
+    type: Schema.Types.ObjectId,
+    ref: 'Camera'
+  },
+  detectionId: {
+    type: Schema.Types.ObjectId,
+    ref: 'AIDetection'
+  },
+  location: {
+    coordinates: {
+      type: [Number],
+      required: [true, 'Location coordinates are required'],
+      validate: {
+        validator: function(coordinates: number[]) {
+          return coordinates.length === 2 && 
+                 coordinates[0] >= -180 && coordinates[0] <= 180 &&
+                 coordinates[1] >= -90 && coordinates[1] <= 90;
+        },
+        message: 'Location coordinates must be [longitude, latitude] within valid ranges'
+      }
+    },
+    address: {
+      type: String,
+      trim: true,
+      maxlength: [500, 'Address must be less than 500 characters']
+    },
+    accuracy: {
+      type: Number,
+      min: [0, 'Location accuracy must be positive'],
+      max: [10000, 'Location accuracy seems too high']
+    }
+  },
+  detectionData: {
+    confidence: {
+      type: Number,
+      min: [0, 'Confidence must be between 0 and 1'],
+      max: [1, 'Confidence must be between 0 and 1']
+    },
+    boundingBox: {
+      x: Number,
+      y: Number,
+      width: Number,
+      height: Number
+    },
+    objectCount: {
+      type: Number,
+      default: 1,
+      min: [0, 'Object count cannot be negative']
+    },
+    aiModel: {
+      type: String,
+      trim: true
+    },
+    detectionTimestamp: Date
+  },
+  media: {
+    images: {
+      type: [String],
+      default: [],
+      validate: {
+        validator: function(images: string[]) {
+          return images.length <= 10;
+        },
+        message: 'Too many images (max 10)'
+      }
+    },
+    videos: {
+      type: [String],
+      default: [],
+      validate: {
+        validator: function(videos: string[]) {
+          return videos.length <= 5;
+        },
+        message: 'Too many videos (max 5)'
+      }
+    },
+    thumbnails: {
+      type: [String],
+      default: []
+    },
+    attachments: [{
+      fileName: {
+        type: String,
+        required: true,
+        trim: true
+      },
+      fileUrl: {
+        type: String,
+        required: true,
+        trim: true
+      },
+      fileType: {
+        type: String,
+        required: true,
+        trim: true
+      },
+      fileSize: {
+        type: Number,
+        required: true,
+        min: [0, 'File size cannot be negative']
+      },
+      uploadedAt: {
+        type: Date,
+        default: Date.now
+      }
+    }]
+  },
+  reporter: {
+    userId: {
+      type: Schema.Types.ObjectId,
+      ref: 'User'
+    },
+    name: {
+      type: String,
+      trim: true,
+      maxlength: [100, 'Reporter name must be less than 100 characters']
+    },
+    email: {
+      type: String,
+      trim: true,
+      lowercase: true,
+      validate: {
+        validator: function(email: string) {
+          return !email || /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
+        },
+        message: 'Invalid email format'
+      }
+    },
+    phone: {
+      type: String,
+      trim: true,
+      validate: {
+        validator: function(phone: string) {
+          return !phone || /^\+?[1-9]\d{1,14}$/.test(phone);
+        },
+        message: 'Invalid phone number format'
+      }
+    },
+    isAnonymous: {
+      type: Boolean,
+      required: [true, 'Anonymous flag is required'],
+      default: false
+    }
+  },
+  assignedTo: {
+    type: Schema.Types.ObjectId,
+    ref: 'User'
+  },
+  acknowledgedBy: {
+    type: Schema.Types.ObjectId,
+    ref: 'User'
+  },
+  acknowledgedAt: Date,
+  resolvedBy: {
+    type: Schema.Types.ObjectId,
+    ref: 'User'
+  },
+  resolvedAt: Date,
+  estimatedResolutionTime: Date,
+  actualResolutionTime: Date,
+  notes: [{
+    content: {
+      type: String,
+      required: [true, 'Note content is required'],
+      trim: true,
+      maxlength: [2000, 'Note content must be less than 2000 characters']
+    },
+    author: {
+      type: Schema.Types.ObjectId,
+      ref: 'User',
+      required: [true, 'Note author is required']
+    },
+    timestamp: {
+      type: Date,
+      default: Date.now
+    },
+    noteType: {
+      type: String,
+      enum: ['general', 'investigation', 'resolution', 'escalation'],
+      default: 'general'
+    },
+    isInternal: {
+      type: Boolean,
+      default: false
+    }
+  }],
+  tags: {
+    type: [String],
+    default: [],
+    validate: {
+      validator: function(tags: string[]) {
+        return tags.length <= 20;
+      },
+      message: 'Too many tags (max 20)'
+    }
+  },
+  customFields: {
+    type: Map,
+    of: Schema.Types.Mixed,
+    default: new Map()
+  },
+  source: {
+    type: String,
+    required: [true, 'Event source is required'],
+    enum: {
+      values: ['camera_system', 'user_report', 'ai_detection', 'sensor_alert', 'manual_entry', 'mobile_app'],
+      message: 'Invalid event source'
+    },
+    default: 'manual_entry'
+  },
+  verified: {
+    type: Boolean,
+    default: false
+  },
+  publiclyVisible: {
+    type: Boolean,
+    default: false
+  },
+  resolution: {
+    summary: {
+      type: String,
+      trim: true,
+      maxlength: [1000, 'Resolution summary must be less than 1000 characters']
+    },
+    actions: {
+      type: [String],
+      default: []
+    },
+    preventiveMeasures: {
+      type: [String],
+      default: []
+    },
+    followUpRequired: {
+      type: Boolean,
+      default: false
+    },
+    satisfactionRating: {
+      type: Number,
+      min: [1, 'Rating must be between 1 and 5'],
+      max: [5, 'Rating must be between 1 and 5']
+    }
+  },
+  workflow: [{
+    status: {
+      type: String,
+      required: true
+    },
+    timestamp: {
+      type: Date,
+      default: Date.now
+    },
+    userId: {
+      type: Schema.Types.ObjectId,
+      ref: 'User',
+      required: true
+    },
+    notes: String
+  }]
+}, {
+  timestamps: true,
+  toJSON: { virtuals: true },
+  toObject: { virtuals: true }
+});
+
+// Indexes for performance optimization
+eventSchema.index({ 'location.coordinates': '2dsphere' });
+eventSchema.index({ type: 1 });
+eventSchema.index({ status: 1 });
+eventSchema.index({ severity: 1 });
+eventSchema.index({ priority: 1 });
+eventSchema.index({ cameraId: 1 });
+eventSchema.index({ 'reporter.userId': 1 });
+eventSchema.index({ assignedTo: 1 });
+eventSchema.index({ createdAt: -1 });
+eventSchema.index({ tags: 1 });
+eventSchema.index({ source: 1 });
+eventSchema.index({ verified: 1 });
+eventSchema.index({ publiclyVisible: 1 });
+
+// Virtual fields
+eventSchema.virtual('isResolved').get(function() {
+  return ['resolved', 'closed'].includes(this.status);
+});
+
+eventSchema.virtual('isOverdue').get(function() {
+  return this.estimatedResolutionTime && 
+         this.estimatedResolutionTime < new Date() && 
+         !this.isResolved;
+});
+
+// Pre-save middleware
+eventSchema.pre('save', function(next) {
+  // Auto-resolve timestamp
+  if (this.isModified('status') && this.status === 'resolved' && !this.resolvedAt) {
+    this.resolvedAt = new Date();
+    this.actualResolutionTime = new Date();
+  }
+
+  // Add to workflow
+  if (this.isModified('status')) {
+    this.workflow.push({
+      status: this.status,
+      timestamp: new Date(),
+      userId: this.assignedTo || this.reporter.userId,
+      notes: `Status changed to ${this.status}`
+    } as any);
+  }
+
+  next();
+});
+
+// Instance methods
+eventSchema.methods.addNote = function(content: string, author: mongoose.Types.ObjectId, type = 'general', isInternal = false) {
+  this.notes.push({
+    content,
+    author,
+    timestamp: new Date(),
+    noteType: type,
+    isInternal
+  });
+  return this.save();
+};
+
+eventSchema.methods.assign = function(userId: mongoose.Types.ObjectId, assignedBy?: mongoose.Types.ObjectId) {
+  this.assignedTo = userId;
+  this.workflow.push({
+    status: 'assigned',
+    timestamp: new Date(),
+    userId: assignedBy || userId,
+    notes: `Event assigned to user ${userId}`
+  });
+  return this.save();
+};
+
 export const Event = mongoose.model<IEvent>('Event', eventSchema);
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/models/EventType.ts b/event-monitoring-mvp/backend/src/models/EventType.ts
new file mode 100644
index 0000000..875ec55
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/models/EventType.ts
@@ -0,0 +1,296 @@
+import mongoose, { Document, Schema } from 'mongoose';
+
+/**
+ * Interface for Event Type document
+ * 
+ * This model supports a flexible hierarchical event type system where
+ * types can have subtypes, allowing for dynamic management by mobile
+ * teams and administrators without code changes.
+ */
+export interface IEventType extends Document {
+  name: string;
+  description?: string;
+  category: 'security' | 'traffic' | 'emergency' | 'maintenance' | 'social' | 'environmental' | 'infrastructure' | 'other';
+  parentType?: mongoose.Types.ObjectId; // Reference to parent type for subtypes
+  isActive: boolean;
+  isPublic: boolean; // Can be used by citizen reporters
+  requiresVerification: boolean; // Needs operator approval
+  defaultSeverity: 'low' | 'medium' | 'high' | 'critical' | 'emergency';
+  defaultPriority: 1 | 2 | 3 | 4 | 5;
+  requiredFields: string[]; // Array of required field names for this event type
+  allowedRoles: string[]; // Which user roles can create events of this type
+  autoAssignmentRules?: {
+    severity?: 'low' | 'medium' | 'high' | 'critical' | 'emergency';
+    location?: {
+      type: 'Point';
+      coordinates: [number, number];
+      radius: number; // In meters
+    };
+    timeRange?: {
+      startHour: number; // 0-23
+      endHour: number; // 0-23
+    };
+    assignTo?: mongoose.Types.ObjectId; // User ID to auto-assign
+  };
+  metadata: {
+    createdBy: mongoose.Types.ObjectId;
+    lastModifiedBy: mongoose.Types.ObjectId;
+    version: number;
+    tags: string[];
+    externalId?: string; // For mobile team integration
+  };
+  statistics: {
+    totalEvents: number;
+    lastUsed?: Date;
+    avgResolutionTime?: number; // In minutes
+  };
+}
+
+/**
+ * Event Type Schema Definition
+ * 
+ * Supports hierarchical event types with flexible validation rules,
+ * auto-assignment capabilities, and comprehensive metadata tracking.
+ */
+const EventTypeSchema = new Schema<IEventType>({
+  name: {
+    type: String,
+    required: [true, 'Event type name is required'],
+    trim: true,
+    minlength: [2, 'Event type name must be at least 2 characters'],
+    maxlength: [100, 'Event type name cannot exceed 100 characters']
+  },
+  description: {
+    type: String,
+    trim: true,
+    maxlength: [500, 'Description cannot exceed 500 characters']
+  },
+  category: {
+    type: String,
+    required: [true, 'Category is required'],
+    enum: {
+      values: ['security', 'traffic', 'emergency', 'maintenance', 'social', 'environmental', 'infrastructure', 'other'],
+      message: '{VALUE} is not a valid category'
+    }
+  },
+  parentType: {
+    type: Schema.Types.ObjectId,
+    ref: 'EventType',
+    default: null
+  },
+  isActive: {
+    type: Boolean,
+    default: true
+  },
+  isPublic: {
+    type: Boolean,
+    default: false
+  },
+  requiresVerification: {
+    type: Boolean,
+    default: true
+  },
+  defaultSeverity: {
+    type: String,
+    required: [true, 'Default severity is required'],
+    enum: {
+      values: ['low', 'medium', 'high', 'critical', 'emergency'],
+      message: '{VALUE} is not a valid severity level'
+    },
+    default: 'medium'
+  },
+  defaultPriority: {
+    type: Number,
+    required: [true, 'Default priority is required'],
+    min: [1, 'Priority must be between 1 and 5'],
+    max: [5, 'Priority must be between 1 and 5'],
+    default: 3
+  },
+  requiredFields: {
+    type: [String],
+    default: ['title', 'location']
+  },
+  allowedRoles: {
+    type: [String],
+    required: [true, 'At least one allowed role must be specified'],
+    validate: {
+      validator: function(roles: string[]) {
+        const validRoles = ['citizen', 'operator', 'admin', 'mobile_admin', 'super_admin'];
+        return roles.every(role => validRoles.includes(role)) && roles.length > 0;
+      },
+      message: 'Invalid user role in allowedRoles array'
+    }
+  },
+  autoAssignmentRules: {
+    severity: {
+      type: String,
+      enum: ['low', 'medium', 'high', 'critical', 'emergency']
+    },
+    location: {
+      type: {
+        type: String,
+        enum: ['Point']
+      },
+      coordinates: {
+        type: [Number],
+        validate: {
+          validator: function(coordinates: number[]) {
+            return coordinates && coordinates.length === 2;
+          },
+          message: 'Location coordinates must be [longitude, latitude]'
+        }
+      },
+      radius: {
+        type: Number,
+        min: [0, 'Radius must be positive']
+      }
+    },
+    timeRange: {
+      startHour: {
+        type: Number,
+        min: [0, 'Start hour must be between 0 and 23'],
+        max: [23, 'Start hour must be between 0 and 23']
+      },
+      endHour: {
+        type: Number,
+        min: [0, 'End hour must be between 0 and 23'],
+        max: [23, 'End hour must be between 0 and 23']
+      }
+    },
+    assignTo: {
+      type: Schema.Types.ObjectId,
+      ref: 'User'
+    }
+  },
+  metadata: {
+    createdBy: {
+      type: Schema.Types.ObjectId,
+      ref: 'User',
+      required: [true, 'Created by user is required']
+    },
+    lastModifiedBy: {
+      type: Schema.Types.ObjectId,
+      ref: 'User',
+      required: [true, 'Last modified by user is required']
+    },
+    version: {
+      type: Number,
+      default: 1,
+      min: [1, 'Version must be positive']
+    },
+    tags: {
+      type: [String],
+      default: []
+    },
+    externalId: {
+      type: String,
+      sparse: true,
+      unique: true
+    }
+  },
+  statistics: {
+    totalEvents: {
+      type: Number,
+      default: 0,
+      min: [0, 'Total events cannot be negative']
+    },
+    lastUsed: {
+      type: Date
+    },
+    avgResolutionTime: {
+      type: Number,
+      min: [0, 'Average resolution time cannot be negative']
+    }
+  }
+}, {
+  timestamps: true,
+  toJSON: { virtuals: true },
+  toObject: { virtuals: true }
+});
+
+// Indexes for performance optimization
+EventTypeSchema.index({ name: 1, parentType: 1 }, { unique: true });
+EventTypeSchema.index({ category: 1 });
+EventTypeSchema.index({ isActive: 1, isPublic: 1 });
+EventTypeSchema.index({ allowedRoles: 1 });
+EventTypeSchema.index({ 'metadata.externalId': 1 }, { sparse: true });
+EventTypeSchema.index({ 'autoAssignmentRules.location': '2dsphere' });
+
+// Virtual for getting all subtypes
+EventTypeSchema.virtual('subtypes', {
+  ref: 'EventType',
+  localField: '_id',
+  foreignField: 'parentType'
+});
+
+// Virtual for getting full hierarchical path
+EventTypeSchema.virtual('fullPath').get(function() {
+  if (this.parentType) {
+    return `${this.parentType.name || 'Unknown'} > ${this.name}`;
+  }
+  return this.name;
+});
+
+// Middleware to prevent deletion of event types that are in use
+EventTypeSchema.pre('deleteOne', { document: true, query: false }, async function() {
+  const Event = mongoose.model('Event');
+  const eventsUsingType = await Event.countDocuments({ 
+    $or: [
+      { 'eventType.typeId': this._id },
+      { type: this.name } // Backward compatibility check
+    ]
+  });
+  
+  if (eventsUsingType > 0) {
+    throw new Error(`Cannot delete event type '${this.name}' as it is being used by ${eventsUsingType} events`);
+  }
+});
+
+// Middleware to update version number on modification
+EventTypeSchema.pre('save', function() {
+  if (this.isModified() && !this.isNew) {
+    this.metadata.version += 1;
+  }
+});
+
+// Static method to get event types by category
+EventTypeSchema.statics.getByCategory = function(category: string, includeInactive = false) {
+  const query: any = { category };
+  if (!includeInactive) {
+    query.isActive = true;
+  }
+  return this.find(query).populate('parentType', 'name').sort({ name: 1 });
+};
+
+// Static method to get public event types for mobile app
+EventTypeSchema.statics.getPublicTypes = function() {
+  return this.find({ 
+    isActive: true, 
+    isPublic: true,
+    allowedRoles: { $in: ['citizen'] }
+  }).populate('parentType', 'name').sort({ category: 1, name: 1 });
+};
+
+// Instance method to check if user can use this event type
+EventTypeSchema.methods.canBeUsedBy = function(userRole: string) {
+  return this.isActive && this.allowedRoles.includes(userRole);
+};
+
+// Instance method to get complete hierarchy
+EventTypeSchema.methods.getHierarchy = async function() {
+  const hierarchy = [this.name];
+  let current = this;
+  
+  while (current.parentType) {
+    current = await this.model('EventType').findById(current.parentType);
+    if (current) {
+      hierarchy.unshift(current.name);
+    } else {
+      break;
+    }
+  }
+  
+  return hierarchy.join(' > ');
+};
+
+export const EventType = mongoose.model<IEventType>('EventType', EventTypeSchema);
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/models/FirstResponder.ts b/event-monitoring-mvp/backend/src/models/FirstResponder.ts
new file mode 100644
index 0000000..0a8c0d0
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/models/FirstResponder.ts
@@ -0,0 +1,57 @@
+import mongoose, { Document, Schema } from 'mongoose';
+
+export interface IFirstResponder extends Document {
+  frId: string;
+  phone: string;
+  name: string;
+  role: string;
+  companyId: mongoose.Types.ObjectId;
+  isActive: boolean;
+  createdAt: Date;
+  updatedAt: Date;
+}
+
+const firstResponderSchema = new Schema<IFirstResponder>(
+  {
+    frId: {
+      type: String,
+      required: true,
+      unique: true,
+      trim: true
+    },
+    phone: {
+      type: String,
+      required: true,
+      unique: true,
+      trim: true
+    },
+    name: {
+      type: String,
+      required: true,
+      trim: true
+    },
+    role: {
+      type: String,
+      required: true,
+      trim: true
+    },
+    companyId: {
+      type: Schema.Types.ObjectId,
+      ref: 'Company',
+      required: true
+    },
+    isActive: {
+      type: Boolean,
+      default: true
+    }
+  },
+  {
+    timestamps: true
+  }
+);
+
+firstResponderSchema.index({ phone: 1 });
+firstResponderSchema.index({ companyId: 1 });
+firstResponderSchema.index({ isActive: 1 });
+
+export const FirstResponder = mongoose.model<IFirstResponder>('FirstResponder', firstResponderSchema);
diff --git a/event-monitoring-mvp/backend/src/models/Permission.ts b/event-monitoring-mvp/backend/src/models/Permission.ts
new file mode 100644
index 0000000..7889bc4
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/models/Permission.ts
@@ -0,0 +1,365 @@
+import mongoose, { Document, Schema } from 'mongoose';
+
+/**
+ * Interface for Permission document
+ * 
+ * This model defines granular permissions that can be assigned to users,
+ * allowing super admins to create flexible authorization systems without
+ * code changes. Supports resource-specific permissions and dynamic assignment.
+ */
+export interface IPermission extends Document {
+  name: string;
+  description?: string;
+  resource: string; // e.g., 'events', 'cameras', 'users', 'reports', 'eventTypes'
+  actions: string[]; // e.g., ['read', 'create', 'update', 'delete', 'assign', 'approve']
+  scope: 'global' | 'location' | 'department' | 'self' | 'assigned';
+  conditions?: {
+    locations?: mongoose.Types.ObjectId[]; // Geographic restrictions
+    departments?: string[]; // Department-based restrictions
+    severity?: ('low' | 'medium' | 'high' | 'critical' | 'emergency')[]; // Severity limitations
+    timeRestrictions?: {
+      allowedHours: { start: number; end: number }[];
+      allowedDays: number[]; // 0-6 (Sunday-Saturday)
+      timezone: string;
+    };
+    ipWhitelist?: string[]; // IP-based restrictions
+  };
+  metadata: {
+    createdBy: mongoose.Types.ObjectId;
+    lastModifiedBy: mongoose.Types.ObjectId;
+    isSystemPermission: boolean; // Cannot be deleted by users
+    version: number;
+    tags: string[];
+  };
+  usage: {
+    assignedToUsers: number;
+    assignedToRoles: number;
+    lastAssigned?: Date;
+  };
+}
+
+/**
+ * Permission Schema Definition
+ * 
+ * Defines granular permissions with flexible conditions and scope controls
+ * for implementing fine-grained authorization systems.
+ */
+const PermissionSchema = new Schema<IPermission>({
+  name: {
+    type: String,
+    required: [true, 'Permission name is required'],
+    unique: true,
+    trim: true,
+    minlength: [3, 'Permission name must be at least 3 characters'],
+    maxlength: [100, 'Permission name cannot exceed 100 characters'],
+    match: [/^[a-zA-Z0-9_.-]+$/, 'Permission name can only contain letters, numbers, underscores, dots, and hyphens']
+  },
+  description: {
+    type: String,
+    trim: true,
+    maxlength: [500, 'Description cannot exceed 500 characters']
+  },
+  resource: {
+    type: String,
+    required: [true, 'Resource is required'],
+    enum: {
+      values: [
+        'events', 'cameras', 'users', 'reports', 'eventTypes', 
+        'permissions', 'analytics', 'settings', 'notifications',
+        'mobile_users', 'ai_detections', 'media', 'locations'
+      ],
+      message: '{VALUE} is not a valid resource'
+    }
+  },
+  actions: {
+    type: [String],
+    required: [true, 'At least one action must be specified'],
+    validate: {
+      validator: function(actions: string[]) {
+        const validActions = [
+          'read', 'create', 'update', 'delete', 'assign', 'approve',
+          'reject', 'escalate', 'export', 'import', 'archive', 
+          'restore', 'comment', 'share', 'download', 'upload'
+        ];
+        return actions.length > 0 && actions.every(action => validActions.includes(action));
+      },
+      message: 'Invalid action in actions array'
+    }
+  },
+  scope: {
+    type: String,
+    required: [true, 'Scope is required'],
+    enum: {
+      values: ['global', 'location', 'department', 'self', 'assigned'],
+      message: '{VALUE} is not a valid scope'
+    },
+    default: 'self'
+  },
+  conditions: {
+    locations: {
+      type: [Schema.Types.ObjectId],
+      ref: 'Location',
+      default: []
+    },
+    departments: {
+      type: [String],
+      default: []
+    },
+    severity: {
+      type: [String],
+      enum: ['low', 'medium', 'high', 'critical', 'emergency'],
+      default: []
+    },
+    timeRestrictions: {
+      allowedHours: [{
+        start: {
+          type: Number,
+          min: [0, 'Hour must be between 0 and 23'],
+          max: [23, 'Hour must be between 0 and 23']
+        },
+        end: {
+          type: Number,
+          min: [0, 'Hour must be between 0 and 23'],
+          max: [23, 'Hour must be between 0 and 23']
+        }
+      }],
+      allowedDays: {
+        type: [Number],
+        validate: {
+          validator: function(days: number[]) {
+            return days.every(day => day >= 0 && day <= 6);
+          },
+          message: 'Days must be between 0 (Sunday) and 6 (Saturday)'
+        }
+      },
+      timezone: {
+        type: String,
+        default: 'UTC'
+      }
+    },
+    ipWhitelist: {
+      type: [String],
+      validate: {
+        validator: function(ips: string[]) {
+          const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
+          const cidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\/([0-9]|[1-2][0-9]|3[0-2])$/;
+          return ips.every(ip => ipRegex.test(ip) || cidrRegex.test(ip));
+        },
+        message: 'Invalid IP address or CIDR notation in whitelist'
+      }
+    }
+  },
+  metadata: {
+    createdBy: {
+      type: Schema.Types.ObjectId,
+      ref: 'User',
+      required: [true, 'Created by user is required']
+    },
+    lastModifiedBy: {
+      type: Schema.Types.ObjectId,
+      ref: 'User',
+      required: [true, 'Last modified by user is required']
+    },
+    isSystemPermission: {
+      type: Boolean,
+      default: false
+    },
+    version: {
+      type: Number,
+      default: 1,
+      min: [1, 'Version must be positive']
+    },
+    tags: {
+      type: [String],
+      default: []
+    }
+  },
+  usage: {
+    assignedToUsers: {
+      type: Number,
+      default: 0,
+      min: [0, 'Assigned to users count cannot be negative']
+    },
+    assignedToRoles: {
+      type: Number,
+      default: 0,
+      min: [0, 'Assigned to roles count cannot be negative']
+    },
+    lastAssigned: {
+      type: Date
+    }
+  }
+}, {
+  timestamps: true,
+  toJSON: { virtuals: true },
+  toObject: { virtuals: true }
+});
+
+// Indexes for performance optimization
+PermissionSchema.index({ name: 1 }, { unique: true });
+PermissionSchema.index({ resource: 1, actions: 1 });
+PermissionSchema.index({ scope: 1 });
+PermissionSchema.index({ 'metadata.isSystemPermission': 1 });
+
+// Prevent deletion of system permissions
+PermissionSchema.pre('deleteOne', { document: true, query: false }, async function() {
+  if (this.metadata.isSystemPermission) {
+    throw new Error(`Cannot delete system permission '${this.name}'`);
+  }
+  
+  // Check if permission is assigned to any users or roles
+  if (this.usage.assignedToUsers > 0 || this.usage.assignedToRoles > 0) {
+    throw new Error(`Cannot delete permission '${this.name}' as it is currently assigned to users or roles`);
+  }
+});
+
+// Update version on modification
+PermissionSchema.pre('save', function() {
+  if (this.isModified() && !this.isNew) {
+    this.metadata.version += 1;
+  }
+});
+
+// Static method to get permissions by resource
+PermissionSchema.statics.getByResource = function(resource: string, actions?: string[]) {
+  const query: any = { resource };
+  if (actions && actions.length > 0) {
+    query.actions = { $in: actions };
+  }
+  return this.find(query).sort({ name: 1 });
+};
+
+// Static method to get all available resources
+PermissionSchema.statics.getResources = function() {
+  return this.distinct('resource');
+};
+
+// Instance method to check if permission applies to specific conditions
+PermissionSchema.methods.appliesToConditions = function(checkConditions: {
+  location?: string;
+  department?: string;
+  severity?: string;
+  currentTime?: Date;
+  userIp?: string;
+}) {
+  // Check location restrictions
+  if (this.conditions?.locations?.length > 0 && checkConditions.location) {
+    if (!this.conditions.locations.includes(checkConditions.location)) {
+      return false;
+    }
+  }
+  
+  // Check department restrictions
+  if (this.conditions?.departments?.length > 0 && checkConditions.department) {
+    if (!this.conditions.departments.includes(checkConditions.department)) {
+      return false;
+    }
+  }
+  
+  // Check severity restrictions
+  if (this.conditions?.severity?.length > 0 && checkConditions.severity) {
+    if (!this.conditions.severity.includes(checkConditions.severity as any)) {
+      return false;
+    }
+  }
+  
+  // Check time restrictions
+  if (this.conditions?.timeRestrictions && checkConditions.currentTime) {
+    const time = checkConditions.currentTime;
+    const hour = time.getHours();
+    const day = time.getDay();
+    
+    if (this.conditions.timeRestrictions.allowedDays?.length > 0) {
+      if (!this.conditions.timeRestrictions.allowedDays.includes(day)) {
+        return false;
+      }
+    }
+    
+    if (this.conditions.timeRestrictions.allowedHours?.length > 0) {
+      const isInAllowedHours = this.conditions.timeRestrictions.allowedHours.some(
+        range => hour >= range.start && hour <= range.end
+      );
+      if (!isInAllowedHours) {
+        return false;
+      }
+    }
+  }
+  
+  // Check IP restrictions
+  if (this.conditions?.ipWhitelist?.length > 0 && checkConditions.userIp) {
+    // Simple IP check (production should use more sophisticated IP matching)
+    if (!this.conditions.ipWhitelist.includes(checkConditions.userIp)) {
+      return false;
+    }
+  }
+  
+  return true;
+};
+
+/**
+ * Interface for Role-Permission Assignment
+ * 
+ * Links roles to permissions with optional condition overrides
+ */
+export interface IRolePermission extends Document {
+  role: 'citizen' | 'operator' | 'admin' | 'mobile_admin' | 'super_admin';
+  permission: mongoose.Types.ObjectId;
+  conditionOverrides?: {
+    scope?: 'global' | 'location' | 'department' | 'self' | 'assigned';
+    locations?: mongoose.Types.ObjectId[];
+    departments?: string[];
+  };
+  assignedBy: mongoose.Types.ObjectId;
+  assignedAt: Date;
+  isActive: boolean;
+}
+
+const RolePermissionSchema = new Schema<IRolePermission>({
+  role: {
+    type: String,
+    required: [true, 'Role is required'],
+    enum: {
+      values: ['citizen', 'operator', 'admin', 'mobile_admin', 'super_admin'],
+      message: '{VALUE} is not a valid role'
+    }
+  },
+  permission: {
+    type: Schema.Types.ObjectId,
+    ref: 'Permission',
+    required: [true, 'Permission is required']
+  },
+  conditionOverrides: {
+    scope: {
+      type: String,
+      enum: ['global', 'location', 'department', 'self', 'assigned']
+    },
+    locations: {
+      type: [Schema.Types.ObjectId],
+      ref: 'Location'
+    },
+    departments: {
+      type: [String]
+    }
+  },
+  assignedBy: {
+    type: Schema.Types.ObjectId,
+    ref: 'User',
+    required: [true, 'Assigned by user is required']
+  },
+  assignedAt: {
+    type: Date,
+    default: Date.now
+  },
+  isActive: {
+    type: Boolean,
+    default: true
+  }
+}, {
+  timestamps: true
+});
+
+// Compound index to prevent duplicate role-permission assignments
+RolePermissionSchema.index({ role: 1, permission: 1 }, { unique: true });
+
+export const Permission = mongoose.model<IPermission>('Permission', PermissionSchema);
+export const RolePermission = mongoose.model<IRolePermission>('RolePermission', RolePermissionSchema);
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/models/README.md b/event-monitoring-mvp/backend/src/models/README.md
new file mode 100644
index 0000000..d3f91d5
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/models/README.md
@@ -0,0 +1,354 @@
+# Database Models Overview
+
+This file provides a simple overview of all database models and their key fields for easy reference and validation.
+
+## User Model
+**Collection**: `users`
+**Purpose**: Handles all user types with flexible authentication and permissions
+
+### Key Fields
+```
+_id: ObjectId
+username: String (sparse, unique) - optional for phone-only users
+email: String (sparse, unique) - optional for phone-only users
+password: String (hashed) - optional for phone auth
+phone: String (sparse, unique) - for mobile authentication
+role: Enum ['citizen', 'operator', 'admin', 'mobile_admin', 'super_admin']
+authMethod: Enum ['email_password', 'phone_otp', 'social_oauth']
+isActive: Boolean
+isVerified: Boolean
+
+profile: {
+  firstName: String
+  lastName: String
+  department: String
+  location: { coordinates: [Number], address: String }
+  timezone: String
+  preferredLanguage: String
+}
+
+permissions: {
+  granted: [ObjectId] -> Permission
+  inherited: [ObjectId] -> Permission
+  lastUpdated: Date
+  updatedBy: ObjectId -> User
+}
+
+authentication: {
+  phoneVerified: Boolean
+  emailVerified: Boolean
+  failedAttempts: Number
+  lockoutUntil: Date
+}
+
+mobileSettings: {
+  deviceTokens: [String]
+  lastActiveLocation: { coordinates: [Number], timestamp: Date }
+}
+
+usage: {
+  eventsCreated: Number
+  loginCount: Number
+  lastActivityAt: Date
+}
+```
+
+### Indexes
+- username (unique, sparse)
+- email (unique, sparse)  
+- phone (unique, sparse)
+- role
+- profile.location (2dsphere)
+
+---
+
+## Event Model
+**Collection**: `events`
+**Purpose**: Central event tracking with dynamic types and mobile support
+
+### Key Fields
+```
+_id: ObjectId
+title: String (required)
+description: String
+
+eventType: {
+  typeId: ObjectId -> EventType (required if no legacy type)
+  name: String (cached)
+  category: String (cached)
+}
+type: String (legacy enum - for backward compatibility)
+
+severity: Enum ['low', 'medium', 'high', 'critical', 'emergency']
+priority: Number [1-5]
+status: Enum ['pending', 'acknowledged', 'investigating', 'resolved', 'closed', 'dismissed']
+
+location: {
+  coordinates: [Number] (required) [lng, lat]
+  address: String
+  accuracy: Number
+  source: Enum ['gps', 'network', 'manual', 'camera']
+}
+
+reporter: {
+  userId: ObjectId -> User
+  name: String (for anonymous)
+  phone: String
+  isAnonymous: Boolean
+  sessionId: String (for anonymous tracking)
+  deviceInfo: { platform: Enum, version: String }
+}
+
+media: {
+  images: [String] (URLs)
+  videos: [String] (URLs)
+  attachments: [{
+    fileName: String
+    fileUrl: String
+    fileType: String
+    fileSize: Number
+    uploadedBy: ObjectId -> User
+  }]
+}
+
+assignedTo: ObjectId -> User
+workflow: [{ status: String, timestamp: Date, userId: ObjectId, notes: String }]
+
+mobileSubmission: {
+  submittedOffline: Boolean
+  submissionAttempts: Number
+  clientTimestamp: Date
+  networkType: Enum ['wifi', 'cellular', 'unknown']
+}
+
+validation: {
+  requiresApproval: Boolean
+  approvedBy: ObjectId -> User
+  autoApproved: Boolean
+}
+
+source: Enum ['camera_system', 'user_report', 'ai_detection', 'mobile_app']
+verified: Boolean
+publiclyVisible: Boolean
+```
+
+### Indexes
+- location (2dsphere)
+- eventType.typeId
+- eventType.category
+- type (legacy support)
+- status, severity, priority
+- assignedTo
+- reporter.userId
+- source
+
+---
+
+## EventType Model
+**Collection**: `eventtypes`
+**Purpose**: Dynamic event type management for mobile team
+
+### Key Fields
+```
+_id: ObjectId
+name: String (required, unique with parentType)
+description: String
+category: Enum ['security', 'traffic', 'emergency', 'maintenance', 'social', 'environmental', 'infrastructure', 'other']
+parentType: ObjectId -> EventType (for subtypes)
+
+isActive: Boolean
+isPublic: Boolean (can citizens use this?)
+requiresVerification: Boolean (needs operator approval?)
+allowedRoles: [String] (which roles can create events of this type)
+
+defaultSeverity: Enum ['low', 'medium', 'high', 'critical', 'emergency']
+defaultPriority: Number [1-5]
+requiredFields: [String] (dynamic validation requirements)
+
+autoAssignmentRules: {
+  location: { coordinates: [Number], radius: Number }
+  timeRange: { startHour: Number, endHour: Number }
+  assignTo: ObjectId -> User
+}
+
+metadata: {
+  createdBy: ObjectId -> User
+  lastModifiedBy: ObjectId -> User
+  version: Number
+  externalId: String (for mobile team integration)
+}
+
+statistics: {
+  totalEvents: Number
+  lastUsed: Date
+  avgResolutionTime: Number
+}
+```
+
+### Indexes
+- name + parentType (unique)
+- category
+- isActive + isPublic
+- allowedRoles
+
+---
+
+## Permission Model
+**Collection**: `permissions`
+**Purpose**: Granular permission system
+
+### Key Fields
+```
+_id: ObjectId
+name: String (required, unique)
+description: String
+resource: Enum ['events', 'cameras', 'users', 'eventTypes', 'permissions', 'mobile_users']
+actions: [String] ['read', 'create', 'update', 'delete', 'assign', 'approve']
+scope: Enum ['global', 'location', 'department', 'self', 'assigned']
+
+conditions: {
+  locations: [ObjectId] -> Location
+  departments: [String]
+  severity: [String]
+  timeRestrictions: {
+    allowedHours: [{ start: Number, end: Number }]
+    allowedDays: [Number] (0-6)
+  }
+}
+
+metadata: {
+  createdBy: ObjectId -> User
+  isSystemPermission: Boolean
+  version: Number
+}
+
+usage: {
+  assignedToUsers: Number
+  assignedToRoles: Number
+}
+```
+
+### Indexes
+- name (unique)
+- resource + actions
+- scope
+
+---
+
+## RolePermission Model
+**Collection**: `rolepermissions`
+**Purpose**: Link roles to permissions
+
+### Key Fields
+```
+_id: ObjectId
+role: Enum ['citizen', 'operator', 'admin', 'mobile_admin', 'super_admin']
+permission: ObjectId -> Permission
+conditionOverrides: {
+  scope: String
+  locations: [ObjectId]
+  departments: [String]
+}
+assignedBy: ObjectId -> User
+isActive: Boolean
+```
+
+### Indexes
+- role + permission (unique)
+
+---
+
+## Camera Model (Existing)
+**Collection**: `cameras`
+**Purpose**: Camera device management
+
+### Key Fields
+```
+_id: ObjectId
+name: String
+url: String
+location: { coordinates: [Number], address: String }
+isOnline: Boolean
+createdBy: ObjectId -> User
+```
+
+---
+
+## AIDetection Model (Existing)
+**Collection**: `aidetections`
+**Purpose**: AI detection results
+
+### Key Fields
+```
+_id: ObjectId
+cameraId: ObjectId -> Camera
+confidence: Number
+boundingBox: { x: Number, y: Number, width: Number, height: Number }
+detectionType: String
+promoted: Boolean
+promotedEventId: ObjectId -> Event
+```
+
+---
+
+## Model Relationships
+
+```
+User (1) â”€â”€â”€ (âˆ) Event [assignedTo, reporter.userId, acknowledgedBy]
+User (1) â”€â”€â”€ (âˆ) EventType [createdBy, lastModifiedBy]  
+User (1) â”€â”€â”€ (âˆ) Permission [createdBy]
+User (1) â”€â”€â”€ (âˆ) RolePermission [assignedBy]
+
+EventType (1) â”€â”€â”€ (âˆ) Event [eventType.typeId]
+EventType (1) â”€â”€â”€ (âˆ) EventType [parentType] (self-referencing)
+
+Permission (1) â”€â”€â”€ (âˆ) RolePermission [permission]
+Permission (âˆ) â”€â”€â”€ (âˆ) User [permissions.granted, permissions.inherited]
+
+Camera (1) â”€â”€â”€ (âˆ) Event [cameraId]
+Camera (1) â”€â”€â”€ (âˆ) AIDetection [cameraId]
+
+AIDetection (1) â”€â”€â”€ (1) Event [detectionId/promotedEventId]
+```
+
+## Key Design Decisions
+
+1. **Flexible Authentication**: Users can authenticate via email+password, phone OTP, or social OAuth
+2. **Hierarchical Event Types**: EventType supports parent-child relationships for categories/subcategories
+3. **Backward Compatibility**: Events support both new eventType reference and legacy type field
+4. **Permission Inheritance**: Users get permissions from both their role and individual assignments
+5. **Mobile-First**: Anonymous reporting, offline submission tracking, device management
+6. **Caching Strategy**: EventType name/category cached in Event for performance
+7. **Soft Constraints**: Sparse indexes allow optional fields (username, email, phone)
+
+---
+
+## Implementation Status âœ…
+
+### Updated Authentication System
+- âœ… **Enhanced User Model** with multiple authentication methods
+- âœ… **Updated Auth Controller** supporting email/password and phone OTP
+- âœ… **New Auth Endpoints**:
+  - `POST /api/auth/register` - Enhanced registration with multiple auth methods
+  - `POST /api/auth/login` - Multi-method login (credential + password/OTP)
+  - `POST /api/auth/send-otp` - Send OTP to phone number
+  - `POST /api/auth/verify-phone` - Verify phone with OTP
+  - `PUT /api/auth/change-password` - Change password for email users
+- âœ… **Enhanced Auth Middleware** with permission-based access control
+- âœ… **Updated Validation** for all new authentication methods
+
+### Database Models
+- âœ… **EventType Model** - Dynamic type management for mobile team
+- âœ… **Permission Model** - Granular permission system with conditions
+- âœ… **Enhanced User Model** - Multi-role system with flexible authentication
+- âœ… **Updated Event Model** - EventType integration with backward compatibility
+
+### Next Implementation Steps
+- ğŸ”„ **Mobile API Routes** - Citizen reporting endpoints (`/api/mobile/*`)
+- ğŸ”„ **EventType Management Routes** - CRUD operations for mobile team
+- ğŸ”„ **SMS/OTP Service Integration** - Real SMS sending and OTP validation
+- ğŸ”„ **Redis Cache Setup** - OTP storage and session management
+- ğŸ”„ **Migration Scripts** - Convert legacy events to new EventType system
+- ğŸ”„ **Permission Seeding** - Create initial roles and permissions
+
+The authentication system is now ready for both traditional operator login and mobile citizen registration! ğŸš€
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/models/User.ts b/event-monitoring-mvp/backend/src/models/User.ts
index 8af3e16..628c684 100644
--- a/event-monitoring-mvp/backend/src/models/User.ts
+++ b/event-monitoring-mvp/backend/src/models/User.ts
@@ -1,85 +1,235 @@
-import mongoose, { Document, Schema } from 'mongoose';
-import bcrypt from 'bcryptjs';
-
-export interface IUser extends Document {
-  username: string;
-  email: string;
-  password: string;
-  role: 'admin' | 'operator';
-  isActive: boolean;
-  lastLogin?: Date;
-  createdAt: Date;
-  updatedAt: Date;
-  comparePassword(candidatePassword: string): Promise<boolean>;
-}
-
-const userSchema = new Schema<IUser>(
-  {
-    username: {
-      type: String,
-      required: [true, 'Username is required'],
-      unique: true,
-      trim: true,
-      minlength: [3, 'Username must be at least 3 characters'],
-      maxlength: [30, 'Username must be less than 30 characters']
-    },
-    email: {
-      type: String,
-      required: [true, 'Email is required'],
-      unique: true,
-      lowercase: true,
-      match: [
-        /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
-        'Please enter a valid email address'
-      ]
-    },
-    password: {
-      type: String,
-      required: [true, 'Password is required'],
-      minlength: [6, 'Password must be at least 6 characters'],
-      select: false
-    },
-    role: {
-      type: String,
-      enum: ['admin', 'operator'],
-      default: 'operator'
-    },
-    isActive: {
-      type: Boolean,
-      default: true
-    },
-    lastLogin: {
-      type: Date
-    }
-  },
-  {
-    timestamps: true
-  }
-);
-
-// Hash password before saving
-userSchema.pre('save', async function (next) {
-  if (!this.isModified('password')) return next();
-
-  try {
-    const salt = await bcrypt.genSalt(12);
-    this.password = await bcrypt.hash(this.password, salt);
-    next();
-  } catch (error) {
-    next(error as Error);
-  }
-});
-
-// Compare password method
-userSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {
-  return bcrypt.compare(candidatePassword, this.password);
-};
-
-// Remove password from JSON output
-userSchema.methods.toJSON = function () {
-  const obj = this.toObject();
-  delete obj.password;
-  return obj;
-};
-
-export const User = mongoose.model<IUser>('User', userSchema);
\ No newline at end of file
+import mongoose, { Document, Schema } from 'mongoose';
+import bcrypt from 'bcryptjs';
+import validator from 'validator';
+
+/**
+ * Interface for User document - Web application users only
+ * 
+ * Mobile users authenticate through their own app and are not stored here.
+ * We only receive event submissions from mobile users, not their auth data.
+ */
+export interface IUser extends Document {
+  username?: string;
+  email: string; // Required for web users
+  password: string; // Required for web authentication
+  phone?: string; // For phone authentication
+  roles: UserRole[]; // Array of roles for flexible assignment
+  authMethod: 'email_password' | 'phone_otp' | 'social_oauth' | 'anonymous';
+  oauthProvider?: string;
+  oauthId?: string;
+  authentication: {
+    failedAttempts: number;
+    lockoutUntil?: Date;
+    lastLoginAt?: Date;
+    twoFactorEnabled: boolean;
+  };
+  profile: {
+    firstName?: string;
+    lastName?: string;
+    avatar?: string;
+    department?: string;
+  };
+  permissions: Permission[];
+  isActive: boolean;
+  isEmailVerified: boolean;
+  emailVerifiedAt?: Date;
+  lastLoginAt?: Date;
+  createdAt: Date;
+  updatedAt: Date;
+  isLocked: boolean;
+  comparePassword(candidatePassword: string): Promise<boolean>;
+}
+
+// User roles for web application
+export type UserRole = 'operator' | 'admin' | 'mobile_admin' | 'super_admin';
+
+// Permission structure for granular access control
+export interface Permission {
+  resource: string;
+  action: string;
+  granted: boolean;
+  conditions?: {
+    ownOnly?: boolean;
+    timeRestriction?: string;
+    locationRestriction?: string;
+  };
+}
+/**
+ * User Schema for web application users only
+ * 
+ * Mobile authentication is handled separately - we only receive events from mobile users
+ */
+const userSchema = new Schema<IUser>({
+  username: {
+    type: String,
+    sparse: true,
+    unique: true,
+    trim: true,
+    minlength: [3, 'Username must be at least 3 characters'],
+    maxlength: [30, 'Username must be less than 30 characters']
+  },
+  email: {
+    type: String,
+    required: [true, 'Email is required'],
+    unique: true,
+    lowercase: true,
+    validate: [validator.isEmail, 'Invalid email format']
+  },
+  phone: {
+    type: String,
+    sparse: true,
+    unique: true,
+    trim: true,
+    validate: {
+      validator: function(phone: string) {
+        return !phone || /^\+?[1-9]\d{1,14}$/.test(phone);
+      },
+      message: 'Invalid phone number format'
+    }
+  },
+  password: {
+    type: String,
+    required: [true, 'Password is required'],
+    minlength: [6, 'Password must be at least 6 characters'],
+    select: false
+  },
+  roles: [{
+    type: String,
+    enum: ['operator', 'admin', 'mobile_admin', 'super_admin'],
+    default: 'operator'
+  }],
+  authMethod: {
+    type: String,
+    enum: ['email_password', 'phone_otp', 'social_oauth', 'anonymous'],
+    default: 'email_password'
+  },
+  oauthProvider: {
+    type: String,
+    enum: ['google', 'microsoft', 'github']
+  },
+  oauthId: String,
+  profile: {
+    firstName: {
+      type: String,
+      trim: true,
+      maxlength: [50, 'First name cannot exceed 50 characters']
+    },
+    lastName: {
+      type: String,
+      trim: true,
+      maxlength: [50, 'Last name cannot exceed 50 characters']
+    },
+    avatar: String,
+    department: String
+  },
+  permissions: [{
+    resource: { type: String, required: true },
+    action: { type: String, required: true },
+    granted: { type: Boolean, default: true },
+    conditions: {
+      ownOnly: Boolean,
+      timeRestriction: String,
+      locationRestriction: String
+    }
+  }],
+  isActive: {
+    type: Boolean,
+    default: true
+  },
+  isEmailVerified: {
+    type: Boolean,
+    default: false
+  },
+  authentication: {
+    failedAttempts: {
+      type: Number,
+      default: 0
+    },
+    lockoutUntil: Date,
+    lastLoginAt: Date,
+    twoFactorEnabled: {
+      type: Boolean,
+      default: false
+    }
+  },
+}, {
+  timestamps: true
+});
+
+// Indexes for performance
+userSchema.index({ email: 1 }, { unique: true });
+userSchema.index({ username: 1 }, { unique: true, sparse: true });
+userSchema.index({ phone: 1 }, { unique: true, sparse: true });
+userSchema.index({ roles: 1 });
+userSchema.index({ isActive: 1 });
+
+// Virtual properties
+userSchema.virtual('isLocked').get(function() {
+  return this.authentication.lockoutUntil && this.authentication.lockoutUntil > new Date();
+});
+
+// Static methods
+userSchema.statics.findByCredential = async function(credential: string) {
+  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
+  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
+  
+  let query: any = {};
+  
+  if (emailRegex.test(credential)) {
+    query = { email: credential.toLowerCase() };
+  } else if (phoneRegex.test(credential)) {
+    query = { phone: credential };
+  } else {
+    query = { username: credential };
+  }
+  
+  return this.findOne(query).select('+password');
+};
+
+// Hash password before saving
+userSchema.pre('save', async function (next) {
+  if (!this.isModified('password') || !this.password) return next();
+
+  try {
+    const salt = await bcrypt.genSalt(12);
+    this.password = await bcrypt.hash(this.password, salt);
+    return next();
+  } catch (error) {
+  const err = error instanceof Error ? error : new Error(String(error));
+  return next(err);
+  }
+});
+
+
+
+// Compare password method
+userSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {
+  if (!this.password || !candidatePassword) return false;
+  return bcrypt.compare(candidatePassword, this.password);
+};
+
+// Check if user has permission
+userSchema.methods.hasPermission = function(resource: string, action: string): boolean {
+  return this.permissions.some((permission: Permission) => 
+    permission.resource === resource && 
+    permission.action === action && 
+    permission.granted
+  );
+};
+
+// Virtual for full name
+userSchema.virtual('fullName').get(function() {
+  if (this.profile?.firstName && this.profile?.lastName) {
+    return `${this.profile.firstName} ${this.profile.lastName}`;
+  }
+  return this.username || this.email || 'Unknown User';
+});
+
+// Remove sensitive data from JSON output
+userSchema.methods.toJSON = function () {
+  const obj = this.toObject();
+  delete obj.password;
+  return obj;
+};
+
+export const User = mongoose.model<IUser>('User', userSchema);
diff --git a/event-monitoring-mvp/backend/src/models/VmsServer.ts b/event-monitoring-mvp/backend/src/models/VmsServer.ts
new file mode 100644
index 0000000..2b7fe31
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/models/VmsServer.ts
@@ -0,0 +1,103 @@
+import mongoose, { Document, Schema } from 'mongoose';
+
+/**
+ * VMS Server Model
+ *
+ * Why this exists:
+ * - Our current system stores camera metadata + RTSP URLs.
+ * - A VMS (Video Management System) is a separate service that *manages* live streams + recordings.
+ * - To integrate cleanly, we first need to store VMS server connection details in MongoDB.
+ *
+ * This model represents ONE VMS instance (e.g., Shinobi / ZoneMinder / Agent DVR).
+ * Cameras will later reference a VmsServer via `camera.vms.serverId`.
+ */
+
+
+// TEST-ONLY: provider list is intentionally small for early integration testing.
+export type VmsProvider = 'shinobi' | 'zoneminder' | 'agentdvr' | 'other';
+
+export interface IVmsServer extends Document {
+  name: string;                 // Friendly label, e.g. "Local Shinobi"
+  provider: VmsProvider;        // Which VMS type this server is
+  baseUrl: string;              // Base URL of the VMS server (http://host:port)
+auth?: {
+  /**
+   * Different VMS providers use different auth styles:
+   * - Some use API keys/tokens
+   * - Some use username/password
+   *
+   * Shinobi needs BOTH:
+   * - apiKey (API KEY)
+   * - groupKey (GROUP KEY)
+   *
+   * NOTE (security): For production, secrets should be encrypted at rest or stored in a vault.
+   */
+  apiKey?: string;
+  groupKey?: string; // Shinobi GROUP KEY
+  username?: string;
+  password?: string;
+};
+
+  isActive: boolean;            // Allows disabling a VMS server without deleting it
+  createdAt: Date;
+  updatedAt: Date;
+}
+
+const vmsServerSchema = new Schema<IVmsServer>(
+  {
+    name: {
+      type: String,
+      required: [true, 'VMS server name is required'],
+      trim: true,
+      maxlength: [100, 'VMS server name must be less than 100 characters'],
+    },
+    provider: {
+      type: String,
+      enum: ['shinobi', 'zoneminder', 'agentdvr', 'other'],
+      required: [true, 'VMS provider is required'],
+      default: 'other',
+    },
+    baseUrl: {
+      type: String,
+      required: [true, 'VMS baseUrl is required'],
+      trim: true,
+      match: [/^https?:\/\/.+/, 'baseUrl must be a valid http(s) URL'],
+    },
+    auth: {
+      apiKey: { type: String },
+      groupKey: { type: String },
+      username: { type: String },
+      password: { type: String },
+    },
+    isActive: {
+      type: Boolean,
+      default: true,
+    },
+  },
+  {
+    timestamps: true,
+
+    /**
+     * Security: never serialize credentials back to clients.
+     * Controllers should still be careful, but this prevents accidental leakage.
+     */
+    toJSON: {
+      transform: (_doc: unknown, ret: any) => {
+        delete ret.auth;
+        return ret;
+      },
+    },
+    toObject: {
+      transform: (_doc: unknown, ret: any) => {
+        delete ret.auth;
+        return ret;
+      },
+    },
+  }
+);
+
+// Helpful indexes
+vmsServerSchema.index({ provider: 1 });
+vmsServerSchema.index({ isActive: 1 });
+
+export const VmsServer = mongoose.model<IVmsServer>('VmsServer', vmsServerSchema);
diff --git a/event-monitoring-mvp/backend/src/routes/aiDetections.ts b/event-monitoring-mvp/backend/src/routes/aiDetections.ts
index 8a4f9f4..1c9167b 100644
--- a/event-monitoring-mvp/backend/src/routes/aiDetections.ts
+++ b/event-monitoring-mvp/backend/src/routes/aiDetections.ts
@@ -1,159 +1,159 @@
-import express from 'express';
-import { AIDetectionController } from '../controllers/aiDetectionController';
-import { auth } from '../middleware/auth';
-import { validation } from '../middleware/validation';
-import { body, query } from 'express-validator';
-
-const router = express.Router();
-
-// Validation schemas
-const promoteValidation = [
-  body('eventData.type')
-    .optional()
-    .isIn(['motion', 'person_detected', 'vehicle_detected', 'intrusion', 'anomaly'])
-    .withMessage('Invalid event type'),
-  body('eventData.severity')
-    .optional()
-    .isIn(['low', 'medium', 'high', 'critical'])
-    .withMessage('Invalid severity level'),
-  body('eventData.description')
-    .optional()
-    .isLength({ min: 1, max: 500 })
-    .withMessage('Description must be between 1 and 500 characters'),
-];
-
-const radiusValidation = [
-  query('lat')
-    .isFloat({ min: -90, max: 90 })
-    .withMessage('Invalid latitude'),
-  query('lng')
-    .isFloat({ min: -180, max: 180 })
-    .withMessage('Invalid longitude'),
-  query('radius')
-    .optional()
-    .isInt({ min: 1, max: 50000 })
-    .withMessage('Radius must be between 1 and 50000 meters'),
-];
-
-const createDetectionValidation = [
-  body('cameraId')
-    .isMongoId()
-    .withMessage('Invalid camera ID'),
-  body('detectionId')
-    .isString()
-    .isLength({ min: 1, max: 100 })
-    .withMessage('Detection ID is required'),
-  body('timestamp')
-    .isISO8601()
-    .withMessage('Invalid timestamp'),
-  body('type')
-    .isIn(['person', 'vehicle', 'unknown_object', 'motion'])
-    .withMessage('Invalid detection type'),
-  body('confidence')
-    .isFloat({ min: 0, max: 1 })
-    .withMessage('Confidence must be between 0 and 1'),
-  body('boundingBox.x')
-    .isFloat({ min: 0 })
-    .withMessage('Invalid bounding box X coordinate'),
-  body('boundingBox.y')
-    .isFloat({ min: 0 })
-    .withMessage('Invalid bounding box Y coordinate'),
-  body('boundingBox.width')
-    .isFloat({ min: 0 })
-    .withMessage('Invalid bounding box width'),
-  body('boundingBox.height')
-    .isFloat({ min: 0 })
-    .withMessage('Invalid bounding box height'),
-  body('metadata.aiModel')
-    .isString()
-    .isLength({ min: 1, max: 100 })
-    .withMessage('AI model name is required'),
-  body('metadata.processingTime')
-    .isFloat({ min: 0 })
-    .withMessage('Invalid processing time'),
-  body('metadata.frameNumber')
-    .isInt({ min: 0 })
-    .withMessage('Invalid frame number'),
-  body('snapshots.fullFrame')
-    .isURL()
-    .withMessage('Invalid full frame URL'),
-  body('snapshots.croppedObject')
-    .isURL()
-    .withMessage('Invalid cropped object URL'),
-  body('snapshots.thumbnail')
-    .isURL()
-    .withMessage('Invalid thumbnail URL'),
-];
-
-// Routes
-
-/**
- * @route   GET /api/detections
- * @desc    Get all AI detections with filtering and pagination
- * @access  Private
- */
-router.get('/', auth, AIDetectionController.getDetections);
-
-/**
- * @route   GET /api/detections/radius
- * @desc    Get detections within radius of a point
- * @access  Private
- */
-router.get('/radius', 
-  auth, 
-  radiusValidation, 
-  validation, 
-  AIDetectionController.getDetectionsInRadius
-);
-
-/**
- * @route   GET /api/detections/stats
- * @desc    Get detection statistics
- * @access  Private
- */
-router.get('/stats', auth, AIDetectionController.getDetectionStats);
-
-/**
- * @route   GET /api/detections/:id
- * @desc    Get single detection by ID
- * @access  Private
- */
-router.get('/:id', auth, AIDetectionController.getDetectionById);
-
-/**
- * @route   POST /api/detections
- * @desc    Create new detection (for AI service)
- * @access  Private (AI Service)
- */
-router.post('/', 
-  auth, 
-  createDetectionValidation, 
-  validation, 
-  AIDetectionController.createDetection
-);
-
-/**
- * @route   POST /api/detections/:id/promote
- * @desc    Promote detection to event
- * @access  Private
- */
-router.post('/:id/promote', 
-  auth, 
-  promoteValidation, 
-  validation, 
-  AIDetectionController.promoteToEvent
-);
-
-/**
- * @route   POST /api/detections/:id/dismiss
- * @desc    Dismiss detection as false positive
- * @access  Private
- */
-router.post('/:id/dismiss', 
-  auth, 
-  body('reason').optional().isLength({ max: 500 }).withMessage('Reason too long'),
-  validation,
-  AIDetectionController.dismissDetection
-);
-
+import express from 'express';
+import { AIDetectionController } from '../controllers/aiDetectionController';
+import { auth } from '../middleware/auth';
+import { validation } from '../middleware/validation';
+import { body, query } from 'express-validator';
+
+const router = express.Router();
+
+// Validation schemas
+const promoteValidation = [
+  body('eventData.type')
+    .optional()
+    .isIn(['motion', 'person_detected', 'vehicle_detected', 'intrusion', 'anomaly'])
+    .withMessage('Invalid event type'),
+  body('eventData.severity')
+    .optional()
+    .isIn(['low', 'medium', 'high', 'critical'])
+    .withMessage('Invalid severity level'),
+  body('eventData.description')
+    .optional()
+    .isLength({ min: 1, max: 500 })
+    .withMessage('Description must be between 1 and 500 characters'),
+];
+
+const radiusValidation = [
+  query('lat')
+    .isFloat({ min: -90, max: 90 })
+    .withMessage('Invalid latitude'),
+  query('lng')
+    .isFloat({ min: -180, max: 180 })
+    .withMessage('Invalid longitude'),
+  query('radius')
+    .optional()
+    .isInt({ min: 1, max: 50000 })
+    .withMessage('Radius must be between 1 and 50000 meters'),
+];
+
+const createDetectionValidation = [
+  body('cameraId')
+    .isMongoId()
+    .withMessage('Invalid camera ID'),
+  body('detectionId')
+    .isString()
+    .isLength({ min: 1, max: 100 })
+    .withMessage('Detection ID is required'),
+  body('timestamp')
+    .isISO8601()
+    .withMessage('Invalid timestamp'),
+  body('type')
+    .isIn(['person', 'vehicle', 'unknown_object', 'motion'])
+    .withMessage('Invalid detection type'),
+  body('confidence')
+    .isFloat({ min: 0, max: 1 })
+    .withMessage('Confidence must be between 0 and 1'),
+  body('boundingBox.x')
+    .isFloat({ min: 0 })
+    .withMessage('Invalid bounding box X coordinate'),
+  body('boundingBox.y')
+    .isFloat({ min: 0 })
+    .withMessage('Invalid bounding box Y coordinate'),
+  body('boundingBox.width')
+    .isFloat({ min: 0 })
+    .withMessage('Invalid bounding box width'),
+  body('boundingBox.height')
+    .isFloat({ min: 0 })
+    .withMessage('Invalid bounding box height'),
+  body('metadata.aiModel')
+    .isString()
+    .isLength({ min: 1, max: 100 })
+    .withMessage('AI model name is required'),
+  body('metadata.processingTime')
+    .isFloat({ min: 0 })
+    .withMessage('Invalid processing time'),
+  body('metadata.frameNumber')
+    .isInt({ min: 0 })
+    .withMessage('Invalid frame number'),
+  body('snapshots.fullFrame')
+    .isURL()
+    .withMessage('Invalid full frame URL'),
+  body('snapshots.croppedObject')
+    .isURL()
+    .withMessage('Invalid cropped object URL'),
+  body('snapshots.thumbnail')
+    .isURL()
+    .withMessage('Invalid thumbnail URL'),
+];
+
+// Routes
+
+/**
+ * @route   GET /api/detections
+ * @desc    Get all AI detections with filtering and pagination
+ * @access  Private
+ */
+router.get('/', auth, AIDetectionController.getDetections);
+
+/**
+ * @route   GET /api/detections/radius
+ * @desc    Get detections within radius of a point
+ * @access  Private
+ */
+router.get('/radius', 
+  auth, 
+  radiusValidation, 
+  validation, 
+  AIDetectionController.getDetectionsInRadius
+);
+
+/**
+ * @route   GET /api/detections/stats
+ * @desc    Get detection statistics
+ * @access  Private
+ */
+router.get('/stats', auth, AIDetectionController.getDetectionStats);
+
+/**
+ * @route   GET /api/detections/:id
+ * @desc    Get single detection by ID
+ * @access  Private
+ */
+router.get('/:id', auth, AIDetectionController.getDetectionById);
+
+/**
+ * @route   POST /api/detections
+ * @desc    Create new detection (for AI service)
+ * @access  Private (AI Service)
+ */
+router.post('/', 
+  auth, 
+  createDetectionValidation, 
+  validation, 
+  AIDetectionController.createDetection
+);
+
+/**
+ * @route   POST /api/detections/:id/promote
+ * @desc    Promote detection to event
+ * @access  Private
+ */
+router.post('/:id/promote', 
+  auth, 
+  promoteValidation, 
+  validation, 
+  AIDetectionController.promoteToEvent
+);
+
+/**
+ * @route   POST /api/detections/:id/dismiss
+ * @desc    Dismiss detection as false positive
+ * @access  Private
+ */
+router.post('/:id/dismiss', 
+  auth, 
+  body('reason').optional().isLength({ max: 500 }).withMessage('Reason too long'),
+  validation,
+  AIDetectionController.dismissDetection
+);
+
 export default router;
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/routes/auth.ts b/event-monitoring-mvp/backend/src/routes/auth.ts
index ba798ec..4f60310 100644
--- a/event-monitoring-mvp/backend/src/routes/auth.ts
+++ b/event-monitoring-mvp/backend/src/routes/auth.ts
@@ -1,28 +1,57 @@
-import express from 'express';
-import { register, login, getProfile, updateProfile } from '../controllers/authController';
-import { auth } from '../middleware/auth';
-import { validateRegistration, validateLogin } from '../middleware/validation';
-
-const router = express.Router();
-
-// @route   POST /api/auth/register
-// @desc    Register a new user
-// @access  Public (in production, should be admin only)
-router.post('/register', validateRegistration, register);
-
-// @route   POST /api/auth/login
-// @desc    Login user
-// @access  Public
-router.post('/login', validateLogin, login);
-
-// @route   GET /api/auth/profile
-// @desc    Get current user profile
-// @access  Private
-router.get('/profile', auth, getProfile);
-
-// @route   PUT /api/auth/profile
-// @desc    Update user profile
-// @access  Private
-router.put('/profile', auth, updateProfile);
-
+import express from 'express';
+import { 
+  register, 
+  login, 
+  getProfile, 
+  updateProfile, 
+  verifyPhone, 
+  sendOTP, 
+  changePassword 
+} from '../controllers/authController';
+import { auth } from '../middleware/auth';
+import { 
+  validateRegistration, 
+  validateLogin, 
+  validatePhoneVerification,
+  validateSendOTP,
+  validateChangePassword 
+} from '../middleware/validation';
+
+const router = express.Router();
+
+// @route   POST /api/auth/register
+// @desc    Register a new user (supports email+password and phone+OTP)
+// @access  Public (for operators/admins) or Admin-only (for creating other roles)
+router.post('/register', validateRegistration, register);
+
+// @route   POST /api/auth/login
+// @desc    Login user (supports multiple authentication methods)
+// @access  Public
+router.post('/login', validateLogin, login);
+
+// @route   POST /api/auth/send-otp
+// @desc    Send OTP to phone number
+// @access  Public
+router.post('/send-otp', validateSendOTP, sendOTP);
+
+// @route   POST /api/auth/verify-phone
+// @desc    Verify phone number with OTP
+// @access  Public
+router.post('/verify-phone', validatePhoneVerification, verifyPhone);
+
+// @route   GET /api/auth/profile
+// @desc    Get current user profile with permissions
+// @access  Private
+router.get('/profile', auth, getProfile);
+
+// @route   PUT /api/auth/profile
+// @desc    Update user profile information
+// @access  Private
+router.put('/profile', auth, updateProfile);
+
+// @route   PUT /api/auth/change-password
+// @desc    Change user password
+// @access  Private
+router.put('/change-password', auth, validateChangePassword, changePassword);
+
 export default router;
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/routes/cameras.ts b/event-monitoring-mvp/backend/src/routes/cameras.ts
index 1b90d38..0863090 100644
--- a/event-monitoring-mvp/backend/src/routes/cameras.ts
+++ b/event-monitoring-mvp/backend/src/routes/cameras.ts
@@ -1,57 +1,112 @@
-import express from 'express';
-import {
-  getCameras,
-  getCamera,
-  createCamera,
+import express from 'express';
+import {
+  getCameras,
+  getCamera,
+  createCamera,
   updateCamera,
   deleteCamera,
+  deleteCamerasBySource,
   updateCameraStatus,
   startAIProcessing,
-  stopAIProcessing
+  stopAIProcessing,
+  testCameraConnection,
 } from '../controllers/cameraController';
-import { auth, adminOnly } from '../middleware/auth';
-import { validateCamera } from '../middleware/validation';
-
-const router = express.Router();
-
-// @route   GET /api/cameras
-// @desc    Get all cameras
-// @access  Private
-router.get('/', auth, getCameras);
-
-// @route   GET /api/cameras/:id
-// @desc    Get camera by ID
-// @access  Private
-router.get('/:id', auth, getCamera);
-
-// @route   POST /api/cameras
-// @desc    Create new camera
-// @access  Private (Admin only)
-router.post('/', auth, adminOnly, validateCamera, createCamera);
-
-// @route   PUT /api/cameras/:id
-// @desc    Update camera
-// @access  Private (Admin only)
-router.put('/:id', auth, adminOnly, validateCamera, updateCamera);
+
+import {
+  connectCameraToVms,
+  disconnectCameraFromVms,
+  getCameraVmsStreams
+} from '../controllers/cameraVmsController';
+
+import { auth } from '../middleware/auth';
+import { validateCamera } from '../middleware/validation';
+
+const router = express.Router();
+
+// @route   GET /api/cameras
+// @desc    Get all cameras
+// @access  Private
+router.get('/', auth, getCameras);
+
+// @route   GET /api/cameras/:id
+// @desc    Get camera by ID
+// @access  Private
+router.get('/:id', auth, getCamera);
+
+// @route   POST /api/cameras
+// @desc    Create new camera
+// @access  Private (Admin only)
+router.post('/', auth, validateCamera, createCamera);
+
+// @route   PUT /api/cameras/:id
+// @desc    Update camera
+// @access  Private (Admin only)
+router.put('/:id', auth, validateCamera, updateCamera);
+
+
+// TEST-ONLY: Bulk delete for demo/import sources (soft delete).
+// @route   DELETE /api/cameras/source/:source
+// @desc    Delete cameras by metadata.source
+// @access  Private (dev branch: any authenticated user)
+router.delete('/source/:source', auth, deleteCamerasBySource);
 
 // @route   DELETE /api/cameras/:id
 // @desc    Delete camera
-// @access  Private (Admin only)
-router.delete('/:id', auth, adminOnly, deleteCamera);
+// @access  Private (dev branch: any authenticated user)
+router.delete('/:id', auth, deleteCamera);
 
 // @route   PATCH /api/cameras/:id/status
 // @desc    Update camera status
 // @access  Private
 router.patch('/:id/status', auth, updateCameraStatus);
-
-// @route   POST /api/cameras/:id/ai/start
-// @desc    Start AI processing for camera
-// @access  Private
-router.post('/:id/ai/start', auth, startAIProcessing);
-
+
+/**
+ * VMS Integration Routes
+ *
+ * What these routes do:
+ * - Connect/Disconnect: store/clear a mapping between our Camera record and a VMS server/monitor.
+ * - Streams: return stream information for the frontend (RTSP now; browser-playable URLs later).
+ *
+ * Why we need these:
+ * - VMS is essential per Jira: the VMS manages live + recordings.
+ * - Our app needs a stable API contract to attach cameras to a VMS and fetch playable URLs.
+ */
+
+
+// TEST-ONLY: dev branch allows any authenticated user to connect VMS for faster validation.
+// @route   POST /api/cameras/:id/vms/connect
+// @desc    Connect camera to a VMS server (save mapping to camera.vms)
+// @access  Private (dev branch: any authenticated user)
+router.post('/:id/vms/connect', auth, connectCameraToVms);
+
+
+// TEST-ONLY: dev branch allows any authenticated user to disconnect VMS for faster validation.
+// @route   POST /api/cameras/:id/vms/disconnect
+// @desc    Disconnect camera from VMS (clear mapping from camera.vms)
+// @access  Private (dev branch: any authenticated user)
+router.post('/:id/vms/disconnect', auth, disconnectCameraFromVms);
+
+// @route   GET /api/cameras/:id/vms/streams
+// @desc    Get stream info for camera (RTSP + VMS mapping; later HLS/WebRTC URLs)
+// @access  Private
+router.get('/:id/vms/streams', auth, getCameraVmsStreams);
+
+
+// @route   POST /api/cameras/:id/ai/start
+// @desc    Start AI processing for camera
+// @access  Private
+router.post('/:id/ai/start', auth, startAIProcessing);
+
 // @route   POST /api/cameras/:id/ai/stop
 // @desc    Stop AI processing for camera
 // @access  Private
 router.post('/:id/ai/stop', auth, stopAIProcessing);
 
-export default router;
\ No newline at end of file
+// @route   POST /api/cameras/test-connection
+// @desc    Test stream URL connectivity (RTSP/HTTP)
+// @access  Private
+router.post('/test-connection', auth, testCameraConnection);
+
+
+
+export default router;
diff --git a/event-monitoring-mvp/backend/src/routes/events.ts b/event-monitoring-mvp/backend/src/routes/events.ts
index be0cbde..200125f 100644
--- a/event-monitoring-mvp/backend/src/routes/events.ts
+++ b/event-monitoring-mvp/backend/src/routes/events.ts
@@ -1,51 +1,51 @@
-import express from 'express';
-import {
-  getEvents,
-  getEvent,
-  createEvent,
-  updateEvent,
-  deleteEvent,
-  updateEventStatus,
-  getEventStats
-} from '../controllers/eventController';
-import { auth, adminOnly } from '../middleware/auth';
-import { validateEvent } from '../middleware/validation';
-
-const router = express.Router();
-
-// @route   GET /api/events
-// @desc    Get all events with pagination and filtering
-// @access  Private
-router.get('/', auth, getEvents);
-
-// @route   GET /api/events/stats
-// @desc    Get event statistics
-// @access  Private
-router.get('/stats', auth, getEventStats);
-
-// @route   GET /api/events/:id
-// @desc    Get event by ID
-// @access  Private
-router.get('/:id', auth, getEvent);
-
-// @route   POST /api/events
-// @desc    Create new event (usually from AI service)
-// @access  Private
-router.post('/', auth, validateEvent, createEvent);
-
-// @route   PUT /api/events/:id
-// @desc    Update event
-// @access  Private
-router.put('/:id', auth, validateEvent, updateEvent);
-
-// @route   DELETE /api/events/:id
-// @desc    Delete event
-// @access  Private (Admin only)
-router.delete('/:id', auth, adminOnly, deleteEvent);
-
-// @route   PATCH /api/events/:id/status
-// @desc    Update event status
-// @access  Private
-router.patch('/:id/status', auth, updateEventStatus);
-
+import express from 'express';
+import {
+  getEvents,
+  getEvent,
+  createEvent,
+  updateEvent,
+  deleteEvent,
+  updateEventStatus,
+  getEventStats
+} from '../controllers/eventController';
+import { auth, adminOnly } from '../middleware/auth';
+import { validateEvent } from '../middleware/validation';
+
+const router = express.Router();
+
+// @route   GET /api/events
+// @desc    Get all events with pagination and filtering
+// @access  Private
+router.get('/', auth, getEvents);
+
+// @route   GET /api/events/stats
+// @desc    Get event statistics
+// @access  Private
+router.get('/stats', auth, getEventStats);
+
+// @route   GET /api/events/:id
+// @desc    Get event by ID
+// @access  Private
+router.get('/:id', auth, getEvent);
+
+// @route   POST /api/events
+// @desc    Create new event (usually from AI service)
+// @access  Private
+router.post('/', auth, validateEvent, createEvent);
+
+// @route   PUT /api/events/:id
+// @desc    Update event
+// @access  Private
+router.put('/:id', auth, validateEvent, updateEvent);
+
+// @route   DELETE /api/events/:id
+// @desc    Delete event
+// @access  Private (Admin only)
+router.delete('/:id', auth, adminOnly, deleteEvent);
+
+// @route   PATCH /api/events/:id/status
+// @desc    Update event status
+// @access  Private
+router.patch('/:id/status', auth, updateEventStatus);
+
 export default router;
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/routes/mobile.ts b/event-monitoring-mvp/backend/src/routes/mobile.ts
new file mode 100644
index 0000000..6a741c4
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/routes/mobile.ts
@@ -0,0 +1,32 @@
+import express from 'express';
+import {
+  validateCompany,
+  verifyFR,
+  getEventTypes,
+  createReport,
+  getMyReports,
+  getReportById
+} from '../controllers/mobileController';
+import { validateMobileApiKey, validateMobileUserAccess } from '../middleware/mobileAuth';
+import { validateVerifyFR, validateCreateReport } from '../middleware/validation';
+
+const router = express.Router();
+
+/**
+ * Mobile App Integration Routes
+ * Base path: /api/mobile
+ */
+
+// Auth endpoints
+router.post('/auth/company-validate', validateMobileApiKey, validateCompany);
+router.post('/auth/verify-fr', validateMobileApiKey, validateVerifyFR, verifyFR);
+
+// Event types
+router.get('/event-types', validateMobileApiKey, getEventTypes);
+
+// Reports
+router.post('/reports', validateMobileApiKey, validateCreateReport, createReport);
+router.get('/reports/my', validateMobileApiKey, validateMobileUserAccess, getMyReports);
+router.get('/reports/:id', validateMobileApiKey, validateMobileUserAccess, getReportById);
+
+export default router;
diff --git a/event-monitoring-mvp/backend/src/routes/users.ts b/event-monitoring-mvp/backend/src/routes/users.ts
index 949fecb..952cdbf 100644
--- a/event-monitoring-mvp/backend/src/routes/users.ts
+++ b/event-monitoring-mvp/backend/src/routes/users.ts
@@ -1,45 +1,45 @@
-import express from 'express';
-import {
-  getUsers,
-  getUser,
-  createUser,
-  updateUser,
-  deleteUser,
-  updateUserRole
-} from '../controllers/userController';
-import { auth, adminOnly } from '../middleware/auth';
-import { validateUser } from '../middleware/validation';
-
-const router = express.Router();
-
-// @route   GET /api/users
-// @desc    Get all users
-// @access  Private (Admin only)
-router.get('/', auth, adminOnly, getUsers);
-
-// @route   GET /api/users/:id
-// @desc    Get user by ID
-// @access  Private (Admin only)
-router.get('/:id', auth, adminOnly, getUser);
-
-// @route   POST /api/users
-// @desc    Create new user
-// @access  Private (Admin only)
-router.post('/', auth, adminOnly, validateUser, createUser);
-
-// @route   PUT /api/users/:id
-// @desc    Update user
-// @access  Private (Admin only)
-router.put('/:id', auth, adminOnly, validateUser, updateUser);
-
-// @route   DELETE /api/users/:id
-// @desc    Delete user
-// @access  Private (Admin only)
-router.delete('/:id', auth, adminOnly, deleteUser);
-
-// @route   PATCH /api/users/:id/role
-// @desc    Update user role
-// @access  Private (Admin only)
-router.patch('/:id/role', auth, adminOnly, updateUserRole);
-
+import express from 'express';
+import {
+  getUsers,
+  getUser,
+  createUser,
+  updateUser,
+  deleteUser,
+  updateUserRole
+} from '../controllers/userController';
+import { auth, adminOnly } from '../middleware/auth';
+import { validateUser } from '../middleware/validation';
+
+const router = express.Router();
+
+// @route   GET /api/users
+// @desc    Get all users
+// @access  Private (Admin only)
+router.get('/', auth, adminOnly, getUsers);
+
+// @route   GET /api/users/:id
+// @desc    Get user by ID
+// @access  Private (Admin only)
+router.get('/:id', auth, adminOnly, getUser);
+
+// @route   POST /api/users
+// @desc    Create new user
+// @access  Private (Admin only)
+router.post('/', auth, adminOnly, validateUser, createUser);
+
+// @route   PUT /api/users/:id
+// @desc    Update user
+// @access  Private (Admin only)
+router.put('/:id', auth, adminOnly, validateUser, updateUser);
+
+// @route   DELETE /api/users/:id
+// @desc    Delete user
+// @access  Private (Admin only)
+router.delete('/:id', auth, adminOnly, deleteUser);
+
+// @route   PATCH /api/users/:id/role
+// @desc    Update user role
+// @access  Private (Admin only)
+router.patch('/:id/role', auth, adminOnly, updateUserRole);
+
 export default router;
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/src/routes/vms.ts b/event-monitoring-mvp/backend/src/routes/vms.ts
new file mode 100644
index 0000000..98b049e
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/routes/vms.ts
@@ -0,0 +1,38 @@
+import { Router } from 'express';
+import { auth } from '../middleware/auth';
+import {
+  listVmsServers,
+  createVmsServer,
+  updateVmsServer,
+  deleteVmsServer,
+  listVmsMonitors,
+  importVmsMonitors,
+} from '../controllers/vmsController';
+
+const router = Router();
+
+router.use(auth);
+
+/**
+ * TEST-ONLY: dev-branch access relaxes admin-only routes so we can verify VMS integration quickly.
+ * DEV NOTE:
+ * These routes were admin-only, but for the camera-connection dev branch we allow any authenticated user
+ * so we can test Shinobi/VMS integration without fighting role setup.
+ * Revert to adminOnly before merging to main.
+ */
+router.get('/servers', listVmsServers);
+router.post('/servers', createVmsServer);
+// Update VMS server details (including auth keys when needed).
+router.patch('/servers/:id', updateVmsServer);
+// Soft-delete a VMS server (mark inactive) so it stops appearing in active lists.
+router.delete('/servers/:id', deleteVmsServer);
+
+// @route   GET /api/vms/servers/:id/monitors
+// @desc    List monitors from a VMS server (Shinobi)
+router.get('/servers/:id/monitors', listVmsMonitors);
+
+// @route   POST /api/vms/servers/:id/monitors/import
+// @desc    Batch-import monitors into cameras (Shinobi)
+router.post('/servers/:id/monitors/import', importVmsMonitors);
+
+export default router;
diff --git a/event-monitoring-mvp/backend/src/types/mobile.ts b/event-monitoring-mvp/backend/src/types/mobile.ts
new file mode 100644
index 0000000..9d4a105
--- /dev/null
+++ b/event-monitoring-mvp/backend/src/types/mobile.ts
@@ -0,0 +1,121 @@
+import { Request } from 'express';
+
+// Company info attached to request after API key validation
+export interface MobileAuthenticatedRequest extends Request {
+  company?: {
+    id: string;
+    name: string;
+    settings?: Record<string, any>;
+  };
+  frUser?: {
+    frId: string;
+    phone: string;
+    name: string;
+    role: string;
+  };
+}
+
+// API 1: Company Validate
+export interface CompanyValidateResponse {
+  valid: boolean;
+  company?: {
+    id: string;
+    name: string;
+    settings?: Record<string, any>;
+  };
+}
+
+// API 2: Verify FR
+export interface VerifyFRRequest {
+  phone: string;
+}
+
+export interface VerifyFRResponse {
+  isFR: boolean;
+  frId?: string;
+  name?: string;
+  role?: string;
+}
+
+// API 3: Event Types
+export interface EventType {
+  id: string;
+  name: string;
+  severity: string;
+}
+
+export interface EventTypesResponse {
+  eventTypes: EventType[];
+}
+
+// API 4: Create Report
+export interface CreateReportRequest {
+  phone: string;
+  type: string;
+  subType?: string;
+  severity: string;
+  description?: string;
+  location: {
+    latitude: number;
+    longitude: number;
+  };
+  media?: {
+    images?: string[];
+    videos?: string[];
+  };
+}
+
+export interface CreateReportResponse {
+  success: boolean;
+  reportId?: string;
+  reporterType?: 'FR' | 'CIVILIAN';
+  message?: string;
+}
+
+// API 5: Get My Reports
+export interface GetReportsQuery {
+  date?: string;
+  status?: string;
+  type?: string;
+  severity?: string;
+  limit?: number;
+  offset?: number;
+}
+
+export interface ReportSummary {
+  id: string;
+  type: string;
+  subType?: string;
+  severity: string;
+  status: string;
+  description?: string;
+  location: {
+    latitude: number;
+    longitude: number;
+  };
+  createdAt: string;
+}
+
+export interface GetReportsResponse {
+  reports: ReportSummary[];
+  pagination: {
+    total: number;
+    limit: number;
+    offset: number;
+    hasMore: boolean;
+  };
+}
+
+// API 6: Get Report by ID
+export interface ReportDetail extends ReportSummary {
+  media?: {
+    images?: string[];
+    videos?: string[];
+  };
+  reporterType: 'FR' | 'CIVILIAN';
+  updatedAt: string;
+}
+
+export interface ReportDetailResponse {
+  report: ReportDetail;
+}
diff --git a/event-monitoring-mvp/backend/src/utils/database.ts b/event-monitoring-mvp/backend/src/utils/database.ts
index b36ac67..10a2c60 100644
--- a/event-monitoring-mvp/backend/src/utils/database.ts
+++ b/event-monitoring-mvp/backend/src/utils/database.ts
@@ -1,23 +1,23 @@
-import mongoose from 'mongoose';
-
-export const connectDB = async (): Promise<void> => {
-  try {
-    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/event_monitoring';
-    
-    await mongoose.connect(mongoURI);
-    
-    console.log('ğŸ“Š MongoDB connected successfully');
-  } catch (error) {
-    console.error('âŒ MongoDB connection failed:', error);
-    process.exit(1);
-  }
-};
-
-export const disconnectDB = async (): Promise<void> => {
-  try {
-    await mongoose.disconnect();
-    console.log('ğŸ“Š MongoDB disconnected');
-  } catch (error) {
-    console.error('âŒ MongoDB disconnection failed:', error);
-  }
+import mongoose from 'mongoose';
+
+export const connectDB = async (): Promise<void> => {
+  try {
+    const mongoURI = process.env.MONGODB_URI || 'mongodb://localhost:27017/event_monitoring';
+    
+    await mongoose.connect(mongoURI);
+    
+    console.log('ğŸ“Š MongoDB connected successfully');
+  } catch (error) {
+    console.error('âŒ MongoDB connection failed:', error);
+    process.exit(1);
+  }
+};
+
+export const disconnectDB = async (): Promise<void> => {
+  try {
+    await mongoose.disconnect();
+    console.log('ğŸ“Š MongoDB disconnected');
+  } catch (error) {
+    console.error('âŒ MongoDB disconnection failed:', error);
+  }
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/backend/tsconfig.json b/event-monitoring-mvp/backend/tsconfig.json
index 4a3c239..e567015 100644
--- a/event-monitoring-mvp/backend/tsconfig.json
+++ b/event-monitoring-mvp/backend/tsconfig.json
@@ -1,29 +1,29 @@
-{
-  "compilerOptions": {
-    "target": "ES2020",
-    "module": "commonjs",
-    "lib": ["ES2020"],
-    "outDir": "./dist",
-    "rootDir": "./src",
-    "removeComments": true,
-    "strict": true,
-    "esModuleInterop": true,
-    "skipLibCheck": true,
-    "forceConsistentCasingInFileNames": true,
-    "resolveJsonModule": true,
-    "declaration": true,
-    "declarationMap": true,
-    "sourceMap": true,
-    "experimentalDecorators": true,
-    "emitDecoratorMetadata": true,
-    "moduleResolution": "node",
-    "allowSyntheticDefaultImports": true,
-    "noImplicitAny": true,
-    "noImplicitReturns": true,
-    "noImplicitThis": true,
-    "noUnusedLocals": true,
-    "noUnusedParameters": true
-  },
-  "include": ["src/**/*"],
-  "exclude": ["node_modules", "dist", "**/*.test.ts"]
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "module": "commonjs",
+    "lib": ["ES2020"],
+    "outDir": "./dist",
+    "rootDir": "./src",
+    "removeComments": true,
+    "strict": true,
+    "esModuleInterop": true,
+    "skipLibCheck": true,
+    "forceConsistentCasingInFileNames": true,
+    "resolveJsonModule": true,
+    "declaration": true,
+    "declarationMap": true,
+    "sourceMap": true,
+    "experimentalDecorators": true,
+    "emitDecoratorMetadata": true,
+    "moduleResolution": "node",
+    "allowSyntheticDefaultImports": true,
+    "noImplicitAny": true,
+    "noImplicitReturns": true,
+    "noImplicitThis": true,
+    "noUnusedLocals": true,
+    "noUnusedParameters": true
+  },
+  "include": ["src/**/*"],
+  "exclude": ["node_modules", "dist", "**/*.test.ts"]
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp/docker-compose.yml b/event-monitoring-mvp/docker-compose.yml
index af923c7..07fa047 100644
--- a/event-monitoring-mvp/docker-compose.yml
+++ b/event-monitoring-mvp/docker-compose.yml
@@ -1,91 +1,91 @@
-version: '3.8'
-
-services:
-  # MongoDB Database
-  mongodb:
-    image: mongo:6.0
-    container_name: event-monitoring-mongodb
-    restart: always
-    environment:
-      MONGO_INITDB_ROOT_USERNAME: admin
-      MONGO_INITDB_ROOT_PASSWORD: password123
-      MONGO_INITDB_DATABASE: event_monitoring
-    ports:
-      - "27017:27017"
-    volumes:
-      - mongodb_data:/data/db
-      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
-    networks:
-      - event-monitoring-network
-
-  # Backend API
-  backend:
-    build:
-      context: ./backend
-      dockerfile: Dockerfile
-    container_name: event-monitoring-backend
-    restart: always
-    environment:
-      NODE_ENV: development
-      PORT: 5000
-      MONGODB_URI: mongodb://admin:password123@mongodb:27017/event_monitoring?authSource=admin
-      JWT_SECRET: your-super-secret-jwt-key-change-in-production
-      AI_SERVICE_URL: http://ai-service:8000
-    ports:
-      - "5000:5000"
-    depends_on:
-      - mongodb
-    networks:
-      - event-monitoring-network
-    volumes:
-      - ./backend:/app
-      - /app/node_modules
-
-  # Frontend React App
-  frontend:
-    build:
-      context: ./frontend
-      dockerfile: Dockerfile
-    container_name: event-monitoring-frontend
-    restart: always
-    environment:
-      REACT_APP_API_URL: http://localhost:5000/api
-      REACT_APP_MAPBOX_TOKEN: your-mapbox-token-here
-    ports:
-      - "3000:3000"
-    depends_on:
-      - backend
-    networks:
-      - event-monitoring-network
-    volumes:
-      - ./frontend:/app
-      - /app/node_modules
-
-  # AI Service
-  ai-service:
-    build:
-      context: ./ai-service
-      dockerfile: Dockerfile
-    container_name: event-monitoring-ai
-    restart: always
-    environment:
-      PYTHONUNBUFFERED: 1
-      API_URL: http://backend:5000/api
-      MODEL_PATH: /app/models
-    ports:
-      - "8000:8000"
-    depends_on:
-      - backend
-    networks:
-      - event-monitoring-network
-    volumes:
-      - ./ai-service:/app
-      - ai_models:/app/models
-
-volumes:
-  mongodb_data:
-  ai_models:
-
-networks:
-  event-monitoring-network:
+version: '3.8'
+
+services:
+  # MongoDB Database
+  mongodb:
+    image: mongo:6.0
+    container_name: event-monitoring-mongodb
+    restart: always
+    environment:
+      MONGO_INITDB_ROOT_USERNAME: admin
+      MONGO_INITDB_ROOT_PASSWORD: password123
+      MONGO_INITDB_DATABASE: event_monitoring
+    ports:
+      - "27017:27017"
+    volumes:
+      - mongodb_data:/data/db
+      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
+    networks:
+      - event-monitoring-network
+
+  # Backend API
+  backend:
+    build:
+      context: ./backend
+      dockerfile: Dockerfile
+    container_name: event-monitoring-backend
+    restart: always
+    environment:
+      NODE_ENV: development
+      PORT: 5000
+      MONGODB_URI: mongodb://admin:password123@mongodb:27017/event_monitoring?authSource=admin
+      JWT_SECRET: your-super-secret-jwt-key-change-in-production
+      AI_SERVICE_URL: http://ai-service:8000
+    ports:
+      - "5000:5000"
+    depends_on:
+      - mongodb
+    networks:
+      - event-monitoring-network
+    volumes:
+      - ./backend:/app
+      - /app/node_modules
+
+  # Frontend React App
+  frontend:
+    build:
+      context: ./frontend
+      dockerfile: Dockerfile
+    container_name: event-monitoring-frontend
+    restart: always
+    environment:
+      REACT_APP_API_URL: http://localhost:5000/api
+      REACT_APP_MAPBOX_TOKEN: your-mapbox-token-here
+    ports:
+      - "3000:3000"
+    depends_on:
+      - backend
+    networks:
+      - event-monitoring-network
+    volumes:
+      - ./frontend:/app
+      - /app/node_modules
+
+  # AI Service
+  ai-service:
+    build:
+      context: ./ai-service
+      dockerfile: Dockerfile
+    container_name: event-monitoring-ai
+    restart: always
+    environment:
+      PYTHONUNBUFFERED: 1
+      API_URL: http://backend:5000/api
+      MODEL_PATH: /app/models
+    ports:
+      - "8000:8000"
+    depends_on:
+      - backend
+    networks:
+      - event-monitoring-network
+    volumes:
+      - ./ai-service:/app
+      - ai_models:/app/models
+
+volumes:
+  mongodb_data:
+  ai_models:
+
+networks:
+  event-monitoring-network:
     driver: bridge
\ No newline at end of file
diff --git a/event-monitoring-mvp/docker/mongo-init-clean.js b/event-monitoring-mvp/docker/mongo-init-clean.js
new file mode 100644
index 0000000..51a677f
--- /dev/null
+++ b/event-monitoring-mvp/docker/mongo-init-clean.js
@@ -0,0 +1,27 @@
+// MongoDB initialization script - CLEAN VERSION
+db = db.getSiblingDB('event_monitoring');
+
+// Create essential collections
+db.createCollection('users');
+db.createCollection('cameras');
+db.createCollection('events');
+
+// Essential indexes only
+// Users (web app users only)
+db.users.createIndex({ "email": 1 }, { unique: true });
+db.users.createIndex({ "username": 1 }, { unique: true, sparse: true });
+db.users.createIndex({ "phone": 1 }, { unique: true, sparse: true });
+
+// Cameras
+db.cameras.createIndex({ "location.coordinates": "2dsphere" });
+db.cameras.createIndex({ "status": 1 });
+
+// Events (enhanced for mobile integration)
+db.events.createIndex({ "type": 1 });
+db.events.createIndex({ "severity": 1 });
+db.events.createIndex({ "status": 1 });
+db.events.createIndex({ "location.coordinates": "2dsphere" });
+db.events.createIndex({ "createdAt": -1 });
+db.events.createIndex({ "source": 1 });
+
+print("âœ… MongoDB initialization complete");
\ No newline at end of file
diff --git a/event-monitoring-mvp/docker/mongo-init.js b/event-monitoring-mvp/docker/mongo-init.js
index 9f8a061..0b9d57b 100644
--- a/event-monitoring-mvp/docker/mongo-init.js
+++ b/event-monitoring-mvp/docker/mongo-init.js
@@ -1,46 +1,171 @@
-// MongoDB initialization script
-db = db.getSiblingDB('event_monitoring');
-
-// Create collections
-db.createCollection('users');
-db.createCollection('cameras');
-db.createCollection('events');
-
-// Create indexes
-// Users indexes
-db.users.createIndex({ "email": 1 }, { unique: true });
-db.users.createIndex({ "username": 1 }, { unique: true });
-db.users.createIndex({ "isActive": 1 });
-
-// Cameras indexes
-db.cameras.createIndex({ "location": "2dsphere" });
-db.cameras.createIndex({ "status": 1 });
-db.cameras.createIndex({ "isActive": 1 });
-db.cameras.createIndex({ "createdBy": 1 });
-
-// Events indexes
-db.events.createIndex({ "cameraId": 1 });
-db.events.createIndex({ "type": 1 });
-db.events.createIndex({ "severity": 1 });
-db.events.createIndex({ "status": 1 });
-db.events.createIndex({ "location": "2dsphere" });
-db.events.createIndex({ "createdAt": -1 });
-db.events.createIndex({ "assignedTo": 1 });
-
-// Compound indexes
-db.events.createIndex({ "status": 1, "createdAt": -1 });
-db.events.createIndex({ "type": 1, "status": 1 });
-db.events.createIndex({ "cameraId": 1, "createdAt": -1 });
-
-// Create default admin user
-db.users.insertOne({
-  username: "admin",
-  email: "admin@example.com",
-  password: "$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj0HIMU.Gsva", // password123
-  role: "admin",
-  isActive: true,
-  createdAt: new Date(),
-  updatedAt: new Date()
-});
-
-print("Database initialized successfully!");
\ No newline at end of file
+// MongoDB initialization script
+db = db.getSiblingDB('event_monitoring');
+ 
+// Create collections
+db.createCollection('users');
+db.createCollection('cameras');
+db.createCollection('events');
+db.createCollection('eventtypes');
+db.createCollection('permissions');
+
+// Create indexes
+// Users indexes - Web users only (no phone authentication)
+db.users.createIndex({ "email": 1 }, { unique: true });
+db.users.createIndex({ "username": 1 }, { unique: true, sparse: true });
+db.users.createIndex({ "isActive": 1 });
+db.users.createIndex({ "roles": 1 });
+db.users.createIndex({ "createdAt": -1 });
+db.users.createIndex({ "lastLoginAt": -1 });
+
+// EventType indexes
+db.eventtypes.createIndex({ "name": 1, "isActive": 1 });
+db.eventtypes.createIndex({ "category": 1 });
+db.eventtypes.createIndex({ "isPublic": 1 });
+db.eventtypes.createIndex({ "parentType": 1 });
+db.eventtypes.createIndex({ "order": 1 });
+
+// Permission indexes  
+db.permissions.createIndex({ "userId": 1 });
+db.permissions.createIndex({ "resource": 1 });
+db.permissions.createIndex({ "action": 1 });
+db.permissions.createIndex({ "userId": 1, "resource": 1, "action": 1 }, { unique: true });
+
+// Cameras indexes
+db.cameras.createIndex({ "location": "2dsphere" });
+db.cameras.createIndex({ "status": 1 });
+db.cameras.createIndex({ "isActive": 1 });
+db.cameras.createIndex({ "createdBy": 1 });
+
+// Events indexes - Enhanced for EventType integration
+db.events.createIndex({ "cameraId": 1 });
+db.events.createIndex({ "eventType": 1 });
+db.events.createIndex({ "type": 1 }); // Legacy support
+db.events.createIndex({ "severity": 1 });
+db.events.createIndex({ "status": 1 });
+db.events.createIndex({ "location": "2dsphere" });
+db.events.createIndex({ "createdAt": -1 });
+db.events.createIndex({ "assignedTo": 1 });
+db.events.createIndex({ "submittedBy": 1 });
+db.events.createIndex({ "isAnonymous": 1 });
+
+// Compound indexes
+db.events.createIndex({ "status": 1, "createdAt": -1 });
+db.events.createIndex({ "eventType": 1, "status": 1 });
+db.events.createIndex({ "type": 1, "status": 1 }); // Legacy support
+db.events.createIndex({ "cameraId": 1, "createdAt": -1 });
+db.events.createIndex({ "submittedBy": 1, "createdAt": -1 });
+
+// Create default permissions
+const defaultPermissions = [
+  // Admin permissions
+  { resource: '*', action: '*', description: 'Full system access' },
+  // Operator permissions
+  { resource: 'events', action: 'read', description: 'View events' },
+  { resource: 'events', action: 'update', description: 'Update event status' },
+  { resource: 'cameras', action: 'read', description: 'View cameras' },
+  { resource: 'cameras', action: 'manage', description: 'Manage cameras' },
+  // Mobile admin permissions
+  { resource: 'event-types', action: 'manage', description: 'Manage event types' },
+  { resource: 'mobile-users', action: 'read', description: 'View mobile users' },
+  // Citizen permissions
+  { resource: 'events', action: 'create', description: 'Submit events' },
+  { resource: 'events', action: 'read', description: 'View own events', conditions: { ownOnly: true } }
+];
+
+db.permissions.insertMany(defaultPermissions.map(p => ({
+  ...p,
+  createdAt: new Date(),
+  updatedAt: new Date()
+})));
+
+// Create default EventTypes
+const defaultEventTypes = [
+  {
+    name: 'Security Incidents',
+    category: 'security',
+    description: 'Security-related events and incidents',
+    isPublic: true,
+    isActive: true,
+    order: 1,
+    allowedRoles: ['citizen', 'operator', 'admin'],
+    fields: [
+      { name: 'severity', type: 'select', options: ['low', 'medium', 'high', 'critical'], required: true },
+      { name: 'description', type: 'textarea', required: true }
+    ]
+  },
+  {
+    name: 'Theft',
+    category: 'security', 
+    description: 'Theft and robbery incidents',
+    parentType: 'Security Incidents',
+    isPublic: true,
+    isActive: true,
+    order: 1,
+    allowedRoles: ['citizen', 'operator', 'admin']
+  },
+  {
+    name: 'Vandalism',
+    category: 'security',
+    description: 'Property damage and vandalism',
+    parentType: 'Security Incidents',
+    isPublic: true,
+    isActive: true,
+    order: 2,
+    allowedRoles: ['citizen', 'operator', 'admin']
+  },
+  {
+    name: 'Infrastructure Issues',
+    category: 'infrastructure',
+    description: 'Infrastructure and maintenance issues',
+    isPublic: true,
+    isActive: true,
+    order: 2,
+    allowedRoles: ['citizen', 'operator', 'admin'],
+    fields: [
+      { name: 'urgency', type: 'select', options: ['low', 'medium', 'high'], required: true },
+      { name: 'location', type: 'text', required: true }
+    ]
+  },
+  {
+    name: 'Traffic Issues',
+    category: 'traffic',
+    description: 'Traffic-related incidents and issues',
+    isPublic: true,
+    isActive: true,
+    order: 3,
+    allowedRoles: ['citizen', 'operator', 'admin']
+  }
+];
+
+db.eventtypes.insertMany(defaultEventTypes.map(et => ({
+  ...et,
+  createdAt: new Date(),
+  updatedAt: new Date()
+})));
+
+// Create default admin user with web-only structure
+db.users.insertOne({
+  username: "admin",
+  email: "admin@example.com",
+  password: "$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj0HIMU.Gsva", // password123
+  roles: ["super_admin"],
+  authMethod: "email",
+  profile: {
+    firstName: "System",
+    lastName: "Administrator"
+  },
+  permissions: [
+    { resource: "*", action: "*", granted: true }
+  ],
+  isActive: true,
+  isEmailVerified: true,
+  createdAt: new Date(),
+  updatedAt: new Date()
+});
+
+print("Database initialized successfully with enhanced models!");
+print("âœ… Collections: users, cameras, events, eventtypes, permissions");
+print("âœ… Default EventTypes created for mobile team integration");
+print("âœ… Default permissions created");
+print("âœ… Web admin user: admin@example.com / password123");
+print("ğŸ“± Mobile users authenticate through their own app - we only receive events");
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/.env.example b/event-monitoring-mvp/frontend/.env.example
index 7e692fc..6cd65f7 100644
--- a/event-monitoring-mvp/frontend/.env.example
+++ b/event-monitoring-mvp/frontend/.env.example
@@ -1,21 +1,21 @@
-# Environment Variables for React App
-REACT_APP_API_URL=http://localhost:5000/api
-REACT_APP_SOCKET_URL=http://localhost:5000
-
-# Map Configuration
-REACT_APP_MAPBOX_TOKEN=your-mapbox-access-token-here
-REACT_APP_DEFAULT_MAP_CENTER_LAT=40.7128
-REACT_APP_DEFAULT_MAP_CENTER_LNG=-74.0060
-REACT_APP_DEFAULT_MAP_ZOOM=10
-
-# Video Configuration
-REACT_APP_VIDEO_REFRESH_INTERVAL=30000
-REACT_APP_MAX_VIDEO_STREAMS=4
-
-# UI Configuration
-REACT_APP_EVENTS_REFRESH_INTERVAL=5000
-REACT_APP_PAGINATION_SIZE=20
-
-# Debug
-REACT_APP_DEBUG_MODE=true
+# Environment Variables for React App
+REACT_APP_API_URL=http://localhost:5000/api
+REACT_APP_SOCKET_URL=http://localhost:5000
+
+# Map Configuration
+REACT_APP_MAPBOX_TOKEN=your-mapbox-access-token-here
+REACT_APP_DEFAULT_MAP_CENTER_LAT=40.7128
+REACT_APP_DEFAULT_MAP_CENTER_LNG=-74.0060
+REACT_APP_DEFAULT_MAP_ZOOM=10
+
+# Video Configuration
+REACT_APP_VIDEO_REFRESH_INTERVAL=30000
+REACT_APP_MAX_VIDEO_STREAMS=4
+
+# UI Configuration
+REACT_APP_EVENTS_REFRESH_INTERVAL=5000
+REACT_APP_PAGINATION_SIZE=20
+
+# Debug
+REACT_APP_DEBUG_MODE=true
 REACT_APP_LOG_LEVEL=debug
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/Dockerfile b/event-monitoring-mvp/frontend/Dockerfile
index e240c36..cc45191 100644
--- a/event-monitoring-mvp/frontend/Dockerfile
+++ b/event-monitoring-mvp/frontend/Dockerfile
@@ -1,32 +1,32 @@
-# React Frontend Dockerfile
-FROM node:18-alpine as build
-
-# Set working directory
-WORKDIR /app
-
-# Copy package files
-COPY package*.json ./
-
-# Install dependencies
-RUN npm ci
-
-# Copy source code
-COPY . .
-
-# Build the application
-RUN npm run build
-
-# Production stage
-FROM nginx:1.21-alpine
-
-# Copy build files to nginx
-COPY --from=build /app/build /usr/share/nginx/html
-
-# Copy nginx configuration
-COPY nginx.conf /etc/nginx/conf.d/default.conf
-
-# Expose port
-EXPOSE 3000
-
-# Start nginx
+# React Frontend Dockerfile
+FROM node:18-alpine as build
+
+# Set working directory
+WORKDIR /app
+
+# Copy package files
+COPY package*.json ./
+
+# Install dependencies
+RUN npm ci
+
+# Copy source code
+COPY . .
+
+# Build the application
+RUN npm run build
+
+# Production stage
+FROM nginx:1.21-alpine
+
+# Copy build files to nginx
+COPY --from=build /app/build /usr/share/nginx/html
+
+# Copy nginx configuration
+COPY nginx.conf /etc/nginx/conf.d/default.conf
+
+# Expose port
+EXPOSE 3000
+
+# Start nginx
 CMD ["nginx", "-g", "daemon off;"]
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/README.md b/event-monitoring-mvp/frontend/README.md
index 43e7f26..d2eb974 100644
--- a/event-monitoring-mvp/frontend/README.md
+++ b/event-monitoring-mvp/frontend/README.md
@@ -1,173 +1,173 @@
-# Frontend - Event Monitoring MVP
-
-Modern React.js frontend application for the Event Monitoring system with real-time dashboards, interactive maps, and comprehensive camera management.
-
-## ğŸš€ Quick Start
-
-### Prerequisites
-- **Node.js** 18+ and npm
-- **Modern browser** with ES2020 support
-
-### Development Setup
-
-1. **Install Dependencies**
-   ```bash
-   cd frontend
-   npm install
-   ```
-
-2. **Environment Configuration**
-   ```bash
-   # Create environment file
-   cp .env.example .env
-   
-   # Edit with your settings
-   nano .env
-   ```
-
-3. **Start Development Server**
-   ```bash
-   npm start
-   ```
-
-4. **Access Application**
-   - Open http://localhost:3000
-   - Login with default credentials: `admin@example.com` / `password123`
-cd frontend
-npm install
-```
-
-### 2. Environment Setup
-```bash
-# Copy the environment template
-cp .env.example .env
-
-# Edit the .env file with your configuration
-nano .env
-```
-
-### 3. Start Development Server
-```bash
-npm start
-```
-
-The frontend will be available at: http://localhost:3000
-
-## Environment Configuration
-
-Edit the `.env` file with these settings:
-
-```bash
-# API Configuration
-REACT_APP_API_URL=http://localhost:5000/api
-REACT_APP_SOCKET_URL=http://localhost:5000
-
-# Map Configuration (Get your token from https://mapbox.com)
-REACT_APP_MAPBOX_TOKEN=your-mapbox-access-token-here
-REACT_APP_DEFAULT_MAP_CENTER_LAT=40.7128
-REACT_APP_DEFAULT_MAP_CENTER_LNG=-74.0060
-REACT_APP_DEFAULT_MAP_ZOOM=10
-
-# Video Configuration
-REACT_APP_VIDEO_REFRESH_INTERVAL=30000
-REACT_APP_MAX_VIDEO_STREAMS=4
-
-# UI Configuration
-REACT_APP_EVENTS_REFRESH_INTERVAL=5000
-REACT_APP_PAGINATION_SIZE=20
-
-# Debug
-REACT_APP_DEBUG_MODE=true
-REACT_APP_LOG_LEVEL=debug
-```
-
-## Available Scripts
-
-### Development
-```bash
-npm start          # Start development server (hot reload)
-npm test           # Run tests
-npm run lint       # Run ESLint
-npm run lint:fix   # Fix ESLint issues
-npm run format     # Format code with Prettier
-```
-
-### Production
-```bash
-npm run build      # Create production build
-npm run preview    # Preview production build locally
-```
-
-## Getting a Mapbox Token
-
-1. Go to https://mapbox.com
-2. Sign up for a free account
-3. Go to Account â†’ Access Tokens
-4. Create a new token or copy the default public token
-5. Add it to your `.env` file as `REACT_APP_MAPBOX_TOKEN`
-
-## Troubleshooting
-
-### Common Issues
-
-**1. Dependencies not installing:**
-```bash
-# Clear npm cache and reinstall
-rm -rf node_modules package-lock.json
-npm cache clean --force
-npm install
-```
-
-**2. Port 3000 already in use:**
-```bash
-# Kill process on port 3000
-sudo lsof -t -i:3000 | xargs kill -9
-# Or use a different port
-PORT=3001 npm start
-```
-
-**3. Environment variables not loading:**
-- Make sure `.env` file is in the frontend root directory
-- Restart the development server after changing `.env`
-- Environment variables must start with `REACT_APP_`
-
-**4. API connection issues:**
-- Ensure backend is running on port 5000
-- Check `REACT_APP_API_URL` in `.env`
-- Check browser console for CORS errors
-
-### Development Tips
-
-1. **Hot Reload**: The dev server automatically reloads when you save files
-2. **Browser Extensions**: Install React Developer Tools for debugging
-3. **Network Tab**: Use browser dev tools to monitor API calls
-4. **Console Logs**: Check browser console for errors and warnings
-
-## Project Structure
-
-```
-frontend/
-â”œâ”€â”€ public/          # Static files
-â”œâ”€â”€ src/
-â”‚   â”œâ”€â”€ components/  # Reusable UI components
-â”‚   â”œâ”€â”€ pages/       # Page components
-â”‚   â”œâ”€â”€ store/       # Redux store and slices
-â”‚   â”œâ”€â”€ services/    # API services
-â”‚   â”œâ”€â”€ hooks/       # Custom React hooks
-â”‚   â”œâ”€â”€ utils/       # Utility functions
-â”‚   â”œâ”€â”€ types/       # TypeScript type definitions
-â”‚   â”œâ”€â”€ App.tsx      # Main App component
-â”‚   â””â”€â”€ index.tsx    # App entry point
-â”œâ”€â”€ package.json     # Dependencies and scripts
-â”œâ”€â”€ tsconfig.json    # TypeScript configuration
-â””â”€â”€ .env.example     # Environment template
-```
-
-## Next Steps
-
-After the frontend is running:
-
-1. **Backend Setup**: Follow `../backend/README.md` to start the API server
-2. **Database**: Set up MongoDB (see main project README)
-3. **AI Service**: Configure the Python AI service (see `../ai-service/README.md`)
+# Frontend - Event Monitoring MVP
+
+Modern React.js frontend application for the Event Monitoring system with real-time dashboards, interactive maps, and comprehensive camera management.
+
+## ğŸš€ Quick Start
+
+### Prerequisites
+- **Node.js** 18+ and npm
+- **Modern browser** with ES2020 support
+
+### Development Setup
+
+1. **Install Dependencies**
+   ```bash
+   cd frontend
+   npm install
+   ```
+
+2. **Environment Configuration**
+   ```bash
+   # Create environment file
+   cp .env.example .env
+   
+   # Edit with your settings
+   nano .env
+   ```
+
+3. **Start Development Server**
+   ```bash
+   npm start
+   ```
+
+4. **Access Application**
+   - Open http://localhost:3000
+   - Login with default credentials: `admin@example.com` / `password123`
+cd frontend
+npm install
+```
+
+### 2. Environment Setup
+```bash
+# Copy the environment template
+cp .env.example .env
+
+# Edit the .env file with your configuration
+nano .env
+```
+
+### 3. Start Development Server
+```bash
+npm start
+```
+
+The frontend will be available at: http://localhost:3000
+
+## Environment Configuration
+
+Edit the `.env` file with these settings:
+
+```bash
+# API Configuration
+REACT_APP_API_URL=http://localhost:5000/api
+REACT_APP_SOCKET_URL=http://localhost:5000
+
+# Map Configuration (Get your token from https://mapbox.com)
+REACT_APP_MAPBOX_TOKEN=your-mapbox-access-token-here
+REACT_APP_DEFAULT_MAP_CENTER_LAT=40.7128
+REACT_APP_DEFAULT_MAP_CENTER_LNG=-74.0060
+REACT_APP_DEFAULT_MAP_ZOOM=10
+
+# Video Configuration
+REACT_APP_VIDEO_REFRESH_INTERVAL=30000
+REACT_APP_MAX_VIDEO_STREAMS=4
+
+# UI Configuration
+REACT_APP_EVENTS_REFRESH_INTERVAL=5000
+REACT_APP_PAGINATION_SIZE=20
+
+# Debug
+REACT_APP_DEBUG_MODE=true
+REACT_APP_LOG_LEVEL=debug
+```
+
+## Available Scripts
+
+### Development
+```bash
+npm start          # Start development server (hot reload)
+npm test           # Run tests
+npm run lint       # Run ESLint
+npm run lint:fix   # Fix ESLint issues
+npm run format     # Format code with Prettier
+```
+
+### Production
+```bash
+npm run build      # Create production build
+npm run preview    # Preview production build locally
+```
+
+## Getting a Mapbox Token
+
+1. Go to https://mapbox.com
+2. Sign up for a free account
+3. Go to Account â†’ Access Tokens
+4. Create a new token or copy the default public token
+5. Add it to your `.env` file as `REACT_APP_MAPBOX_TOKEN`
+
+## Troubleshooting
+
+### Common Issues
+
+**1. Dependencies not installing:**
+```bash
+# Clear npm cache and reinstall
+rm -rf node_modules package-lock.json
+npm cache clean --force
+npm install
+```
+
+**2. Port 3000 already in use:**
+```bash
+# Kill process on port 3000
+sudo lsof -t -i:3000 | xargs kill -9
+# Or use a different port
+PORT=3001 npm start
+```
+
+**3. Environment variables not loading:**
+- Make sure `.env` file is in the frontend root directory
+- Restart the development server after changing `.env`
+- Environment variables must start with `REACT_APP_`
+
+**4. API connection issues:**
+- Ensure backend is running on port 5000
+- Check `REACT_APP_API_URL` in `.env`
+- Check browser console for CORS errors
+
+### Development Tips
+
+1. **Hot Reload**: The dev server automatically reloads when you save files
+2. **Browser Extensions**: Install React Developer Tools for debugging
+3. **Network Tab**: Use browser dev tools to monitor API calls
+4. **Console Logs**: Check browser console for errors and warnings
+
+## Project Structure
+
+```
+frontend/
+â”œâ”€â”€ public/          # Static files
+â”œâ”€â”€ src/
+â”‚   â”œâ”€â”€ components/  # Reusable UI components
+â”‚   â”œâ”€â”€ pages/       # Page components
+â”‚   â”œâ”€â”€ store/       # Redux store and slices
+â”‚   â”œâ”€â”€ services/    # API services
+â”‚   â”œâ”€â”€ hooks/       # Custom React hooks
+â”‚   â”œâ”€â”€ utils/       # Utility functions
+â”‚   â”œâ”€â”€ types/       # TypeScript type definitions
+â”‚   â”œâ”€â”€ App.tsx      # Main App component
+â”‚   â””â”€â”€ index.tsx    # App entry point
+â”œâ”€â”€ package.json     # Dependencies and scripts
+â”œâ”€â”€ tsconfig.json    # TypeScript configuration
+â””â”€â”€ .env.example     # Environment template
+```
+
+## Next Steps
+
+After the frontend is running:
+
+1. **Backend Setup**: Follow `../backend/README.md` to start the API server
+2. **Database**: Set up MongoDB (see main project README)
+3. **AI Service**: Configure the Python AI service (see `../ai-service/README.md`)
 4. **Full Stack**: Use Docker Compose for complete setup (see main README)
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/nginx.conf b/event-monitoring-mvp/frontend/nginx.conf
index 6fcbcf3..683ef40 100644
--- a/event-monitoring-mvp/frontend/nginx.conf
+++ b/event-monitoring-mvp/frontend/nginx.conf
@@ -1,26 +1,26 @@
-server {
-    listen 3000;
-    server_name localhost;
-    root /usr/share/nginx/html;
-    index index.html;
-
-    # Handle client-side routing
-    location / {
-        try_files $uri $uri/ /index.html;
-    }
-
-    # Static files caching
-    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
-        expires 1y;
-        add_header Cache-Control "public, immutable";
-    }
-
-    # Security headers
-    add_header X-Frame-Options "SAMEORIGIN" always;
-    add_header X-Content-Type-Options "nosniff" always;
-    add_header Referrer-Policy "no-referrer-when-downgrade" always;
-
-    # Compression
-    gzip on;
-    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
+server {
+    listen 3000;
+    server_name localhost;
+    root /usr/share/nginx/html;
+    index index.html;
+
+    # Handle client-side routing
+    location / {
+        try_files $uri $uri/ /index.html;
+    }
+
+    # Static files caching
+    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
+        expires 1y;
+        add_header Cache-Control "public, immutable";
+    }
+
+    # Security headers
+    add_header X-Frame-Options "SAMEORIGIN" always;
+    add_header X-Content-Type-Options "nosniff" always;
+    add_header Referrer-Policy "no-referrer-when-downgrade" always;
+
+    # Compression
+    gzip on;
+    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/package.json b/event-monitoring-mvp/frontend/package.json
index 845d7a7..8e306e3 100644
--- a/event-monitoring-mvp/frontend/package.json
+++ b/event-monitoring-mvp/frontend/package.json
@@ -1,77 +1,78 @@
-{
-  "name": "event-monitoring-frontend",
-  "version": "1.0.0",
-  "description": "React frontend for Event Monitoring MVP",
-  "private": true,
-  "dependencies": {
-    "@emotion/react": "^11.10.8",
-    "@emotion/styled": "^11.10.8",
-    "@mui/icons-material": "^5.11.16",
-    "@mui/lab": "^5.0.0-alpha.129",
-    "@mui/material": "^5.12.3",
-    "@reduxjs/toolkit": "^1.9.5",
-    "@types/leaflet": "^1.9.21",
-    "@types/mapbox-gl": "^3.4.1",
-    "axios": "^1.4.0",
-    "date-fns": "^2.30.0",
-    "formik": "^2.2.9",
+{
+  "name": "event-monitoring-frontend",
+  "version": "1.0.0",
+  "description": "React frontend for Event Monitoring MVP",
+  "private": true,
+  "dependencies": {
+    "@emotion/react": "^11.10.8",
+    "@emotion/styled": "^11.10.8",
+    "@mui/icons-material": "^5.11.16",
+    "@mui/lab": "^5.0.0-alpha.129",
+    "@mui/material": "^5.12.3",
+    "@reduxjs/toolkit": "^1.9.5",
+    "@types/leaflet": "^1.9.21",
+    "@types/mapbox-gl": "^3.4.1",
+    "axios": "^1.4.0",
+    "date-fns": "^2.30.0",
+    "formik": "^2.2.9",
     "framer-motion": "^10.12.4",
+    "hls.js": "^1.5.15",
     "leaflet": "^1.9.4",
-    "react": "^18.2.0",
-    "react-dom": "^18.2.0",
-    "react-leaflet": "^4.2.1",
-    "react-map-gl": "^7.0.23",
-    "react-query": "^3.39.3",
-    "react-redux": "^8.0.5",
-    "react-router-dom": "^6.10.0",
-    "react-scripts": "5.0.1",
-    "react-toastify": "^9.1.2",
-    "recharts": "^2.6.2",
-    "redux-persist": "^6.0.0",
-    "socket.io-client": "^4.6.1",
-    "yup": "^1.1.1"
-  },
-  "devDependencies": {
-    "@types/node": "^18.16.3",
-    "@types/react": "^18.2.6",
-    "@types/react-dom": "^18.2.4",
-    "@typescript-eslint/eslint-plugin": "^5.59.2",
-    "@typescript-eslint/parser": "^5.59.2",
-    "eslint": "^8.40.0",
-    "eslint-plugin-react": "^7.32.2",
-    "eslint-plugin-react-hooks": "^4.6.0",
-    "prettier": "^2.8.8",
-    "typescript": "^4.9.5"
-  },
-  "scripts": {
-    "start": "react-scripts start",
-    "build": "react-scripts build",
-    "test": "react-scripts test",
-    "eject": "react-scripts eject",
-    "lint": "eslint src/**/*.{ts,tsx}",
-    "lint:fix": "eslint src/**/*.{ts,tsx} --fix",
-    "format": "prettier --write src/**/*.{ts,tsx,css,md}"
-  },
-  "eslintConfig": {
-    "extends": [
-      "react-app",
-      "react-app/jest"
-    ]
-  },
-  "browserslist": {
-    "production": [
-      ">0.2%",
-      "not dead",
-      "not op_mini all"
-    ],
-    "development": [
-      "last 1 chrome version",
-      "last 1 firefox version",
-      "last 1 safari version"
-    ]
-  },
-  "engines": {
-    "node": ">=18.0.0",
-    "npm": ">=8.0.0"
-  }
-}
+    "react": "^18.2.0",
+    "react-dom": "^18.2.0",
+    "react-leaflet": "^4.2.1",
+    "react-map-gl": "^7.0.23",
+    "react-query": "^3.39.3",
+    "react-redux": "^8.0.5",
+    "react-router-dom": "^6.10.0",
+    "react-scripts": "5.0.1",
+    "react-toastify": "^9.1.2",
+    "recharts": "^2.6.2",
+    "redux-persist": "^6.0.0",
+    "socket.io-client": "^4.6.1",
+    "yup": "^1.1.1"
+  },
+  "devDependencies": {
+    "@types/node": "^18.16.3",
+    "@types/react": "^18.2.6",
+    "@types/react-dom": "^18.2.4",
+    "@typescript-eslint/eslint-plugin": "^5.59.2",
+    "@typescript-eslint/parser": "^5.59.2",
+    "eslint": "^8.40.0",
+    "eslint-plugin-react": "^7.32.2",
+    "eslint-plugin-react-hooks": "^4.6.0",
+    "prettier": "^2.8.8",
+    "typescript": "^4.9.5"
+  },
+  "scripts": {
+    "start": "react-scripts start",
+    "build": "react-scripts build",
+    "test": "react-scripts test",
+    "eject": "react-scripts eject",
+    "lint": "eslint src/**/*.{ts,tsx}",
+    "lint:fix": "eslint src/**/*.{ts,tsx} --fix",
+    "format": "prettier --write src/**/*.{ts,tsx,css,md}"
+  },
+  "eslintConfig": {
+    "extends": [
+      "react-app",
+      "react-app/jest"
+    ]
+  },
+  "browserslist": {
+    "production": [
+      ">0.2%",
+      "not dead",
+      "not op_mini all"
+    ],
+    "development": [
+      "last 1 chrome version",
+      "last 1 firefox version",
+      "last 1 safari version"
+    ]
+  },
+  "engines": {
+    "node": ">=18.0.0",
+    "npm": ">=8.0.0"
+  }
+}
diff --git a/event-monitoring-mvp/frontend/public/index.html b/event-monitoring-mvp/frontend/public/index.html
index 83b4861..3b7874d 100644
--- a/event-monitoring-mvp/frontend/public/index.html
+++ b/event-monitoring-mvp/frontend/public/index.html
@@ -1,36 +1,36 @@
-<!DOCTYPE html>
-<html lang="en">
-  <head>
-    <meta charset="utf-8" />
-    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
-    <meta name="viewport" content="width=device-width, initial-scale=1" />
-    <meta name="theme-color" content="#000000" />
-    <meta
-      name="description"
-      content="Event Monitoring and Management Platform - Real-time security monitoring with AI-powered video analytics"
-    />
-    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
-    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
-    
-    <!-- Mapbox CSS -->
-    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
-    
-    <!-- Roboto Font -->
-    <link
-      rel="stylesheet"
-      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&display=swap"
-    />
-    
-    <!-- Material Icons -->
-    <link
-      rel="stylesheet"
-      href="https://fonts.googleapis.com/icon?family=Material+Icons"
-    />
-    
-    <title>Event Monitoring Platform</title>
-  </head>
-  <body>
-    <noscript>You need to enable JavaScript to run this app.</noscript>
-    <div id="root"></div>
-  </body>
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
+    <meta name="viewport" content="width=device-width, initial-scale=1" />
+    <meta name="theme-color" content="#000000" />
+    <meta
+      name="description"
+      content="Event Monitoring and Management Platform - Real-time security monitoring with AI-powered video analytics"
+    />
+    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
+    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
+    
+    <!-- Mapbox CSS -->
+    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
+    
+    <!-- Roboto Font -->
+    <link
+      rel="stylesheet"
+      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&display=swap"
+    />
+    
+    <!-- Material Icons -->
+    <link
+      rel="stylesheet"
+      href="https://fonts.googleapis.com/icon?family=Material+Icons"
+    />
+    
+    <title>Event Monitoring Platform</title>
+  </head>
+  <body>
+    <noscript>You need to enable JavaScript to run this app.</noscript>
+    <div id="root"></div>
+  </body>
 </html>
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/App.tsx b/event-monitoring-mvp/frontend/src/App.tsx
index 1348496..12834fa 100644
--- a/event-monitoring-mvp/frontend/src/App.tsx
+++ b/event-monitoring-mvp/frontend/src/App.tsx
@@ -1,72 +1,72 @@
-import React from 'react';
-import { Routes, Route, Navigate } from 'react-router-dom';
-import { useSelector } from 'react-redux';
-
-// Component imports
-import Layout from './components/Layout/Layout';
-import Login from './pages/Login';
-import Dashboard from './pages/Dashboard';
-import Events from './pages/Events';
-import EventSubmission from './pages/EventSubmission';
-import Cameras from './pages/Cameras';
-import AddCamera from './pages/AddCamera';
-import LiveView from './pages/LiveView';
-import MapView from './pages/MapView';
-import Profile from './pages/Profile';
-import Settings from './pages/Settings';
-
-// Redux store types
-import { RootState } from './store/store';
-
-/**
- * Main Application Component
- * 
- * This is the root component that handles authentication-based routing.
- * If the user is not authenticated, it shows the Login page.
- * If authenticated, it renders the main application layout with all routes.
- * 
- * Features:
- * - Authentication guard (redirects to login if not authenticated)
- * - Route configuration for all application pages
- * - Layout wrapper for authenticated pages
- * - Fallback route for unknown paths
- * 
- * @returns JSX.Element - Either Login page or main app with routing
- */
-const App: React.FC = () => {
-  // Get authentication state from Redux store
-  const isAuthenticated = useSelector((state: RootState) => state.auth.isAuthenticated);
-
-  // If user is not authenticated, show login page
-  if (!isAuthenticated) {
-    return <Login />;
-  }
-
-  // Render main application with authenticated layout and routing
-  return (
-    <Layout>
-      <Routes>
-        {/* Main dashboard route */}
-        <Route path="/" element={<Dashboard />} />
-        <Route path="/dashboard" element={<Dashboard />} />
-        
-        {/* Camera and monitoring routes */}
-        <Route path="/live-view" element={<LiveView />} />
-        <Route path="/map" element={<MapView />} />
-        <Route path="/events" element={<Events />} />
-        <Route path="/events/submit" element={<EventSubmission />} />
-        <Route path="/cameras" element={<Cameras />} />
-        <Route path="/cameras/add" element={<AddCamera />} />
-        
-        {/* User management routes */}
-        <Route path="/profile" element={<Profile />} />
-        <Route path="/settings" element={<Settings />} />
-        
-        {/* Catch-all route - redirects unknown paths to dashboard */}
-        <Route path="*" element={<Navigate to="/" replace />} />
-      </Routes>
-    </Layout>
-  );
-};
-
+import React from 'react';
+import { Routes, Route, Navigate } from 'react-router-dom';
+import { useSelector } from 'react-redux';
+
+// Component imports
+import Layout from './components/Layout/Layout';
+import Login from './pages/Login';
+import Dashboard from './pages/Dashboard';
+import Events from './pages/Events';
+import EventSubmission from './pages/EventSubmission';
+import Cameras from './pages/Cameras';
+import AddCamera from './pages/AddCamera';
+import LiveView from './pages/LiveView';
+import MapView from './pages/MapView';
+import Profile from './pages/Profile';
+import Settings from './pages/Settings';
+
+// Redux store types
+import { RootState } from './store/store';
+
+/**
+ * Main Application Component
+ * 
+ * This is the root component that handles authentication-based routing.
+ * If the user is not authenticated, it shows the Login page.
+ * If authenticated, it renders the main application layout with all routes.
+ * 
+ * Features:
+ * - Authentication guard (redirects to login if not authenticated)
+ * - Route configuration for all application pages
+ * - Layout wrapper for authenticated pages
+ * - Fallback route for unknown paths
+ * 
+ * @returns JSX.Element - Either Login page or main app with routing
+ */
+const App: React.FC = () => {
+  // Get authentication state from Redux store
+  const isAuthenticated = useSelector((state: RootState) => state.auth.isAuthenticated);
+
+  // If user is not authenticated, show login page
+  if (!isAuthenticated) {
+    return <Login />;
+  }
+
+  // Render main application with authenticated layout and routing
+  return (
+    <Layout>
+      <Routes>
+        {/* Main dashboard route */}
+        <Route path="/" element={<Dashboard />} />
+        <Route path="/dashboard" element={<Dashboard />} />
+        
+        {/* Camera and monitoring routes */}
+        <Route path="/live-view" element={<LiveView />} />
+        <Route path="/map" element={<MapView />} />
+        <Route path="/events" element={<Events />} />
+        <Route path="/events/submit" element={<EventSubmission />} />
+        <Route path="/cameras" element={<Cameras />} />
+        <Route path="/cameras/add" element={<AddCamera />} />
+        
+        {/* User management routes */}
+        <Route path="/profile" element={<Profile />} />
+        <Route path="/settings" element={<Settings />} />
+        
+        {/* Catch-all route - redirects unknown paths to dashboard */}
+        <Route path="*" element={<Navigate to="/" replace />} />
+      </Routes>
+    </Layout>
+  );
+};
+
 export default App;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/components/Layout/Layout.tsx b/event-monitoring-mvp/frontend/src/components/Layout/Layout.tsx
index 55f147a..6070dd2 100644
--- a/event-monitoring-mvp/frontend/src/components/Layout/Layout.tsx
+++ b/event-monitoring-mvp/frontend/src/components/Layout/Layout.tsx
@@ -1,320 +1,320 @@
-import React, { useState } from 'react';
-import {
-  Box,
-  CssBaseline,
-  Drawer,
-  AppBar,
-  Toolbar,
-  List,
-  Typography,
-  Divider,
-  IconButton,
-  ListItem,
-  ListItemButton,
-  ListItemIcon,
-  ListItemText,
-  Avatar,
-  Menu,
-  MenuItem,
-  useTheme,
-  useMediaQuery,
-  Badge,
-  Tooltip,
-} from '@mui/material';
-import {
-  Menu as MenuIcon,
-  Dashboard as DashboardIcon,
-  Event as EventIcon,
-  Videocam as VideocamIcon,
-  LiveTv as LiveTvIcon,
-  Map as MapIcon,
-  AccountCircle as AccountCircleIcon,
-  Logout as LogoutIcon,
-  Settings as SettingsIcon,
-  Notifications as NotificationsIcon,
-} from '@mui/icons-material';
-import { useNavigate, useLocation } from 'react-router-dom';
-import { useSelector, useDispatch } from 'react-redux';
-import { RootState, logout, toggleSidebar } from '../../store/store';
-
-const drawerWidth = 280;
-const miniDrawerWidth = 72;
-
-interface LayoutProps {
-  children: React.ReactNode;
-}
-
-const Layout: React.FC<LayoutProps> = ({ children }) => {
-  const theme = useTheme();
-  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
-  const navigate = useNavigate();
-  const location = useLocation();
-  const dispatch = useDispatch();
-  
-  const { user } = useSelector((state: RootState) => state.auth);
-  const { sidebarOpen } = useSelector((state: RootState) => state.ui);
-  
-  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
-  const [notificationCount] = useState(3); // Mock notification count
-
-  const menuItems = [
-    { text: 'Dashboard', icon: <DashboardIcon />, path: '/dashboard' },
-    { text: 'Events', icon: <EventIcon />, path: '/events' },
-    { text: 'Cameras', icon: <VideocamIcon />, path: '/cameras' },
-    { text: 'Live View', icon: <LiveTvIcon />, path: '/live-view' },
-    { text: 'Map View', icon: <MapIcon />, path: '/map' },
-  ];
-
-  const handleDrawerToggle = () => {
-    dispatch(toggleSidebar());
-  };
-
-  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
-    setAnchorEl(event.currentTarget);
-  };
-
-  const handleProfileMenuClose = () => {
-    setAnchorEl(null);
-  };
-
-  const handleLogout = () => {
-    dispatch(logout());
-    handleProfileMenuClose();
-    navigate('/login');
-  };
-
-  const handleNavigate = (path: string) => {
-    navigate(path);
-    if (isMobile) {
-      dispatch(toggleSidebar());
-    }
-  };
-
-  const drawer = (
-    <Box>
-      <Toolbar>
-        <Typography 
-          variant="h6" 
-          noWrap 
-          component="div" 
-          sx={{ 
-            fontWeight: 'bold',
-            display: sidebarOpen ? 'block' : 'none'
-          }}
-        >
-          Event Monitor
-        </Typography>
-        {!sidebarOpen && (
-          <Box sx={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
-            <EventIcon sx={{ color: 'primary.main' }} />
-          </Box>
-        )}
-      </Toolbar>
-      <Divider />
-      <List>
-        {menuItems.map((item) => (
-          <ListItem key={item.text} disablePadding>
-            <Tooltip title={!sidebarOpen ? item.text : ''} placement="right">
-              <ListItemButton
-                selected={location.pathname === item.path}
-                onClick={() => handleNavigate(item.path)}
-                sx={{
-                  minHeight: 48,
-                  justifyContent: sidebarOpen ? 'initial' : 'center',
-                  px: 2.5,
-                  '&.Mui-selected': {
-                    backgroundColor: theme.palette.primary.light,
-                    '& .MuiListItemIcon-root': {
-                      color: theme.palette.primary.main,
-                    },
-                    '& .MuiListItemText-primary': {
-                      color: theme.palette.primary.main,
-                      fontWeight: 'bold',
-                    },
-                  },
-                  '&:hover': {
-                    backgroundColor: theme.palette.action.hover,
-                  },
-                }}
-              >
-                <ListItemIcon
-                  sx={{
-                    minWidth: 0,
-                    mr: sidebarOpen ? 3 : 'auto',
-                    justifyContent: 'center',
-                  }}
-                >
-                  {item.icon}
-                </ListItemIcon>
-                <ListItemText 
-                  primary={item.text} 
-                  sx={{ opacity: sidebarOpen ? 1 : 0 }}
-                />
-              </ListItemButton>
-            </Tooltip>
-          </ListItem>
-        ))}
-      </List>
-    </Box>
-  );
-
-  return (
-    <Box sx={{ display: 'flex' }}>
-      <CssBaseline />
-      <AppBar
-        position="fixed"
-        sx={{
-          width: { 
-            xs: '100%', 
-            md: sidebarOpen ? `calc(100% - ${drawerWidth}px)` : `calc(100% - ${miniDrawerWidth}px)` 
-          },
-          ml: { 
-            xs: 0, 
-            md: sidebarOpen ? `${drawerWidth}px` : `${miniDrawerWidth}px` 
-          },
-          transition: theme.transitions.create(['width', 'margin'], {
-            easing: theme.transitions.easing.sharp,
-            duration: theme.transitions.duration.leavingScreen,
-          }),
-        }}
-      >
-        <Toolbar>
-          <IconButton
-            color="inherit"
-            aria-label="open drawer"
-            edge="start"
-            onClick={handleDrawerToggle}
-            sx={{ mr: 2 }}
-          >
-            <MenuIcon />
-          </IconButton>
-          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
-            {menuItems.find(item => item.path === location.pathname)?.text || 'Dashboard'}
-          </Typography>
-          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-            <IconButton
-              size="large"
-              aria-label="notifications"
-              color="inherit"
-            >
-              <Badge badgeContent={notificationCount} color="error">
-                <NotificationsIcon />
-              </Badge>
-            </IconButton>
-            <IconButton
-              size="large"
-              aria-label="account of current user"
-              aria-controls="menu-appbar"
-              aria-haspopup="true"
-              onClick={handleProfileMenuOpen}
-              color="inherit"
-            >
-              <Avatar sx={{ width: 32, height: 32, bgcolor: theme.palette.secondary.main }}>
-                {user?.username?.charAt(0).toUpperCase() || 'U'}
-              </Avatar>
-            </IconButton>
-          </Box>
-        </Toolbar>
-      </AppBar>
-
-      {/* Mobile drawer */}
-      <Drawer
-        variant="temporary"
-        open={sidebarOpen}
-        onClose={handleDrawerToggle}
-        ModalProps={{
-          keepMounted: true, // Better open performance on mobile.
-        }}
-        sx={{
-          display: { xs: 'block', md: 'none' },
-          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
-        }}
-      >
-        {drawer}
-      </Drawer>
-
-      {/* Desktop drawer */}
-      <Drawer
-        variant="permanent"
-        sx={{
-          display: { xs: 'none', md: 'block' },
-          '& .MuiDrawer-paper': {
-            boxSizing: 'border-box',
-            width: sidebarOpen ? drawerWidth : miniDrawerWidth,
-            transition: theme.transitions.create('width', {
-              easing: theme.transitions.easing.sharp,
-              duration: theme.transitions.duration.enteringScreen,
-            }),
-            overflowX: 'hidden',
-          },
-        }}
-        open
-      >
-        {drawer}
-      </Drawer>
-
-      {/* Profile menu */}
-      <Menu
-        id="menu-appbar"
-        anchorEl={anchorEl}
-        anchorOrigin={{
-          vertical: 'top',
-          horizontal: 'right',
-        }}
-        keepMounted
-        transformOrigin={{
-          vertical: 'top',
-          horizontal: 'right',
-        }}
-        open={Boolean(anchorEl)}
-        onClose={handleProfileMenuClose}
-      >
-        <MenuItem onClick={() => { handleProfileMenuClose(); handleNavigate('/profile'); }}>
-          <ListItemIcon>
-            <AccountCircleIcon fontSize="small" />
-          </ListItemIcon>
-          Profile
-        </MenuItem>
-        <MenuItem onClick={() => { handleProfileMenuClose(); handleNavigate('/settings'); }}>
-          <ListItemIcon>
-            <SettingsIcon fontSize="small" />
-          </ListItemIcon>
-          Settings
-        </MenuItem>
-        <Divider />
-        <MenuItem onClick={handleLogout}>
-          <ListItemIcon>
-            <LogoutIcon fontSize="small" />
-          </ListItemIcon>
-          Logout
-        </MenuItem>
-      </Menu>
-
-      {/* Main content */}
-      <Box
-        component="main"
-        sx={{
-          flexGrow: 1,
-          p: 3,
-          width: { 
-            xs: '100%', 
-            md: sidebarOpen ? `calc(100% - ${drawerWidth}px)` : `calc(100% - ${miniDrawerWidth}px)` 
-          },
-          ml: { 
-            xs: 0, 
-            md: sidebarOpen ? `${drawerWidth}px` : `${miniDrawerWidth}px` 
-          },
-          mt: '64px', // AppBar height
-          transition: theme.transitions.create(['width', 'margin'], {
-            easing: theme.transitions.easing.sharp,
-            duration: theme.transitions.duration.leavingScreen,
-          }),
-        }}
-      >
-        {children}
-      </Box>
-    </Box>
-  );
-};
-
+import React, { useState } from 'react';
+import {
+  Box,
+  CssBaseline,
+  Drawer,
+  AppBar,
+  Toolbar,
+  List,
+  Typography,
+  Divider,
+  IconButton,
+  ListItem,
+  ListItemButton,
+  ListItemIcon,
+  ListItemText,
+  Avatar,
+  Menu,
+  MenuItem,
+  useTheme,
+  useMediaQuery,
+  Badge,
+  Tooltip,
+} from '@mui/material';
+import {
+  Menu as MenuIcon,
+  Dashboard as DashboardIcon,
+  Event as EventIcon,
+  Videocam as VideocamIcon,
+  LiveTv as LiveTvIcon,
+  Map as MapIcon,
+  AccountCircle as AccountCircleIcon,
+  Logout as LogoutIcon,
+  Settings as SettingsIcon,
+  Notifications as NotificationsIcon,
+} from '@mui/icons-material';
+import { useNavigate, useLocation } from 'react-router-dom';
+import { useSelector, useDispatch } from 'react-redux';
+import { RootState, logout, toggleSidebar } from '../../store/store';
+
+const drawerWidth = 280;
+const miniDrawerWidth = 72;
+
+interface LayoutProps {
+  children: React.ReactNode;
+}
+
+const Layout: React.FC<LayoutProps> = ({ children }) => {
+  const theme = useTheme();
+  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
+  const navigate = useNavigate();
+  const location = useLocation();
+  const dispatch = useDispatch();
+  
+  const { user } = useSelector((state: RootState) => state.auth);
+  const { sidebarOpen } = useSelector((state: RootState) => state.ui);
+  
+  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
+  const [notificationCount] = useState(3); // Mock notification count
+
+  const menuItems = [
+    { text: 'Dashboard', icon: <DashboardIcon />, path: '/dashboard' },
+    { text: 'Events', icon: <EventIcon />, path: '/events' },
+    { text: 'Cameras', icon: <VideocamIcon />, path: '/cameras' },
+    { text: 'Live View', icon: <LiveTvIcon />, path: '/live-view' },
+    { text: 'Map View', icon: <MapIcon />, path: '/map' },
+  ];
+
+  const handleDrawerToggle = () => {
+    dispatch(toggleSidebar());
+  };
+
+  const handleProfileMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
+    setAnchorEl(event.currentTarget);
+  };
+
+  const handleProfileMenuClose = () => {
+    setAnchorEl(null);
+  };
+
+  const handleLogout = () => {
+    dispatch(logout());
+    handleProfileMenuClose();
+    navigate('/login');
+  };
+
+  const handleNavigate = (path: string) => {
+    navigate(path);
+    if (isMobile) {
+      dispatch(toggleSidebar());
+    }
+  };
+
+  const drawer = (
+    <Box>
+      <Toolbar>
+        <Typography 
+          variant="h6" 
+          noWrap 
+          component="div" 
+          sx={{ 
+            fontWeight: 'bold',
+            display: sidebarOpen ? 'block' : 'none'
+          }}
+        >
+          Event Monitor
+        </Typography>
+        {!sidebarOpen && (
+          <Box sx={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
+            <EventIcon sx={{ color: 'primary.main' }} />
+          </Box>
+        )}
+      </Toolbar>
+      <Divider />
+      <List>
+        {menuItems.map((item) => (
+          <ListItem key={item.text} disablePadding>
+            <Tooltip title={!sidebarOpen ? item.text : ''} placement="right">
+              <ListItemButton
+                selected={location.pathname === item.path}
+                onClick={() => handleNavigate(item.path)}
+                sx={{
+                  minHeight: 48,
+                  justifyContent: sidebarOpen ? 'initial' : 'center',
+                  px: 2.5,
+                  '&.Mui-selected': {
+                    backgroundColor: theme.palette.primary.light,
+                    '& .MuiListItemIcon-root': {
+                      color: theme.palette.primary.main,
+                    },
+                    '& .MuiListItemText-primary': {
+                      color: theme.palette.primary.main,
+                      fontWeight: 'bold',
+                    },
+                  },
+                  '&:hover': {
+                    backgroundColor: theme.palette.action.hover,
+                  },
+                }}
+              >
+                <ListItemIcon
+                  sx={{
+                    minWidth: 0,
+                    mr: sidebarOpen ? 3 : 'auto',
+                    justifyContent: 'center',
+                  }}
+                >
+                  {item.icon}
+                </ListItemIcon>
+                <ListItemText 
+                  primary={item.text} 
+                  sx={{ opacity: sidebarOpen ? 1 : 0 }}
+                />
+              </ListItemButton>
+            </Tooltip>
+          </ListItem>
+        ))}
+      </List>
+    </Box>
+  );
+
+  return (
+    <Box sx={{ display: 'flex' }}>
+      <CssBaseline />
+      <AppBar
+        position="fixed"
+        sx={{
+          width: { 
+            xs: '100%', 
+            md: sidebarOpen ? `calc(100% - ${drawerWidth}px)` : `calc(100% - ${miniDrawerWidth}px)` 
+          },
+          ml: { 
+            xs: 0, 
+            md: sidebarOpen ? `${drawerWidth}px` : `${miniDrawerWidth}px` 
+          },
+          transition: theme.transitions.create(['width', 'margin'], {
+            easing: theme.transitions.easing.sharp,
+            duration: theme.transitions.duration.leavingScreen,
+          }),
+        }}
+      >
+        <Toolbar>
+          <IconButton
+            color="inherit"
+            aria-label="open drawer"
+            edge="start"
+            onClick={handleDrawerToggle}
+            sx={{ mr: 2 }}
+          >
+            <MenuIcon />
+          </IconButton>
+          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
+            {menuItems.find(item => item.path === location.pathname)?.text || 'Dashboard'}
+          </Typography>
+          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+            <IconButton
+              size="large"
+              aria-label="notifications"
+              color="inherit"
+            >
+              <Badge badgeContent={notificationCount} color="error">
+                <NotificationsIcon />
+              </Badge>
+            </IconButton>
+            <IconButton
+              size="large"
+              aria-label="account of current user"
+              aria-controls="menu-appbar"
+              aria-haspopup="true"
+              onClick={handleProfileMenuOpen}
+              color="inherit"
+            >
+              <Avatar sx={{ width: 32, height: 32, bgcolor: theme.palette.secondary.main }}>
+                {user?.username?.charAt(0).toUpperCase() || 'U'}
+              </Avatar>
+            </IconButton>
+          </Box>
+        </Toolbar>
+      </AppBar>
+
+      {/* Mobile drawer */}
+      <Drawer
+        variant="temporary"
+        open={sidebarOpen}
+        onClose={handleDrawerToggle}
+        ModalProps={{
+          keepMounted: true, // Better open performance on mobile.
+        }}
+        sx={{
+          display: { xs: 'block', md: 'none' },
+          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
+        }}
+      >
+        {drawer}
+      </Drawer>
+
+      {/* Desktop drawer */}
+      <Drawer
+        variant="permanent"
+        sx={{
+          display: { xs: 'none', md: 'block' },
+          '& .MuiDrawer-paper': {
+            boxSizing: 'border-box',
+            width: sidebarOpen ? drawerWidth : miniDrawerWidth,
+            transition: theme.transitions.create('width', {
+              easing: theme.transitions.easing.sharp,
+              duration: theme.transitions.duration.enteringScreen,
+            }),
+            overflowX: 'hidden',
+          },
+        }}
+        open
+      >
+        {drawer}
+      </Drawer>
+
+      {/* Profile menu */}
+      <Menu
+        id="menu-appbar"
+        anchorEl={anchorEl}
+        anchorOrigin={{
+          vertical: 'top',
+          horizontal: 'right',
+        }}
+        keepMounted
+        transformOrigin={{
+          vertical: 'top',
+          horizontal: 'right',
+        }}
+        open={Boolean(anchorEl)}
+        onClose={handleProfileMenuClose}
+      >
+        <MenuItem onClick={() => { handleProfileMenuClose(); handleNavigate('/profile'); }}>
+          <ListItemIcon>
+            <AccountCircleIcon fontSize="small" />
+          </ListItemIcon>
+          Profile
+        </MenuItem>
+        <MenuItem onClick={() => { handleProfileMenuClose(); handleNavigate('/settings'); }}>
+          <ListItemIcon>
+            <SettingsIcon fontSize="small" />
+          </ListItemIcon>
+          Settings
+        </MenuItem>
+        <Divider />
+        <MenuItem onClick={handleLogout}>
+          <ListItemIcon>
+            <LogoutIcon fontSize="small" />
+          </ListItemIcon>
+          Logout
+        </MenuItem>
+      </Menu>
+
+      {/* Main content */}
+      <Box
+        component="main"
+        sx={{
+          flexGrow: 1,
+          p: 3,
+          width: { 
+            xs: '100%', 
+            md: sidebarOpen ? `calc(100% - ${drawerWidth}px)` : `calc(100% - ${miniDrawerWidth}px)` 
+          },
+          ml: { 
+            xs: 0, 
+            md: sidebarOpen ? `${drawerWidth}px` : `${miniDrawerWidth}px` 
+          },
+          mt: '64px', // AppBar height
+          transition: theme.transitions.create(['width', 'margin'], {
+            easing: theme.transitions.easing.sharp,
+            duration: theme.transitions.duration.leavingScreen,
+          }),
+        }}
+      >
+        {children}
+      </Box>
+    </Box>
+  );
+};
+
 export default Layout;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/components/MapContextMenu.tsx b/event-monitoring-mvp/frontend/src/components/MapContextMenu.tsx
index 0054bde..37faedd 100644
--- a/event-monitoring-mvp/frontend/src/components/MapContextMenu.tsx
+++ b/event-monitoring-mvp/frontend/src/components/MapContextMenu.tsx
@@ -1,233 +1,233 @@
-import React, { useState, useEffect } from 'react';
-import {
-  Menu,
-  MenuItem,
-  ListItemIcon,
-  ListItemText,
-  Divider,
-  Paper,
-  Typography,
-  Box
-} from '@mui/material';
-import {
-  VideocamOutlined as CameraIcon,
-  EventNote as EventIcon,
-  MyLocation as LocationIcon,
-  Visibility as ViewIcon,
-  Analytics as AnalyticsIcon,
-  LocationOn as PinIcon,
-  Map as MapIcon,
-  Timeline as TimelineIcon
-} from '@mui/icons-material';
-
-interface ContextMenuPosition {
-  x: number;
-  y: number;
-}
-
-interface ContextMenuProps {
-  position: ContextMenuPosition | null;
-  latLng: { lat: number; lng: number } | null;
-  onClose: () => void;
-  onAddCamera: (position: { lat: number; lng: number }) => void;
-  onCreateEvent: (position: { lat: number; lng: number }) => void;
-  onViewCoverage: (position: { lat: number; lng: number }) => void;
-  onAnalyzeArea: (position: { lat: number; lng: number }) => void;
-  onSetWaypoint: (position: { lat: number; lng: number }) => void;
-  onMeasureDistance: (position: { lat: number; lng: number }) => void;
-  onViewTimeline: (position: { lat: number; lng: number }) => void;
-  userRole?: 'admin' | 'operator' | 'viewer';
-  nearbyData?: {
-    cameras: number;
-    events: number;
-    detections: number;
-  };
-}
-
-const MapContextMenu: React.FC<ContextMenuProps> = ({
-  position,
-  latLng,
-  onClose,
-  onAddCamera,
-  onCreateEvent,
-  onViewCoverage,
-  onAnalyzeArea,
-  onSetWaypoint,
-  onMeasureDistance,
-  onViewTimeline,
-  userRole = 'operator',
-  nearbyData
-}) => {
-  const [menuItems, setMenuItems] = useState<any[]>([]);
-
-  useEffect(() => {
-    if (!latLng) return;
-
-    const items = [
-      // Location info header
-      {
-        type: 'header',
-        content: (
-          <Box sx={{ p: 1, bgcolor: 'primary.main', color: 'white' }}>
-            <Typography variant="subtitle2">
-              ğŸ“ {latLng.lat.toFixed(6)}, {latLng.lng.toFixed(6)}
-            </Typography>
-            {nearbyData && (
-              <Typography variant="caption" sx={{ display: 'block', mt: 0.5 }}>
-                ğŸ“¹ {nearbyData.cameras} cameras â€¢ ğŸš¨ {nearbyData.events} events â€¢ ğŸ¤– {nearbyData.detections} detections
-              </Typography>
-            )}
-          </Box>
-        )
-      },
-      
-      // Camera management
-      {
-        type: 'divider'
-      },
-      {
-        id: 'add-camera',
-        label: 'Add Camera Here',
-        icon: <CameraIcon />,
-        action: () => onAddCamera(latLng),
-        requiresRole: ['admin', 'operator'],
-        disabled: false
-      },
-      {
-        id: 'view-coverage',
-        label: 'Show Camera Coverage',
-        icon: <ViewIcon />,
-        action: () => onViewCoverage(latLng),
-        disabled: false
-      },
-      
-      // Event management
-      {
-        type: 'divider'
-      },
-      {
-        id: 'create-event',
-        label: 'Create Event Here',
-        icon: <EventIcon />,
-        action: () => onCreateEvent(latLng),
-        requiresRole: ['admin', 'operator'],
-        disabled: false
-      },
-      {
-        id: 'view-timeline',
-        label: 'View Location Timeline',
-        icon: <TimelineIcon />,
-        action: () => onViewTimeline(latLng),
-        disabled: false
-      },
-      
-      // Analysis tools
-      {
-        type: 'divider'
-      },
-      {
-        id: 'analyze-area',
-        label: 'Analyze Area',
-        icon: <AnalyticsIcon />,
-        action: () => onAnalyzeArea(latLng),
-        disabled: false
-      },
-      {
-        id: 'set-waypoint',
-        label: 'Set Waypoint',
-        icon: <PinIcon />,
-        action: () => onSetWaypoint(latLng),
-        disabled: false
-      },
-      {
-        id: 'measure-distance',
-        label: 'Measure Distance',
-        icon: <MapIcon />,
-        action: () => onMeasureDistance(latLng),
-        disabled: false
-      }
-    ];
-
-    // Filter items based on user role
-    const filteredItems = items.filter(item => {
-      if (item.type) return true; // Headers and dividers always shown
-      if (!item.requiresRole) return true; // No role requirement
-      return item.requiresRole.includes(userRole);
-    });
-
-    setMenuItems(filteredItems);
-  }, [latLng, userRole, nearbyData]);
-
-  const handleItemClick = (item: any) => {
-    if (item.action && !item.disabled) {
-      item.action();
-    }
-    onClose();
-  };
-
-  if (!position || !latLng) {
-    return null;
-  }
-
-  return (
-    <Paper
-      sx={{
-        position: 'fixed',
-        left: position.x,
-        top: position.y,
-        zIndex: 10000,
-        minWidth: 250,
-        maxWidth: 300,
-        boxShadow: 3,
-        overflow: 'hidden',
-        transform: `translate(${position.x > window.innerWidth - 300 ? '-100%' : '0'}, ${
-          position.y > window.innerHeight - 400 ? '-100%' : '0'
-        })`
-      }}
-      onContextMenu={(e) => e.preventDefault()}
-      onClick={(e) => e.stopPropagation()}
-    >
-      {menuItems.map((item, index) => {
-        if (item.type === 'header') {
-          return (
-            <Box key={`header-${index}`}>
-              {item.content}
-            </Box>
-          );
-        }
-        
-        if (item.type === 'divider') {
-          return <Divider key={`divider-${index}`} />;
-        }
-
-        return (
-          <MenuItem
-            key={item.id}
-            onClick={() => handleItemClick(item)}
-            disabled={item.disabled}
-            sx={{
-              py: 1,
-              '&:hover': {
-                bgcolor: 'primary.light',
-                color: 'white',
-                '& .MuiListItemIcon-root': {
-                  color: 'white'
-                }
-              }
-            }}
-          >
-            <ListItemIcon sx={{ color: 'inherit' }}>
-              {item.icon}
-            </ListItemIcon>
-            <ListItemText 
-              primary={item.label}
-              sx={{ color: 'inherit' }}
-            />
-          </MenuItem>
-        );
-      })}
-    </Paper>
-  );
-};
-
+import React, { useState, useEffect } from 'react';
+import {
+  Menu,
+  MenuItem,
+  ListItemIcon,
+  ListItemText,
+  Divider,
+  Paper,
+  Typography,
+  Box
+} from '@mui/material';
+import {
+  VideocamOutlined as CameraIcon,
+  EventNote as EventIcon,
+  MyLocation as LocationIcon,
+  Visibility as ViewIcon,
+  Analytics as AnalyticsIcon,
+  LocationOn as PinIcon,
+  Map as MapIcon,
+  Timeline as TimelineIcon
+} from '@mui/icons-material';
+
+interface ContextMenuPosition {
+  x: number;
+  y: number;
+}
+
+interface ContextMenuProps {
+  position: ContextMenuPosition | null;
+  latLng: { lat: number; lng: number } | null;
+  onClose: () => void;
+  onAddCamera: (position: { lat: number; lng: number }) => void;
+  onCreateEvent: (position: { lat: number; lng: number }) => void;
+  onViewCoverage: (position: { lat: number; lng: number }) => void;
+  onAnalyzeArea: (position: { lat: number; lng: number }) => void;
+  onSetWaypoint: (position: { lat: number; lng: number }) => void;
+  onMeasureDistance: (position: { lat: number; lng: number }) => void;
+  onViewTimeline: (position: { lat: number; lng: number }) => void;
+  userRole?: 'admin' | 'operator' | 'viewer';
+  nearbyData?: {
+    cameras: number;
+    events: number;
+    detections: number;
+  };
+}
+
+const MapContextMenu: React.FC<ContextMenuProps> = ({
+  position,
+  latLng,
+  onClose,
+  onAddCamera,
+  onCreateEvent,
+  onViewCoverage,
+  onAnalyzeArea,
+  onSetWaypoint,
+  onMeasureDistance,
+  onViewTimeline,
+  userRole = 'operator',
+  nearbyData
+}) => {
+  const [menuItems, setMenuItems] = useState<any[]>([]);
+
+  useEffect(() => {
+    if (!latLng) return;
+
+    const items = [
+      // Location info header
+      {
+        type: 'header',
+        content: (
+          <Box sx={{ p: 1, bgcolor: 'primary.main', color: 'white' }}>
+            <Typography variant="subtitle2">
+              ğŸ“ {latLng.lat.toFixed(6)}, {latLng.lng.toFixed(6)}
+            </Typography>
+            {nearbyData && (
+              <Typography variant="caption" sx={{ display: 'block', mt: 0.5 }}>
+                ğŸ“¹ {nearbyData.cameras} cameras â€¢ ğŸš¨ {nearbyData.events} events â€¢ ğŸ¤– {nearbyData.detections} detections
+              </Typography>
+            )}
+          </Box>
+        )
+      },
+      
+      // Camera management
+      {
+        type: 'divider'
+      },
+      {
+        id: 'add-camera',
+        label: 'Add Camera Here',
+        icon: <CameraIcon />,
+        action: () => onAddCamera(latLng),
+        requiresRole: ['admin', 'operator'],
+        disabled: false
+      },
+      {
+        id: 'view-coverage',
+        label: 'Show Camera Coverage',
+        icon: <ViewIcon />,
+        action: () => onViewCoverage(latLng),
+        disabled: false
+      },
+      
+      // Event management
+      {
+        type: 'divider'
+      },
+      {
+        id: 'create-event',
+        label: 'Create Event Here',
+        icon: <EventIcon />,
+        action: () => onCreateEvent(latLng),
+        requiresRole: ['admin', 'operator'],
+        disabled: false
+      },
+      {
+        id: 'view-timeline',
+        label: 'View Location Timeline',
+        icon: <TimelineIcon />,
+        action: () => onViewTimeline(latLng),
+        disabled: false
+      },
+      
+      // Analysis tools
+      {
+        type: 'divider'
+      },
+      {
+        id: 'analyze-area',
+        label: 'Analyze Area',
+        icon: <AnalyticsIcon />,
+        action: () => onAnalyzeArea(latLng),
+        disabled: false
+      },
+      {
+        id: 'set-waypoint',
+        label: 'Set Waypoint',
+        icon: <PinIcon />,
+        action: () => onSetWaypoint(latLng),
+        disabled: false
+      },
+      {
+        id: 'measure-distance',
+        label: 'Measure Distance',
+        icon: <MapIcon />,
+        action: () => onMeasureDistance(latLng),
+        disabled: false
+      }
+    ];
+
+    // Filter items based on user role
+    const filteredItems = items.filter(item => {
+      if (item.type) return true; // Headers and dividers always shown
+      if (!item.requiresRole) return true; // No role requirement
+      return item.requiresRole.includes(userRole);
+    });
+
+    setMenuItems(filteredItems);
+  }, [latLng, userRole, nearbyData]);
+
+  const handleItemClick = (item: any) => {
+    if (item.action && !item.disabled) {
+      item.action();
+    }
+    onClose();
+  };
+
+  if (!position || !latLng) {
+    return null;
+  }
+
+  return (
+    <Paper
+      sx={{
+        position: 'fixed',
+        left: position.x,
+        top: position.y,
+        zIndex: 10000,
+        minWidth: 250,
+        maxWidth: 300,
+        boxShadow: 3,
+        overflow: 'hidden',
+        transform: `translate(${position.x > window.innerWidth - 300 ? '-100%' : '0'}, ${
+          position.y > window.innerHeight - 400 ? '-100%' : '0'
+        })`
+      }}
+      onContextMenu={(e) => e.preventDefault()}
+      onClick={(e) => e.stopPropagation()}
+    >
+      {menuItems.map((item, index) => {
+        if (item.type === 'header') {
+          return (
+            <Box key={`header-${index}`}>
+              {item.content}
+            </Box>
+          );
+        }
+        
+        if (item.type === 'divider') {
+          return <Divider key={`divider-${index}`} />;
+        }
+
+        return (
+          <MenuItem
+            key={item.id}
+            onClick={() => handleItemClick(item)}
+            disabled={item.disabled}
+            sx={{
+              py: 1,
+              '&:hover': {
+                bgcolor: 'primary.light',
+                color: 'white',
+                '& .MuiListItemIcon-root': {
+                  color: 'white'
+                }
+              }
+            }}
+          >
+            <ListItemIcon sx={{ color: 'inherit' }}>
+              {item.icon}
+            </ListItemIcon>
+            <ListItemText 
+              primary={item.label}
+              sx={{ color: 'inherit' }}
+            />
+          </MenuItem>
+        );
+      })}
+    </Paper>
+  );
+};
+
 export default MapContextMenu;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/index.css b/event-monitoring-mvp/frontend/src/index.css
index eb9232d..33851b2 100644
--- a/event-monitoring-mvp/frontend/src/index.css
+++ b/event-monitoring-mvp/frontend/src/index.css
@@ -1,122 +1,122 @@
-body {
-  margin: 0;
-  font-family: 'Roboto', Arial, sans-serif;
-  -webkit-font-smoothing: antialiased;
-  -moz-osx-font-smoothing: grayscale;
-  background-color: #f5f5f5;
-}
-
-code {
-  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
-}
-
-/* Global styles for map */
-.mapboxgl-popup {
-  max-width: 300px;
-}
-
-.mapboxgl-popup-content {
-  padding: 12px 15px;
-  border-radius: 8px;
-}
-
-/* Video player styles */
-.video-player {
-  width: 100%;
-  height: 100%;
-  object-fit: cover;
-  border-radius: 4px;
-}
-
-.video-container {
-  position: relative;
-  width: 100%;
-  height: 100%;
-  background: #000;
-  border-radius: 4px;
-  overflow: hidden;
-}
-
-.video-overlay {
-  position: absolute;
-  top: 0;
-  left: 0;
-  right: 0;
-  bottom: 0;
-  display: flex;
-  align-items: center;
-  justify-content: center;
-  background: rgba(0, 0, 0, 0.7);
-  color: white;
-  font-size: 14px;
-}
-
-/* Event severity colors */
-.severity-low {
-  color: #4caf50;
-}
-
-.severity-medium {
-  color: #ff9800;
-}
-
-.severity-high {
-  color: #f44336;
-}
-
-.severity-critical {
-  color: #d32f2f;
-  font-weight: bold;
-}
-
-/* Event status colors */
-.status-open {
-  color: #f44336;
-}
-
-.status-acknowledged {
-  color: #ff9800;
-}
-
-.status-investigating {
-  color: #2196f3;
-}
-
-.status-resolved {
-  color: #4caf50;
-}
-
-.status-closed {
-  color: #9e9e9e;
-}
-
-/* Loading spinner */
-.loading-spinner {
-  animation: spin 1s linear infinite;
-}
-
-@keyframes spin {
-  0% { transform: rotate(0deg); }
-  100% { transform: rotate(360deg); }
-}
-
-/* Responsive utilities */
-.hide-sm {
-  display: block;
-}
-
-@media (max-width: 600px) {
-  .hide-sm {
-    display: none;
-  }
-}
-
-.show-sm {
-  display: none;
-}
-
-@media (max-width: 600px) {
-  .show-sm {
-    display: block;
-  }
+body {
+  margin: 0;
+  font-family: 'Roboto', Arial, sans-serif;
+  -webkit-font-smoothing: antialiased;
+  -moz-osx-font-smoothing: grayscale;
+  background-color: #f5f5f5;
+}
+
+code {
+  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
+}
+
+/* Global styles for map */
+.mapboxgl-popup {
+  max-width: 300px;
+}
+
+.mapboxgl-popup-content {
+  padding: 12px 15px;
+  border-radius: 8px;
+}
+
+/* Video player styles */
+.video-player {
+  width: 100%;
+  height: 100%;
+  object-fit: cover;
+  border-radius: 4px;
+}
+
+.video-container {
+  position: relative;
+  width: 100%;
+  height: 100%;
+  background: #000;
+  border-radius: 4px;
+  overflow: hidden;
+}
+
+.video-overlay {
+  position: absolute;
+  top: 0;
+  left: 0;
+  right: 0;
+  bottom: 0;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  background: rgba(0, 0, 0, 0.7);
+  color: white;
+  font-size: 14px;
+}
+
+/* Event severity colors */
+.severity-low {
+  color: #4caf50;
+}
+
+.severity-medium {
+  color: #ff9800;
+}
+
+.severity-high {
+  color: #f44336;
+}
+
+.severity-critical {
+  color: #d32f2f;
+  font-weight: bold;
+}
+
+/* Event status colors */
+.status-open {
+  color: #f44336;
+}
+
+.status-acknowledged {
+  color: #ff9800;
+}
+
+.status-investigating {
+  color: #2196f3;
+}
+
+.status-resolved {
+  color: #4caf50;
+}
+
+.status-closed {
+  color: #9e9e9e;
+}
+
+/* Loading spinner */
+.loading-spinner {
+  animation: spin 1s linear infinite;
+}
+
+@keyframes spin {
+  0% { transform: rotate(0deg); }
+  100% { transform: rotate(360deg); }
+}
+
+/* Responsive utilities */
+.hide-sm {
+  display: block;
+}
+
+@media (max-width: 600px) {
+  .hide-sm {
+    display: none;
+  }
+}
+
+.show-sm {
+  display: none;
+}
+
+@media (max-width: 600px) {
+  .show-sm {
+    display: block;
+  }
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/index.tsx b/event-monitoring-mvp/frontend/src/index.tsx
index 53c4f60..fe55493 100644
--- a/event-monitoring-mvp/frontend/src/index.tsx
+++ b/event-monitoring-mvp/frontend/src/index.tsx
@@ -1,77 +1,77 @@
-import React from 'react';
-import ReactDOM from 'react-dom/client';
-import { BrowserRouter } from 'react-router-dom';
-import { Provider } from 'react-redux';
-import { PersistGate } from 'redux-persist/integration/react';
-import { QueryClient, QueryClientProvider } from 'react-query';
-import { ThemeProvider, createTheme } from '@mui/material/styles';
-import CssBaseline from '@mui/material/CssBaseline';
-import { ToastContainer } from 'react-toastify';
-
-import App from './App';
-import { store, persistor } from './store/store';
-import 'react-toastify/dist/ReactToastify.css';
-import './index.css';
-
-// Create React Query client
-const queryClient = new QueryClient({
-  defaultOptions: {
-    queries: {
-      retry: 1,
-      refetchOnWindowFocus: false,
-      staleTime: 5 * 60 * 1000, // 5 minutes
-    },
-  },
-});
-
-// Create Material-UI theme
-const theme = createTheme({
-  palette: {
-    mode: 'light',
-    primary: {
-      main: '#1976d2',
-    },
-    secondary: {
-      main: '#dc004e',
-    },
-    background: {
-      default: '#f5f5f5',
-    },
-  },
-  typography: {
-    fontFamily: 'Roboto, Arial, sans-serif',
-  },
-});
-
-const root = ReactDOM.createRoot(
-  document.getElementById('root') as HTMLElement
-);
-
-root.render(
-  <React.StrictMode>
-    <Provider store={store}>
-      <PersistGate loading={<div>Loading...</div>} persistor={persistor}>
-        <QueryClientProvider client={queryClient}>
-          <ThemeProvider theme={theme}>
-            <CssBaseline />
-            <BrowserRouter>
-              <App />
-              <ToastContainer
-                position="top-right"
-                autoClose={5000}
-                hideProgressBar={false}
-                newestOnTop={false}
-                closeOnClick
-                rtl={false}
-                pauseOnFocusLoss
-                draggable
-                pauseOnHover
-                theme="light"
-              />
-            </BrowserRouter>
-          </ThemeProvider>
-        </QueryClientProvider>
-      </PersistGate>
-    </Provider>
-  </React.StrictMode>
+import React from 'react';
+import ReactDOM from 'react-dom/client';
+import { BrowserRouter } from 'react-router-dom';
+import { Provider } from 'react-redux';
+import { PersistGate } from 'redux-persist/integration/react';
+import { QueryClient, QueryClientProvider } from 'react-query';
+import { ThemeProvider, createTheme } from '@mui/material/styles';
+import CssBaseline from '@mui/material/CssBaseline';
+import { ToastContainer } from 'react-toastify';
+
+import App from './App';
+import { store, persistor } from './store/store';
+import 'react-toastify/dist/ReactToastify.css';
+import './index.css';
+
+// Create React Query client
+const queryClient = new QueryClient({
+  defaultOptions: {
+    queries: {
+      retry: 1,
+      refetchOnWindowFocus: false,
+      staleTime: 5 * 60 * 1000, // 5 minutes
+    },
+  },
+});
+
+// Create Material-UI theme
+const theme = createTheme({
+  palette: {
+    mode: 'light',
+    primary: {
+      main: '#1976d2',
+    },
+    secondary: {
+      main: '#dc004e',
+    },
+    background: {
+      default: '#f5f5f5',
+    },
+  },
+  typography: {
+    fontFamily: 'Roboto, Arial, sans-serif',
+  },
+});
+
+const root = ReactDOM.createRoot(
+  document.getElementById('root') as HTMLElement
+);
+
+root.render(
+  <React.StrictMode>
+    <Provider store={store}>
+      <PersistGate loading={<div>Loading...</div>} persistor={persistor}>
+        <QueryClientProvider client={queryClient}>
+          <ThemeProvider theme={theme}>
+            <CssBaseline />
+            <BrowserRouter>
+              <App />
+              <ToastContainer
+                position="top-right"
+                autoClose={5000}
+                hideProgressBar={false}
+                newestOnTop={false}
+                closeOnClick
+                rtl={false}
+                pauseOnFocusLoss
+                draggable
+                pauseOnHover
+                theme="light"
+              />
+            </BrowserRouter>
+          </ThemeProvider>
+        </QueryClientProvider>
+      </PersistGate>
+    </Provider>
+  </React.StrictMode>
 );
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/pages/AddCamera.tsx b/event-monitoring-mvp/frontend/src/pages/AddCamera.tsx
index 578998d..9bb39bd 100644
--- a/event-monitoring-mvp/frontend/src/pages/AddCamera.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/AddCamera.tsx
@@ -1,676 +1,1539 @@
-import React, { useState } from 'react';
-import {
-  Box,
-  Typography,
-  Paper,
-  Grid,
-  TextField,
-  Button,
-  MenuItem,
-  FormControl,
-  FormLabel,
-  RadioGroup,
-  FormControlLabel,
-  Radio,
-  Switch,
-  Alert,
-  Stepper,
-  Step,
-  StepLabel,
-  Card,
-  CardContent,
-  Divider,
-  IconButton,
-  Tooltip,
-} from '@mui/material';
-import {
-  ArrowBack as ArrowBackIcon,
-  Videocam as VideocamIcon,
-  LocationOn as LocationOnIcon,
-  Settings as SettingsIcon,
-  Cable as TestIcon,
-  Save as SaveIcon,
-  Map as MapIcon,
-} from '@mui/icons-material';
-import { useNavigate } from 'react-router-dom';
-import { useFormik } from 'formik';
-import * as yup from 'yup';
-import { toast } from 'react-toastify';
-import {
-  MapContainer,
-  TileLayer,
-  Marker,
-  Popup,
-} from 'react-leaflet';
-import L from 'leaflet';
-import 'leaflet/dist/leaflet.css';
-
-// Fix for default markers in react-leaflet
-delete (L.Icon.Default.prototype as any)._getIconUrl;
-L.Icon.Default.mergeOptions({
-  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
-  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
-  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
-});
-
-// Create custom camera preview icon
-const createCameraPreviewIcon = () => {
-  const svgIcon = `
-    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
-      <circle cx="20" cy="20" r="18" fill="#2196f3" stroke="white" stroke-width="3"/>
-      <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
-    </svg>
-  `;
-
-  return L.divIcon({
-    html: svgIcon,
-    className: 'custom-camera-preview-marker',
-    iconSize: [40, 40],
-    iconAnchor: [20, 20],
-  });
-};
-
-const steps = ['Basic Information', 'Connection Settings', 'Location & Configuration'];
-
-const validationSchema = yup.object({
-  name: yup
-    .string()
-    .required('Camera name is required')
-    .min(3, 'Name must be at least 3 characters')
-    .max(100, 'Name must be less than 100 characters'),
-  description: yup
-    .string()
-    .max(500, 'Description must be less than 500 characters'),
-  type: yup
-    .string()
-    .required('Camera type is required')
-    .oneOf(['ip', 'analog', 'usb'], 'Invalid camera type'),
-  streamUrl: yup
-    .string()
-    .required('Stream URL is required')
-    .matches(
-      /^(rtsp|rtmp|http|https):\/\/.+/,
-      'Stream URL must be a valid RTSP, RTMP, HTTP, or HTTPS URL'
-    ),
-  locationAddress: yup
-    .string()
-    .required('Location address is required'),
-  longitude: yup
-    .number()
-    .required('Longitude is required')
-    .min(-180, 'Longitude must be between -180 and 180')
-    .max(180, 'Longitude must be between -180 and 180'),
-  latitude: yup
-    .number()
-    .required('Latitude is required')
-    .min(-90, 'Latitude must be between -90 and 90')
-    .max(90, 'Latitude must be between -90 and 90'),
-  resolution: yup
-    .string()
-    .required('Resolution is required'),
-  fps: yup
-    .number()
-    .required('FPS is required')
-    .min(1, 'FPS must be at least 1')
-    .max(60, 'FPS must be at most 60'),
-});
-
+// import React, { useState } from 'react';
+// import {
+//   Box,
+//   Typography,
+//   Paper,
+//   Grid,
+//   TextField,
+//   Button,
+//   MenuItem,
+//   FormControl,
+//   FormLabel,
+//   RadioGroup,
+//   FormControlLabel,
+//   Radio,
+//   Switch,
+//   Alert,
+//   Stepper,
+//   Step,
+//   StepLabel,
+//   Card,
+//   CardContent,
+//   Divider,
+//   IconButton,
+//   Tooltip,
+// } from '@mui/material';
+// import {
+//   ArrowBack as ArrowBackIcon,
+//   Videocam as VideocamIcon,
+//   LocationOn as LocationOnIcon,
+//   Settings as SettingsIcon,
+//   Cable as TestIcon,
+//   Save as SaveIcon,
+//   Map as MapIcon,
+// } from '@mui/icons-material';
+// import { useNavigate } from 'react-router-dom';
+// import { useFormik } from 'formik';
+// import * as yup from 'yup';
+// import { toast } from 'react-toastify';
+// import { addCamera, CreateCameraData } from '../services/cameraService';
+// import {
+//   MapContainer,
+//   TileLayer,
+//   Marker,
+//   Popup,
+// } from 'react-leaflet';
+// import L from 'leaflet';
+// import 'leaflet/dist/leaflet.css';
+
+// // Fix for default markers in react-leaflet
+// delete (L.Icon.Default.prototype as any)._getIconUrl;
+// L.Icon.Default.mergeOptions({
+//   iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
+//   iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
+//   shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
+// });
+
+// // Create custom camera preview icon
+// const createCameraPreviewIcon = () => {
+//   // Helper to safely format coordinates
+//   const svgIcon = `
+//     <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
+//       <circle cx="20" cy="20" r="18" fill="#2196f3" stroke="white" stroke-width="3"/>
+//       <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
+//     </svg>
+//   `;
+
+//   return L.divIcon({
+//     html: svgIcon,
+//     className: 'custom-camera-preview-marker',
+//     iconSize: [40, 40],
+//     iconAnchor: [20, 20],
+//   });
+// };
+  
+// const formatCoord = (val: any) => {
+//     const num = Number(val);
+//      return isNaN(num) ? '0.000000' : num.toFixed(6);
+//   };
+
+// const steps = ['Basic Information', 'Connection Settings', 'Location & Configuration'];
+
+// const validationSchema = yup.object({
+//   name: yup
+//     .string()
+//     .required('Camera name is required')
+//     .min(3, 'Name must be at least 3 characters')
+//     .max(100, 'Name must be less than 100 characters'),
+//   description: yup
+//     .string()
+//     .max(500, 'Description must be less than 500 characters'),
+//   type: yup
+//     .string()
+//     .required('Camera type is required')
+//     .oneOf(['ip', 'analog', 'usb'], 'Invalid camera type'),
+//   streamUrl: yup
+//     .string()
+//     .required('Stream URL is required')
+//     .matches(
+//       /^(rtsp|rtmp|http|https):\/\/.+/,
+//       'Stream URL must be a valid RTSP, RTMP, HTTP, or HTTPS URL'
+//     ),
+//   locationAddress: yup
+//     .string()
+//     .required('Location address is required'),
+//   longitude: yup
+//     .number()
+//     .required('Longitude is required')
+//     .min(-180, 'Longitude must be between -180 and 180')
+//     .max(180, 'Longitude must be between -180 and 180'),
+//   latitude: yup
+//     .number()
+//     .required('Latitude is required')
+//     .min(-90, 'Latitude must be between -90 and 90')
+//     .max(90, 'Latitude must be between -90 and 90'),
+//   resolution: yup
+//     .string()
+//     .required('Resolution is required'),
+//   fps: yup
+//     .number()
+//     .required('FPS is required')
+//     .min(1, 'FPS must be at least 1')
+//     .max(60, 'FPS must be at most 60'),
+// });
+
+// const AddCamera: React.FC = () => {
+//   const navigate = useNavigate();
+//   const [activeStep, setActiveStep] = useState(0);
+//   const [testingConnection, setTestingConnection] = useState(false);
+//   const [connectionStatus, setConnectionStatus] = useState<'idle' | 'success' | 'error'>('idle');
+//   const [showMapPreview, setShowMapPreview] = useState(false);
+
+//   const formik = useFormik({
+//     initialValues: {
+//       name: '',
+//       description: '',
+//       type: 'ip',
+//       streamUrl: '',
+//       locationAddress: '',
+//       longitude: 0,
+//       latitude: 0,
+//       resolution: '1920x1080',
+//       fps: 30,
+//       recordingEnabled: false,
+//       motionDetection: true,
+//       nightVision: false,
+//       audioEnabled: false,
+//     },
+//     validationSchema,
+//     // FILE: frontend/src/pages/AddCamera.tsx
+//     onSubmit: async (values) => {
+//       try {
+//         console.log('Submitting camera data:', values);
+
+//         /**
+//          * 1. Transform form values into backend format
+//          * Backend expects:
+//          * location.coordinates = [longitude, latitude]
+//          * FPS and coordinates must be numbers
+//          */
+//         const payload: CreateCameraData = {
+//           name: values.name,
+//           description: values.description,
+//           type: values.type as 'ip' | 'analog' | 'usb',
+//           streamUrl: values.streamUrl,
+//           location: {
+//             coordinates: [
+//               Number(values.longitude),
+//               Number(values.latitude),
+//             ],
+//             address: values.locationAddress,
+//           },
+//           settings: {
+//             resolution: values.resolution,
+//             fps: Number(values.fps),
+//             recordingEnabled: values.recordingEnabled,
+//           },
+//         };
+
+//         /**
+//          * 2. Save camera to MongoDB via backend
+//          */
+//         await addCamera(payload);
+
+//         /**
+//          * 3. User feedback
+//          */
+//         toast.success('Camera saved to database successfully!');
+
+//         /**
+//          * 4. Navigate back to cameras list
+//          */
+//         navigate('/cameras');
+//       } catch (error: any) {
+//         /**
+//          * 5. Error handling
+//          */
+//         console.error('Submission failed', error);
+//         toast.error(error.message || 'Failed to add camera');
+//       }
+//     }
+//   });
+
+//   const handleNext = () => {
+//     setActiveStep((prev) => prev + 1);
+//   };
+
+//   const handleBack = () => {
+//     setActiveStep((prev) => prev - 1);
+//   };
+
+//   const handleTestConnection = async () => {
+//     if (!formik.values.streamUrl) {
+//       toast.error('Please enter a stream URL first');
+//       return;
+//     }
+
+//     setTestingConnection(true);
+//     setConnectionStatus('idle');
+    
+//     try {
+//       // TODO: Replace with actual connection test API call
+//       await new Promise(resolve => setTimeout(resolve, 2000));
+      
+//       // Mock test result - 70% chance of success
+//       const success = Math.random() > 0.3;
+      
+//       if (success) {
+//         setConnectionStatus('success');
+//         toast.success('Connection test successful!');
+//       } else {
+//         setConnectionStatus('error');
+//         toast.error('Connection test failed. Please check your URL and network settings.');
+//       }
+//     } catch (error) {
+//       setConnectionStatus('error');
+//       toast.error('Connection test failed');
+//     } finally {
+//       setTestingConnection(false);
+//     }
+//   };
+
+//   const getLocationFromAddress = async () => {
+//     if (!formik.values.locationAddress) {
+//       toast.error('Please enter an address first');
+//       return;
+//     }
+
+//     try {
+//       // Try to extract coordinates from URL if it looks like a Google Maps link
+//       if (formik.values.locationAddress.includes('google.com/maps') || 
+//           formik.values.locationAddress.includes('maps.app.goo.gl')) {
+//         const coords = extractCoordinatesFromUrl(formik.values.locationAddress);
+//         if (coords) {
+//           formik.setFieldValue('latitude', parseFloat(coords.lat.toFixed(6)));
+//           formik.setFieldValue('longitude', parseFloat(coords.lng.toFixed(6)));
+//           setShowMapPreview(true);
+//           toast.success('Coordinates extracted from Google Maps URL!');
+//           return;
+//         }
+//       }
+
+//       // TODO: Replace with actual geocoding API call (Google Maps, OpenStreetMap, etc.)
+//       // For now, using mock geocoding
+//       const mockCoordinates = {
+//         lat: 40.7128 + (Math.random() - 0.5) * 0.1,
+//         lng: -74.0060 + (Math.random() - 0.5) * 0.1,
+//       };
+
+//       formik.setFieldValue('latitude', parseFloat(mockCoordinates.lat.toFixed(6)));
+//       formik.setFieldValue('longitude', parseFloat(mockCoordinates.lng.toFixed(6)));
+      
+//       // Automatically show map preview when coordinates are obtained
+//       setShowMapPreview(true);
+      
+//       toast.success('Coordinates updated from address');
+//     } catch (error) {
+//       toast.error('Failed to get coordinates from address');
+//     }
+//   };
+
+//   // Extract coordinates from Google Maps URLs
+//   const extractCoordinatesFromUrl = (url: string): { lat: number; lng: number } | null => {
+//     try {
+//       // Handle different Google Maps URL formats
+      
+//       // Format 1: @lat,lng,zoom (most common)
+//       let match = url.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*),?\d*\.?\d*z?/);
+//       if (match) {
+//         return {
+//           lat: parseFloat(match[1]),
+//           lng: parseFloat(match[2])
+//         };
+//       }
+      
+//       // Format 2: ll=lat,lng
+//       match = url.match(/ll=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
+//       if (match) {
+//         return {
+//           lat: parseFloat(match[1]),
+//           lng: parseFloat(match[2])
+//         };
+//       }
+      
+//       // Format 3: q=lat,lng
+//       match = url.match(/q=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
+//       if (match) {
+//         return {
+//           lat: parseFloat(match[1]),
+//           lng: parseFloat(match[2])
+//         };
+//       }
+      
+//       // Format 4: destination=lat,lng
+//       match = url.match(/destination=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
+//       if (match) {
+//         return {
+//           lat: parseFloat(match[1]),
+//           lng: parseFloat(match[2])
+//         };
+//       }
+      
+//       // Format 5: center=lat,lng
+//       match = url.match(/center=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
+//       if (match) {
+//         return {
+//           lat: parseFloat(match[1]),
+//           lng: parseFloat(match[2])
+//         };
+//       }
+      
+//       return null;
+//     } catch (error) {
+//       console.error('Error extracting coordinates from URL:', error);
+//       return null;
+//     }
+//   };
+
+//   const renderStepContent = (step: number) => {
+//     switch (step) {
+//       case 0:
+//         return (
+//           <Grid container spacing={3}>
+//             <Grid item xs={12}>
+//               <Typography variant="h6" gutterBottom>
+//                 Basic Camera Information
+//               </Typography>
+//             </Grid>
+//             <Grid item xs={12} sm={6}>
+//               <TextField
+//                 fullWidth
+//                 id="name"
+//                 name="name"
+//                 label="Camera Name"
+//                 value={formik.values.name}
+//                 onChange={formik.handleChange}
+//                 onBlur={formik.handleBlur}
+//                 error={formik.touched.name && Boolean(formik.errors.name)}
+//                 helperText={formik.touched.name && formik.errors.name}
+//                 placeholder="e.g., Front Gate Camera"
+//               />
+//             </Grid>
+//             <Grid item xs={12} sm={6}>
+//               <FormControl component="fieldset" fullWidth>
+//                 <FormLabel component="legend">Camera Type</FormLabel>
+//                 <RadioGroup
+//                   name="type"
+//                   value={formik.values.type}
+//                   onChange={formik.handleChange}
+//                   row
+//                 >
+//                   <FormControlLabel value="ip" control={<Radio />} label="IP Camera" />
+//                   <FormControlLabel value="analog" control={<Radio />} label="Analog" />
+//                   <FormControlLabel value="usb" control={<Radio />} label="USB" />
+//                 </RadioGroup>
+//               </FormControl>
+//             </Grid>
+//             <Grid item xs={12}>
+//               <TextField
+//                 fullWidth
+//                 id="description"
+//                 name="description"
+//                 label="Description (Optional)"
+//                 multiline
+//                 rows={3}
+//                 value={formik.values.description}
+//                 onChange={formik.handleChange}
+//                 onBlur={formik.handleBlur}
+//                 error={formik.touched.description && Boolean(formik.errors.description)}
+//                 helperText={formik.touched.description && formik.errors.description}
+//                 placeholder="Describe the camera's purpose and coverage area..."
+//               />
+//             </Grid>
+//           </Grid>
+//         );
+
+//       case 1:
+//         return (
+//           <Grid container spacing={3}>
+//             <Grid item xs={12}>
+//               <Typography variant="h6" gutterBottom>
+//                 Connection Settings
+//               </Typography>
+//             </Grid>
+//             <Grid item xs={12}>
+//               <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-end' }}>
+//                 <TextField
+//                   fullWidth
+//                   id="streamUrl"
+//                   name="streamUrl"
+//                   label="Stream URL"
+//                   value={formik.values.streamUrl}
+//                   onChange={formik.handleChange}
+//                   onBlur={formik.handleBlur}
+//                   error={formik.touched.streamUrl && Boolean(formik.errors.streamUrl)}
+//                   helperText={formik.touched.streamUrl && formik.errors.streamUrl}
+//                   placeholder="rtsp://username:password@camera-ip:554/stream"
+//                 />
+//                 <Button
+//                   variant="outlined"
+//                   onClick={handleTestConnection}
+//                   disabled={testingConnection}
+//                   startIcon={<TestIcon />}
+//                   sx={{ minWidth: 140, height: 56 }}
+//                 >
+//                   {testingConnection ? 'Testing...' : 'Test'}
+//                 </Button>
+//               </Box>
+//               {connectionStatus === 'success' && (
+//                 <Alert severity="success" sx={{ mt: 1 }}>
+//                   Connection test successful! Camera stream is accessible.
+//                 </Alert>
+//               )}
+//               {connectionStatus === 'error' && (
+//                 <Alert severity="error" sx={{ mt: 1 }}>
+//                   Connection failed. Please check the URL, credentials, and network connectivity.
+//                 </Alert>
+//               )}
+//             </Grid>
+//             <Grid item xs={12}>
+//               <Card variant="outlined">
+//                 <CardContent>
+//                   <Typography variant="subtitle2" gutterBottom>
+//                     Common Stream URL Formats:
+//                   </Typography>
+//                   <Typography variant="body2" color="text.secondary">
+//                     â€¢ RTSP: rtsp://username:password@ip:port/path<br/>
+//                     â€¢ HTTP: http://ip:port/stream<br/>
+//                     â€¢ HTTPS: https://ip:port/stream<br/>
+//                     â€¢ RTMP: rtmp://ip:port/stream
+//                   </Typography>
+//                 </CardContent>
+//               </Card>
+//             </Grid>
+//           </Grid>
+//         );
+
+//       case 2:
+//         return (
+//           <Grid container spacing={3}>
+//             <Grid item xs={12}>
+//               <Typography variant="h6" gutterBottom>
+//                 Location & Configuration
+//               </Typography>
+//             </Grid>
+//             <Grid item xs={12}>
+//               <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-end' }}>
+//                 <TextField
+//                   fullWidth
+//                   id="locationAddress"
+//                   name="locationAddress"
+//                   label="Location Address or Google Maps URL"
+//                   value={formik.values.locationAddress}
+//                   onChange={formik.handleChange}
+//                   onBlur={formik.handleBlur}
+//                   error={formik.touched.locationAddress && Boolean(formik.errors.locationAddress)}
+//                   helperText={formik.touched.locationAddress && formik.errors.locationAddress || 
+//                     "Enter an address or paste a Google Maps URL for automatic coordinate extraction"}
+//                   placeholder="123 Main St, City, State OR https://maps.google.com/..."
+//                   multiline
+//                   rows={2}
+//                 />
+//                 <Button
+//                   variant="outlined"
+//                   onClick={getLocationFromAddress}
+//                   startIcon={<LocationOnIcon />}
+//                   sx={{ minWidth: 140, height: 56 }}
+//                 >
+//                   Get Coords
+//                 </Button>
+//               </Box>
+//             </Grid>
+            
+//             {/* Coordinate Input with Map Preview */}
+//             <Grid item xs={12}>
+//               <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
+//                 <Typography variant="subtitle2">
+//                   Camera Coordinates
+//                 </Typography>
+//                 <Button
+//                   variant="outlined"
+//                   startIcon={<MapIcon />}
+//                   onClick={() => setShowMapPreview(!showMapPreview)}
+//                   size="small"
+//                 >
+//                   {showMapPreview ? 'Hide' : 'Show'} Map Preview
+//                 </Button>
+//               </Box>
+//             </Grid>
+            
+//             <Grid item xs={6}>
+//               <TextField
+//                 fullWidth
+//                 id="latitude"
+//                 name="latitude"
+//                 label="Latitude"
+//                 type="number"
+//                 value={formik.values.latitude}
+//                 onChange={(e) => {
+//                   formik.handleChange(e);
+//                   if (formik.values.longitude !== 0) {
+//                     setShowMapPreview(true);
+//                   }
+//                 }}
+//                 onBlur={formik.handleBlur}
+//                 error={formik.touched.latitude && Boolean(formik.errors.latitude)}
+//                 helperText={formik.touched.latitude && formik.errors.latitude}
+//                 inputProps={{ step: 0.000001, min: -90, max: 90 }}
+//               />
+//             </Grid>
+//             <Grid item xs={6}>
+//               <TextField
+//                 fullWidth
+//                 id="longitude"
+//                 name="longitude"
+//                 label="Longitude"
+//                 type="number"
+//                 value={formik.values.longitude}
+//                 onChange={(e) => {
+//                   formik.handleChange(e);
+//                   if (formik.values.latitude !== 0) {
+//                     setShowMapPreview(true);
+//                   }
+//                 }}
+//                 onBlur={formik.handleBlur}
+//                 error={formik.touched.longitude && Boolean(formik.errors.longitude)}
+//                 helperText={formik.touched.longitude && formik.errors.longitude}
+//                 inputProps={{ step: 0.000001, min: -180, max: 180 }}
+//               />
+//             </Grid>
+
+//             {/* Interactive Map Preview */}
+//             {showMapPreview && formik.values.latitude !== 0 && formik.values.longitude !== 0 && (
+//               <Grid item xs={12}>
+//                 <Paper elevation={2} sx={{ p: 2 }}>
+//                   <Typography variant="subtitle2" gutterBottom>
+//                     Camera Location Preview
+//                   </Typography>
+//                   <Box sx={{ height: 300, borderRadius: 1, overflow: 'hidden' }}>
+//                     <MapContainer
+//                       center={[formik.values.latitude, formik.values.longitude]}
+//                       zoom={15}
+//                       scrollWheelZoom={false}
+//                       style={{ height: '100%', width: '100%' }}
+//                       key={`${formik.values.latitude}-${formik.values.longitude}`}
+//                     >
+//                       <TileLayer
+//                         attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+//                         url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
+//                       />
+//                       <Marker
+//                         position={[formik.values.latitude, formik.values.longitude]}
+//                         icon={createCameraPreviewIcon()}
+//                       >
+//                         <Popup>
+//                           <Box sx={{ minWidth: 200 }}>
+//                             <Typography variant="h6" gutterBottom>
+//                               <VideocamIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
+//                               {formik.values.name || 'New Camera'}
+//                             </Typography>
+//                             <Typography variant="body2" gutterBottom>
+//                               {formik.values.description || 'Camera location preview'}
+//                             </Typography>
+//                             <Typography variant="caption" display="block" gutterBottom>
+//                               ğŸ“ {formik.values.locationAddress || 'No address specified'}
+//                             </Typography>
+//                             <Typography variant="caption" display="block">
+//                               ğŸ“… Lat: {formatCoord(formik.values.latitude)}, Lng: {formatCoord(formik.values.longitude)}
+//                             </Typography>
+//                           </Box>
+//                         </Popup>
+//                       </Marker>
+//                     </MapContainer>
+//                   </Box>
+//                   <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
+//                     ğŸ’¡ This preview shows where your camera will appear on the main map
+//                   </Typography>
+//                 </Paper>
+//               </Grid>
+//             )}
+
+//             <Grid item xs={6}>
+//               <TextField
+//                 fullWidth
+//                 id="resolution"
+//                 name="resolution"
+//                 label="Resolution"
+//                 select
+//                 value={formik.values.resolution}
+//                 onChange={formik.handleChange}
+//               >
+//                 <MenuItem value="3840x2160">4K (3840x2160)</MenuItem>
+//                 <MenuItem value="1920x1080">Full HD (1920x1080)</MenuItem>
+//                 <MenuItem value="1280x720">HD (1280x720)</MenuItem>
+//                 <MenuItem value="640x480">SD (640x480)</MenuItem>
+//               </TextField>
+//             </Grid>
+//             <Grid item xs={6}>
+//               <TextField
+//                 fullWidth
+//                 id="fps"
+//                 name="fps"
+//                 label="Frame Rate (FPS)"
+//                 type="number"
+//                 value={formik.values.fps}
+//                 onChange={formik.handleChange}
+//                 onBlur={formik.handleBlur}
+//                 error={formik.touched.fps && Boolean(formik.errors.fps)}
+//                 helperText={formik.touched.fps && formik.errors.fps}
+//                 inputProps={{ min: 1, max: 60 }}
+//               />
+//             </Grid>
+//             <Grid item xs={12}>
+//               <Typography variant="subtitle2" gutterBottom>
+//                 Additional Features
+//               </Typography>
+//               <Grid container spacing={2}>
+//                 <Grid item xs={6} sm={3}>
+//                   <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+//                     <Typography variant="body2">Recording</Typography>
+//                     <Switch
+//                       checked={formik.values.recordingEnabled}
+//                       onChange={(e) => formik.setFieldValue('recordingEnabled', e.target.checked)}
+//                       name="recordingEnabled"
+//                     />
+//                   </Box>
+//                 </Grid>
+//                 <Grid item xs={6} sm={3}>
+//                   <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+//                     <Typography variant="body2">Motion Detection</Typography>
+//                     <Switch
+//                       checked={formik.values.motionDetection}
+//                       onChange={(e) => formik.setFieldValue('motionDetection', e.target.checked)}
+//                       name="motionDetection"
+//                     />
+//                   </Box>
+//                 </Grid>
+//                 <Grid item xs={6} sm={3}>
+//                   <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+//                     <Typography variant="body2">Night Vision</Typography>
+//                     <Switch
+//                       checked={formik.values.nightVision}
+//                       onChange={(e) => formik.setFieldValue('nightVision', e.target.checked)}
+//                       name="nightVision"
+//                     />
+//                   </Box>
+//                 </Grid>
+//                 <Grid item xs={6} sm={3}>
+//                   <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+//                     <Typography variant="body2">Audio</Typography>
+//                     <Switch
+//                       checked={formik.values.audioEnabled}
+//                       onChange={(e) => formik.setFieldValue('audioEnabled', e.target.checked)}
+//                       name="audioEnabled"
+//                     />
+//                   </Box>
+//                 </Grid>
+//               </Grid>
+//             </Grid>
+//           </Grid>
+//         );
+
+//       default:
+//         return 'Unknown step';
+//     }
+//   };
+
+//   return (
+//     <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto', p: 3 }}>
+//       <Box sx={{ mb: 3, display: 'flex', alignItems: 'center', gap: 2 }}>
+//         <Tooltip title="Back to Cameras">
+//           <IconButton onClick={() => navigate('/cameras')} color="primary">
+//             <ArrowBackIcon />
+//           </IconButton>
+//         </Tooltip>
+//         <VideocamIcon sx={{ fontSize: 32, color: 'primary.main' }} />
+//         <Typography variant="h4" component="h1">
+//           Add New Camera
+//         </Typography>
+//       </Box>
+
+//       <Paper sx={{ p: 3 }}>
+//         <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
+//           {steps.map((label) => (
+//             <Step key={label}>
+//               <StepLabel>{label}</StepLabel>
+//             </Step>
+//           ))}
+//         </Stepper>
+
+//         <Box component="form" onSubmit={formik.handleSubmit}>
+//           {renderStepContent(activeStep)}
+
+//           <Divider sx={{ my: 4 }} />
+
+//           <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
+//             <Button
+//               disabled={activeStep === 0}
+//               onClick={handleBack}
+//               variant="outlined"
+//             >
+//               Back
+//             </Button>
+//             <Box sx={{ display: 'flex', gap: 2 }}>
+//               <Button
+//                 variant="outlined"
+//                 onClick={() => navigate('/cameras')}
+//               >
+//                 Cancel
+//               </Button>
+//               {activeStep === steps.length - 1 ? (
+//                 <Button
+//                   type="submit"
+//                   variant="contained"
+//                   disabled={formik.isSubmitting}
+//                   startIcon={<SaveIcon />}
+//                 >
+//                   {formik.isSubmitting ? 'Adding Camera...' : 'Add Camera'}
+//                 </Button>
+//               ) : (
+//                 <Button
+//                   onClick={handleNext}
+//                   variant="contained"
+//                 >
+//                   Next
+//                 </Button>
+//               )}
+//             </Box>
+//           </Box>
+//         </Box>
+//       </Paper>
+//     </Box>
+//   );
+// };
+
+import React, { useEffect, useState } from 'react';
+import {
+  Box,
+  Typography,
+  Paper,
+  Grid,
+  TextField,
+  Button,
+  MenuItem,
+  FormControl,
+  FormLabel,
+  RadioGroup,
+  FormControlLabel,
+  Radio,
+  Switch,
+  Alert,
+  Stepper,
+  Step,
+  StepLabel,
+  Card,
+  CardContent,
+  Divider,
+  IconButton,
+  Tooltip,
+  CircularProgress,
+} from '@mui/material';
+import {
+  ArrowBack as ArrowBackIcon,
+  Videocam as VideocamIcon,
+  LocationOn as LocationOnIcon,
+  Settings as SettingsIcon,
+  Cable as TestIcon,
+  Save as SaveIcon,
+  Map as MapIcon,
+} from '@mui/icons-material';
+import { useNavigate } from 'react-router-dom';
+import { useFormik } from 'formik';
+import * as yup from 'yup';
+import { toast } from 'react-toastify';
+import { addCamera, CreateCameraData, getVmsServers, testCameraConnection, VmsServer } from '../services/cameraService';
+import {
+  MapContainer,
+  TileLayer,
+  Marker,
+  Popup,
+} from 'react-leaflet';
+import L from 'leaflet';
+import 'leaflet/dist/leaflet.css';
+
+// Fix for default markers in react-leaflet
+delete (L.Icon.Default.prototype as any)._getIconUrl;
+L.Icon.Default.mergeOptions({
+  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
+  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
+  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
+});
+
+// Create custom camera preview icon
+const createCameraPreviewIcon = () => {
+  const svgIcon = `
+    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
+      <circle cx="20" cy="20" r="18" fill="#2196f3" stroke="white" stroke-width="3"/>
+      <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
+    </svg>
+  `;
+
+  return L.divIcon({
+    html: svgIcon,
+    className: 'custom-camera-preview-marker',
+    iconSize: [40, 40],
+    iconAnchor: [20, 20],
+  });
+};
+
+// Helper to safely format coordinates
+const formatCoord = (val: any) => {
+  const num = Number(val);
+  return isNaN(num) ? '0.000000' : num.toFixed(6);
+};
+
+const steps = ['Basic Information', 'Connection Settings', 'Location & Configuration'];
+
+const validationSchema = yup.object({
+  name: yup
+    .string()
+    .required('Camera name is required')
+    .min(3, 'Name must be at least 3 characters')
+    .max(100, 'Name must be less than 100 characters'),
+  description: yup
+    .string()
+    .max(500, 'Description must be less than 500 characters'),
+  type: yup
+    .string()
+    .required('Camera type is required')
+    .oneOf(['ip', 'analog', 'usb'], 'Invalid camera type'),
+  streamUrl: yup
+    .string()
+    .required('Stream URL is required')
+    .matches(
+      /^(rtsp|rtmp|http|https):\/\/.+/,
+      'Stream URL must be a valid RTSP, RTMP, HTTP, or HTTPS URL'
+    ),
+  locationAddress: yup
+    .string()
+    .optional(),
+  longitude: yup
+    .number()
+    .required('Longitude is required')
+    .min(-180, 'Longitude must be between -180 and 180')
+    .max(180, 'Longitude must be between -180 and 180'),
+  latitude: yup
+    .number()
+    .required('Latitude is required')
+    .min(-90, 'Latitude must be between -90 and 90')
+    .max(90, 'Latitude must be between -90 and 90'),
+  resolution: yup
+    .string()
+    .required('Resolution is required'),
+  fps: yup
+    .number()
+    .required('FPS is required')
+    .min(1, 'FPS must be at least 1')
+    .max(60, 'FPS must be at most 60'),
+});
+
 const AddCamera: React.FC = () => {
   const navigate = useNavigate();
   const [activeStep, setActiveStep] = useState(0);
   const [testingConnection, setTestingConnection] = useState(false);
   const [connectionStatus, setConnectionStatus] = useState<'idle' | 'success' | 'error'>('idle');
   const [showMapPreview, setShowMapPreview] = useState(false);
-
-  const formik = useFormik({
-    initialValues: {
-      name: '',
-      description: '',
-      type: 'ip',
-      streamUrl: '',
-      locationAddress: '',
-      longitude: 0,
-      latitude: 0,
-      resolution: '1920x1080',
-      fps: 30,
-      recordingEnabled: false,
-      motionDetection: true,
-      nightVision: false,
-      audioEnabled: false,
-    },
-    validationSchema,
+  const [vmsServers, setVmsServers] = useState<VmsServer[]>([]);
+  const [vmsLoading, setVmsLoading] = useState(false);
+  const [testViaVms, setTestViaVms] = useState(false);
+  const [testVmsServerId, setTestVmsServerId] = useState('');
+  const [testMonitorId, setTestMonitorId] = useState('');
+
+  const formik = useFormik({
+    initialValues: {
+      name: '',
+      description: '',
+      type: 'ip',
+      streamUrl: '',
+      locationAddress: '',
+      longitude: 0,
+      latitude: 0,
+      resolution: '1920x1080',
+      fps: 30,
+      recordingEnabled: false,
+      motionDetection: true,
+      nightVision: false,
+      audioEnabled: false,
+    },
+    validationSchema,
     onSubmit: async (values) => {
+      // Guard: only allow submission on the final step to prevent auto-add.
+      if (activeStep !== steps.length - 1) {
+        toast.warning('Complete all steps before adding the camera.');
+        return;
+      }
+
       try {
-        // TODO: Replace with actual API call
         console.log('Submitting camera data:', values);
-        
-        // Mock API delay
-        await new Promise(resolve => setTimeout(resolve, 1000));
-        
-        toast.success('Camera added successfully!');
-        navigate('/cameras');
-      } catch (error: any) {
-        toast.error(error.message || 'Failed to add camera');
+
+        /**
+         * 1. Transform form values into backend format
+         * Backend expects:
+         * location.coordinates = [longitude, latitude]
+         * FPS and coordinates must be numbers
+         */
+        const payload: CreateCameraData = {
+          name: values.name,
+          description: values.description,
+          type: values.type as 'ip' | 'analog' | 'usb',
+          streamUrl: values.streamUrl,
+          location: {
+            coordinates: [
+              Number(values.longitude),
+              Number(values.latitude),
+            ],
+            address: values.locationAddress || 'Manual Coordinates',
+          },
+          settings: {
+            resolution: values.resolution,
+            fps: Number(values.fps),
+            recordingEnabled: values.recordingEnabled,
+          },
+        };
+
+        /**
+         * 2. Save camera to MongoDB via backend
+         */
+        await addCamera(payload);
+
+        /**
+         * 3. User feedback
+         */
+        toast.success('Camera saved to database successfully!');
+
+        /**
+         * 4. Navigate back to cameras list
+         */
+        navigate('/cameras');
+      } catch (error: any) {
+        /**
+         * 5. Error handling
+         */
+        console.error('Submission failed', error);
+        toast.error(error.message || 'Failed to add camera');
+      }
+    }
+  });
+
+  const handleNext = async () => {
+    // Validate Step 0: Basic Information
+    if (activeStep === 0) {
+      // Force "touched" state so errors appear visually
+      formik.setTouched({ name: true, type: true, description: true });
+      
+      const errors = await formik.validateForm();
+      if (errors.name || errors.type) {
+        toast.error("Please fill in all required fields.");
+        return;
+      }
+      setActiveStep((prev) => prev + 1);
+    } 
+    // Validate Step 1: Connection Settings
+    else if (activeStep === 1) {
+      formik.setTouched({ streamUrl: true });
+      const errors = await formik.validateForm();
+      
+      if (errors.streamUrl) {
+        toast.error("Please enter a valid Stream URL.");
+        return;
+      }
+      
+      if (connectionStatus !== 'success') {
+        toast.warning("You must successfully test the connection first.");
+        return;
+      }
+      setActiveStep((prev) => prev + 1);
+    } 
+    // Step 2: Location (No extra validation needed beyond Yup)
+    else {
+      setActiveStep((prev) => prev + 1);
+    }
+  };
+
+  const handleBack = () => {
+    setActiveStep((prev) => prev - 1);
+  };
+
+  // Fetch VMS servers for the VMS-based test flow.
+  const loadVmsServers = async () => {
+    try {
+      setVmsLoading(true);
+      const list = await getVmsServers();
+      setVmsServers(list);
+      if (!testVmsServerId && list.length > 0) {
+        setTestVmsServerId(list[0]._id);
       }
-    },
-  });
-
-  const handleNext = () => {
-    setActiveStep((prev) => prev + 1);
+    } catch (error) {
+      console.error('Error fetching VMS servers:', error);
+    } finally {
+      setVmsLoading(false);
+    }
   };
 
-  const handleBack = () => {
-    setActiveStep((prev) => prev - 1);
-  };
+  useEffect(() => {
+    // Fetch available VMS servers once for the test flow.
+    loadVmsServers();
+  }, []);
 
   const handleTestConnection = async () => {
     if (!formik.values.streamUrl) {
       toast.error('Please enter a stream URL first');
       return;
     }
+
+    setTestingConnection(true);
+    setConnectionStatus('idle');
+    
+    if (testViaVms) {
+      if (!testVmsServerId || !testMonitorId) {
+        toast.error('Select a VMS server and enter a Monitor ID');
+        setTestingConnection(false);
+        return;
+      }
+    }
 
-    setTestingConnection(true);
-    setConnectionStatus('idle');
-    
     try {
-      // TODO: Replace with actual connection test API call
-      await new Promise(resolve => setTimeout(resolve, 2000));
-      
-      // Mock test result - 70% chance of success
-      const success = Math.random() > 0.3;
-      
-      if (success) {
+      // Server-side reachability check so tests reflect real connectivity.
+      const result = await testCameraConnection({
+        streamUrl: formik.values.streamUrl,
+        mode: testViaVms ? 'vms' : 'rtsp',
+        vmsServerId: testViaVms ? testVmsServerId : undefined,
+        monitorId: testViaVms ? testMonitorId : undefined,
+      });
+
+      if (result.ok) {
         setConnectionStatus('success');
-        toast.success('Connection test successful!');
+        toast.success(result.message || 'Connection test successful!');
       } else {
         setConnectionStatus('error');
-        toast.error('Connection test failed. Please check your URL and network settings.');
+        toast.error(result.message || 'Connection test failed');
       }
-    } catch (error) {
+    } catch (error: any) {
       setConnectionStatus('error');
-      toast.error('Connection test failed');
+      toast.error(error.message || 'Connection test failed');
     } finally {
       setTestingConnection(false);
     }
   };
-
-  const getLocationFromAddress = async () => {
-    if (!formik.values.locationAddress) {
-      toast.error('Please enter an address first');
-      return;
-    }
-
+
+  const getLocationFromAddress = async () => {
+    if (!formik.values.locationAddress) {
+      toast.error('Please enter an address first');
+      return;
+    }
+
     try {
-      // Try to extract coordinates from URL if it looks like a Google Maps link
-      if (formik.values.locationAddress.includes('google.com/maps') || 
-          formik.values.locationAddress.includes('maps.app.goo.gl')) {
-        const coords = extractCoordinatesFromUrl(formik.values.locationAddress);
-        if (coords) {
-          formik.setFieldValue('latitude', parseFloat(coords.lat.toFixed(6)));
-          formik.setFieldValue('longitude', parseFloat(coords.lng.toFixed(6)));
-          setShowMapPreview(true);
-          toast.success('Coordinates extracted from Google Maps URL!');
-          return;
-        }
-      }
-
       // TODO: Replace with actual geocoding API call (Google Maps, OpenStreetMap, etc.)
-      // For now, using mock geocoding
+      // TEST-ONLY: Use mock coordinates to keep the flow working without a geocoder.
       const mockCoordinates = {
         lat: 40.7128 + (Math.random() - 0.5) * 0.1,
         lng: -74.0060 + (Math.random() - 0.5) * 0.1,
       };
-
-      formik.setFieldValue('latitude', parseFloat(mockCoordinates.lat.toFixed(6)));
-      formik.setFieldValue('longitude', parseFloat(mockCoordinates.lng.toFixed(6)));
-      
-      // Automatically show map preview when coordinates are obtained
-      setShowMapPreview(true);
-      
-      toast.success('Coordinates updated from address');
-    } catch (error) {
-      toast.error('Failed to get coordinates from address');
-    }
-  };
-
-  // Extract coordinates from Google Maps URLs
-  const extractCoordinatesFromUrl = (url: string): { lat: number; lng: number } | null => {
-    try {
-      // Handle different Google Maps URL formats
-      
-      // Format 1: @lat,lng,zoom (most common)
-      let match = url.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*),?\d*\.?\d*z?/);
-      if (match) {
-        return {
-          lat: parseFloat(match[1]),
-          lng: parseFloat(match[2])
-        };
-      }
-      
-      // Format 2: ll=lat,lng
-      match = url.match(/ll=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
-      if (match) {
-        return {
-          lat: parseFloat(match[1]),
-          lng: parseFloat(match[2])
-        };
-      }
-      
-      // Format 3: q=lat,lng
-      match = url.match(/q=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
-      if (match) {
-        return {
-          lat: parseFloat(match[1]),
-          lng: parseFloat(match[2])
-        };
-      }
-      
-      // Format 4: destination=lat,lng
-      match = url.match(/destination=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
-      if (match) {
-        return {
-          lat: parseFloat(match[1]),
-          lng: parseFloat(match[2])
-        };
-      }
-      
-      // Format 5: center=lat,lng
-      match = url.match(/center=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
-      if (match) {
-        return {
-          lat: parseFloat(match[1]),
-          lng: parseFloat(match[2])
-        };
-      }
-      
-      return null;
-    } catch (error) {
-      console.error('Error extracting coordinates from URL:', error);
-      return null;
-    }
-  };
-
-  const renderStepContent = (step: number) => {
-    switch (step) {
-      case 0:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Basic Camera Information
-              </Typography>
-            </Grid>
-            <Grid item xs={12} sm={6}>
-              <TextField
-                fullWidth
-                id="name"
-                name="name"
-                label="Camera Name"
-                value={formik.values.name}
-                onChange={formik.handleChange}
-                onBlur={formik.handleBlur}
-                error={formik.touched.name && Boolean(formik.errors.name)}
-                helperText={formik.touched.name && formik.errors.name}
-                placeholder="e.g., Front Gate Camera"
-              />
-            </Grid>
-            <Grid item xs={12} sm={6}>
-              <FormControl component="fieldset" fullWidth>
-                <FormLabel component="legend">Camera Type</FormLabel>
-                <RadioGroup
-                  name="type"
-                  value={formik.values.type}
-                  onChange={formik.handleChange}
-                  row
-                >
-                  <FormControlLabel value="ip" control={<Radio />} label="IP Camera" />
-                  <FormControlLabel value="analog" control={<Radio />} label="Analog" />
-                  <FormControlLabel value="usb" control={<Radio />} label="USB" />
-                </RadioGroup>
-              </FormControl>
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                id="description"
-                name="description"
-                label="Description (Optional)"
-                multiline
-                rows={3}
-                value={formik.values.description}
-                onChange={formik.handleChange}
-                onBlur={formik.handleBlur}
-                error={formik.touched.description && Boolean(formik.errors.description)}
-                helperText={formik.touched.description && formik.errors.description}
-                placeholder="Describe the camera's purpose and coverage area..."
-              />
-            </Grid>
-          </Grid>
-        );
-
-      case 1:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Connection Settings
-              </Typography>
-            </Grid>
-            <Grid item xs={12}>
-              <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-end' }}>
-                <TextField
-                  fullWidth
-                  id="streamUrl"
-                  name="streamUrl"
-                  label="Stream URL"
-                  value={formik.values.streamUrl}
-                  onChange={formik.handleChange}
-                  onBlur={formik.handleBlur}
-                  error={formik.touched.streamUrl && Boolean(formik.errors.streamUrl)}
-                  helperText={formik.touched.streamUrl && formik.errors.streamUrl}
-                  placeholder="rtsp://username:password@camera-ip:554/stream"
-                />
+
+      formik.setFieldValue('latitude', parseFloat(mockCoordinates.lat.toFixed(6)));
+      formik.setFieldValue('longitude', parseFloat(mockCoordinates.lng.toFixed(6)));
+      
+      // Automatically show map preview when coordinates are obtained
+      setShowMapPreview(true);
+      
+      toast.success('Coordinates updated from address');
+    } catch (error) {
+      toast.error('Failed to get coordinates from address');
+    }
+  };
+
+  const renderStepContent = (step: number) => {
+    switch (step) {
+      case 0:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Basic Camera Information
+              </Typography>
+            </Grid>
+            <Grid item xs={12} sm={6}>
+              <TextField
+                fullWidth
+                id="name"
+                name="name"
+                label="Camera Name"
+                value={formik.values.name}
+                onChange={formik.handleChange}
+                onBlur={formik.handleBlur}
+                error={formik.touched.name && Boolean(formik.errors.name)}
+                helperText={formik.touched.name && formik.errors.name}
+                placeholder="e.g., Front Gate Camera"
+              />
+            </Grid>
+            <Grid item xs={12} sm={6}>
+              <FormControl component="fieldset" fullWidth>
+                <FormLabel component="legend">Camera Type</FormLabel>
+                <RadioGroup
+                  name="type"
+                  value={formik.values.type}
+                  onChange={formik.handleChange}
+                  row
+                >
+                  <FormControlLabel value="ip" control={<Radio />} label="IP Camera" />
+                  <FormControlLabel value="analog" control={<Radio />} label="Analog" />
+                  <FormControlLabel value="usb" control={<Radio />} label="USB" />
+                </RadioGroup>
+              </FormControl>
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                id="description"
+                name="description"
+                label="Description (Optional)"
+                multiline
+                rows={3}
+                value={formik.values.description}
+                onChange={formik.handleChange}
+                onBlur={formik.handleBlur}
+                error={formik.touched.description && Boolean(formik.errors.description)}
+                helperText={formik.touched.description && formik.errors.description}
+                placeholder="Describe the camera's purpose and coverage area..."
+              />
+            </Grid>
+          </Grid>
+        );
+
+      case 1:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Connection Settings
+              </Typography>
+            </Grid>
+            <Grid item xs={12}>
+              <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-start' }}>
+                <TextField
+                  fullWidth
+                  id="streamUrl"
+                  name="streamUrl"
+                  label="Stream URL"
+                  value={formik.values.streamUrl}
+                  onChange={(e) => {
+                    formik.handleChange(e);
+                    // Reset connection status when user edits the URL
+                    if (connectionStatus !== 'idle') {
+                      setConnectionStatus('idle');
+                    }
+                  }}
+                  onBlur={formik.handleBlur}
+                  error={formik.touched.streamUrl && Boolean(formik.errors.streamUrl)}
+                  helperText={formik.touched.streamUrl && formik.errors.streamUrl}
+                  placeholder="rtsp://username:password@camera-ip:554/stream"
+                />
                 <Button
                   variant="outlined"
                   onClick={handleTestConnection}
                   disabled={testingConnection}
                   startIcon={<TestIcon />}
+                  type="button" // Prevent form submit while testing
                   sx={{ minWidth: 140, height: 56 }}
                 >
-                  {testingConnection ? 'Testing...' : 'Test'}
-                </Button>
-              </Box>
-              {connectionStatus === 'success' && (
-                <Alert severity="success" sx={{ mt: 1 }}>
-                  Connection test successful! Camera stream is accessible.
-                </Alert>
-              )}
-              {connectionStatus === 'error' && (
-                <Alert severity="error" sx={{ mt: 1 }}>
-                  Connection failed. Please check the URL, credentials, and network connectivity.
-                </Alert>
-              )}
-            </Grid>
-            <Grid item xs={12}>
+                  {testingConnection ? <CircularProgress size={24} /> : 'Test'}
+                </Button>
+              </Box>
+              {connectionStatus === 'success' && (
+                <Alert severity="success" sx={{ mt: 1 }}>
+                  Connection test successful! Camera stream is accessible.
+                </Alert>
+              )}
+              {connectionStatus === 'error' && (
+                <Alert severity="error" sx={{ mt: 1 }}>
+                  Connection failed. Please check the URL, credentials, and network connectivity.
+                </Alert>
+              )}
+            </Grid>
+            <Grid item xs={12}>
               <Card variant="outlined">
                 <CardContent>
-                  <Typography variant="subtitle2" gutterBottom>
-                    Common Stream URL Formats:
-                  </Typography>
-                  <Typography variant="body2" color="text.secondary">
-                    â€¢ RTSP: rtsp://username:password@ip:port/path<br/>
-                    â€¢ HTTP: http://ip:port/stream<br/>
-                    â€¢ HTTPS: https://ip:port/stream<br/>
-                    â€¢ RTMP: rtmp://ip:port/stream
-                  </Typography>
+                  <Typography variant="subtitle2" gutterBottom>
+                    Common Stream URL Formats:
+                  </Typography>
+                  <Typography variant="body2" color="text.secondary">
+                    â€¢ RTSP: rtsp://username:password@ip:port/path<br/>
+                    â€¢ HTTP: http://ip:port/stream<br/>
+                    â€¢ HTTPS: https://ip:port/stream<br/>
+                    â€¢ RTMP: rtmp://ip:port/stream
+                  </Typography>
                 </CardContent>
               </Card>
             </Grid>
-          </Grid>
-        );
-
-      case 2:
-        return (
-          <Grid container spacing={3}>
             <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Location & Configuration
-              </Typography>
-            </Grid>
-            <Grid item xs={12}>
-              <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-end' }}>
-                <TextField
-                  fullWidth
-                  id="locationAddress"
-                  name="locationAddress"
-                  label="Location Address or Google Maps URL"
-                  value={formik.values.locationAddress}
-                  onChange={formik.handleChange}
-                  onBlur={formik.handleBlur}
-                  error={formik.touched.locationAddress && Boolean(formik.errors.locationAddress)}
-                  helperText={formik.touched.locationAddress && formik.errors.locationAddress || 
-                    "Enter an address or paste a Google Maps URL for automatic coordinate extraction"}
-                  placeholder="123 Main St, City, State OR https://maps.google.com/..."
-                  multiline
-                  rows={2}
-                />
-                <Button
-                  variant="outlined"
-                  onClick={getLocationFromAddress}
-                  startIcon={<LocationOnIcon />}
-                  sx={{ minWidth: 140, height: 56 }}
-                >
-                  Get Coords
-                </Button>
-              </Box>
-            </Grid>
-            
-            {/* Coordinate Input with Map Preview */}
-            <Grid item xs={12}>
-              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
-                <Typography variant="subtitle2">
-                  Camera Coordinates
-                </Typography>
-                <Button
-                  variant="outlined"
-                  startIcon={<MapIcon />}
-                  onClick={() => setShowMapPreview(!showMapPreview)}
-                  size="small"
-                >
-                  {showMapPreview ? 'Hide' : 'Show'} Map Preview
-                </Button>
-              </Box>
-            </Grid>
-            
-            <Grid item xs={6}>
-              <TextField
-                fullWidth
-                id="latitude"
-                name="latitude"
-                label="Latitude"
-                type="number"
-                value={formik.values.latitude}
-                onChange={(e) => {
-                  formik.handleChange(e);
-                  if (formik.values.longitude !== 0) {
-                    setShowMapPreview(true);
-                  }
-                }}
-                onBlur={formik.handleBlur}
-                error={formik.touched.latitude && Boolean(formik.errors.latitude)}
-                helperText={formik.touched.latitude && formik.errors.latitude}
-                inputProps={{ step: 0.000001, min: -90, max: 90 }}
-              />
-            </Grid>
-            <Grid item xs={6}>
-              <TextField
-                fullWidth
-                id="longitude"
-                name="longitude"
-                label="Longitude"
-                type="number"
-                value={formik.values.longitude}
-                onChange={(e) => {
-                  formik.handleChange(e);
-                  if (formik.values.latitude !== 0) {
-                    setShowMapPreview(true);
-                  }
-                }}
-                onBlur={formik.handleBlur}
-                error={formik.touched.longitude && Boolean(formik.errors.longitude)}
-                helperText={formik.touched.longitude && formik.errors.longitude}
-                inputProps={{ step: 0.000001, min: -180, max: 180 }}
-              />
-            </Grid>
-
-            {/* Interactive Map Preview */}
-            {showMapPreview && formik.values.latitude !== 0 && formik.values.longitude !== 0 && (
-              <Grid item xs={12}>
-                <Paper elevation={2} sx={{ p: 2 }}>
-                  <Typography variant="subtitle2" gutterBottom>
-                    Camera Location Preview
-                  </Typography>
-                  <Box sx={{ height: 300, borderRadius: 1, overflow: 'hidden' }}>
-                    <MapContainer
-                      center={[formik.values.latitude, formik.values.longitude]}
-                      zoom={15}
-                      style={{ height: '100%', width: '100%' }}
-                      key={`${formik.values.latitude}-${formik.values.longitude}`}
-                    >
-                      <TileLayer
-                        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
-                        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
-                      />
-                      <Marker
-                        position={[formik.values.latitude, formik.values.longitude]}
-                        icon={createCameraPreviewIcon()}
-                      >
-                        <Popup>
-                          <Box sx={{ minWidth: 200 }}>
-                            <Typography variant="h6" gutterBottom>
-                              <VideocamIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
-                              {formik.values.name || 'New Camera'}
-                            </Typography>
-                            <Typography variant="body2" gutterBottom>
-                              {formik.values.description || 'Camera location preview'}
-                            </Typography>
-                            <Typography variant="caption" display="block" gutterBottom>
-                              ğŸ“ {formik.values.locationAddress || 'No address specified'}
-                            </Typography>
-                            <Typography variant="caption" display="block">
-                              ğŸ“… Lat: {formik.values.latitude.toFixed(6)}, Lng: {formik.values.longitude.toFixed(6)}
-                            </Typography>
-                          </Box>
-                        </Popup>
-                      </Marker>
-                    </MapContainer>
-                  </Box>
-                  <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
-                    ğŸ’¡ This preview shows where your camera will appear on the main map
-                  </Typography>
-                </Paper>
-              </Grid>
-            )}
-
-            <Grid item xs={6}>
-              <TextField
-                fullWidth
-                id="resolution"
-                name="resolution"
-                label="Resolution"
-                select
-                value={formik.values.resolution}
-                onChange={formik.handleChange}
-              >
-                <MenuItem value="3840x2160">4K (3840x2160)</MenuItem>
-                <MenuItem value="1920x1080">Full HD (1920x1080)</MenuItem>
-                <MenuItem value="1280x720">HD (1280x720)</MenuItem>
-                <MenuItem value="640x480">SD (640x480)</MenuItem>
-              </TextField>
-            </Grid>
-            <Grid item xs={6}>
-              <TextField
-                fullWidth
-                id="fps"
-                name="fps"
-                label="Frame Rate (FPS)"
-                type="number"
-                value={formik.values.fps}
-                onChange={formik.handleChange}
-                onBlur={formik.handleBlur}
-                error={formik.touched.fps && Boolean(formik.errors.fps)}
-                helperText={formik.touched.fps && formik.errors.fps}
-                inputProps={{ min: 1, max: 60 }}
+              {/* TEST-ONLY: Toggle between direct RTSP test and VMS (Shinobi) reachability. */}
+              <FormControlLabel
+                control={
+                  <Switch
+                    checked={testViaVms}
+                    onChange={(e) => setTestViaVms(e.target.checked)}
+                  />
+                }
+                label="Test via VMS (Shinobi)"
               />
             </Grid>
-            <Grid item xs={12}>
-              <Typography variant="subtitle2" gutterBottom>
-                Additional Features
-              </Typography>
-              <Grid container spacing={2}>
-                <Grid item xs={6} sm={3}>
-                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
-                    <Typography variant="body2">Recording</Typography>
-                    <Switch
-                      checked={formik.values.recordingEnabled}
-                      onChange={(e) => formik.setFieldValue('recordingEnabled', e.target.checked)}
-                      name="recordingEnabled"
-                    />
-                  </Box>
+            {testViaVms && (
+              <>
+                <Grid item xs={12} sm={6}>
+                  <TextField
+                    select
+                    fullWidth
+                    label="VMS Server"
+                    value={testVmsServerId}
+                    onChange={(e) => setTestVmsServerId(e.target.value)}
+                    helperText={
+                      vmsLoading
+                        ? 'Loading VMS servers...'
+                        : vmsServers.length
+                          ? 'Choose the Shinobi server'
+                          : 'No VMS servers found'
+                    }
+                  >
+                    {vmsServers.map((server) => (
+                      <MenuItem key={server._id} value={server._id}>
+                        {server.name} ({server.provider})
+                      </MenuItem>
+                    ))}
+                  </TextField>
                 </Grid>
-                <Grid item xs={6} sm={3}>
-                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
-                    <Typography variant="body2">Motion Detection</Typography>
-                    <Switch
-                      checked={formik.values.motionDetection}
-                      onChange={(e) => formik.setFieldValue('motionDetection', e.target.checked)}
-                      name="motionDetection"
-                    />
-                  </Box>
+                <Grid item xs={12} sm={6}>
+                  <TextField
+                    fullWidth
+                    label="Monitor ID"
+                    value={testMonitorId}
+                    onChange={(e) => setTestMonitorId(e.target.value)}
+                    placeholder="e.g. demo-monitor-1"
+                  />
                 </Grid>
-                <Grid item xs={6} sm={3}>
-                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
-                    <Typography variant="body2">Night Vision</Typography>
-                    <Switch
-                      checked={formik.values.nightVision}
-                      onChange={(e) => formik.setFieldValue('nightVision', e.target.checked)}
-                      name="nightVision"
-                    />
-                  </Box>
+                <Grid item xs={12}>
+                  <Button variant="outlined" onClick={loadVmsServers} type="button">
+                    Refresh VMS Servers
+                  </Button>
                 </Grid>
-                <Grid item xs={6} sm={3}>
-                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
-                    <Typography variant="body2">Audio</Typography>
-                    <Switch
-                      checked={formik.values.audioEnabled}
-                      onChange={(e) => formik.setFieldValue('audioEnabled', e.target.checked)}
-                      name="audioEnabled"
-                    />
-                  </Box>
-                </Grid>
-              </Grid>
-            </Grid>
+              </>
+            )}
           </Grid>
         );
-
-      default:
-        return 'Unknown step';
-    }
-  };
-
-  return (
-    <Box>
-      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center', gap: 2 }}>
-        <Tooltip title="Back to Cameras">
-          <IconButton onClick={() => navigate('/cameras')} color="primary">
-            <ArrowBackIcon />
-          </IconButton>
-        </Tooltip>
-        <VideocamIcon sx={{ fontSize: 32, color: 'primary.main' }} />
-        <Typography variant="h4" component="h1">
-          Add New Camera
-        </Typography>
-      </Box>
-
-      <Paper sx={{ p: 3 }}>
-        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
-          {steps.map((label) => (
-            <Step key={label}>
-              <StepLabel>{label}</StepLabel>
-            </Step>
-          ))}
-        </Stepper>
-
-        <Box component="form" onSubmit={formik.handleSubmit}>
-          {renderStepContent(activeStep)}
-
-          <Divider sx={{ my: 4 }} />
-
-          <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
+
+      case 2:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Location & Configuration
+              </Typography>
+            </Grid>
+            <Grid item xs={12}>
+              <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-end' }}>
+                <TextField
+                  fullWidth
+                  id="locationAddress"
+                  name="locationAddress"
+                  label="Location Address or Google Maps URL"
+                  value={formik.values.locationAddress}
+                  onChange={formik.handleChange}
+                  onBlur={formik.handleBlur}
+                  error={formik.touched.locationAddress && Boolean(formik.errors.locationAddress)}
+                  helperText={formik.touched.locationAddress && formik.errors.locationAddress || 
+                    "Enter an address or paste a Google Maps URL for automatic coordinate extraction"}
+                  placeholder="123 Main St, City, State OR https://maps.google.com/..."
+                  multiline
+                  rows={2}
+                />
+                <Button
+                  variant="outlined"
+                  onClick={getLocationFromAddress}
+                  startIcon={<LocationOnIcon />}
+                  sx={{ minWidth: 140, height: 56 }}
+                >
+                  Get Coords
+                </Button>
+              </Box>
+            </Grid>
+            
+            {/* Coordinate Input with Map Preview */}
+            <Grid item xs={12}>
+              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
+                <Typography variant="subtitle2">
+                  Camera Coordinates
+                </Typography>
+                <Button
+                  variant="outlined"
+                  startIcon={<MapIcon />}
+                  onClick={() => setShowMapPreview(!showMapPreview)}
+                  size="small"
+                >
+                  {showMapPreview ? 'Hide' : 'Show'} Map Preview
+                </Button>
+              </Box>
+            </Grid>
+            
+            <Grid item xs={6}>
+              <TextField
+                fullWidth
+                id="latitude"
+                name="latitude"
+                label="Latitude"
+                type="number"
+                value={formik.values.latitude}
+                onChange={(e) => {
+                  formik.handleChange(e);
+                  if (formik.values.longitude !== 0) {
+                    setShowMapPreview(true);
+                  }
+                }}
+                onBlur={formik.handleBlur}
+                error={formik.touched.latitude && Boolean(formik.errors.latitude)}
+                helperText={formik.touched.latitude && formik.errors.latitude}
+                inputProps={{ step: 0.000001, min: -90, max: 90 }}
+              />
+            </Grid>
+            <Grid item xs={6}>
+              <TextField
+                fullWidth
+                id="longitude"
+                name="longitude"
+                label="Longitude"
+                type="number"
+                value={formik.values.longitude}
+                onChange={(e) => {
+                  formik.handleChange(e);
+                  if (formik.values.latitude !== 0) {
+                    setShowMapPreview(true);
+                  }
+                }}
+                onBlur={formik.handleBlur}
+                error={formik.touched.longitude && Boolean(formik.errors.longitude)}
+                helperText={formik.touched.longitude && formik.errors.longitude}
+                inputProps={{ step: 0.000001, min: -180, max: 180 }}
+              />
+            </Grid>
+
+            {/* Interactive Map Preview */}
+            {showMapPreview && formik.values.latitude !== 0 && formik.values.longitude !== 0 && (
+              <Grid item xs={12}>
+                <Paper elevation={2} sx={{ p: 2 }}>
+                  <Typography variant="subtitle2" gutterBottom>
+                    Camera Location Preview
+                  </Typography>
+                  <Box sx={{ height: 300, borderRadius: 1, overflow: 'hidden' }}>
+                    <MapContainer
+                      center={[formik.values.latitude, formik.values.longitude]}
+                      zoom={15}
+                      scrollWheelZoom={false}
+                      style={{ height: '100%', width: '100%' }}
+                      key={`${formik.values.latitude}-${formik.values.longitude}`}
+                    >
+                      <TileLayer
+                        attribution='Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+                        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
+                      />
+                      <Marker
+                        position={[formik.values.latitude, formik.values.longitude]}
+                        icon={createCameraPreviewIcon()}
+                      >
+                        <Popup>
+                          <Box sx={{ minWidth: 200 }}>
+                            <Typography variant="h6" gutterBottom>
+                              <VideocamIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
+                              {formik.values.name || 'New Camera'}
+                            </Typography>
+                            <Typography variant="body2" gutterBottom>
+                              {formik.values.description || 'Camera location preview'}
+                            </Typography>
+                            <Typography variant="caption" display="block" gutterBottom>
+                              ğŸ“ {formik.values.locationAddress || 'No address specified'}
+                            </Typography>
+                            <Typography variant="caption" display="block">
+                              ğŸ“… Lat: {formatCoord(formik.values.latitude)}, Lng: {formatCoord(formik.values.longitude)}
+                            </Typography>
+                          </Box>
+                        </Popup>
+                      </Marker>
+                    </MapContainer>
+                  </Box>
+                  <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
+                    ğŸ’¡ This preview shows where your camera will appear on the main map
+                  </Typography>
+                </Paper>
+              </Grid>
+            )}
+
+            <Grid item xs={6}>
+              <TextField
+                fullWidth
+                id="resolution"
+                name="resolution"
+                label="Resolution"
+                select
+                value={formik.values.resolution}
+                onChange={formik.handleChange}
+              >
+                <MenuItem value="3840x2160">4K (3840x2160)</MenuItem>
+                <MenuItem value="1920x1080">Full HD (1920x1080)</MenuItem>
+                <MenuItem value="1280x720">HD (1280x720)</MenuItem>
+                <MenuItem value="640x480">SD (640x480)</MenuItem>
+              </TextField>
+            </Grid>
+            <Grid item xs={6}>
+              <TextField
+                fullWidth
+                id="fps"
+                name="fps"
+                label="Frame Rate (FPS)"
+                type="number"
+                value={formik.values.fps}
+                onChange={formik.handleChange}
+                onBlur={formik.handleBlur}
+                error={formik.touched.fps && Boolean(formik.errors.fps)}
+                helperText={formik.touched.fps && formik.errors.fps}
+                inputProps={{ min: 1, max: 60 }}
+              />
+            </Grid>
+            <Grid item xs={12}>
+              <Typography variant="subtitle2" gutterBottom>
+                Additional Features
+              </Typography>
+              <Grid container spacing={2}>
+                <Grid item xs={6} sm={3}>
+                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+                    <Typography variant="body2">Recording</Typography>
+                    <Switch
+                      checked={formik.values.recordingEnabled}
+                      onChange={(e) => formik.setFieldValue('recordingEnabled', e.target.checked)}
+                      name="recordingEnabled"
+                    />
+                  </Box>
+                </Grid>
+                <Grid item xs={6} sm={3}>
+                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+                    <Typography variant="body2">Motion Detection</Typography>
+                    <Switch
+                      checked={formik.values.motionDetection}
+                      onChange={(e) => formik.setFieldValue('motionDetection', e.target.checked)}
+                      name="motionDetection"
+                    />
+                  </Box>
+                </Grid>
+                <Grid item xs={6} sm={3}>
+                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+                    <Typography variant="body2">Night Vision</Typography>
+                    <Switch
+                      checked={formik.values.nightVision}
+                      onChange={(e) => formik.setFieldValue('nightVision', e.target.checked)}
+                      name="nightVision"
+                    />
+                  </Box>
+                </Grid>
+                <Grid item xs={6} sm={3}>
+                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
+                    <Typography variant="body2">Audio</Typography>
+                    <Switch
+                      checked={formik.values.audioEnabled}
+                      onChange={(e) => formik.setFieldValue('audioEnabled', e.target.checked)}
+                      name="audioEnabled"
+                    />
+                  </Box>
+                </Grid>
+              </Grid>
+            </Grid>
+          </Grid>
+        );
+
+      default:
+        return 'Unknown step';
+    }
+  };
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto', p: 3 }}>
+      <Box sx={{ mb: 3, display: 'flex', alignItems: 'center', gap: 2 }}>
+        <Tooltip title="Back to Cameras">
+          <IconButton onClick={() => navigate('/cameras')} color="primary">
+            <ArrowBackIcon />
+          </IconButton>
+        </Tooltip>
+        <VideocamIcon sx={{ fontSize: 32, color: 'primary.main' }} />
+        <Typography variant="h4" component="h1">
+          Add New Camera
+        </Typography>
+      </Box>
+
+      <Paper sx={{ p: 3 }}>
+        <Stepper activeStep={activeStep} sx={{ mb: 4 }}>
+          {steps.map((label) => (
+            <Step key={label}>
+              <StepLabel>{label}</StepLabel>
+            </Step>
+          ))}
+        </Stepper>
+
+        <Box component="form" onSubmit={formik.handleSubmit}>
+          {renderStepContent(activeStep)}
+
+          <Divider sx={{ my: 4 }} />
+
+          <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
             <Button
               disabled={activeStep === 0}
               onClick={handleBack}
               variant="outlined"
+              type="button" // Prevent form submit on navigation
             >
               Back
             </Button>
@@ -678,6 +1541,7 @@ const AddCamera: React.FC = () => {
               <Button
                 variant="outlined"
                 onClick={() => navigate('/cameras')}
+                type="button" // Prevent form submit on cancel
               >
                 Cancel
               </Button>
@@ -694,16 +1558,18 @@ const AddCamera: React.FC = () => {
                 <Button
                   onClick={handleNext}
                   variant="contained"
+                  disabled={activeStep === 1 && connectionStatus !== 'success'}
+                  type="button" // Prevent form submit on step advance
                 >
                   Next
                 </Button>
               )}
             </Box>
-          </Box>
-        </Box>
-      </Paper>
-    </Box>
-  );
-};
-
-export default AddCamera;
\ No newline at end of file
+          </Box>
+        </Box>
+      </Paper>
+    </Box>
+  );
+};
+
+export default AddCamera;
diff --git a/event-monitoring-mvp/frontend/src/pages/Cameras.tsx b/event-monitoring-mvp/frontend/src/pages/Cameras.tsx
index 8d154ce..db8a292 100644
--- a/event-monitoring-mvp/frontend/src/pages/Cameras.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/Cameras.tsx
@@ -1,306 +1,960 @@
-import React, { useState, useEffect } from 'react';
-import {
-  Box,
-  Typography,
+import React, { useState, useEffect } from 'react';
+import {
+  Box,
+  Typography,
   Grid,
   Card,
   CardContent,
   CardActions,
   Button,
   Chip,
+  Checkbox,
   IconButton,
   Dialog,
   DialogTitle,
   DialogContent,
   DialogActions,
+  FormControlLabel,
+  FormGroup,
   TextField,
   MenuItem,
   Fab,
   CircularProgress,
 } from '@mui/material';
-import {
-  Edit as EditIcon,
-  Delete as DeleteIcon,
-  Videocam as VideocamIcon,
-  Add as AddIcon,
-  PlayArrow as PlayArrowIcon,
-  Stop as StopIcon,
-} from '@mui/icons-material';
-import { useNavigate } from 'react-router-dom';
-import { fetchCamerasData } from '../services/dataService';
-
-// Camera interface matching backend model structure
-interface Camera {
-  _id: string;
-  name: string;
-  description?: string;
-  streamUrl: string;
-  status: 'online' | 'offline' | 'maintenance';
-  type: 'ip' | 'analog' | 'usb';
-  location: {
-    coordinates: [number, number]; // [longitude, latitude]
-    address?: string;
-  };
+import {
+  Edit as EditIcon,
+  Delete as DeleteIcon,
+  Videocam as VideocamIcon,
+  Add as AddIcon,
+  PlayArrow as PlayArrowIcon,
+  Stop as StopIcon,
+} from '@mui/icons-material';
+import { useNavigate } from 'react-router-dom';
+import {
+  getCameras,
+  deleteCamera,
+  setCameraStatus,
+  // VMS additions
+  getVmsServers,
+  createVmsServer,
+  updateVmsServer,
+  deleteVmsServer,
+  getVmsMonitors,
+  importVmsMonitors,
+  deleteCamerasBySource,
+  connectCameraToVms,
+  disconnectCameraFromVms,
+  getCameraVmsStreams,
+  VmsServer,
+  VmsProvider,
+  VmsMonitor,
+} from '../services/cameraService';
+
+
+
+
+// Camera interface matching backend model structure
+interface Camera {
+  _id: string;
+  name: string;
+  description?: string;
+  streamUrl: string;
+  status: 'online' | 'offline' | 'maintenance';
+  type: 'ip' | 'analog' | 'usb';
+  location: {
+    coordinates: [number, number]; // [longitude, latitude]
+    address?: string;
+  };
   settings: {
     resolution: string;
     fps: number;
     recordingEnabled: boolean;
   };
-  isActive: boolean;
-  createdAt: string;
-  updatedAt: string;
-}
-
+  metadata?: {
+    source?: string;
+  };
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
 const Cameras: React.FC = () => {
   const navigate = useNavigate();
-  const [openDialog, setOpenDialog] = useState(false);
-  const [selectedCamera, setSelectedCamera] = useState<Camera | null>(null);
-  const [cameras, setCameras] = useState<Camera[]>([]);
-  const [loading, setLoading] = useState(true);
+  const DEMO_SOURCE = 'shinobi-demo';
+  const [openDialog, setOpenDialog] = useState(false);
+  const [selectedCamera, setSelectedCamera] = useState<Camera | null>(null);
+  const [cameras, setCameras] = useState<Camera[]>([]);
+  const [loading, setLoading] = useState(true);
+    // -----------------------------
+  // VMS UI state
+  // -----------------------------
+  const [vmsServers, setVmsServers] = useState<VmsServer[]>([]);
+  const [vmsLoading, setVmsLoading] = useState(false);
+  const [vmsMonitors, setVmsMonitors] = useState<VmsMonitor[]>([]);
+  const [monitorsLoading, setMonitorsLoading] = useState(false);
+  const [monitorsOpen, setMonitorsOpen] = useState(false);
+  const [selectedMonitorIds, setSelectedMonitorIds] = useState<string[]>([]);
+
+  // Create VMS server form fields
+  const [newVmsName, setNewVmsName] = useState('Local VMS');
+  const [newVmsProvider, setNewVmsProvider] = useState<VmsProvider>('shinobi');
+  const [newVmsBaseUrl, setNewVmsBaseUrl] = useState('http://localhost:8080');
+
+  // TEST-ONLY: Shinobi auth inputs are exposed for development validation.
+  const [newVmsApiKey, setNewVmsApiKey] = useState('');
+  const [newVmsGroupKey, setNewVmsGroupKey] = useState('');
+
+  // Edit VMS server dialog state
+  const [editVmsOpen, setEditVmsOpen] = useState(false);
+  const [editVmsServer, setEditVmsServer] = useState<VmsServer | null>(null);
+  const [editVmsName, setEditVmsName] = useState('');
+  const [editVmsProvider, setEditVmsProvider] = useState<VmsProvider>('shinobi');
+  const [editVmsBaseUrl, setEditVmsBaseUrl] = useState('');
+  const [editVmsApiKey, setEditVmsApiKey] = useState('');
+  const [editVmsGroupKey, setEditVmsGroupKey] = useState('');
+
+  // Connect dialog state
+  const [vmsConnectOpen, setVmsConnectOpen] = useState(false);
+  const [vmsConnectCamera, setVmsConnectCamera] = useState<Camera | null>(null);
+  const [selectedVmsServerId, setSelectedVmsServerId] = useState<string>('');
+  const [monitorId, setMonitorId] = useState<string>('');
+
+  // Demo import defaults
+  const [importLat, setImportLat] = useState<string>('0');
+  const [importLng, setImportLng] = useState<string>('0');
+  const [importAddress, setImportAddress] = useState<string>('Imported from VMS');
+
+  // TEST-ONLY: Streams dialog prints raw backend response for quick validation.
+  const [streamsOpen, setStreamsOpen] = useState(false);
+  const [streamsText, setStreamsText] = useState<string>('');
+
+  
+  const fetchCameras = async () => {
+    try {
+      setLoading(true);
+      const cameraList = await getCameras();
+      setCameras(cameraList);
+    } catch (error) {
+      console.error('Error fetching cameras:', error);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+
+
+  const fetchVmsServers = async () => {
+    try {
+      setVmsLoading(true);
+      const list = await getVmsServers();
+      setVmsServers(list);
+
+      // Auto-select first server for convenience
+      if (!selectedVmsServerId && list.length > 0) {
+        setSelectedVmsServerId(list[0]._id);
+      }
+    } catch (error) {
+      console.error('Error fetching VMS servers:', error);
+    } finally {
+      setVmsLoading(false);
+    }
+  };
+
+  const handleFetchMonitors = async () => {
+    if (!selectedVmsServerId) {
+      alert('Select a VMS server first');
+      return;
+    }
 
-  // API call to fetch cameras from backend
-  const fetchCameras = async () => {
     try {
-      setLoading(true);
-      
-      const cameras = await fetchCamerasData();
-      setCameras(cameras);
+      setMonitorsLoading(true);
+      const monitors = await getVmsMonitors(selectedVmsServerId);
+      setVmsMonitors(monitors);
+      setSelectedMonitorIds([]);
+      setMonitorsOpen(true);
     } catch (error) {
-      console.error('Error fetching cameras:', error);
+      console.error('Error fetching VMS monitors:', error);
+      alert((error as any)?.message || 'Failed to fetch VMS monitors');
     } finally {
-      setLoading(false);
+      setMonitorsLoading(false);
     }
   };
 
-  useEffect(() => {
-    fetchCameras();
-  }, []);
+  const toggleMonitorSelection = (id: string) => {
+    setSelectedMonitorIds((prev) =>
+      prev.includes(id) ? prev.filter((mid) => mid !== id) : [...prev, id]
+    );
+  };
+
+  const handleImportMonitors = async (importAll: boolean) => {
+    if (!selectedVmsServerId) {
+      alert('Select a VMS server first');
+      return;
+    }
+
+    const lat = Number(importLat);
+    const lng = Number(importLng);
+    if (Number.isNaN(lat) || Number.isNaN(lng)) {
+      alert('Default location coordinates must be numbers');
+      return;
+    }
 
-  const getStatusColor = (status: string) => {
-    switch (status) {
-      case 'online': return 'success';
-      case 'offline': return 'error';
-      case 'maintenance': return 'warning';
-      default: return 'default';
+    try {
+      await importVmsMonitors(selectedVmsServerId, {
+        monitorIds: importAll ? undefined : selectedMonitorIds,
+        defaultLocation: { coordinates: [lng, lat], address: importAddress },
+        source: DEMO_SOURCE,
+      });
+
+      await fetchCameras();
+      setMonitorsOpen(false);
+    } catch (error) {
+      console.error('Error importing monitors:', error);
+      alert((error as any)?.message || 'Failed to import monitors');
     }
   };
 
-  const handleEditCamera = (camera: any) => {
-    setSelectedCamera(camera);
-    setOpenDialog(true);
+  const handleDeleteDemoCameras = async () => {
+    const ok = window.confirm('Delete all demo cameras imported from Shinobi?');
+    if (!ok) return;
+
+    try {
+      await deleteCamerasBySource(DEMO_SOURCE);
+      await fetchCameras();
+    } catch (error) {
+      console.error('Error deleting demo cameras:', error);
+      alert((error as any)?.message || 'Failed to delete demo cameras');
+    }
+  };
+
+  const handleCreateVmsServer = async () => {
+    try {
+        await createVmsServer({
+        name: newVmsName,
+        provider: newVmsProvider,
+        baseUrl: newVmsBaseUrl,
+
+        // Dev/testing: store Shinobi keys so backend can generate embed/hls URLs.
+        // VmsServer model strips auth from responses, so it won't be returned to frontend.
+        auth: {
+          apiKey: newVmsApiKey || undefined,
+          groupKey: newVmsGroupKey || undefined,
+        },
+      });
+
+      // Refresh list so UI reflects the new server
+      await fetchVmsServers();
+    } catch (error) {
+      console.error('Error creating VMS server:', error);
+      alert((error as any)?.message || 'Failed to create VMS server');
+    }
   };
 
-  const handleAddCamera = () => {
-    navigate('/cameras/add');
+  // Open edit dialog and prefill values for the selected server.
+  const openEditVmsDialog = (server: VmsServer) => {
+    setEditVmsServer(server);
+    setEditVmsName(server.name);
+    setEditVmsProvider(server.provider);
+    setEditVmsBaseUrl(server.baseUrl);
+    setEditVmsApiKey('');
+    setEditVmsGroupKey('');
+    setEditVmsOpen(true);
   };
 
-  const handleCloseDialog = () => {
-    setOpenDialog(false);
-    setSelectedCamera(null);
+  // Apply updates to an existing VMS server (auth can be re-entered here).
+  const handleUpdateVmsServer = async () => {
+    if (!editVmsServer) return;
+
+    try {
+      await updateVmsServer(editVmsServer._id, {
+        name: editVmsName,
+        provider: editVmsProvider,
+        baseUrl: editVmsBaseUrl,
+        auth: {
+          apiKey: editVmsApiKey || undefined,
+          groupKey: editVmsGroupKey || undefined,
+        },
+      });
+
+      await fetchVmsServers();
+      setEditVmsOpen(false);
+      setEditVmsServer(null);
+    } catch (error) {
+      console.error('Error updating VMS server:', error);
+      alert((error as any)?.message || 'Failed to update VMS server');
+    }
   };
 
-  const CameraCard: React.FC<{ camera: Camera }> = ({ camera }) => (
-    <Card>
-      <CardContent>
-        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
-          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-            <VideocamIcon color="primary" />
-            <Typography variant="h6" component="h2">
-              {camera.name}
-            </Typography>
+  // Remove VMS server from active list (soft delete on backend)
+  const handleDeleteVmsServer = async (server: VmsServer) => {
+    const ok = window.confirm(`Remove VMS server "${server.name}"?`);
+    if (!ok) return;
+
+    try {
+      await deleteVmsServer(server._id);
+      await fetchVmsServers();
+    } catch (error) {
+      console.error('Error deleting VMS server:', error);
+      alert((error as any)?.message || 'Failed to delete VMS server');
+    }
+  };
+
+  const openConnectDialog = (camera: Camera) => {
+    setVmsConnectCamera(camera);
+    setVmsConnectOpen(true);
+
+    // default: pick first server if none selected
+    if (!selectedVmsServerId && vmsServers.length > 0) {
+      setSelectedVmsServerId(vmsServers[0]._id);
+    }
+  };
+
+  const closeConnectDialog = () => {
+    setVmsConnectOpen(false);
+    setVmsConnectCamera(null);
+    setMonitorId('');
+  };
+
+  const handleConnectToVms = async () => {
+    if (!vmsConnectCamera) return;
+
+    if (!selectedVmsServerId) {
+      alert('Select a VMS server first');
+      return;
+    }
+
+    try {
+      await connectCameraToVms(vmsConnectCamera._id, {
+        serverId: selectedVmsServerId,
+        monitorId: monitorId || undefined,
+      });
+
+      await fetchCameras(); // refresh cards (camera.vms will now exist)
+      closeConnectDialog();
+    } catch (error) {
+      console.error('Error connecting camera to VMS:', error);
+      alert((error as any)?.message || 'Failed to connect camera to VMS');
+    }
+  };
+
+  const handleDisconnectFromVms = async (camera: Camera) => {
+    try {
+      await disconnectCameraFromVms(camera._id);
+      await fetchCameras();
+    } catch (error) {
+      console.error('Error disconnecting camera from VMS:', error);
+      alert((error as any)?.message || 'Failed to disconnect camera from VMS');
+    }
+  };
+
+  const handleShowStreams = async (camera: Camera) => {
+    try {
+      const data = await getCameraVmsStreams(camera._id);
+      setStreamsText(JSON.stringify(data, null, 2));
+      setStreamsOpen(true);
+    } catch (error) {
+      console.error('Error fetching streams:', error);
+      alert((error as any)?.message || 'Failed to fetch streams');
+    }
+  };
+
+  useEffect(() => {
+    fetchCameras();
+    fetchVmsServers();
+  }, []);
+
+  const handleToggleConnection = async (camera: Camera) => {
+    try {
+      // If it's online -> disconnect (set offline)
+      // If it's offline/maintenance -> connect (set online)
+      const newStatus = camera.status === 'online' ? 'offline' : 'online';
+      await setCameraStatus(camera._id, newStatus);
+
+      // simplest: refetch list so UI always matches DB
+      await fetchCameras();
+    } catch (error) {
+      console.error('Error updating camera status:', error);
+    }
+  };
+
+  const handleDeleteCamera = async (camera: Camera) => {
+    // simple confirm for now (fast + effective)
+    const ok = window.confirm(`Delete camera "${camera.name}"?`);
+    if (!ok) return;
+
+    try {
+      await deleteCamera(camera._id);
+
+      // update UI
+      await fetchCameras();
+    } catch (error) {
+      console.error('Error deleting camera:', error);
+    }
+  };
+
+
+  // const getStatusColor = (status: string) => {
+  //   switch (status) {
+  //     case 'online': return 'success';
+  //     case 'offline': return 'error';
+  //     case 'maintenance': return 'warning';
+  //     default: return 'default';
+  //   }
+  // };
+
+  const handleEditCamera = (camera: any) => {
+    setSelectedCamera(camera);
+    setOpenDialog(true);
+  };
+
+  const handleAddCamera = () => {
+    navigate('/cameras/add');
+  };
+
+  const handleCloseDialog = () => {
+    setOpenDialog(false);
+    setSelectedCamera(null);
+  };
+
+  const CameraCard: React.FC<{ camera: Camera }> = ({ camera }) => (
+    <Card>
+      <CardContent>
+        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
+          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+            <VideocamIcon color="primary" />
+            <Typography variant="h6" component="h2">
+              {camera.name}
+            </Typography>
+          </Box>
+          <Chip 
+            label={camera.status.toUpperCase()}
+            color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
+            size="small"
+          />
+        </Box>
+        
+        <Typography variant="body2" color="text.secondary" gutterBottom>
+          {camera.description}
+        </Typography>
+        
+        <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
+          <Chip
+            label={`${camera.type.toUpperCase()} Camera`}
+            size="small"
+            variant="outlined"
+          />
+          <Chip
+            label={camera.settings.resolution}
+            size="small"
+            variant="outlined"
+          />
+          <Chip
+            label={`${camera.settings.fps} FPS`}
+            size="small"
+            variant="outlined"
+          />
+          <Chip
+            label={camera.settings.recordingEnabled ? 'Recording' : 'Not Recording'}
+            size="small"
+            variant="outlined"
+            color={camera.settings.recordingEnabled ? 'success' : 'default'}
+          />
+        </Box>
+        
+        <Typography variant="body2" gutterBottom>
+          <strong>Resolution:</strong> {camera.settings.resolution}
+        </Typography>
+        <Typography variant="body2" gutterBottom>
+          <strong>FPS:</strong> {camera.settings.fps}
+        </Typography>
+        
+        <Typography variant="body2" gutterBottom>
+          <strong>Location:</strong> {camera.location.address}
+        </Typography>
+      </CardContent>
+      
+      <CardActions>
+        <Button
+          size="small"
+          startIcon={camera.status === 'online' ? <StopIcon /> : <PlayArrowIcon />}
+          color={camera.status === 'online' ? 'error' : 'success'}
+          onClick={() => handleToggleConnection(camera)}
+        >
+          {camera.status === 'online' ? 'Disconnect' : 'Connect'}
+        </Button>
+                <Button
+                  size="small"
+                  variant="outlined"
+                  onClick={() => openConnectDialog(camera)}
+                  disabled={vmsServers.length === 0}
+                >
+                  VMS Connect
+                </Button>
+
+
+        <Button
+          size="small"
+          variant="outlined"
+          onClick={() => handleDisconnectFromVms(camera)}
+        >
+          VMS Disconnect
+        </Button>
+
+        <Button
+          size="small"
+          variant="outlined"
+          onClick={() => handleShowStreams(camera)}
+        >
+          Streams
+        </Button>
+        <IconButton size="small" onClick={() => handleEditCamera(camera)}>
+          <EditIcon />
+        </IconButton>
+        <IconButton size="small" color="error" onClick={() => handleDeleteCamera(camera)}>
+          <DeleteIcon />
+        </IconButton>
+      </CardActions>
+    </Card>
+  );
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto', p: 3, pb: 10 }}>
+      <Box sx={{ mb: 3 }}>
+        <Typography variant="h4" gutterBottom fontWeight="bold">
+          Security Cameras
+        </Typography>
+        <Typography variant="subtitle1" color="text.secondary">
+          Manage your {cameras.length} security cameras
+        </Typography>
+      </Box>
+
+      {/* TEST-ONLY: Shinobi demo/test flow kept separate for easy cleanup. */}
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Typography variant="h6" gutterBottom>
+            Shinobi Demo / Test
+          </Typography>
+
+          <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', alignItems: 'center' }}>
+            <TextField
+              label="Name"
+              size="small"
+              value={newVmsName}
+              onChange={(e) => setNewVmsName(e.target.value)}
+            />
+
+            <TextField
+              select
+              label="Provider"
+              size="small"
+              value={newVmsProvider}
+              onChange={(e) => setNewVmsProvider(e.target.value as VmsProvider)}
+              sx={{ minWidth: 160 }}
+            >
+              <MenuItem value="shinobi">Shinobi</MenuItem>
+              <MenuItem value="zoneminder">ZoneMinder</MenuItem>
+              <MenuItem value="agentdvr">Agent DVR</MenuItem>
+              <MenuItem value="other">Other</MenuItem>
+            </TextField>
+
+            <TextField
+              label="Base URL"
+              size="small"
+              value={newVmsBaseUrl}
+              onChange={(e) => setNewVmsBaseUrl(e.target.value)}
+              placeholder="http://localhost:8080"
+              sx={{ minWidth: 260 }}
+            />
+
+            <TextField
+              label="API Key (Shinobi)"
+              size="small"
+              value={newVmsApiKey}
+              onChange={(e) => setNewVmsApiKey(e.target.value)}
+              sx={{ minWidth: 260 }}
+            />
+
+            <TextField
+              label="Group Key (Shinobi)"
+              size="small"
+              value={newVmsGroupKey}
+              onChange={(e) => setNewVmsGroupKey(e.target.value)}
+              sx={{ minWidth: 260 }}
+            />
+
+            <Button variant="contained" onClick={handleCreateVmsServer} disabled={vmsLoading}>
+              Add VMS Server
+            </Button>
+
+            <Button variant="outlined" onClick={fetchVmsServers} disabled={vmsLoading}>
+              Refresh
+            </Button>
+
+            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+              <Typography variant="body2" color="text.secondary">
+                Servers:
+              </Typography>
+              <Chip
+                label={vmsLoading ? 'Loading...' : `${vmsServers.length}`}
+                size="small"
+                variant="outlined"
+              />
+            </Box>
           </Box>
-          <Chip 
-            label={camera.status.toUpperCase()}
-            color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
-            size="small"
-          />
-        </Box>
-        
-        <Typography variant="body2" color="text.secondary" gutterBottom>
-          {camera.description}
-        </Typography>
-        
-        <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
-          <Chip
-            label={`${camera.type.toUpperCase()} Camera`}
-            size="small"
-            variant="outlined"
-          />
-          <Chip
-            label={camera.settings.resolution}
-            size="small"
-            variant="outlined"
-          />
-          <Chip
-            label={`${camera.settings.fps} FPS`}
-            size="small"
-            variant="outlined"
-          />
-          <Chip
-            label={camera.settings.recordingEnabled ? 'Recording' : 'Not Recording'}
-            size="small"
-            variant="outlined"
-            color={camera.settings.recordingEnabled ? 'success' : 'default'}
-          />
-        </Box>
-        
-        <Typography variant="body2" gutterBottom>
-          <strong>Resolution:</strong> {camera.settings.resolution}
-        </Typography>
-        <Typography variant="body2" gutterBottom>
-          <strong>FPS:</strong> {camera.settings.fps}
-        </Typography>
-        
-        <Typography variant="body2" gutterBottom>
-          <strong>Location:</strong> {camera.location.address}
-        </Typography>
-      </CardContent>
-      
-      <CardActions>
-        <Button
-          size="small"
-          startIcon={camera.status === 'online' ? <StopIcon /> : <PlayArrowIcon />}
-          color={camera.status === 'online' ? 'error' : 'success'}
-        >
-          {camera.status === 'online' ? 'Stop AI' : 'Start AI'}
-        </Button>
-        <IconButton size="small" onClick={() => handleEditCamera(camera)}>
-          <EditIcon />
-        </IconButton>
-        <IconButton size="small" color="error">
-          <DeleteIcon />
-        </IconButton>
-      </CardActions>
-    </Card>
-  );
 
-  return (
-    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto', p: 3, pb: 10 }}>
-      <Box sx={{ mb: 3 }}>
-        <Typography variant="h4" gutterBottom fontWeight="bold">
-          Security Cameras
-        </Typography>
-        <Typography variant="subtitle1" color="text.secondary">
-          Manage your {cameras.length} security cameras
-        </Typography>
-      </Box>
-
-      {loading ? (
-        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
-          <CircularProgress size={60} />
-        </Box>
-      ) : (
-        <Box sx={{ pb: 10 }}> {/* Add bottom padding for FAB */}
-          <Grid container spacing={3}>
-            {cameras.map((camera) => (
-              <Grid item xs={12} md={6} lg={4} key={camera._id}>
-                <CameraCard camera={camera} />
-              </Grid>
-            ))}
-          </Grid>
-        </Box>
-      )}      {/* Add Camera FAB */}
-      <Fab
-        color="primary"
-        aria-label="add camera"
-        sx={{ position: 'fixed', bottom: 16, right: 16 }}
-        onClick={handleAddCamera}
-      >
-        <AddIcon />
-      </Fab>
-
-      {/* Camera Dialog */}
-      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="md" fullWidth>
-        <DialogTitle>
-          {selectedCamera ? 'Edit Camera' : 'Add New Camera'}
-        </DialogTitle>
+          {/* Active servers list with quick remove */}
+          <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap', mt: 2 }}>
+            {vmsServers.length === 0 ? (
+              <Typography variant="body2" color="text.secondary">
+                No VMS servers yet.
+              </Typography>
+            ) : (
+              vmsServers.map((server) => (
+                <Chip
+                  key={server._id}
+                  label={`${server.name} (${server.provider})`}
+                  variant="outlined"
+                  onClick={() => openEditVmsDialog(server)}
+                  onDelete={() => handleDeleteVmsServer(server)}
+                />
+              ))
+            )}
+          </Box>
+
+          <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mt: 2 }}>
+            <TextField
+              label="Default Lat"
+              size="small"
+              value={importLat}
+              onChange={(e) => setImportLat(e.target.value)}
+              sx={{ maxWidth: 140 }}
+            />
+            <TextField
+              label="Default Lng"
+              size="small"
+              value={importLng}
+              onChange={(e) => setImportLng(e.target.value)}
+              sx={{ maxWidth: 140 }}
+            />
+            <TextField
+              label="Default Address"
+              size="small"
+              value={importAddress}
+              onChange={(e) => setImportAddress(e.target.value)}
+              sx={{ minWidth: 260 }}
+            />
+            <Button variant="outlined" onClick={handleFetchMonitors} disabled={monitorsLoading}>
+              Discover Monitors
+            </Button>
+            <Button variant="outlined" onClick={() => handleImportMonitors(true)}>
+              Import All
+            </Button>
+            <Button variant="outlined" color="error" onClick={handleDeleteDemoCameras}>
+              Delete Demo Cameras
+            </Button>
+          </Box>
+        </CardContent>
+      </Card>
+
+      {/* Production flow: use full camera form for real deployments. */}
+      <Card sx={{ mb: 3 }}>
+        <CardContent>
+          <Typography variant="h6" gutterBottom>
+            Production / Real Cameras
+          </Typography>
+          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
+            Use the full camera form for real deployments (location, settings, validation).
+          </Typography>
+          <Button variant="contained" onClick={handleAddCamera}>
+            Add Production Camera
+          </Button>
+        </CardContent>
+      </Card>
+
+
+      {loading ? (
+        <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
+          <CircularProgress size={60} />
+        </Box>
+      ) : (
+        <Box sx={{ pb: 10 }}> {/* Add bottom padding for FAB */}
+          <Grid container spacing={3}>
+            {cameras.map((camera) => (
+              <Grid item xs={12} md={6} lg={4} key={camera._id}>
+                <CameraCard camera={camera} />
+              </Grid>
+            ))}
+          </Grid>
+        </Box>
+      )}      {/* Add Camera FAB */}
+      <Fab
+        color="primary"
+        aria-label="add camera"
+        sx={{ position: 'fixed', bottom: 16, right: 16 }}
+        onClick={handleAddCamera}
+      >
+        <AddIcon />
+      </Fab>
+
+      {/* Camera Dialog */}
+      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="md" fullWidth>
+        <DialogTitle>
+          {selectedCamera ? 'Edit Camera' : 'Add New Camera'}
+        </DialogTitle>
+        <DialogContent>
+          <Grid container spacing={2} sx={{ mt: 1 }}>
+            <Grid item xs={12} sm={6}>
+              <TextField
+                fullWidth
+                label="Camera Name"
+                defaultValue={selectedCamera?.name || ''}
+              />
+            </Grid>
+            <Grid item xs={12} sm={6}>
+              <TextField
+                fullWidth
+                select
+                label="Camera Type"
+                defaultValue={selectedCamera?.type || 'ip'}
+              >
+                <MenuItem value="ip">IP Camera</MenuItem>
+                <MenuItem value="analog">Analog Camera</MenuItem>
+                <MenuItem value="usb">USB Camera</MenuItem>
+              </TextField>
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Description"
+                defaultValue={selectedCamera?.description || ''}
+              />
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Stream URL"
+                defaultValue={selectedCamera?.streamUrl || ''}
+                placeholder="rtsp://camera-ip:554/stream"
+              />
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Location Address"
+                defaultValue={selectedCamera?.location?.address || ''}
+              />
+            </Grid>
+            <Grid item xs={12} sm={4}>
+              <TextField
+                fullWidth
+                select
+                label="Resolution"
+                defaultValue={selectedCamera?.settings?.resolution || '1920x1080'}
+              >
+                <MenuItem value="3840x2160">4K (3840x2160)</MenuItem>
+                <MenuItem value="1920x1080">Full HD (1920x1080)</MenuItem>
+                <MenuItem value="1280x720">HD (1280x720)</MenuItem>
+                <MenuItem value="640x480">SD (640x480)</MenuItem>
+              </TextField>
+            </Grid>
+            <Grid item xs={12} sm={4}>
+              <TextField
+                fullWidth
+                type="number"
+                label="FPS"
+                defaultValue={selectedCamera?.settings?.fps || 30}
+                inputProps={{ min: 1, max: 60 }}
+              />
+            </Grid>
+            <Grid item xs={12} sm={4}>
+              <TextField
+                fullWidth
+                select
+                label="Recording"
+                defaultValue={selectedCamera?.settings?.recordingEnabled ? 'true' : 'false'}
+              >
+                <MenuItem value="true">Enabled</MenuItem>
+                <MenuItem value="false">Disabled</MenuItem>
+              </TextField>
+            </Grid>
+          </Grid>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={handleCloseDialog}>Cancel</Button>
+          <Button variant="contained" onClick={handleCloseDialog}>
+            {selectedCamera ? 'Update' : 'Add'} Camera
+          </Button>
+        </DialogActions>
+      </Dialog>
+            {/* VMS Connect Dialog */}
+      <Dialog open={vmsConnectOpen} onClose={closeConnectDialog} maxWidth="sm" fullWidth>
+        <DialogTitle>Connect Camera to VMS</DialogTitle>
+        <DialogContent>
+          <Box sx={{ mt: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
+            <Typography variant="body2" color="text.secondary">
+              Camera: <strong>{vmsConnectCamera?.name}</strong>
+            </Typography>
+
+            <TextField
+              select
+              label="VMS Server"
+              value={selectedVmsServerId}
+              onChange={(e) => setSelectedVmsServerId(e.target.value)}
+              fullWidth
+              size="small"
+            >
+              {vmsServers.map((s) => (
+                <MenuItem key={s._id} value={s._id}>
+                  {s.name} ({s.provider})
+                </MenuItem>
+              ))}
+            </TextField>
+
+            <TextField
+              label="Monitor ID (optional)"
+              value={monitorId}
+              onChange={(e) => setMonitorId(e.target.value)}
+              fullWidth
+              size="small"
+              placeholder="e.g. demo-monitor-1"
+              helperText="Optional for now. Later this will be created automatically by the VMS adapter."
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={closeConnectDialog}>Cancel</Button>
+          <Button variant="contained" onClick={handleConnectToVms}>
+            Connect
+          </Button>
+        </DialogActions>
+      </Dialog>
+
+      {/* TEST-ONLY: Streams Info Dialog is a raw debug view. */}
+      <Dialog open={streamsOpen} onClose={() => setStreamsOpen(false)} maxWidth="md" fullWidth>
+        <DialogTitle>Camera Stream Info</DialogTitle>
         <DialogContent>
-          <Grid container spacing={2} sx={{ mt: 1 }}>
-            <Grid item xs={12} sm={6}>
-              <TextField
-                fullWidth
-                label="Camera Name"
-                defaultValue={selectedCamera?.name || ''}
-              />
-            </Grid>
-            <Grid item xs={12} sm={6}>
-              <TextField
-                fullWidth
-                select
-                label="Camera Type"
-                defaultValue={selectedCamera?.type || 'ip'}
-              >
-                <MenuItem value="ip">IP Camera</MenuItem>
-                <MenuItem value="analog">Analog Camera</MenuItem>
-                <MenuItem value="usb">USB Camera</MenuItem>
-              </TextField>
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Description"
-                defaultValue={selectedCamera?.description || ''}
-              />
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Stream URL"
-                defaultValue={selectedCamera?.streamUrl || ''}
-                placeholder="rtsp://camera-ip:554/stream"
-              />
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Location Address"
-                defaultValue={selectedCamera?.location?.address || ''}
-              />
-            </Grid>
-            <Grid item xs={12} sm={4}>
-              <TextField
-                fullWidth
-                select
-                label="Resolution"
-                defaultValue={selectedCamera?.settings?.resolution || '1920x1080'}
-              >
-                <MenuItem value="3840x2160">4K (3840x2160)</MenuItem>
-                <MenuItem value="1920x1080">Full HD (1920x1080)</MenuItem>
-                <MenuItem value="1280x720">HD (1280x720)</MenuItem>
-                <MenuItem value="640x480">SD (640x480)</MenuItem>
-              </TextField>
-            </Grid>
-            <Grid item xs={12} sm={4}>
-              <TextField
-                fullWidth
-                type="number"
-                label="FPS"
-                defaultValue={selectedCamera?.settings?.fps || 30}
-                inputProps={{ min: 1, max: 60 }}
-              />
-            </Grid>
-            <Grid item xs={12} sm={4}>
-              <TextField
-                fullWidth
-                select
-                label="Recording"
-                defaultValue={selectedCamera?.settings?.recordingEnabled ? 'true' : 'false'}
-              >
-                <MenuItem value="true">Enabled</MenuItem>
-                <MenuItem value="false">Disabled</MenuItem>
-              </TextField>
-            </Grid>
-          </Grid>
+          <Box
+            component="pre"
+            sx={{
+              backgroundColor: '#111',
+              color: '#eee',
+              p: 2,
+              borderRadius: 1,
+              overflow: 'auto',
+              fontSize: '0.85rem',
+            }}
+          >
+            {streamsText}
+          </Box>
         </DialogContent>
         <DialogActions>
-          <Button onClick={handleCloseDialog}>Cancel</Button>
-          <Button variant="contained" onClick={handleCloseDialog}>
-            {selectedCamera ? 'Update' : 'Add'} Camera
+          <Button onClick={() => setStreamsOpen(false)}>Close</Button>
+        </DialogActions>
+      </Dialog>
+
+      {/* TEST-ONLY: Shinobi monitor discovery dialog for demo imports. */}
+      <Dialog open={monitorsOpen} onClose={() => setMonitorsOpen(false)} maxWidth="md" fullWidth>
+        <DialogTitle>Shinobi Monitors</DialogTitle>
+        <DialogContent>
+          {monitorsLoading ? (
+            <Box sx={{ display: 'flex', justifyContent: 'center', py: 3 }}>
+              <CircularProgress />
+            </Box>
+          ) : (
+            <FormGroup>
+              {/* Defensive guard in case the API returns a non-array shape. */}
+              {(Array.isArray(vmsMonitors) ? vmsMonitors : []).map((monitor) => {
+                const id = String(monitor.mid || monitor.id);
+                return (
+                  <FormControlLabel
+                    key={id}
+                    control={
+                      <Checkbox
+                        checked={selectedMonitorIds.includes(id)}
+                        onChange={() => toggleMonitorSelection(id)}
+                      />
+                    }
+                    label={`${monitor.name || monitor.title || id}`}
+                  />
+                );
+              })}
+            </FormGroup>
+          )}
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={() => setMonitorsOpen(false)}>Close</Button>
+          <Button
+            variant="contained"
+            onClick={() => handleImportMonitors(false)}
+            disabled={selectedMonitorIds.length === 0}
+          >
+            Import Selected
           </Button>
         </DialogActions>
       </Dialog>
+
+      {/* Edit VMS Server Dialog (allows updating stored auth keys) */}
+      <Dialog open={editVmsOpen} onClose={() => setEditVmsOpen(false)} maxWidth="sm" fullWidth>
+        <DialogTitle>Edit VMS Server</DialogTitle>
+        <DialogContent>
+          <Box sx={{ mt: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
+            <TextField
+              label="Name"
+              size="small"
+              value={editVmsName}
+              onChange={(e) => setEditVmsName(e.target.value)}
+              fullWidth
+            />
+
+            <TextField
+              select
+              label="Provider"
+              size="small"
+              value={editVmsProvider}
+              onChange={(e) => setEditVmsProvider(e.target.value as VmsProvider)}
+              fullWidth
+            >
+              <MenuItem value="shinobi">Shinobi</MenuItem>
+              <MenuItem value="zoneminder">ZoneMinder</MenuItem>
+              <MenuItem value="agentdvr">Agent DVR</MenuItem>
+              <MenuItem value="other">Other</MenuItem>
+            </TextField>
+
+            <TextField
+              label="Base URL"
+              size="small"
+              value={editVmsBaseUrl}
+              onChange={(e) => setEditVmsBaseUrl(e.target.value)}
+              fullWidth
+            />
+
+            <TextField
+              label="API Key (Shinobi)"
+              size="small"
+              value={editVmsApiKey}
+              onChange={(e) => setEditVmsApiKey(e.target.value)}
+              fullWidth
+            />
+
+            <TextField
+              label="Group Key (Shinobi)"
+              size="small"
+              value={editVmsGroupKey}
+              onChange={(e) => setEditVmsGroupKey(e.target.value)}
+              fullWidth
+            />
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={() => setEditVmsOpen(false)}>Cancel</Button>
+          <Button variant="contained" onClick={handleUpdateVmsServer}>
+            Save
+          </Button>
+        </DialogActions>
+      </Dialog>
+
     </Box>
   );
 };
-
-export default Cameras;
\ No newline at end of file
+
+export default Cameras;
diff --git a/event-monitoring-mvp/frontend/src/pages/Dashboard.tsx b/event-monitoring-mvp/frontend/src/pages/Dashboard.tsx
index 713a7ee..8e5d1be 100644
--- a/event-monitoring-mvp/frontend/src/pages/Dashboard.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/Dashboard.tsx
@@ -1,180 +1,180 @@
-import React from 'react';
-import {
-  Box,
-  Grid,
-  Paper,
-  Typography,
-  Card,
-  CardContent,
-  CardHeader,
-  LinearProgress,
-} from '@mui/material';
-import {
-  Event as EventIcon,
-  Videocam as VideocamIcon,
-  Warning as WarningIcon,
-  CheckCircle as CheckCircleIcon,
-} from '@mui/icons-material';
-import { useSelector } from 'react-redux';
-import { RootState } from '../store/store';
-
-const Dashboard: React.FC = () => {
-  const { user } = useSelector((state: RootState) => state.auth);
-
-  // Mock data - replace with real API calls
-  const stats = {
-    totalEvents: 24,
-    activeEvents: 8,
-    totalCameras: 5,
-    onlineCameras: 4,
-    criticalEvents: 2,
-    resolvedToday: 16,
-  };
-
-  const StatCard: React.FC<{
-    title: string;
-    value: number;
-    icon: React.ReactNode;
-    color: string;
-  }> = ({ title, value, icon, color }) => (
-    <Card>
-      <CardContent>
-        <Box sx={{ display: 'flex', alignItems: 'center' }}>
-          <Box
-            sx={{
-              display: 'flex',
-              alignItems: 'center',
-              justifyContent: 'center',
-              width: 48,
-              height: 48,
-              borderRadius: '50%',
-              backgroundColor: `${color}20`,
-              color: color,
-              mr: 2,
-            }}
-          >
-            {icon}
-          </Box>
-          <Box>
-            <Typography variant="h4" fontWeight="bold">
-              {value}
-            </Typography>
-            <Typography variant="body2" color="text.secondary">
-              {title}
-            </Typography>
-          </Box>
-        </Box>
-      </CardContent>
-    </Card>
-  );
-
-  return (
-    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
-      <Typography variant="h4" gutterBottom fontWeight="bold">
-        Welcome back, {user?.username}!
-      </Typography>
-      <Typography variant="subtitle1" color="text.secondary" gutterBottom>
-        Here's what's happening with your security monitoring system.
-      </Typography>
-
-      {/* Statistics Cards */}
-      <Grid container spacing={3} sx={{ mt: 2 }}>
-        <Grid item xs={12} sm={6} md={3}>
-          <StatCard
-            title="Total Events"
-            value={stats.totalEvents}
-            icon={<EventIcon />}
-            color="#1976d2"
-          />
-        </Grid>
-        <Grid item xs={12} sm={6} md={3}>
-          <StatCard
-            title="Active Events"
-            value={stats.activeEvents}
-            icon={<WarningIcon />}
-            color="#ed6c02"
-          />
-        </Grid>
-        <Grid item xs={12} sm={6} md={3}>
-          <StatCard
-            title="Online Cameras"
-            value={stats.onlineCameras}
-            icon={<VideocamIcon />}
-            color="#2e7d32"
-          />
-        </Grid>
-        <Grid item xs={12} sm={6} md={3}>
-          <StatCard
-            title="Resolved Today"
-            value={stats.resolvedToday}
-            icon={<CheckCircleIcon />}
-            color="#9c27b0"
-          />
-        </Grid>
-      </Grid>
-
-      {/* Recent Activity */}
-      <Grid container spacing={3} sx={{ mt: 3 }}>
-        <Grid item xs={12} md={6}>
-          <Paper sx={{ p: 3 }}>
-            <Typography variant="h6" gutterBottom>
-              System Status
-            </Typography>
-            <Box sx={{ mt: 2 }}>
-              <Typography variant="body2" gutterBottom>
-                Camera System
-              </Typography>
-              <LinearProgress
-                variant="determinate"
-                value={80}
-                sx={{ mb: 2, height: 8, borderRadius: 4 }}
-              />
-              <Typography variant="body2" gutterBottom>
-                AI Processing
-              </Typography>
-              <LinearProgress
-                variant="determinate"
-                value={95}
-                color="success"
-                sx={{ mb: 2, height: 8, borderRadius: 4 }}
-              />
-              <Typography variant="body2" gutterBottom>
-                Network Status
-              </Typography>
-              <LinearProgress
-                variant="determinate"
-                value={88}
-                color="info"
-                sx={{ height: 8, borderRadius: 4 }}
-              />
-            </Box>
-          </Paper>
-        </Grid>
-
-        <Grid item xs={12} md={6}>
-          <Paper sx={{ p: 3 }}>
-            <Typography variant="h6" gutterBottom>
-              Recent Events
-            </Typography>
-            <Box sx={{ mt: 2 }}>
-              <Typography variant="body2" color="text.secondary">
-                â€¢ Person detected at Front Gate - 2 min ago
-              </Typography>
-              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
-                â€¢ Vehicle detected in Parking Lot - 5 min ago
-              </Typography>
-              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
-                â€¢ Motion detected at Side Entrance - 12 min ago
-              </Typography>
-              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
-                â€¢ System check completed - 30 min ago
-              </Typography>
-            </Box>
-          </Paper>
-        </Grid>
-      </Grid>
-    </Box>
-  );
-};
-
+import React from 'react';
+import {
+  Box,
+  Grid,
+  Paper,
+  Typography,
+  Card,
+  CardContent,
+  CardHeader,
+  LinearProgress,
+} from '@mui/material';
+import {
+  Event as EventIcon,
+  Videocam as VideocamIcon,
+  Warning as WarningIcon,
+  CheckCircle as CheckCircleIcon,
+} from '@mui/icons-material';
+import { useSelector } from 'react-redux';
+import { RootState } from '../store/store';
+
+const Dashboard: React.FC = () => {
+  const { user } = useSelector((state: RootState) => state.auth);
+
+  // Mock data - replace with real API calls
+  const stats = {
+    totalEvents: 24,
+    activeEvents: 8,
+    totalCameras: 5,
+    onlineCameras: 4,
+    criticalEvents: 2,
+    resolvedToday: 16,
+  };
+
+  const StatCard: React.FC<{
+    title: string;
+    value: number;
+    icon: React.ReactNode;
+    color: string;
+  }> = ({ title, value, icon, color }) => (
+    <Card>
+      <CardContent>
+        <Box sx={{ display: 'flex', alignItems: 'center' }}>
+          <Box
+            sx={{
+              display: 'flex',
+              alignItems: 'center',
+              justifyContent: 'center',
+              width: 48,
+              height: 48,
+              borderRadius: '50%',
+              backgroundColor: `${color}20`,
+              color: color,
+              mr: 2,
+            }}
+          >
+            {icon}
+          </Box>
+          <Box>
+            <Typography variant="h4" fontWeight="bold">
+              {value}
+            </Typography>
+            <Typography variant="body2" color="text.secondary">
+              {title}
+            </Typography>
+          </Box>
+        </Box>
+      </CardContent>
+    </Card>
+  );
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
+      <Typography variant="h4" gutterBottom fontWeight="bold">
+        Welcome back, {user?.username}!
+      </Typography>
+      <Typography variant="subtitle1" color="text.secondary" gutterBottom>
+        Here's what's happening with your security monitoring system.
+      </Typography>
+
+      {/* Statistics Cards */}
+      <Grid container spacing={3} sx={{ mt: 2 }}>
+        <Grid item xs={12} sm={6} md={3}>
+          <StatCard
+            title="Total Events"
+            value={stats.totalEvents}
+            icon={<EventIcon />}
+            color="#1976d2"
+          />
+        </Grid>
+        <Grid item xs={12} sm={6} md={3}>
+          <StatCard
+            title="Active Events"
+            value={stats.activeEvents}
+            icon={<WarningIcon />}
+            color="#ed6c02"
+          />
+        </Grid>
+        <Grid item xs={12} sm={6} md={3}>
+          <StatCard
+            title="Online Cameras"
+            value={stats.onlineCameras}
+            icon={<VideocamIcon />}
+            color="#2e7d32"
+          />
+        </Grid>
+        <Grid item xs={12} sm={6} md={3}>
+          <StatCard
+            title="Resolved Today"
+            value={stats.resolvedToday}
+            icon={<CheckCircleIcon />}
+            color="#9c27b0"
+          />
+        </Grid>
+      </Grid>
+
+      {/* Recent Activity */}
+      <Grid container spacing={3} sx={{ mt: 3 }}>
+        <Grid item xs={12} md={6}>
+          <Paper sx={{ p: 3 }}>
+            <Typography variant="h6" gutterBottom>
+              System Status
+            </Typography>
+            <Box sx={{ mt: 2 }}>
+              <Typography variant="body2" gutterBottom>
+                Camera System
+              </Typography>
+              <LinearProgress
+                variant="determinate"
+                value={80}
+                sx={{ mb: 2, height: 8, borderRadius: 4 }}
+              />
+              <Typography variant="body2" gutterBottom>
+                AI Processing
+              </Typography>
+              <LinearProgress
+                variant="determinate"
+                value={95}
+                color="success"
+                sx={{ mb: 2, height: 8, borderRadius: 4 }}
+              />
+              <Typography variant="body2" gutterBottom>
+                Network Status
+              </Typography>
+              <LinearProgress
+                variant="determinate"
+                value={88}
+                color="info"
+                sx={{ height: 8, borderRadius: 4 }}
+              />
+            </Box>
+          </Paper>
+        </Grid>
+
+        <Grid item xs={12} md={6}>
+          <Paper sx={{ p: 3 }}>
+            <Typography variant="h6" gutterBottom>
+              Recent Events
+            </Typography>
+            <Box sx={{ mt: 2 }}>
+              <Typography variant="body2" color="text.secondary">
+                â€¢ Person detected at Front Gate - 2 min ago
+              </Typography>
+              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
+                â€¢ Vehicle detected in Parking Lot - 5 min ago
+              </Typography>
+              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
+                â€¢ Motion detected at Side Entrance - 12 min ago
+              </Typography>
+              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
+                â€¢ System check completed - 30 min ago
+              </Typography>
+            </Box>
+          </Paper>
+        </Grid>
+      </Grid>
+    </Box>
+  );
+};
+
 export default Dashboard;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/pages/EventSubmission.tsx b/event-monitoring-mvp/frontend/src/pages/EventSubmission.tsx
index e6a27e2..907b0a6 100644
--- a/event-monitoring-mvp/frontend/src/pages/EventSubmission.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/EventSubmission.tsx
@@ -1,814 +1,814 @@
-import React, { useState, useEffect } from 'react';
-import {
-  Box,
-  Card,
-  CardContent,
-  Typography,
-  TextField,
-  Button,
-  FormControl,
-  InputLabel,
-  Select,
-  MenuItem,
-  Chip,
-  FormControlLabel,
-  Switch,
-  Alert,
-  Dialog,
-  DialogTitle,
-  DialogContent,
-  DialogActions,
-  Grid,
-  Paper,
-  Stepper,
-  Step,
-  StepLabel,
-  StepContent,
-  Autocomplete,
-  Avatar,
-  Divider,
-  IconButton,
-  Tooltip,
-} from '@mui/material';
-import {
-  LocationOn as LocationIcon,
-  PhotoCamera as PhotoIcon,
-  Videocam as VideoIcon,
-  Upload as UploadIcon,
-  Map as MapIcon,
-  Warning as WarningIcon,
-  Security as SecurityIcon,
-  Traffic as TrafficIcon,
-  CrisisAlert as EmergencyIcon,
-  Build as BuildIcon,
-  Person as PersonIcon,
-  Notifications as NotificationIcon,
-  Close as CloseIcon,
-  Check as CheckIcon,
-} from '@mui/icons-material';
-import { MapContainer, TileLayer, Marker, useMapEvents } from 'react-leaflet';
-import L from 'leaflet';
-import { useNavigate, useLocation } from 'react-router-dom';
-
-// Event types with icons and descriptions
-const eventTypes = [
-  { value: 'security_incident', label: 'Security Incident', icon: <SecurityIcon />, description: 'Unauthorized access, theft, vandalism' },
-  { value: 'traffic_violation', label: 'Traffic Violation', icon: <TrafficIcon />, description: 'Speeding, illegal parking, running red lights' },
-  { value: 'emergency', label: 'Emergency', icon: <EmergencyIcon />, description: 'Medical emergency, fire, natural disaster' },
-  { value: 'maintenance_needed', label: 'Maintenance Needed', icon: <BuildIcon />, description: 'Equipment failure, infrastructure issues' },
-  { value: 'user_report', label: 'User Report', icon: <PersonIcon />, description: 'General public reports and complaints' },
-  { value: 'system_alert', label: 'System Alert', icon: <NotificationIcon />, description: 'Automated system notifications' },
-  { value: 'suspicious_activity', label: 'Suspicious Activity', icon: <WarningIcon />, description: 'Unusual behavior or activity' },
-  { value: 'other', label: 'Other', icon: <NotificationIcon />, description: 'Other types of incidents' }
-];
-
-const severityLevels = [
-  { value: 'low', label: 'Low', color: '#4caf50', description: 'Minor issue, non-urgent' },
-  { value: 'medium', label: 'Medium', color: '#ff9800', description: 'Moderate issue, should be addressed' },
-  { value: 'high', label: 'High', color: '#f44336', description: 'Serious issue, requires prompt attention' },
-  { value: 'critical', label: 'Critical', color: '#d32f2f', description: 'Very serious, immediate action required' },
-  { value: 'emergency', label: 'Emergency', color: '#b71c1c', description: 'Life-threatening, emergency response needed' }
-];
-
-const priorityLevels = [
-  { value: 1, label: 'Highest', color: '#d32f2f' },
-  { value: 2, label: 'High', color: '#f44336' },
-  { value: 3, label: 'Medium', color: '#ff9800' },
-  { value: 4, label: 'Low', color: '#4caf50' },
-  { value: 5, label: 'Lowest', color: '#9e9e9e' }
-];
-
-interface LocationPickerProps {
-  onLocationSelect: (lat: number, lng: number) => void;
-  initialLocation?: { lat: number; lng: number };
-}
-
-const LocationPicker: React.FC<LocationPickerProps> = ({ onLocationSelect, initialLocation }) => {
-  const [position, setPosition] = useState<{ lat: number; lng: number } | null>(
-    initialLocation || null
-  );
-
-  const MapEvents = () => {
-    useMapEvents({
-      click(e) {
-        const { lat, lng } = e.latlng;
-        setPosition({ lat, lng });
-        onLocationSelect(lat, lng);
-      },
-    });
-    return null;
-  };
-
-  return (
-    <Box sx={{ height: '300px', width: '100%', border: '1px solid #ccc', borderRadius: 1 }}>
-      <MapContainer
-        center={position || [40.7831, -73.9712]}
-        zoom={13}
-        style={{ height: '100%', width: '100%' }}
-      >
-        <TileLayer
-          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
-          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
-        />
-        <MapEvents />
-        {position && (
-          <Marker
-            position={[position.lat, position.lng]}
-            icon={L.divIcon({
-              html: `<div style="background: #f44336; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>`,
-              className: 'custom-marker',
-              iconSize: [20, 20],
-              iconAnchor: [10, 10],
-            })}
-          />
-        )}
-      </MapContainer>
-    </Box>
-  );
-};
-
-const EventSubmission: React.FC = () => {
-  const navigate = useNavigate();
-  const location = useLocation();
-  const [activeStep, setActiveStep] = useState(0);
-  const [formData, setFormData] = useState({
-    title: '',
-    description: '',
-    type: '',
-    severity: 'medium',
-    priority: 3,
-    location: {
-      coordinates: [0, 0],
-      address: '',
-      accuracy: 0
-    },
-    cameraId: '',
-    detectionId: '',
-    reporter: {
-      name: '',
-      email: '',
-      phone: '',
-      isAnonymous: false
-    },
-    tags: [] as string[],
-    source: 'user_report',
-    publiclyVisible: false,
-    media: {
-      images: [] as string[],
-      videos: [] as string[],
-      attachments: [] as any[]
-    }
-  });
-  const [errors, setErrors] = useState<any>({});
-  const [loading, setLoading] = useState(false);
-  const [success, setSuccess] = useState(false);
-  const [cameras, setCameras] = useState<any[]>([]);
-  const [newTag, setNewTag] = useState('');
-
-  // Check if we're promoting a detection
-  const detectionData = location.state?.detection;
-
-  useEffect(() => {
-    // Load cameras for selection
-    loadCameras();
-
-    // Pre-fill form if promoting from detection
-    if (detectionData) {
-      setFormData(prev => ({
-        ...prev,
-        title: `Detection: ${detectionData.type.replace('_', ' ')}`,
-        description: detectionData.description || `AI detected ${detectionData.type.replace('_', ' ')} with ${Math.round(detectionData.confidence * 100)}% confidence`,
-        type: mapDetectionTypeToEventType(detectionData.type),
-        severity: detectionData.severity || 'medium',
-        detectionId: detectionData._id,
-        location: {
-          coordinates: detectionData.location.coordinates,
-          address: detectionData.location.address || '',
-          accuracy: detectionData.location.accuracy || 0
-        },
-        cameraId: detectionData.cameraId,
-        source: 'ai_detection'
-      }));
-    }
-  }, [detectionData]);
-
-  const loadCameras = async () => {
-    try {
-      // Mock camera data - replace with actual API call
+import React, { useState, useEffect } from 'react';
+import {
+  Box,
+  Card,
+  CardContent,
+  Typography,
+  TextField,
+  Button,
+  FormControl,
+  InputLabel,
+  Select,
+  MenuItem,
+  Chip,
+  FormControlLabel,
+  Switch,
+  Alert,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Grid,
+  Paper,
+  Stepper,
+  Step,
+  StepLabel,
+  StepContent,
+  Autocomplete,
+  Avatar,
+  Divider,
+  IconButton,
+  Tooltip,
+} from '@mui/material';
+import {
+  LocationOn as LocationIcon,
+  PhotoCamera as PhotoIcon,
+  Videocam as VideoIcon,
+  Upload as UploadIcon,
+  Map as MapIcon,
+  Warning as WarningIcon,
+  Security as SecurityIcon,
+  Traffic as TrafficIcon,
+  CrisisAlert as EmergencyIcon,
+  Build as BuildIcon,
+  Person as PersonIcon,
+  Notifications as NotificationIcon,
+  Close as CloseIcon,
+  Check as CheckIcon,
+} from '@mui/icons-material';
+import { MapContainer, TileLayer, Marker, useMapEvents } from 'react-leaflet';
+import L from 'leaflet';
+import { useNavigate, useLocation } from 'react-router-dom';
+
+// Event types with icons and descriptions
+const eventTypes = [
+  { value: 'security_incident', label: 'Security Incident', icon: <SecurityIcon />, description: 'Unauthorized access, theft, vandalism' },
+  { value: 'traffic_violation', label: 'Traffic Violation', icon: <TrafficIcon />, description: 'Speeding, illegal parking, running red lights' },
+  { value: 'emergency', label: 'Emergency', icon: <EmergencyIcon />, description: 'Medical emergency, fire, natural disaster' },
+  { value: 'maintenance_needed', label: 'Maintenance Needed', icon: <BuildIcon />, description: 'Equipment failure, infrastructure issues' },
+  { value: 'user_report', label: 'User Report', icon: <PersonIcon />, description: 'General public reports and complaints' },
+  { value: 'system_alert', label: 'System Alert', icon: <NotificationIcon />, description: 'Automated system notifications' },
+  { value: 'suspicious_activity', label: 'Suspicious Activity', icon: <WarningIcon />, description: 'Unusual behavior or activity' },
+  { value: 'other', label: 'Other', icon: <NotificationIcon />, description: 'Other types of incidents' }
+];
+
+const severityLevels = [
+  { value: 'low', label: 'Low', color: '#4caf50', description: 'Minor issue, non-urgent' },
+  { value: 'medium', label: 'Medium', color: '#ff9800', description: 'Moderate issue, should be addressed' },
+  { value: 'high', label: 'High', color: '#f44336', description: 'Serious issue, requires prompt attention' },
+  { value: 'critical', label: 'Critical', color: '#d32f2f', description: 'Very serious, immediate action required' },
+  { value: 'emergency', label: 'Emergency', color: '#b71c1c', description: 'Life-threatening, emergency response needed' }
+];
+
+const priorityLevels = [
+  { value: 1, label: 'Highest', color: '#d32f2f' },
+  { value: 2, label: 'High', color: '#f44336' },
+  { value: 3, label: 'Medium', color: '#ff9800' },
+  { value: 4, label: 'Low', color: '#4caf50' },
+  { value: 5, label: 'Lowest', color: '#9e9e9e' }
+];
+
+interface LocationPickerProps {
+  onLocationSelect: (lat: number, lng: number) => void;
+  initialLocation?: { lat: number; lng: number };
+}
+
+const LocationPicker: React.FC<LocationPickerProps> = ({ onLocationSelect, initialLocation }) => {
+  const [position, setPosition] = useState<{ lat: number; lng: number } | null>(
+    initialLocation || null
+  );
+
+  const MapEvents = () => {
+    useMapEvents({
+      click(e) {
+        const { lat, lng } = e.latlng;
+        setPosition({ lat, lng });
+        onLocationSelect(lat, lng);
+      },
+    });
+    return null;
+  };
+
+  return (
+    <Box sx={{ height: '300px', width: '100%', border: '1px solid #ccc', borderRadius: 1 }}>
+      <MapContainer
+        center={position || [40.7831, -73.9712]}
+        zoom={13}
+        style={{ height: '100%', width: '100%' }}
+      >
+        <TileLayer
+          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
+        />
+        <MapEvents />
+        {position && (
+          <Marker
+            position={[position.lat, position.lng]}
+            icon={L.divIcon({
+              html: `<div style="background: #f44336; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white;"></div>`,
+              className: 'custom-marker',
+              iconSize: [20, 20],
+              iconAnchor: [10, 10],
+            })}
+          />
+        )}
+      </MapContainer>
+    </Box>
+  );
+};
+
+const EventSubmission: React.FC = () => {
+  const navigate = useNavigate();
+  const location = useLocation();
+  const [activeStep, setActiveStep] = useState(0);
+  const [formData, setFormData] = useState({
+    title: '',
+    description: '',
+    type: '',
+    severity: 'medium',
+    priority: 3,
+    location: {
+      coordinates: [0, 0],
+      address: '',
+      accuracy: 0
+    },
+    cameraId: '',
+    detectionId: '',
+    reporter: {
+      name: '',
+      email: '',
+      phone: '',
+      isAnonymous: false
+    },
+    tags: [] as string[],
+    source: 'user_report',
+    publiclyVisible: false,
+    media: {
+      images: [] as string[],
+      videos: [] as string[],
+      attachments: [] as any[]
+    }
+  });
+  const [errors, setErrors] = useState<any>({});
+  const [loading, setLoading] = useState(false);
+  const [success, setSuccess] = useState(false);
+  const [cameras, setCameras] = useState<any[]>([]);
+  const [newTag, setNewTag] = useState('');
+
+  // Check if we're promoting a detection
+  const detectionData = location.state?.detection;
+
+  useEffect(() => {
+    // Load cameras for selection
+    loadCameras();
+
+    // Pre-fill form if promoting from detection
+    if (detectionData) {
+      setFormData(prev => ({
+        ...prev,
+        title: `Detection: ${detectionData.type.replace('_', ' ')}`,
+        description: detectionData.description || `AI detected ${detectionData.type.replace('_', ' ')} with ${Math.round(detectionData.confidence * 100)}% confidence`,
+        type: mapDetectionTypeToEventType(detectionData.type),
+        severity: detectionData.severity || 'medium',
+        detectionId: detectionData._id,
+        location: {
+          coordinates: detectionData.location.coordinates,
+          address: detectionData.location.address || '',
+          accuracy: detectionData.location.accuracy || 0
+        },
+        cameraId: detectionData.cameraId,
+        source: 'ai_detection'
+      }));
+    }
+  }, [detectionData]);
+
+  const loadCameras = async () => {
+    try {
+      // Mock camera data - replace with actual API call
       const mockCameras = [
-        { _id: '1', name: 'Main Entrance', location: { address: 'Main St & 1st Ave' } },
-        { _id: '2', name: 'Parking Lot A', location: { address: 'Parking Area North' } },
-        { _id: '3', name: 'Emergency Exit', location: { address: 'Building Rear Exit' } }
-      ];
-      setCameras(mockCameras);
-    } catch (error) {
-      console.error('Failed to load cameras:', error);
-    }
-  };
-
-  const mapDetectionTypeToEventType = (detectionType: string) => {
-    const mapping: { [key: string]: string } = {
-      'motion_detected': 'suspicious_activity',
-      'person_detected': 'security_incident',
-      'vehicle_detected': 'traffic_violation',
-      'object_detected': 'suspicious_activity',
-      'user_submitted': 'user_report',
-      'ai_flagged': 'system_alert'
-    };
-    return mapping[detectionType] || 'other';
-  };
-
-  const handleInputChange = (field: string, value: any) => {
-    if (field.includes('.')) {
-      const [parent, child] = field.split('.');
-      setFormData(prev => ({
-        ...prev,
-        [parent]: {
-          ...(prev[parent as keyof typeof prev] as object),
-          [child]: value
-        }
-      }));
-    } else {
-      setFormData(prev => ({ ...prev, [field]: value }));
-    }
-    // Clear error for this field
-    if (errors[field]) {
-      setErrors((prev: any) => ({ ...prev, [field]: undefined }));
-    }
-  };
-
-  const handleLocationSelect = (lat: number, lng: number) => {
-    setFormData(prev => ({
-      ...prev,
-      location: {
-        ...prev.location,
-        coordinates: [lng, lat] // Note: GeoJSON format is [longitude, latitude]
-      }
-    }));
-  };
-
-  const handleAddTag = () => {
-    if (newTag.trim() && !formData.tags.includes(newTag.trim())) {
-      setFormData(prev => ({
-        ...prev,
-        tags: [...prev.tags, newTag.trim()]
-      }));
-      setNewTag('');
-    }
-  };
-
-  const handleRemoveTag = (tagToRemove: string) => {
-    setFormData(prev => ({
-      ...prev,
-      tags: prev.tags.filter(tag => tag !== tagToRemove)
-    }));
-  };
-
-  const validateStep = (step: number) => {
-    const newErrors: any = {};
-
-    if (step === 0) {
-      if (!formData.title.trim()) newErrors.title = 'Title is required';
-      if (!formData.type) newErrors.type = 'Event type is required';
-      if (!formData.severity) newErrors.severity = 'Severity is required';
-    }
-
-    if (step === 1) {
-      if (formData.location.coordinates[0] === 0 && formData.location.coordinates[1] === 0) {
-        newErrors.location = 'Please select a location on the map';
-      }
-    }
-
-    if (step === 3 && !formData.reporter.isAnonymous) {
-      if (!formData.reporter.name.trim()) newErrors['reporter.name'] = 'Name is required for non-anonymous reports';
-    }
-
-    setErrors(newErrors);
-    return Object.keys(newErrors).length === 0;
-  };
-
-  const handleNext = () => {
-    if (validateStep(activeStep)) {
-      setActiveStep((prevStep) => prevStep + 1);
-    }
-  };
-
-  const handleBack = () => {
-    setActiveStep((prevStep) => prevStep - 1);
-  };
-
-  const handleSubmit = async () => {
-    if (!validateStep(activeStep)) return;
-
-    setLoading(true);
-    try {
-      const response = await fetch('/api/events', {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-          // Add authorization header here
-        },
-        body: JSON.stringify(formData)
-      });
-
-      const data = await response.json();
-
-      if (response.ok) {
-        setSuccess(true);
-        // Reset form after successful submission
-        setTimeout(() => {
-          navigate('/events', { 
-            state: { 
-              message: 'Event submitted successfully!',
-              newEventId: data.data._id 
-            }
-          });
-        }, 2000);
-      } else {
-        setErrors(data.errors || { general: data.message });
-      }
-    } catch (error) {
-      console.error('Submission error:', error);
-      setErrors({ general: 'Failed to submit event. Please try again.' });
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  const steps = [
-    'Event Details',
-    'Location',
-    'Media & Additional Info',
-    'Reporter Information',
-    'Review & Submit'
-  ];
-
-  const getStepContent = (step: number) => {
-    switch (step) {
-      case 0:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Event Title"
-                value={formData.title}
-                onChange={(e) => handleInputChange('title', e.target.value)}
-                error={!!errors.title}
-                helperText={errors.title}
-                placeholder="Brief description of the event"
-              />
-            </Grid>
-            
-            <Grid item xs={12} md={6}>
-              <FormControl fullWidth error={!!errors.type}>
-                <InputLabel>Event Type</InputLabel>
-                <Select
-                  value={formData.type}
-                  label="Event Type"
-                  onChange={(e) => handleInputChange('type', e.target.value)}
-                >
-                  {eventTypes.map((type) => (
-                    <MenuItem key={type.value} value={type.value}>
-                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                        {type.icon}
-                        <Box>
-                          <Typography variant="body1">{type.label}</Typography>
-                          <Typography variant="caption" color="textSecondary">
-                            {type.description}
-                          </Typography>
-                        </Box>
-                      </Box>
-                    </MenuItem>
-                  ))}
-                </Select>
-              </FormControl>
-            </Grid>
-
-            <Grid item xs={12} md={6}>
-              <FormControl fullWidth>
-                <InputLabel>Severity</InputLabel>
-                <Select
-                  value={formData.severity}
-                  label="Severity"
-                  onChange={(e) => handleInputChange('severity', e.target.value)}
-                >
-                  {severityLevels.map((level) => (
-                    <MenuItem key={level.value} value={level.value}>
-                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                        <Box
-                          sx={{
-                            width: 12,
-                            height: 12,
-                            borderRadius: '50%',
-                            backgroundColor: level.color
-                          }}
-                        />
-                        <Box>
-                          <Typography variant="body1">{level.label}</Typography>
-                          <Typography variant="caption" color="textSecondary">
-                            {level.description}
-                          </Typography>
-                        </Box>
-                      </Box>
-                    </MenuItem>
-                  ))}
-                </Select>
-              </FormControl>
-            </Grid>
-
-            <Grid item xs={12}>
-              <FormControl fullWidth>
-                <InputLabel>Priority</InputLabel>
-                <Select
-                  value={formData.priority}
-                  label="Priority"
-                  onChange={(e) => handleInputChange('priority', e.target.value)}
-                >
-                  {priorityLevels.map((level) => (
-                    <MenuItem key={level.value} value={level.value}>
-                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                        <Box
-                          sx={{
-                            width: 12,
-                            height: 12,
-                            borderRadius: '50%',
-                            backgroundColor: level.color
-                          }}
-                        />
-                        <Typography>{level.label}</Typography>
-                      </Box>
-                    </MenuItem>
-                  ))}
-                </Select>
-              </FormControl>
-            </Grid>
-
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                multiline
-                rows={4}
-                label="Description"
-                value={formData.description}
-                onChange={(e) => handleInputChange('description', e.target.value)}
-                placeholder="Detailed description of the event, what happened, when, and any other relevant information..."
-                helperText="Provide as much detail as possible to help responders understand the situation"
-              />
-            </Grid>
-          </Grid>
-        );
-
-      case 1:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Select Event Location
-              </Typography>
-              <Typography variant="body2" color="textSecondary" paragraph>
-                Click on the map to select the exact location where the event occurred.
-              </Typography>
-            </Grid>
-            
-            <Grid item xs={12}>
-              <LocationPicker
-                onLocationSelect={handleLocationSelect}
-                initialLocation={
-                  formData.location.coordinates[0] !== 0 && formData.location.coordinates[1] !== 0
-                    ? { lat: formData.location.coordinates[1], lng: formData.location.coordinates[0] }
-                    : undefined
-                }
-              />
-              {errors.location && (
-                <Typography color="error" variant="caption">
-                  {errors.location}
-                </Typography>
-              )}
-            </Grid>
-
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Address (Optional)"
-                value={formData.location.address}
-                onChange={(e) => handleInputChange('location.address', e.target.value)}
-                placeholder="Street address or landmark description"
-              />
-            </Grid>
-
-            <Grid item xs={12}>
-              <FormControl fullWidth>
-                <Autocomplete
-                  options={cameras}
-                  getOptionLabel={(option) => `${option.name} - ${option.location?.address || 'No address'}`}
-                  value={cameras.find(cam => cam._id === formData.cameraId) || null}
-                  onChange={(event, newValue) => handleInputChange('cameraId', newValue?._id || '')}
-                  renderInput={(params) => (
-                    <TextField
-                      {...params}
-                      label="Associated Camera (Optional)"
-                      placeholder="Select the camera that captured this event"
-                    />
-                  )}
-                  renderOption={(props, option) => (
-                    <Box component="li" {...props}>
-                      <Avatar sx={{ mr: 2, bgcolor: 'primary.main' }}>
-                        <VideoIcon />
-                      </Avatar>
-                      <Box>
-                        <Typography variant="body1">{option.name}</Typography>
-                        <Typography variant="caption" color="textSecondary">
-                          {option.location?.address || 'No address available'}
-                        </Typography>
-                      </Box>
-                    </Box>
-                  )}
-                />
-              </FormControl>
-            </Grid>
-          </Grid>
-        );
-
-      case 2:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Media & Additional Information
-              </Typography>
-            </Grid>
-
-            <Grid item xs={12}>
-              <Paper sx={{ p: 2, border: '2px dashed #ccc' }}>
-                <Box sx={{ textAlign: 'center' }}>
-                  <UploadIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
-                  <Typography variant="body1" gutterBottom>
-                    Upload Photos or Videos
-                  </Typography>
-                  <Typography variant="body2" color="textSecondary" paragraph>
-                    Drag and drop files here or click to select
-                  </Typography>
-                  <Button variant="outlined" component="label">
-                    Select Files
-                    <input type="file" hidden multiple accept="image/*,video/*" />
-                  </Button>
-                </Box>
-              </Paper>
-            </Grid>
-
-            <Grid item xs={12}>
-              <Box sx={{ mb: 2 }}>
-                <Typography variant="body1" gutterBottom>
-                  Tags
-                </Typography>
-                <Box sx={{ display: 'flex', gap: 1, mb: 1, flexWrap: 'wrap' }}>
-                  {formData.tags.map((tag) => (
-                    <Chip
-                      key={tag}
-                      label={tag}
-                      onDelete={() => handleRemoveTag(tag)}
-                      color="primary"
-                      variant="outlined"
-                    />
-                  ))}
-                </Box>
-                <Box sx={{ display: 'flex', gap: 1 }}>
-                  <TextField
-                    size="small"
-                    label="Add tag"
-                    value={newTag}
-                    onChange={(e) => setNewTag(e.target.value)}
-                    onKeyPress={(e) => e.key === 'Enter' && handleAddTag()}
-                  />
-                  <Button onClick={handleAddTag}>Add</Button>
-                </Box>
-              </Box>
-            </Grid>
-
-            <Grid item xs={12}>
-              <FormControlLabel
-                control={
-                  <Switch
-                    checked={formData.publiclyVisible}
-                    onChange={(e) => handleInputChange('publiclyVisible', e.target.checked)}
-                  />
-                }
-                label="Make this event publicly visible"
-              />
-              <Typography variant="caption" display="block" color="textSecondary">
-                Public events may be visible to community members and in public feeds
-              </Typography>
-            </Grid>
-          </Grid>
-        );
-
-      case 3:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Reporter Information
-              </Typography>
-            </Grid>
-
-            <Grid item xs={12}>
-              <FormControlLabel
-                control={
-                  <Switch
-                    checked={formData.reporter.isAnonymous}
-                    onChange={(e) => handleInputChange('reporter.isAnonymous', e.target.checked)}
-                  />
-                }
-                label="Submit anonymously"
-              />
-              <Typography variant="caption" display="block" color="textSecondary">
-                Anonymous reports will not include your personal information
-              </Typography>
-            </Grid>
-
-            {!formData.reporter.isAnonymous && (
-              <>
-                <Grid item xs={12} md={6}>
-                  <TextField
-                    fullWidth
-                    label="Your Name"
-                    value={formData.reporter.name}
-                    onChange={(e) => handleInputChange('reporter.name', e.target.value)}
-                    error={!!errors['reporter.name']}
-                    helperText={errors['reporter.name']}
-                  />
-                </Grid>
-
-                <Grid item xs={12} md={6}>
-                  <TextField
-                    fullWidth
-                    label="Email (Optional)"
-                    type="email"
-                    value={formData.reporter.email}
-                    onChange={(e) => handleInputChange('reporter.email', e.target.value)}
-                    helperText="We'll use this to update you on the event status"
-                  />
-                </Grid>
-
-                <Grid item xs={12} md={6}>
-                  <TextField
-                    fullWidth
-                    label="Phone Number (Optional)"
-                    value={formData.reporter.phone}
-                    onChange={(e) => handleInputChange('reporter.phone', e.target.value)}
-                    helperText="For urgent follow-up if needed"
-                  />
-                </Grid>
-              </>
-            )}
-          </Grid>
-        );
-
-      case 4:
-        return (
-          <Grid container spacing={3}>
-            <Grid item xs={12}>
-              <Typography variant="h6" gutterBottom>
-                Review Your Submission
-              </Typography>
-            </Grid>
-
-            <Grid item xs={12}>
-              <Card variant="outlined">
-                <CardContent>
-                  <Grid container spacing={2}>
-                    <Grid item xs={12}>
-                      <Typography variant="h6">{formData.title}</Typography>
-                      <Typography color="textSecondary">{formData.description}</Typography>
-                    </Grid>
-                    
-                    <Grid item xs={6}>
-                      <Typography variant="subtitle2">Type:</Typography>
-                      <Typography>
-                        {eventTypes.find(t => t.value === formData.type)?.label || formData.type}
-                      </Typography>
-                    </Grid>
-                    
-                    <Grid item xs={6}>
-                      <Typography variant="subtitle2">Severity:</Typography>
-                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                        <Box
-                          sx={{
-                            width: 12,
-                            height: 12,
-                            borderRadius: '50%',
-                            backgroundColor: severityLevels.find(s => s.value === formData.severity)?.color
-                          }}
-                        />
-                        <Typography>{formData.severity.toUpperCase()}</Typography>
-                      </Box>
-                    </Grid>
-                    
-                    <Grid item xs={12}>
-                      <Typography variant="subtitle2">Location:</Typography>
-                      <Typography>
-                        {formData.location.address || `${formData.location.coordinates[1].toFixed(6)}, ${formData.location.coordinates[0].toFixed(6)}`}
-                      </Typography>
-                    </Grid>
-                    
-                    {formData.tags.length > 0 && (
-                      <Grid item xs={12}>
-                        <Typography variant="subtitle2">Tags:</Typography>
-                        <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap', mt: 1 }}>
-                          {formData.tags.map(tag => (
-                            <Chip key={tag} label={tag} size="small" />
-                          ))}
-                        </Box>
-                      </Grid>
-                    )}
-                  </Grid>
-                </CardContent>
-              </Card>
-            </Grid>
-
-            {errors.general && (
-              <Grid item xs={12}>
-                <Alert severity="error">{errors.general}</Alert>
-              </Grid>
-            )}
-
-            {success && (
-              <Grid item xs={12}>
-                <Alert severity="success" icon={<CheckIcon />}>
-                  Event submitted successfully! Redirecting to events page...
-                </Alert>
-              </Grid>
-            )}
-          </Grid>
-        );
-
-      default:
-        return 'Unknown step';
-    }
-  };
-
-  return (
-    <Box sx={{ maxWidth: 800, mx: 'auto', p: 3 }}>
-      <Card>
-        <CardContent>
-          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
-            <Typography variant="h4" component="h1">
-              {detectionData ? 'Promote Detection to Event' : 'Submit New Event'}
-            </Typography>
-            <IconButton onClick={() => navigate(-1)}>
-              <CloseIcon />
-            </IconButton>
-          </Box>
-
-          {detectionData && (
-            <Alert severity="info" sx={{ mb: 3 }}>
-              You are promoting an AI detection to a confirmed event. Some fields have been pre-filled based on the detection data.
-            </Alert>
-          )}
-
-          <Stepper activeStep={activeStep} orientation="vertical">
-            {steps.map((label, index) => (
-              <Step key={label}>
-                <StepLabel>{label}</StepLabel>
-                <StepContent>
-                  <Box sx={{ mt: 2, mb: 2 }}>
-                    {getStepContent(index)}
-                  </Box>
-                  <Box sx={{ mt: 3 }}>
-                    {index > 0 && (
-                      <Button
-                        onClick={handleBack}
-                        sx={{ mr: 1 }}
-                      >
-                        Back
-                      </Button>
-                    )}
-                    {index < steps.length - 1 ? (
-                      <Button
-                        variant="contained"
-                        onClick={handleNext}
-                      >
-                        Next
-                      </Button>
-                    ) : (
-                      <Button
-                        variant="contained"
-                        onClick={handleSubmit}
-                        disabled={loading || success}
-                      >
-                        {loading ? 'Submitting...' : 'Submit Event'}
-                      </Button>
-                    )}
-                  </Box>
-                </StepContent>
-              </Step>
-            ))}
-          </Stepper>
-        </CardContent>
-      </Card>
-    </Box>
-  );
-};
-
-export default EventSubmission;
+        { _id: '1', name: 'Main Entrance', location: { address: 'Main St & 1st Ave' } },
+        { _id: '2', name: 'Parking Lot A', location: { address: 'Parking Area North' } },
+        { _id: '3', name: 'Emergency Exit', location: { address: 'Building Rear Exit' } }
+      ];
+      setCameras(mockCameras);
+    } catch (error) {
+      console.error('Failed to load cameras:', error);
+    }
+  };
+
+  const mapDetectionTypeToEventType = (detectionType: string) => {
+    const mapping: { [key: string]: string } = {
+      'motion_detected': 'suspicious_activity',
+      'person_detected': 'security_incident',
+      'vehicle_detected': 'traffic_violation',
+      'object_detected': 'suspicious_activity',
+      'user_submitted': 'user_report',
+      'ai_flagged': 'system_alert'
+    };
+    return mapping[detectionType] || 'other';
+  };
+
+  const handleInputChange = (field: string, value: any) => {
+    if (field.includes('.')) {
+      const [parent, child] = field.split('.');
+      setFormData(prev => ({
+        ...prev,
+        [parent]: {
+          ...(prev[parent as keyof typeof prev] as object),
+          [child]: value
+        }
+      }));
+    } else {
+      setFormData(prev => ({ ...prev, [field]: value }));
+    }
+    // Clear error for this field
+    if (errors[field]) {
+      setErrors((prev: any) => ({ ...prev, [field]: undefined }));
+    }
+  };
+
+  const handleLocationSelect = (lat: number, lng: number) => {
+    setFormData(prev => ({
+      ...prev,
+      location: {
+        ...prev.location,
+        coordinates: [lng, lat] // Note: GeoJSON format is [longitude, latitude]
+      }
+    }));
+  };
+
+  const handleAddTag = () => {
+    if (newTag.trim() && !formData.tags.includes(newTag.trim())) {
+      setFormData(prev => ({
+        ...prev,
+        tags: [...prev.tags, newTag.trim()]
+      }));
+      setNewTag('');
+    }
+  };
+
+  const handleRemoveTag = (tagToRemove: string) => {
+    setFormData(prev => ({
+      ...prev,
+      tags: prev.tags.filter(tag => tag !== tagToRemove)
+    }));
+  };
+
+  const validateStep = (step: number) => {
+    const newErrors: any = {};
+
+    if (step === 0) {
+      if (!formData.title.trim()) newErrors.title = 'Title is required';
+      if (!formData.type) newErrors.type = 'Event type is required';
+      if (!formData.severity) newErrors.severity = 'Severity is required';
+    }
+
+    if (step === 1) {
+      if (formData.location.coordinates[0] === 0 && formData.location.coordinates[1] === 0) {
+        newErrors.location = 'Please select a location on the map';
+      }
+    }
+
+    if (step === 3 && !formData.reporter.isAnonymous) {
+      if (!formData.reporter.name.trim()) newErrors['reporter.name'] = 'Name is required for non-anonymous reports';
+    }
+
+    setErrors(newErrors);
+    return Object.keys(newErrors).length === 0;
+  };
+
+  const handleNext = () => {
+    if (validateStep(activeStep)) {
+      setActiveStep((prevStep) => prevStep + 1);
+    }
+  };
+
+  const handleBack = () => {
+    setActiveStep((prevStep) => prevStep - 1);
+  };
+
+  const handleSubmit = async () => {
+    if (!validateStep(activeStep)) return;
+
+    setLoading(true);
+    try {
+      const response = await fetch('/api/events', {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+          // Add authorization header here
+        },
+        body: JSON.stringify(formData)
+      });
+
+      const data = await response.json();
+
+      if (response.ok) {
+        setSuccess(true);
+        // Reset form after successful submission
+        setTimeout(() => {
+          navigate('/events', { 
+            state: { 
+              message: 'Event submitted successfully!',
+              newEventId: data.data._id 
+            }
+          });
+        }, 2000);
+      } else {
+        setErrors(data.errors || { general: data.message });
+      }
+    } catch (error) {
+      console.error('Submission error:', error);
+      setErrors({ general: 'Failed to submit event. Please try again.' });
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  const steps = [
+    'Event Details',
+    'Location',
+    'Media & Additional Info',
+    'Reporter Information',
+    'Review & Submit'
+  ];
+
+  const getStepContent = (step: number) => {
+    switch (step) {
+      case 0:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Event Title"
+                value={formData.title}
+                onChange={(e) => handleInputChange('title', e.target.value)}
+                error={!!errors.title}
+                helperText={errors.title}
+                placeholder="Brief description of the event"
+              />
+            </Grid>
+            
+            <Grid item xs={12} md={6}>
+              <FormControl fullWidth error={!!errors.type}>
+                <InputLabel>Event Type</InputLabel>
+                <Select
+                  value={formData.type}
+                  label="Event Type"
+                  onChange={(e) => handleInputChange('type', e.target.value)}
+                >
+                  {eventTypes.map((type) => (
+                    <MenuItem key={type.value} value={type.value}>
+                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                        {type.icon}
+                        <Box>
+                          <Typography variant="body1">{type.label}</Typography>
+                          <Typography variant="caption" color="textSecondary">
+                            {type.description}
+                          </Typography>
+                        </Box>
+                      </Box>
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            </Grid>
+
+            <Grid item xs={12} md={6}>
+              <FormControl fullWidth>
+                <InputLabel>Severity</InputLabel>
+                <Select
+                  value={formData.severity}
+                  label="Severity"
+                  onChange={(e) => handleInputChange('severity', e.target.value)}
+                >
+                  {severityLevels.map((level) => (
+                    <MenuItem key={level.value} value={level.value}>
+                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                        <Box
+                          sx={{
+                            width: 12,
+                            height: 12,
+                            borderRadius: '50%',
+                            backgroundColor: level.color
+                          }}
+                        />
+                        <Box>
+                          <Typography variant="body1">{level.label}</Typography>
+                          <Typography variant="caption" color="textSecondary">
+                            {level.description}
+                          </Typography>
+                        </Box>
+                      </Box>
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            </Grid>
+
+            <Grid item xs={12}>
+              <FormControl fullWidth>
+                <InputLabel>Priority</InputLabel>
+                <Select
+                  value={formData.priority}
+                  label="Priority"
+                  onChange={(e) => handleInputChange('priority', e.target.value)}
+                >
+                  {priorityLevels.map((level) => (
+                    <MenuItem key={level.value} value={level.value}>
+                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                        <Box
+                          sx={{
+                            width: 12,
+                            height: 12,
+                            borderRadius: '50%',
+                            backgroundColor: level.color
+                          }}
+                        />
+                        <Typography>{level.label}</Typography>
+                      </Box>
+                    </MenuItem>
+                  ))}
+                </Select>
+              </FormControl>
+            </Grid>
+
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                multiline
+                rows={4}
+                label="Description"
+                value={formData.description}
+                onChange={(e) => handleInputChange('description', e.target.value)}
+                placeholder="Detailed description of the event, what happened, when, and any other relevant information..."
+                helperText="Provide as much detail as possible to help responders understand the situation"
+              />
+            </Grid>
+          </Grid>
+        );
+
+      case 1:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Select Event Location
+              </Typography>
+              <Typography variant="body2" color="textSecondary" paragraph>
+                Click on the map to select the exact location where the event occurred.
+              </Typography>
+            </Grid>
+            
+            <Grid item xs={12}>
+              <LocationPicker
+                onLocationSelect={handleLocationSelect}
+                initialLocation={
+                  formData.location.coordinates[0] !== 0 && formData.location.coordinates[1] !== 0
+                    ? { lat: formData.location.coordinates[1], lng: formData.location.coordinates[0] }
+                    : undefined
+                }
+              />
+              {errors.location && (
+                <Typography color="error" variant="caption">
+                  {errors.location}
+                </Typography>
+              )}
+            </Grid>
+
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Address (Optional)"
+                value={formData.location.address}
+                onChange={(e) => handleInputChange('location.address', e.target.value)}
+                placeholder="Street address or landmark description"
+              />
+            </Grid>
+
+            <Grid item xs={12}>
+              <FormControl fullWidth>
+                <Autocomplete
+                  options={cameras}
+                  getOptionLabel={(option) => `${option.name} - ${option.location?.address || 'No address'}`}
+                  value={cameras.find(cam => cam._id === formData.cameraId) || null}
+                  onChange={(event, newValue) => handleInputChange('cameraId', newValue?._id || '')}
+                  renderInput={(params) => (
+                    <TextField
+                      {...params}
+                      label="Associated Camera (Optional)"
+                      placeholder="Select the camera that captured this event"
+                    />
+                  )}
+                  renderOption={(props, option) => (
+                    <Box component="li" {...props}>
+                      <Avatar sx={{ mr: 2, bgcolor: 'primary.main' }}>
+                        <VideoIcon />
+                      </Avatar>
+                      <Box>
+                        <Typography variant="body1">{option.name}</Typography>
+                        <Typography variant="caption" color="textSecondary">
+                          {option.location?.address || 'No address available'}
+                        </Typography>
+                      </Box>
+                    </Box>
+                  )}
+                />
+              </FormControl>
+            </Grid>
+          </Grid>
+        );
+
+      case 2:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Media & Additional Information
+              </Typography>
+            </Grid>
+
+            <Grid item xs={12}>
+              <Paper sx={{ p: 2, border: '2px dashed #ccc' }}>
+                <Box sx={{ textAlign: 'center' }}>
+                  <UploadIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
+                  <Typography variant="body1" gutterBottom>
+                    Upload Photos or Videos
+                  </Typography>
+                  <Typography variant="body2" color="textSecondary" paragraph>
+                    Drag and drop files here or click to select
+                  </Typography>
+                  <Button variant="outlined" component="label">
+                    Select Files
+                    <input type="file" hidden multiple accept="image/*,video/*" />
+                  </Button>
+                </Box>
+              </Paper>
+            </Grid>
+
+            <Grid item xs={12}>
+              <Box sx={{ mb: 2 }}>
+                <Typography variant="body1" gutterBottom>
+                  Tags
+                </Typography>
+                <Box sx={{ display: 'flex', gap: 1, mb: 1, flexWrap: 'wrap' }}>
+                  {formData.tags.map((tag) => (
+                    <Chip
+                      key={tag}
+                      label={tag}
+                      onDelete={() => handleRemoveTag(tag)}
+                      color="primary"
+                      variant="outlined"
+                    />
+                  ))}
+                </Box>
+                <Box sx={{ display: 'flex', gap: 1 }}>
+                  <TextField
+                    size="small"
+                    label="Add tag"
+                    value={newTag}
+                    onChange={(e) => setNewTag(e.target.value)}
+                    onKeyPress={(e) => e.key === 'Enter' && handleAddTag()}
+                  />
+                  <Button onClick={handleAddTag}>Add</Button>
+                </Box>
+              </Box>
+            </Grid>
+
+            <Grid item xs={12}>
+              <FormControlLabel
+                control={
+                  <Switch
+                    checked={formData.publiclyVisible}
+                    onChange={(e) => handleInputChange('publiclyVisible', e.target.checked)}
+                  />
+                }
+                label="Make this event publicly visible"
+              />
+              <Typography variant="caption" display="block" color="textSecondary">
+                Public events may be visible to community members and in public feeds
+              </Typography>
+            </Grid>
+          </Grid>
+        );
+
+      case 3:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Reporter Information
+              </Typography>
+            </Grid>
+
+            <Grid item xs={12}>
+              <FormControlLabel
+                control={
+                  <Switch
+                    checked={formData.reporter.isAnonymous}
+                    onChange={(e) => handleInputChange('reporter.isAnonymous', e.target.checked)}
+                  />
+                }
+                label="Submit anonymously"
+              />
+              <Typography variant="caption" display="block" color="textSecondary">
+                Anonymous reports will not include your personal information
+              </Typography>
+            </Grid>
+
+            {!formData.reporter.isAnonymous && (
+              <>
+                <Grid item xs={12} md={6}>
+                  <TextField
+                    fullWidth
+                    label="Your Name"
+                    value={formData.reporter.name}
+                    onChange={(e) => handleInputChange('reporter.name', e.target.value)}
+                    error={!!errors['reporter.name']}
+                    helperText={errors['reporter.name']}
+                  />
+                </Grid>
+
+                <Grid item xs={12} md={6}>
+                  <TextField
+                    fullWidth
+                    label="Email (Optional)"
+                    type="email"
+                    value={formData.reporter.email}
+                    onChange={(e) => handleInputChange('reporter.email', e.target.value)}
+                    helperText="We'll use this to update you on the event status"
+                  />
+                </Grid>
+
+                <Grid item xs={12} md={6}>
+                  <TextField
+                    fullWidth
+                    label="Phone Number (Optional)"
+                    value={formData.reporter.phone}
+                    onChange={(e) => handleInputChange('reporter.phone', e.target.value)}
+                    helperText="For urgent follow-up if needed"
+                  />
+                </Grid>
+              </>
+            )}
+          </Grid>
+        );
+
+      case 4:
+        return (
+          <Grid container spacing={3}>
+            <Grid item xs={12}>
+              <Typography variant="h6" gutterBottom>
+                Review Your Submission
+              </Typography>
+            </Grid>
+
+            <Grid item xs={12}>
+              <Card variant="outlined">
+                <CardContent>
+                  <Grid container spacing={2}>
+                    <Grid item xs={12}>
+                      <Typography variant="h6">{formData.title}</Typography>
+                      <Typography color="textSecondary">{formData.description}</Typography>
+                    </Grid>
+                    
+                    <Grid item xs={6}>
+                      <Typography variant="subtitle2">Type:</Typography>
+                      <Typography>
+                        {eventTypes.find(t => t.value === formData.type)?.label || formData.type}
+                      </Typography>
+                    </Grid>
+                    
+                    <Grid item xs={6}>
+                      <Typography variant="subtitle2">Severity:</Typography>
+                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                        <Box
+                          sx={{
+                            width: 12,
+                            height: 12,
+                            borderRadius: '50%',
+                            backgroundColor: severityLevels.find(s => s.value === formData.severity)?.color
+                          }}
+                        />
+                        <Typography>{formData.severity.toUpperCase()}</Typography>
+                      </Box>
+                    </Grid>
+                    
+                    <Grid item xs={12}>
+                      <Typography variant="subtitle2">Location:</Typography>
+                      <Typography>
+                        {formData.location.address || `${formData.location.coordinates[1].toFixed(6)}, ${formData.location.coordinates[0].toFixed(6)}`}
+                      </Typography>
+                    </Grid>
+                    
+                    {formData.tags.length > 0 && (
+                      <Grid item xs={12}>
+                        <Typography variant="subtitle2">Tags:</Typography>
+                        <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap', mt: 1 }}>
+                          {formData.tags.map(tag => (
+                            <Chip key={tag} label={tag} size="small" />
+                          ))}
+                        </Box>
+                      </Grid>
+                    )}
+                  </Grid>
+                </CardContent>
+              </Card>
+            </Grid>
+
+            {errors.general && (
+              <Grid item xs={12}>
+                <Alert severity="error">{errors.general}</Alert>
+              </Grid>
+            )}
+
+            {success && (
+              <Grid item xs={12}>
+                <Alert severity="success" icon={<CheckIcon />}>
+                  Event submitted successfully! Redirecting to events page...
+                </Alert>
+              </Grid>
+            )}
+          </Grid>
+        );
+
+      default:
+        return 'Unknown step';
+    }
+  };
+
+  return (
+    <Box sx={{ maxWidth: 800, mx: 'auto', p: 3 }}>
+      <Card>
+        <CardContent>
+          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
+            <Typography variant="h4" component="h1">
+              {detectionData ? 'Promote Detection to Event' : 'Submit New Event'}
+            </Typography>
+            <IconButton onClick={() => navigate(-1)}>
+              <CloseIcon />
+            </IconButton>
+          </Box>
+
+          {detectionData && (
+            <Alert severity="info" sx={{ mb: 3 }}>
+              You are promoting an AI detection to a confirmed event. Some fields have been pre-filled based on the detection data.
+            </Alert>
+          )}
+
+          <Stepper activeStep={activeStep} orientation="vertical">
+            {steps.map((label, index) => (
+              <Step key={label}>
+                <StepLabel>{label}</StepLabel>
+                <StepContent>
+                  <Box sx={{ mt: 2, mb: 2 }}>
+                    {getStepContent(index)}
+                  </Box>
+                  <Box sx={{ mt: 3 }}>
+                    {index > 0 && (
+                      <Button
+                        onClick={handleBack}
+                        sx={{ mr: 1 }}
+                      >
+                        Back
+                      </Button>
+                    )}
+                    {index < steps.length - 1 ? (
+                      <Button
+                        variant="contained"
+                        onClick={handleNext}
+                      >
+                        Next
+                      </Button>
+                    ) : (
+                      <Button
+                        variant="contained"
+                        onClick={handleSubmit}
+                        disabled={loading || success}
+                      >
+                        {loading ? 'Submitting...' : 'Submit Event'}
+                      </Button>
+                    )}
+                  </Box>
+                </StepContent>
+              </Step>
+            ))}
+          </Stepper>
+        </CardContent>
+      </Card>
+    </Box>
+  );
+};
+
+export default EventSubmission;
diff --git a/event-monitoring-mvp/frontend/src/pages/Events.tsx b/event-monitoring-mvp/frontend/src/pages/Events.tsx
index b0572f4..b9c1c4f 100644
--- a/event-monitoring-mvp/frontend/src/pages/Events.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/Events.tsx
@@ -1,259 +1,259 @@
-import React, { useState } from 'react';
-import {
-  Box,
-  Typography,
-  Paper,
-  Table,
-  TableBody,
-  TableCell,
-  TableContainer,
-  TableHead,
-  TableRow,
-  Chip,
-  IconButton,
-  Button,
-  TextField,
-  Grid,
-  MenuItem,
-  Pagination,
-} from '@mui/material';
-import {
-  Visibility as VisibilityIcon,
-  CheckCircle as CheckCircleIcon,
-  Assignment as AssignmentIcon,
-  Add as AddIcon,
-} from '@mui/icons-material';
-import { useNavigate } from 'react-router-dom';
-
-const Events: React.FC = () => {
-  const navigate = useNavigate();
-  const [filters, setFilters] = useState({
-    status: '',
-    type: '',
-    severity: '',
-  });
-  const [page, setPage] = useState(1);
-
-  // Mock data - replace with real API calls
-  const mockEvents = [
-    {
-      id: '1',
-      title: 'Person Detected',
-      type: 'person_detected',
-      severity: 'medium',
-      status: 'open',
-      camera: 'Front Gate Camera',
-      timestamp: '2025-12-12T10:30:00Z',
-      confidence: 0.85,
-    },
-    {
-      id: '2',
-      title: 'Vehicle Detected',
-      type: 'vehicle_detected',
-      severity: 'low',
-      status: 'acknowledged',
-      camera: 'Parking Lot Camera',
-      timestamp: '2025-12-12T10:25:00Z',
-      confidence: 0.92,
-    },
-    {
-      id: '3',
-      title: 'Unauthorized Access',
-      type: 'unauthorized_access',
-      severity: 'high',
-      status: 'investigating',
-      camera: 'Side Entrance Camera',
-      timestamp: '2025-12-12T10:18:00Z',
-      confidence: 0.78,
-    },
-  ];
-
-  const getSeverityColor = (severity: string) => {
-    switch (severity) {
-      case 'critical': return 'error';
-      case 'high': return 'warning';
-      case 'medium': return 'info';
-      case 'low': return 'success';
-      default: return 'default';
-    }
-  };
-
-  const getStatusColor = (status: string) => {
-    switch (status) {
-      case 'open': return 'error';
-      case 'acknowledged': return 'warning';
-      case 'investigating': return 'info';
-      case 'resolved': return 'success';
-      case 'closed': return 'default';
-      default: return 'default';
-    }
-  };
-
-  const formatTimestamp = (timestamp: string) => {
-    return new Date(timestamp).toLocaleString();
-  };
-
-  return (
-    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
-      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
-        <Box>
-          <Typography variant="h4" gutterBottom fontWeight="bold">
-            Event Management
-          </Typography>
-          <Typography variant="subtitle1" color="text.secondary" gutterBottom>
-            Monitor and manage security events from your camera network.
-          </Typography>
-        </Box>
-        <Button
-          variant="contained"
-          startIcon={<AddIcon />}
-          onClick={() => navigate('/events/submit')}
-          sx={{ height: 'fit-content' }}
-        >
-          Submit Event
-        </Button>
-      </Box>
-
-      {/* Filters */}
-      <Paper sx={{ p: 3, mt: 3 }}>
-        <Typography variant="h6" gutterBottom>
-          Filters
-        </Typography>
-        <Grid container spacing={3}>
-          <Grid item xs={12} sm={6} md={3}>
-            <TextField
-              fullWidth
-              select
-              label="Status"
-              value={filters.status}
-              onChange={(e) => setFilters({ ...filters, status: e.target.value })}
-            >
-              <MenuItem value="">All Statuses</MenuItem>
-              <MenuItem value="open">Open</MenuItem>
-              <MenuItem value="acknowledged">Acknowledged</MenuItem>
-              <MenuItem value="investigating">Investigating</MenuItem>
-              <MenuItem value="resolved">Resolved</MenuItem>
-              <MenuItem value="closed">Closed</MenuItem>
-            </TextField>
-          </Grid>
-          <Grid item xs={12} sm={6} md={3}>
-            <TextField
-              fullWidth
-              select
-              label="Type"
-              value={filters.type}
-              onChange={(e) => setFilters({ ...filters, type: e.target.value })}
-            >
-              <MenuItem value="">All Types</MenuItem>
-              <MenuItem value="person_detected">Person Detected</MenuItem>
-              <MenuItem value="vehicle_detected">Vehicle Detected</MenuItem>
-              <MenuItem value="motion_detected">Motion Detected</MenuItem>
-              <MenuItem value="unauthorized_access">Unauthorized Access</MenuItem>
-              <MenuItem value="other">Other</MenuItem>
-            </TextField>
-          </Grid>
-          <Grid item xs={12} sm={6} md={3}>
-            <TextField
-              fullWidth
-              select
-              label="Severity"
-              value={filters.severity}
-              onChange={(e) => setFilters({ ...filters, severity: e.target.value })}
-            >
-              <MenuItem value="">All Severities</MenuItem>
-              <MenuItem value="critical">Critical</MenuItem>
-              <MenuItem value="high">High</MenuItem>
-              <MenuItem value="medium">Medium</MenuItem>
-              <MenuItem value="low">Low</MenuItem>
-            </TextField>
-          </Grid>
-          <Grid item xs={12} sm={6} md={3}>
-            <Button
-              variant="contained"
-              fullWidth
-              onClick={() => setFilters({ status: '', type: '', severity: '' })}
-              sx={{ height: '56px' }}
-            >
-              Clear Filters
-            </Button>
-          </Grid>
-        </Grid>
-      </Paper>
-
-      {/* Events Table */}
-      <TableContainer component={Paper} sx={{ mt: 3 }}>
-        <Table>
-          <TableHead>
-            <TableRow>
-              <TableCell>Event</TableCell>
-              <TableCell>Type</TableCell>
-              <TableCell>Severity</TableCell>
-              <TableCell>Status</TableCell>
-              <TableCell>Camera</TableCell>
-              <TableCell>Timestamp</TableCell>
-              <TableCell>Confidence</TableCell>
-              <TableCell align="center">Actions</TableCell>
-            </TableRow>
-          </TableHead>
-          <TableBody>
-            {mockEvents.map((event) => (
-              <TableRow key={event.id} hover>
-                <TableCell>
-                  <Typography variant="subtitle2">{event.title}</Typography>
-                </TableCell>
-                <TableCell>
-                  <Chip
-                    label={event.type.replace('_', ' ')}
-                    size="small"
-                    variant="outlined"
-                  />
-                </TableCell>
-                <TableCell>
-                  <Chip
-                    label={event.severity}
-                    size="small"
-                    color={getSeverityColor(event.severity) as any}
-                  />
-                </TableCell>
-                <TableCell>
-                  <Chip
-                    label={event.status}
-                    size="small"
-                    color={getStatusColor(event.status) as any}
-                    variant="filled"
-                  />
-                </TableCell>
-                <TableCell>{event.camera}</TableCell>
-                <TableCell>{formatTimestamp(event.timestamp)}</TableCell>
-                <TableCell>{(event.confidence * 100).toFixed(1)}%</TableCell>
-                <TableCell align="center">
-                  <IconButton size="small" title="View Details">
-                    <VisibilityIcon />
-                  </IconButton>
-                  <IconButton size="small" title="Acknowledge">
-                    <CheckCircleIcon />
-                  </IconButton>
-                  <IconButton size="small" title="Assign">
-                    <AssignmentIcon />
-                  </IconButton>
-                </TableCell>
-              </TableRow>
-            ))}
-          </TableBody>
-        </Table>
-      </TableContainer>
-
-      {/* Pagination */}
-      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
-        <Pagination
-          count={10}
-          page={page}
-          onChange={(_, newPage) => setPage(newPage)}
-          color="primary"
-        />
-      </Box>
-    </Box>
-  );
-};
-
-export default Events;
\ No newline at end of file
+import React, { useState } from 'react';
+import {
+  Box,
+  Typography,
+  Paper,
+  Table,
+  TableBody,
+  TableCell,
+  TableContainer,
+  TableHead,
+  TableRow,
+  Chip,
+  IconButton,
+  Button,
+  TextField,
+  Grid,
+  MenuItem,
+  Pagination,
+} from '@mui/material';
+import {
+  Visibility as VisibilityIcon,
+  CheckCircle as CheckCircleIcon,
+  Assignment as AssignmentIcon,
+  Add as AddIcon,
+} from '@mui/icons-material';
+import { useNavigate } from 'react-router-dom';
+
+const Events: React.FC = () => {
+  const navigate = useNavigate();
+  const [filters, setFilters] = useState({
+    status: '',
+    type: '',
+    severity: '',
+  });
+  const [page, setPage] = useState(1);
+
+  // Mock data - replace with real API calls
+const mockEvents = [
+    {
+      id: '1',
+      title: 'Person Detected',
+      type: 'person_detected',
+      severity: 'medium',
+      status: 'open',
+      camera: 'Front Gate Camera',
+      timestamp: '2025-12-12T10:30:00Z',
+      confidence: 0.85,
+    },
+    {
+      id: '2',
+      title: 'Vehicle Detected',
+      type: 'vehicle_detected',
+      severity: 'low',
+      status: 'acknowledged',
+      camera: 'Parking Lot Camera',
+      timestamp: '2025-12-12T10:25:00Z',
+      confidence: 0.92,
+    },
+    {
+      id: '3',
+      title: 'Unauthorized Access',
+      type: 'unauthorized_access',
+      severity: 'high',
+      status: 'investigating',
+      camera: 'Side Entrance Camera',
+      timestamp: '2025-12-12T10:18:00Z',
+      confidence: 0.78,
+    },
+  ];
+
+  const getSeverityColor = (severity: string) => {
+    switch (severity) {
+      case 'critical': return 'error';
+      case 'high': return 'warning';
+      case 'medium': return 'info';
+      case 'low': return 'success';
+      default: return 'default';
+    }
+  };
+
+  const getStatusColor = (status: string) => {
+    switch (status) {
+      case 'open': return 'error';
+      case 'acknowledged': return 'warning';
+      case 'investigating': return 'info';
+      case 'resolved': return 'success';
+      case 'closed': return 'default';
+      default: return 'default';
+    }
+  };
+
+  const formatTimestamp = (timestamp: string) => {
+    return new Date(timestamp).toLocaleString();
+  };
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
+      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
+        <Box>
+          <Typography variant="h4" gutterBottom fontWeight="bold">
+            Event Management
+          </Typography>
+          <Typography variant="subtitle1" color="text.secondary" gutterBottom>
+            Monitor and manage security events from your camera network.
+          </Typography>
+        </Box>
+        <Button
+          variant="contained"
+          startIcon={<AddIcon />}
+          onClick={() => navigate('/events/submit')}
+          sx={{ height: 'fit-content' }}
+        >
+          Submit Event
+        </Button>
+      </Box>
+
+      {/* Filters */}
+      <Paper sx={{ p: 3, mt: 3 }}>
+        <Typography variant="h6" gutterBottom>
+          Filters
+        </Typography>
+        <Grid container spacing={3}>
+          <Grid item xs={12} sm={6} md={3}>
+            <TextField
+              fullWidth
+              select
+              label="Status"
+              value={filters.status}
+              onChange={(e) => setFilters({ ...filters, status: e.target.value })}
+            >
+              <MenuItem value="">All Statuses</MenuItem>
+              <MenuItem value="open">Open</MenuItem>
+              <MenuItem value="acknowledged">Acknowledged</MenuItem>
+              <MenuItem value="investigating">Investigating</MenuItem>
+              <MenuItem value="resolved">Resolved</MenuItem>
+              <MenuItem value="closed">Closed</MenuItem>
+            </TextField>
+          </Grid>
+          <Grid item xs={12} sm={6} md={3}>
+            <TextField
+              fullWidth
+              select
+              label="Type"
+              value={filters.type}
+              onChange={(e) => setFilters({ ...filters, type: e.target.value })}
+            >
+              <MenuItem value="">All Types</MenuItem>
+              <MenuItem value="person_detected">Person Detected</MenuItem>
+              <MenuItem value="vehicle_detected">Vehicle Detected</MenuItem>
+              <MenuItem value="motion_detected">Motion Detected</MenuItem>
+              <MenuItem value="unauthorized_access">Unauthorized Access</MenuItem>
+              <MenuItem value="other">Other</MenuItem>
+            </TextField>
+          </Grid>
+          <Grid item xs={12} sm={6} md={3}>
+            <TextField
+              fullWidth
+              select
+              label="Severity"
+              value={filters.severity}
+              onChange={(e) => setFilters({ ...filters, severity: e.target.value })}
+            >
+              <MenuItem value="">All Severities</MenuItem>
+              <MenuItem value="critical">Critical</MenuItem>
+              <MenuItem value="high">High</MenuItem>
+              <MenuItem value="medium">Medium</MenuItem>
+              <MenuItem value="low">Low</MenuItem>
+            </TextField>
+          </Grid>
+          <Grid item xs={12} sm={6} md={3}>
+            <Button
+              variant="contained"
+              fullWidth
+              onClick={() => setFilters({ status: '', type: '', severity: '' })}
+              sx={{ height: '56px' }}
+            >
+              Clear Filters
+            </Button>
+          </Grid>
+        </Grid>
+      </Paper>
+
+      {/* Events Table */}
+      <TableContainer component={Paper} sx={{ mt: 3 }}>
+        <Table>
+          <TableHead>
+            <TableRow>
+              <TableCell>Event</TableCell>
+              <TableCell>Type</TableCell>
+              <TableCell>Severity</TableCell>
+              <TableCell>Status</TableCell>
+              <TableCell>Camera</TableCell>
+              <TableCell>Timestamp</TableCell>
+              <TableCell>Confidence</TableCell>
+              <TableCell align="center">Actions</TableCell>
+            </TableRow>
+          </TableHead>
+          <TableBody>
+            {mockEvents.map((event) => (
+              <TableRow key={event.id} hover>
+                <TableCell>
+                  <Typography variant="subtitle2">{event.title}</Typography>
+                </TableCell>
+                <TableCell>
+                  <Chip
+                    label={event.type.replace('_', ' ')}
+                    size="small"
+                    variant="outlined"
+                  />
+                </TableCell>
+                <TableCell>
+                  <Chip
+                    label={event.severity}
+                    size="small"
+                    color={getSeverityColor(event.severity) as any}
+                  />
+                </TableCell>
+                <TableCell>
+                  <Chip
+                    label={event.status}
+                    size="small"
+                    color={getStatusColor(event.status) as any}
+                    variant="filled"
+                  />
+                </TableCell>
+                <TableCell>{event.camera}</TableCell>
+                <TableCell>{formatTimestamp(event.timestamp)}</TableCell>
+                <TableCell>{(event.confidence * 100).toFixed(1)}%</TableCell>
+                <TableCell align="center">
+                  <IconButton size="small" title="View Details">
+                    <VisibilityIcon />
+                  </IconButton>
+                  <IconButton size="small" title="Acknowledge">
+                    <CheckCircleIcon />
+                  </IconButton>
+                  <IconButton size="small" title="Assign">
+                    <AssignmentIcon />
+                  </IconButton>
+                </TableCell>
+              </TableRow>
+            ))}
+          </TableBody>
+        </Table>
+      </TableContainer>
+
+      {/* Pagination */}
+      <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
+        <Pagination
+          count={10}
+          page={page}
+          onChange={(_, newPage) => setPage(newPage)}
+          color="primary"
+        />
+      </Box>
+    </Box>
+  );
+};
+
+export default Events;
diff --git a/event-monitoring-mvp/frontend/src/pages/LiveView.tsx b/event-monitoring-mvp/frontend/src/pages/LiveView.tsx
index 1af3d4f..f10f973 100644
--- a/event-monitoring-mvp/frontend/src/pages/LiveView.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/LiveView.tsx
@@ -1,101 +1,275 @@
-import React, { useState } from 'react';
+import React, { useState, useEffect, useRef } from 'react';
 import {
-  Box,
-  Typography,
-  Grid,
-  Paper,
-  Card,
-  CardContent,
-  CardHeader,
-  IconButton,
-  Button,
-  Chip,
-  Switch,
-  FormControlLabel,
-  Dialog,
-  DialogTitle,
-  DialogContent,
-} from '@mui/material';
-import {
-  Fullscreen as FullscreenIcon,
-  VolumeUp as VolumeUpIcon,
-  Settings as SettingsIcon,
-  PlayArrow as PlayArrowIcon,
-  Pause as PauseIcon,
+  Box,
+  Typography,
+  Grid,
+  Paper,
+  Card,
+  CardContent,
+  CardHeader,
+  CardActions,
+  IconButton,
+  Button,
+  Chip,
+  Switch,
+  FormControlLabel,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  CircularProgress,
+} from '@mui/material';
+import {
+  Fullscreen as FullscreenIcon,
+  VolumeUp as VolumeUpIcon,
+  Settings as SettingsIcon,
+  PlayArrow as PlayArrowIcon,
+  Pause as PauseIcon,
 } from '@mui/icons-material';
 
-const LiveView: React.FC = () => {
-  const [fullscreenCamera, setFullscreenCamera] = useState<string | null>(null);
-  const [aiDetectionEnabled, setAiDetectionEnabled] = useState(true);
-  const [selectedCamera, setSelectedCamera] = useState<string | null>(null);
-
-  // Mock camera data
-  const cameras = [
-    {
-      id: '1',
-      name: 'Front Gate Camera',
-      status: 'online',
-      streamUrl: 'rtsp://192.168.1.100:554/stream',
-      aiActive: true,
-      detections: 3,
-    },
-    {
-      id: '2',
-      name: 'Parking Lot Camera',
-      status: 'online',
-      streamUrl: 'rtsp://192.168.1.101:554/stream',
-      aiActive: true,
-      detections: 1,
-    },
-    {
-      id: '3',
-      name: 'Side Entrance Camera',
-      status: 'offline',
-      streamUrl: 'rtsp://192.168.1.102:554/stream',
-      aiActive: false,
-      detections: 0,
-    },
-    {
-      id: '4',
-      name: 'Back Yard Camera',
-      status: 'online',
-      streamUrl: 'rtsp://192.168.1.103:554/stream',
-      aiActive: true,
-      detections: 0,
-    },
-  ];
-
+import { getCameras, getCameraVmsStreams } from '../services/cameraService';
+import Hls from 'hls.js';
+
+/**
+ * Camera type used by LiveView.
+ * Matches the backend camera model fields we rely on in the UI.
+ */
+interface Camera {
+  _id: string;
+  name: string;
+  status: 'online' | 'offline' | 'maintenance';
+  streamUrl: string;
+}
+
+/**
+ * Stream info contract from backend:
+ * GET /api/cameras/:id/vms/streams
+ *
+ * For Shinobi (when camera is connected to a VMS server + monitor):
+ * - liveEmbedUrl: browser-embeddable stream
+ * - liveHlsUrl / snapshotUrl: useful later (playback/thumbnail)
+ */
+interface CameraStreams {
+  cameraId: string;
+  rtspUrl: string;
+  vms: any | null;
+  liveEmbedUrl: string | null;
+  liveHlsUrl: string | null;
+  snapshotUrl: string | null;
+  playbackUrl: string | null;
+}
+
+const LiveView: React.FC = () => {
+    const [fullscreenCamera, setFullscreenCamera] = useState<string | null>(null);
+    const [aiDetectionEnabled, setAiDetectionEnabled] = useState(true);
+
+    // Real cameras from backend
+    const [cameras, setCameras] = useState<Camera[]>([]);
+    const [loading, setLoading] = useState(true);
+
+    // TEST-ONLY: Streams info dialog prints raw stream JSON for validation.
+    const [streamsOpen, setStreamsOpen] = useState(false);
+    const [streamsText, setStreamsText] = useState<string>('');
+
+    /**
+     * Live playback state (per camera)
+     * - We only fetch stream URLs when the user clicks Play.
+     * - We cache the response so repeated Play doesn't refetch.
+     */
+    const [streamsByCameraId, setStreamsByCameraId] = useState<Record<string, CameraStreams | null>>({});
+    const [playingByCameraId, setPlayingByCameraId] = useState<Record<string, boolean>>({});
+    const [streamLoadingCameraId, setStreamLoadingCameraId] = useState<string | null>(null);
+
+
+  /**
+   * Load cameras from backend (replaces mock data).
+   */
+  useEffect(() => {
+    const fetch = async () => {
+      try {
+        setLoading(true);
+        const list = await getCameras();
+        setCameras(list);
+      } catch (err) {
+        console.error('Failed to load cameras:', err);
+        alert((err as any)?.message || 'Failed to load cameras');
+      } finally {
+        setLoading(false);
+      }
+    };
+
+    fetch();
+  }, []);
+
+    /**
+   * Fetch VMS stream info for a camera and show it (debug/testing).
+   */
+    const handleShowStreams = async (camera: Camera) => {
+      try {
+        const data = await getCameraVmsStreams(camera._id);
+        setStreamsText(JSON.stringify(data, null, 2));
+        setStreamsOpen(true);
+      } catch (err) {
+        console.error('Failed to fetch streams:', err);
+        alert((err as any)?.message || 'Failed to fetch streams');
+      }
+    };
+
+    /**
+     * Start live playback for a single camera.
+     * - Fetch stream URLs once (cached).
+     * - Then mark the camera as "playing" so the iframe is rendered.
+     */
+    const handlePlay = async (camera: Camera) => {
+      try {
+        // If we already have streams cached, just start playing.
+        if (streamsByCameraId[camera._id]) {
+          setPlayingByCameraId(prev => ({ ...prev, [camera._id]: true }));
+          return;
+        }
+
+        setStreamLoadingCameraId(camera._id);
+
+        const data = (await getCameraVmsStreams(camera._id)) as CameraStreams;
+        setStreamsByCameraId(prev => ({ ...prev, [camera._id]: data }));
+        setPlayingByCameraId(prev => ({ ...prev, [camera._id]: true }));
+      } catch (err) {
+        console.error('Failed to start stream:', err);
+        alert((err as any)?.message || 'Failed to start stream');
+      } finally {
+        setStreamLoadingCameraId(null);
+      }
+    };
+
+  /**
+   * Stop live playback (removes iframe, keeps cached URLs).
+   */
+  const handlePause = (camera: Camera) => {
+    setPlayingByCameraId(prev => ({ ...prev, [camera._id]: false }));
+  };
+
+
   const VideoPlayer: React.FC<{
-    camera: any;
+    camera: Camera;
     isFullscreen?: boolean;
-  }> = ({ camera, isFullscreen = false }) => (
+  }> = ({ camera, isFullscreen = false }) => {
+    const isPlaying = Boolean(playingByCameraId[camera._id]);
+    const streams = streamsByCameraId[camera._id];
+    const embedUrl = streams?.liveEmbedUrl || null;
+    const liveHlsUrl = streams?.liveHlsUrl || null;
+    const isLoading = streamLoadingCameraId === camera._id;
+    const videoRef = useRef<HTMLVideoElement | null>(null);
+
+    useEffect(() => {
+      if (!isPlaying || !liveHlsUrl || !videoRef.current) {
+        return;
+      }
+
+      // Prefer HLS playback when available (more reliable than iframe).
+      if (videoRef.current.canPlayType('application/vnd.apple.mpegurl')) {
+        videoRef.current.src = liveHlsUrl;
+        videoRef.current.play().catch(() => undefined);
+        return;
+      }
+
+      if (Hls.isSupported()) {
+        const hls = new Hls();
+        hls.loadSource(liveHlsUrl);
+        hls.attachMedia(videoRef.current);
+        hls.on(Hls.Events.MANIFEST_PARSED, () => {
+          videoRef.current?.play().catch(() => undefined);
+        });
+
+        return () => {
+          hls.destroy();
+        };
+      }
+    }, [isPlaying, liveHlsUrl]);
+
+    const renderPlayer = () => {
+      // While fetching stream URLs
+      if (isLoading) {
+        return (
+          <Box sx={{ color: 'white', textAlign: 'center' }}>
+            <CircularProgress />
+            <Typography variant="body2" sx={{ mt: 1 }}>
+              Loading stream...
+            </Typography>
+          </Box>
+        );
+      }
+
+      // When playing and we have a browser-usable HLS URL
+      if (isPlaying && liveHlsUrl) {
+        return (
+          <Box sx={{ width: '100%', height: '100%' }}>
+            <video
+              ref={videoRef}
+              controls
+              playsInline
+              style={{ width: '100%', height: '100%', backgroundColor: '#000' }}
+            />
+          </Box>
+        );
+      }
+
+      // Fallback to iframe embed if HLS is missing
+      if (isPlaying && embedUrl) {
+        return (
+          <Box sx={{ width: '100%', height: '100%' }}>
+            <iframe
+              title={`live-${camera._id}`}
+              src={embedUrl}
+              style={{ width: '100%', height: '100%', border: 0 }}
+              allow="autoplay; fullscreen"
+            />
+          </Box>
+        );
+      }
+
+      // Default state: not playing yet (or no embed URL available)
+      return (
+        <Box sx={{ color: 'white', textAlign: 'center' }}>
+          <PlayArrowIcon sx={{ fontSize: 48, mb: 1 }} />
+          <Typography variant="body2">
+            {streams && !embedUrl && !liveHlsUrl
+              ? 'No VMS stream available for this camera'
+              : 'Click Play to load stream'}
+          </Typography>
+          <Typography variant="caption" display="block">
+            {camera.streamUrl}
+          </Typography>
+        </Box>
+      );
+    };
+
+    return (
     <Card sx={{ height: '100%' }}>
       <CardHeader
         title={camera.name}
-        action={
-          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-            <Chip
-              label={camera.status}
-              size="small"
-              color={camera.status === 'online' ? 'success' : 'error'}
-            />
-            {camera.aiActive && (
-              <Chip
-                label={`${camera.detections} detections`}
-                size="small"
-                color="info"
-              />
-            )}
-            <IconButton
-              size="small"
-              onClick={() => setFullscreenCamera(isFullscreen ? null : camera.id)}
-            >
-              <FullscreenIcon />
-            </IconButton>
-          </Box>
-        }
-        sx={{ pb: 1 }}
-      />
+        action={
+          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+            <Chip
+              label={camera.status}
+              size="small"
+              color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
+            />
+
+            {/* LiveView does not have per-camera AI state yet; show global toggle state only */}
+            {aiDetectionEnabled && (
+              <Chip label="AI ENABLED" size="small" color="info" />
+            )}
+
+            <IconButton
+              size="small"
+              onClick={() => setFullscreenCamera(isFullscreen ? null : camera._id)}
+            >
+              <FullscreenIcon />
+            </IconButton>
+          </Box>
+        }
+        sx={{ pb: 1 }}
+      />
+
       <CardContent sx={{ pt: 0 }}>
         <Box
           sx={{
@@ -110,143 +284,177 @@ const LiveView: React.FC = () => {
           }}
         >
           {camera.status === 'online' ? (
-            <Box sx={{ color: 'white', textAlign: 'center' }}>
-              <PlayArrowIcon sx={{ fontSize: 48, mb: 1 }} />
-              <Typography variant="body2">
-                Live Stream
-              </Typography>
-              <Typography variant="caption" display="block">
-                {camera.streamUrl}
-              </Typography>
-            </Box>
+            renderPlayer()
           ) : (
             <Box sx={{ color: 'gray', textAlign: 'center' }}>
-              <Typography variant="body2">
-                Camera Offline
-              </Typography>
-            </Box>
-          )}
-          
-          {/* Detection overlay (when AI is active) */}
-          {camera.aiActive && camera.status === 'online' && (
-            <Box
-              sx={{
-                position: 'absolute',
-                top: 10,
-                left: 10,
-                backgroundColor: 'rgba(255, 0, 0, 0.8)',
-                color: 'white',
-                padding: '2px 6px',
-                borderRadius: 1,
-                fontSize: '0.75rem',
-              }}
-            >
-              AI ACTIVE
+              <Typography variant="body2">Camera Offline</Typography>
             </Box>
           )}
-        </Box>
-        
-        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
-          <Box sx={{ display: 'flex', gap: 1 }}>
-            <IconButton size="small">
-              <PlayArrowIcon />
-            </IconButton>
-            <IconButton size="small">
-              <PauseIcon />
-            </IconButton>
-            <IconButton size="small">
-              <VolumeUpIcon />
-            </IconButton>
-          </Box>
-          <IconButton size="small">
-            <SettingsIcon />
-          </IconButton>
-        </Box>
-      </CardContent>
+
+
+          {/* Detection overlay (global toggle only, until AI is per-camera) */}
+          {aiDetectionEnabled && camera.status === 'online' && (
+            <Box
+              sx={{
+                position: 'absolute',
+                top: 10,
+                left: 10,
+                backgroundColor: 'rgba(255, 0, 0, 0.8)',
+                color: 'white',
+                padding: '2px 6px',
+                borderRadius: 1,
+                fontSize: '0.75rem',
+              }}
+            >
+              AI ENABLED
+            </Box>
+          )}
+        </Box>
+
+        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 2 }}>
+          <Box sx={{ display: 'flex', gap: 1 }}>
+            <IconButton
+              size="small"
+              onClick={() => handlePlay(camera)}
+              disabled={camera.status !== 'online'}
+            >
+            <PlayArrowIcon />
+              </IconButton>
+              <IconButton
+                size="small"
+                onClick={() => handlePause(camera)}
+                disabled={camera.status !== 'online'}
+              >
+              <PauseIcon />
+            </IconButton>
+            <IconButton size="small">
+              <VolumeUpIcon />  
+            </IconButton>
+          </Box>
+          <IconButton size="small">
+            <SettingsIcon />
+          </IconButton>
+        </Box>
+      </CardContent>
+
+      {/* TEST-ONLY: Debug actions to inspect stream payloads. */}
+      <CardActions sx={{ justifyContent: 'flex-end' }}>
+        <Button size="small" variant="outlined" onClick={() => handleShowStreams(camera)}>
+          Streams Info
+        </Button>
+      </CardActions>
     </Card>
-  );
-
-  return (
-    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
-      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
-        <Box>
-          <Typography variant="h4" gutterBottom fontWeight="bold">
-            Live Video Monitoring
-          </Typography>
-          <Typography variant="subtitle1" color="text.secondary">
-            Real-time surveillance from all connected cameras.
-          </Typography>
-        </Box>
-        <Box>
-          <FormControlLabel
-            control={
-              <Switch
-                checked={aiDetectionEnabled}
-                onChange={(e) => setAiDetectionEnabled(e.target.checked)}
-              />
-            }
-            label="AI Detection"
-          />
-        </Box>
-      </Box>
-
-      {/* Camera Grid */}
-      <Grid container spacing={3}>
-        {cameras.map((camera) => (
-          <Grid item xs={12} sm={6} lg={6} key={camera.id}>
-            <VideoPlayer camera={camera} />
-          </Grid>
-        ))}
-      </Grid>
-
-      {/* Fullscreen Dialog */}
-      <Dialog
-        open={Boolean(fullscreenCamera)}
-        onClose={() => setFullscreenCamera(null)}
-        maxWidth={false}
-        fullWidth
-        PaperProps={{
-          sx: { maxWidth: '95vw', maxHeight: '95vh' }
-        }}
-      >
-        <DialogTitle>
-          Fullscreen View
-          <IconButton
-            onClick={() => setFullscreenCamera(null)}
-            sx={{ position: 'absolute', right: 8, top: 8 }}
-          >
-            âœ•
-          </IconButton>
-        </DialogTitle>
-        <DialogContent>
-          {fullscreenCamera && (
-            <VideoPlayer
-              camera={cameras.find(c => c.id === fullscreenCamera)}
-              isFullscreen
-            />
-          )}
-        </DialogContent>
-      </Dialog>
-
-      {/* Controls Panel */}
-      <Paper sx={{ mt: 3, p: 2 }}>
-        <Typography variant="h6" gutterBottom>
-          Live Stream Controls
-        </Typography>
-        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
-          <Button variant="outlined" startIcon={<PlayArrowIcon />}>
-            Start All
-          </Button>
-          <Button variant="outlined" startIcon={<PauseIcon />}>
-            Pause All
-          </Button>
-          <Button variant="outlined" startIcon={<SettingsIcon />}>
-            Stream Settings
-          </Button>
-        </Box>
-      </Paper>
-    </Box>
-  );
-};
-
-export default LiveView;
\ No newline at end of file
+    );
+  };
+
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
+      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
+        <Box>
+          <Typography variant="h4" gutterBottom fontWeight="bold">
+            Live Video Monitoring
+          </Typography>
+          <Typography variant="subtitle1" color="text.secondary">
+            Real-time surveillance from all connected cameras.
+          </Typography>
+        </Box>
+        <Box>
+          <FormControlLabel
+            control={
+              <Switch
+                checked={aiDetectionEnabled}
+                onChange={(e) => setAiDetectionEnabled(e.target.checked)}
+              />
+            }
+            label="AI Detection"
+          />
+        </Box>
+      </Box>
+
+      {/* Camera Grid */}
+      {loading ? (
+        <Box sx={{ display: 'flex', justifyContent: 'center', py: 6 }}>
+          <CircularProgress size={60} />
+        </Box>
+      ) : (
+        <Grid container spacing={3}>
+          {cameras.map((camera) => (
+            <Grid item xs={12} sm={6} lg={6} key={camera._id}>
+              <VideoPlayer camera={camera} />
+            </Grid>
+          ))}
+        </Grid>
+      )}
+
+
+      {/* Fullscreen Dialog */}
+      <Dialog
+        open={Boolean(fullscreenCamera)}
+        onClose={() => setFullscreenCamera(null)}
+        maxWidth={false}
+        fullWidth
+        PaperProps={{
+          sx: { maxWidth: '95vw', maxHeight: '95vh' }
+        }}
+      >
+        <DialogTitle>
+          Fullscreen View
+          <IconButton
+            onClick={() => setFullscreenCamera(null)}
+            sx={{ position: 'absolute', right: 8, top: 8 }}
+          >
+            âœ•
+          </IconButton>
+        </DialogTitle>
+        <DialogContent>
+          {fullscreenCamera && (
+            <VideoPlayer
+              camera={cameras.find(c => c._id === fullscreenCamera)!}
+              isFullscreen
+            />
+          )}
+        </DialogContent>
+      </Dialog>
+
+      {/* Controls Panel */}
+      <Paper sx={{ mt: 3, p: 2 }}>
+        <Typography variant="h6" gutterBottom>
+          Live Stream Controls
+        </Typography>
+        <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
+          <Button variant="outlined" startIcon={<PlayArrowIcon />}>
+            Start All
+          </Button>
+          <Button variant="outlined" startIcon={<PauseIcon />}>
+            Pause All
+          </Button>
+          <Button variant="outlined" startIcon={<SettingsIcon />}>
+            Stream Settings
+          </Button>
+        </Box>
+      </Paper>
+            {/* TEST-ONLY: Streams Info Dialog shows raw JSON. */}
+      <Dialog open={streamsOpen} onClose={() => setStreamsOpen(false)} maxWidth="md" fullWidth>
+        <DialogTitle>Camera Stream Info</DialogTitle>
+        <DialogContent>
+          <Box
+            component="pre"
+            sx={{
+              backgroundColor: '#111',
+              color: '#eee',
+              p: 2,
+              borderRadius: 1,
+              overflow: 'auto',
+              fontSize: '0.85rem',
+            }}
+          >
+            {streamsText}
+          </Box>
+        </DialogContent>
+      </Dialog>
+    </Box>
+  );
+};
+
+export default LiveView;
diff --git a/event-monitoring-mvp/frontend/src/pages/Login.tsx b/event-monitoring-mvp/frontend/src/pages/Login.tsx
index f8ad1ac..502448e 100644
--- a/event-monitoring-mvp/frontend/src/pages/Login.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/Login.tsx
@@ -1,288 +1,288 @@
-import React, { useState } from 'react';
-import {
-  Container,
-  Paper,
-  Box,
-  TextField,
-  Button,
-  Typography,
-  Alert,
-  CircularProgress,
-  Divider,
-  Link,
-} from '@mui/material';
-import { useFormik } from 'formik';
-import * as yup from 'yup';
-import { useDispatch } from 'react-redux';
-import { loginStart, loginSuccess, loginFailure } from '../store/store';
-import { toast } from 'react-toastify';
-import { authService } from '../services/authService';
-
-const loginValidationSchema = yup.object({
-  email: yup
-    .string()
-    .email('Enter a valid email')
-    .required('Email is required'),
-  password: yup
-    .string()
-    .min(6, 'Password should be at least 6 characters')
-    .required('Password is required'),
-});
-
-const registerValidationSchema = yup.object({
-  username: yup
-    .string()
-    .min(3, 'Username should be at least 3 characters')
-    .required('Username is required'),
-  email: yup
-    .string()
-    .email('Enter a valid email')
-    .required('Email is required'),
-  password: yup
-    .string()
-    .min(6, 'Password should be at least 6 characters')
-    .required('Password is required'),
-  confirmPassword: yup
-    .string()
-    .oneOf([yup.ref('password')], 'Passwords must match')
-    .required('Please confirm your password'),
-});
-
-const Login: React.FC = () => {
-  const dispatch = useDispatch();
-  const [error, setError] = useState<string>('');
-  const [isRegistering, setIsRegistering] = useState<boolean>(false);
-
-  const formik = useFormik({
-    initialValues: {
-      username: '',
-      email: '',
-      password: '',
-      confirmPassword: '',
-    },
-    validationSchema: isRegistering ? registerValidationSchema : loginValidationSchema,
-    enableReinitialize: true,
-    onSubmit: async (values) => {
-      try {
-        setError('');
-        dispatch(loginStart());
-        
-        const response = isRegistering 
-          ? await authService.register({
-              username: values.username,
-              email: values.email,
-              password: values.password,
-            })
-          : await authService.login({
-              email: values.email,
-              password: values.password,
-            });
-        
-        if (response.success) {
-          // Store token in localStorage
-          localStorage.setItem('token', response.data.token);
-          
-          dispatch(loginSuccess({
-            user: response.data.user,
-            token: response.data.token,
-          }));
-          toast.success(isRegistering ? 'Registration successful!' : 'Login successful!');
-        }
-      } catch (error: any) {
-        setError(error.message || (isRegistering ? 'Registration failed' : 'Login failed'));
-        dispatch(loginFailure());
-        toast.error(error.message || (isRegistering ? 'Registration failed' : 'Login failed'));
-      }
-    },
-  });
-
-  const handleToggleMode = () => {
-    setIsRegistering(!isRegistering);
-    setError('');
-    formik.resetForm();
-  };
-
-  return (
-    <Box
-      sx={{
-        minHeight: '100vh',
-        display: 'flex',
-        alignItems: 'center',
-        justifyContent: 'center',
-        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
-        padding: 2,
-      }}
-    >
-      <Container maxWidth="sm">
-        <Paper
-          elevation={24}
-          sx={{
-            padding: 4,
-            borderRadius: 2,
-            background: 'rgba(255, 255, 255, 0.95)',
-            backdropFilter: 'blur(10px)',
-          }}
-        >
-          <Box sx={{ textAlign: 'center', mb: 4 }}>
-            <Typography
-              variant="h4"
-              component="h1"
-              gutterBottom
-              sx={{
-                fontWeight: 'bold',
-                background: 'linear-gradient(45deg, #667eea, #764ba2)',
-                backgroundClip: 'text',
-                WebkitBackgroundClip: 'text',
-                color: 'transparent',
-              }}
-            >
-              Event Monitor
-            </Typography>
-            <Typography variant="h6" color="text.secondary">
-              Security Monitoring Platform
-            </Typography>
-            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
-              {isRegistering ? 'Create your account' : 'Sign in to your account'}
-            </Typography>
-          </Box>
-
-          <Divider sx={{ mb: 3 }} />
-
-          <Box component="form" onSubmit={formik.handleSubmit}>
-            {error && (
-              <Alert severity="error" sx={{ mb: 2 }}>
-                {error}
-              </Alert>
-            )}
-
-            {isRegistering && (
-              <TextField
-                fullWidth
-                id="username"
-                name="username"
-                label="Username"
-                value={formik.values.username}
-                onChange={formik.handleChange}
-                onBlur={formik.handleBlur}
-                error={formik.touched.username && Boolean(formik.errors.username)}
-                helperText={formik.touched.username && formik.errors.username}
-                margin="normal"
-                variant="outlined"
-              />
-            )}
-
-            <TextField
-              fullWidth
-              id="email"
-              name="email"
-              label="Email Address"
-              type="email"
-              value={formik.values.email}
-              onChange={formik.handleChange}
-              onBlur={formik.handleBlur}
-              error={formik.touched.email && Boolean(formik.errors.email)}
-              helperText={formik.touched.email && formik.errors.email}
-              margin="normal"
-              variant="outlined"
-            />
-
-            <TextField
-              fullWidth
-              id="password"
-              name="password"
-              label="Password"
-              type="password"
-              value={formik.values.password}
-              onChange={formik.handleChange}
-              onBlur={formik.handleBlur}
-              error={formik.touched.password && Boolean(formik.errors.password)}
-              helperText={formik.touched.password && formik.errors.password}
-              margin="normal"
-              variant="outlined"
-            />
-
-            {isRegistering && (
-              <TextField
-                fullWidth
-                id="confirmPassword"
-                name="confirmPassword"
-                label="Confirm Password"
-                type="password"
-                value={formik.values.confirmPassword}
-                onChange={formik.handleChange}
-                onBlur={formik.handleBlur}
-                error={formik.touched.confirmPassword && Boolean(formik.errors.confirmPassword)}
-                helperText={formik.touched.confirmPassword && formik.errors.confirmPassword}
-                margin="normal"
-                variant="outlined"
-              />
-            )}
-
-            <Button
-              color="primary"
-              variant="contained"
-              fullWidth
-              type="submit"
-              disabled={formik.isSubmitting}
-              sx={{
-                mt: 3,
-                mb: 2,
-                py: 1.5,
-                fontSize: '1.1rem',
-                fontWeight: 'bold',
-                background: 'linear-gradient(45deg, #667eea, #764ba2)',
-                '&:hover': {
-                  background: 'linear-gradient(45deg, #5a6fd8, #6a4190)',
-                },
-              }}
-            >
-              {formik.isSubmitting ? (
-                <CircularProgress size={24} color="inherit" />
-              ) : (
-                isRegistering ? 'Create Account' : 'Sign In'
-              )}
-            </Button>
-
-            <Box sx={{ textAlign: 'center', mt: 2 }}>
-              <Typography variant="body2">
-                {isRegistering ? 'Already have an account?' : "Don't have an account?"}{' '}
-                <Link
-                  component="button"
-                  variant="body2"
-                  onClick={(e) => {
-                    e.preventDefault();
-                    handleToggleMode();
-                  }}
-                  sx={{
-                    color: 'primary.main',
-                    textDecoration: 'none',
-                    fontWeight: 'bold',
-                    '&:hover': {
-                      textDecoration: 'underline',
-                    },
-                  }}
-                >
-                  {isRegistering ? 'Sign in here' : 'Register here'}
-                </Link>
-              </Typography>
-            </Box>
-          </Box>
-
-          <Divider sx={{ my: 3 }} />
-
-          <Box sx={{ textAlign: 'center' }}>
-            <Typography variant="body2" color="text.secondary">
-              Demo Credentials:
-            </Typography>
-            <Typography variant="body2" sx={{ mt: 1 }}>
-              <strong>Email:</strong> admin@example.com<br />
-              <strong>Password:</strong> password123
-            </Typography>
-          </Box>
-        </Paper>
-      </Container>
-    </Box>
-  );
-};
-
+import React, { useState } from 'react';
+import {
+  Container,
+  Paper,
+  Box,
+  TextField,
+  Button,
+  Typography,
+  Alert,
+  CircularProgress,
+  Divider,
+  Link,
+} from '@mui/material';
+import { useFormik } from 'formik';
+import * as yup from 'yup';
+import { useDispatch } from 'react-redux';
+import { loginStart, loginSuccess, loginFailure } from '../store/store';
+import { toast } from 'react-toastify';
+import { authService } from '../services/authService';
+
+const loginValidationSchema = yup.object({
+  email: yup
+    .string()
+    .email('Enter a valid email')
+    .required('Email is required'),
+  password: yup
+    .string()
+    .min(6, 'Password should be at least 6 characters')
+    .required('Password is required'),
+});
+
+const registerValidationSchema = yup.object({
+  username: yup
+    .string()
+    .min(3, 'Username should be at least 3 characters')
+    .required('Username is required'),
+  email: yup
+    .string()
+    .email('Enter a valid email')
+    .required('Email is required'),
+  password: yup
+    .string()
+    .min(6, 'Password should be at least 6 characters')
+    .required('Password is required'),
+  confirmPassword: yup
+    .string()
+    .oneOf([yup.ref('password')], 'Passwords must match')
+    .required('Please confirm your password'),
+});
+
+const Login: React.FC = () => {
+  const dispatch = useDispatch();
+  const [error, setError] = useState<string>('');
+  const [isRegistering, setIsRegistering] = useState<boolean>(false);
+
+  const formik = useFormik({
+    initialValues: {
+      username: '',
+      email: '',
+      password: '',
+      confirmPassword: '',
+    },
+    validationSchema: isRegistering ? registerValidationSchema : loginValidationSchema,
+    enableReinitialize: true,
+    onSubmit: async (values) => {
+      try {
+        setError('');
+        dispatch(loginStart());
+        
+        const response = isRegistering 
+          ? await authService.register({
+              username: values.username,
+              email: values.email,
+              password: values.password,
+            })
+          : await authService.login({
+              email: values.email,
+              password: values.password,
+            });
+        
+        if (response.success) {
+          // Store token in localStorage
+          localStorage.setItem('token', response.data.token);
+          
+          dispatch(loginSuccess({
+            user: response.data.user,
+            token: response.data.token,
+          }));
+          toast.success(isRegistering ? 'Registration successful!' : 'Login successful!');
+        }
+      } catch (error: any) {
+        setError(error.message || (isRegistering ? 'Registration failed' : 'Login failed'));
+        dispatch(loginFailure());
+        toast.error(error.message || (isRegistering ? 'Registration failed' : 'Login failed'));
+      }
+    },
+  });
+
+  const handleToggleMode = () => {
+    setIsRegistering(!isRegistering);
+    setError('');
+    formik.resetForm();
+  };
+
+  return (
+    <Box
+      sx={{
+        minHeight: '100vh',
+        display: 'flex',
+        alignItems: 'center',
+        justifyContent: 'center',
+        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
+        padding: 2,
+      }}
+    >
+      <Container maxWidth="sm">
+        <Paper
+          elevation={24}
+          sx={{
+            padding: 4,
+            borderRadius: 2,
+            background: 'rgba(255, 255, 255, 0.95)',
+            backdropFilter: 'blur(10px)',
+          }}
+        >
+          <Box sx={{ textAlign: 'center', mb: 4 }}>
+            <Typography
+              variant="h4"
+              component="h1"
+              gutterBottom
+              sx={{
+                fontWeight: 'bold',
+                background: 'linear-gradient(45deg, #667eea, #764ba2)',
+                backgroundClip: 'text',
+                WebkitBackgroundClip: 'text',
+                color: 'transparent',
+              }}
+            >
+              Event Monitor
+            </Typography>
+            <Typography variant="h6" color="text.secondary">
+              Security Monitoring Platform
+            </Typography>
+            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
+              {isRegistering ? 'Create your account' : 'Sign in to your account'}
+            </Typography>
+          </Box>
+
+          <Divider sx={{ mb: 3 }} />
+
+          <Box component="form" onSubmit={formik.handleSubmit}>
+            {error && (
+              <Alert severity="error" sx={{ mb: 2 }}>
+                {error}
+              </Alert>
+            )}
+
+            {isRegistering && (
+              <TextField
+                fullWidth
+                id="username"
+                name="username"
+                label="Username"
+                value={formik.values.username}
+                onChange={formik.handleChange}
+                onBlur={formik.handleBlur}
+                error={formik.touched.username && Boolean(formik.errors.username)}
+                helperText={formik.touched.username && formik.errors.username}
+                margin="normal"
+                variant="outlined"
+              />
+            )}
+
+            <TextField
+              fullWidth
+              id="email"
+              name="email"
+              label="Email Address"
+              type="email"
+              value={formik.values.email}
+              onChange={formik.handleChange}
+              onBlur={formik.handleBlur}
+              error={formik.touched.email && Boolean(formik.errors.email)}
+              helperText={formik.touched.email && formik.errors.email}
+              margin="normal"
+              variant="outlined"
+            />
+
+            <TextField
+              fullWidth
+              id="password"
+              name="password"
+              label="Password"
+              type="password"
+              value={formik.values.password}
+              onChange={formik.handleChange}
+              onBlur={formik.handleBlur}
+              error={formik.touched.password && Boolean(formik.errors.password)}
+              helperText={formik.touched.password && formik.errors.password}
+              margin="normal"
+              variant="outlined"
+            />
+
+            {isRegistering && (
+              <TextField
+                fullWidth
+                id="confirmPassword"
+                name="confirmPassword"
+                label="Confirm Password"
+                type="password"
+                value={formik.values.confirmPassword}
+                onChange={formik.handleChange}
+                onBlur={formik.handleBlur}
+                error={formik.touched.confirmPassword && Boolean(formik.errors.confirmPassword)}
+                helperText={formik.touched.confirmPassword && formik.errors.confirmPassword}
+                margin="normal"
+                variant="outlined"
+              />
+            )}
+
+            <Button
+              color="primary"
+              variant="contained"
+              fullWidth
+              type="submit"
+              disabled={formik.isSubmitting}
+              sx={{
+                mt: 3,
+                mb: 2,
+                py: 1.5,
+                fontSize: '1.1rem',
+                fontWeight: 'bold',
+                background: 'linear-gradient(45deg, #667eea, #764ba2)',
+                '&:hover': {
+                  background: 'linear-gradient(45deg, #5a6fd8, #6a4190)',
+                },
+              }}
+            >
+              {formik.isSubmitting ? (
+                <CircularProgress size={24} color="inherit" />
+              ) : (
+                isRegistering ? 'Create Account' : 'Sign In'
+              )}
+            </Button>
+
+            <Box sx={{ textAlign: 'center', mt: 2 }}>
+              <Typography variant="body2">
+                {isRegistering ? 'Already have an account?' : "Don't have an account?"}{' '}
+                <Link
+                  component="button"
+                  variant="body2"
+                  onClick={(e) => {
+                    e.preventDefault();
+                    handleToggleMode();
+                  }}
+                  sx={{
+                    color: 'primary.main',
+                    textDecoration: 'none',
+                    fontWeight: 'bold',
+                    '&:hover': {
+                      textDecoration: 'underline',
+                    },
+                  }}
+                >
+                  {isRegistering ? 'Sign in here' : 'Register here'}
+                </Link>
+              </Typography>
+            </Box>
+          </Box>
+
+          <Divider sx={{ my: 3 }} />
+
+          <Box sx={{ textAlign: 'center' }}>
+            <Typography variant="body2" color="text.secondary">
+              Demo Credentials:
+            </Typography>
+            <Typography variant="body2" sx={{ mt: 1 }}>
+              <strong>Email:</strong> admin@example.com<br />
+              <strong>Password:</strong> password123
+            </Typography>
+          </Box>
+        </Paper>
+      </Container>
+    </Box>
+  );
+};
+
 export default Login;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/pages/MapView.tsx b/event-monitoring-mvp/frontend/src/pages/MapView.tsx
index 2a742b3..8365459 100644
--- a/event-monitoring-mvp/frontend/src/pages/MapView.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/MapView.tsx
@@ -1,969 +1,968 @@
-import React, { useState, useEffect, useRef } from 'react';
-import {
-  Box,
-  Typography,
-  Card,
-  CardContent,
-  IconButton,
-  Fab,
-  Menu,
-  MenuItem,
-  ListItemIcon,
-  ListItemText,
-  TextField,
-  InputAdornment,
-  FormControl,
-  InputLabel,
-  Select,
-  FormControlLabel,
-  Switch,
-  Chip,
-  Badge,
-  CircularProgress,
-  Alert,
-  Collapse,
-  Tooltip,
-  Button,
-  Drawer,
-  List,
-  ListItem,
-  ListItemButton,
-  Divider,
-  CardActions,
-  Avatar,
-  Grid,
-} from '@mui/material';
-import {
-  Layers as LayersIcon,
-  Search as SearchIcon,
-  FilterList as FilterListIcon,
-  LocationOn as LocationOnIcon,
-  Event as EventIcon,
-  Warning as WarningIcon,
-  Close as CloseIcon,
-  Videocam as VideocamIcon,
-  PlayArrow as PlayArrowIcon,
-  Settings as SettingsIcon,
-  Info as InfoIcon,
-  Fullscreen as FullscreenIcon,
-  ZoomIn as ZoomInIcon,
-  ZoomOut as ZoomOutIcon,
-} from '@mui/icons-material';
-import {
-  MapContainer,
-  TileLayer,
-  Marker,
-  Popup,
-  useMapEvents,
-} from 'react-leaflet';
-import L from 'leaflet';
-import 'leaflet/dist/leaflet.css';
-import { Camera } from '../types/index';
-import { fetchCamerasData, fetchEventsData, SecurityEvent } from '../services/dataService';
-import MapContextMenu from '../components/MapContextMenu';
-import { useNavigate } from 'react-router-dom';
-
-// Fix for default markers in react-leaflet
-delete (L.Icon.Default.prototype as any)._getIconUrl;
-L.Icon.Default.mergeOptions({
-  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
-  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
-  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
-});
-
-// Create custom camera icons based on status
-const createCameraIcon = (status: 'online' | 'offline' | 'maintenance') => {
-  const colors = {
-    online: '#4caf50',
-    offline: '#f44336',
-    maintenance: '#ff9800'
-  };
-
-  const svgIcon = `
-    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
-      <circle cx="20" cy="20" r="18" fill="${colors[status]}" stroke="white" stroke-width="3"/>
-      <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
-    </svg>
-  `;
-
-  return L.divIcon({
-    html: svgIcon,
-    className: 'custom-camera-marker',
-    iconSize: [40, 40],
-    iconAnchor: [20, 20],
-  });
-};
-
-const MapView: React.FC = () => {
-  const navigate = useNavigate();
-  const [loading, setLoading] = useState(true);
-  const [selectedCamera, setSelectedCamera] = useState<Camera | null>(null);
-  const [selectedEvent, setSelectedEvent] = useState<SecurityEvent | null>(null);
-  const [showCameras, setShowCameras] = useState(true);
-  const [showEvents, setShowEvents] = useState(true);
-  const [showDetections, setShowDetections] = useState(true);
-  const [showLayers, setShowLayers] = useState(false);
-  const [cameras, setCameras] = useState<Camera[]>([]);
-  const [events, setEvents] = useState<SecurityEvent[]>([]);
-  const [detections, setDetections] = useState<any[]>([]);
-  const [filteredCameras, setFilteredCameras] = useState<Camera[]>([]);
-  const [filteredEvents, setFilteredEvents] = useState<SecurityEvent[]>([]);
-  const [filteredDetections, setFilteredDetections] = useState<any[]>([]);
-  
-  // Search and filter states
-  const [searchTerm, setSearchTerm] = useState('');
-  const [statusFilter, setStatusFilter] = useState<string>('all');
-  const [eventTypeFilter, setEventTypeFilter] = useState<string>('all');
-  const [severityFilter, setSeverityFilter] = useState<string>('all');
-  const [detectionTypeFilter, setDetectionTypeFilter] = useState<string>('all');
-  const [reportSourceFilter, setReportSourceFilter] = useState<string>('all');
-  const [showUnresolvedOnly, setShowUnresolvedOnly] = useState(false);
-  const [showPendingOnly, setShowPendingOnly] = useState(false);
-  
-  // Live notification states
-  const [liveNotifications, setLiveNotifications] = useState<any[]>([]);
-  const [showLiveNotifications, setShowLiveNotifications] = useState(true);
-  const [autoZoomToNew, setAutoZoomToNew] = useState(true);
-  
-  // Enhanced filtering categories
-  const eventTypes = ['all', 'security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 'user_report', 'system_alert'];
-  const detectionTypes = ['all', 'motion_detected', 'object_detected', 'anomaly_detected', 'user_submitted', 'ai_flagged'];
-  const reportSources = ['all', 'camera_system', 'user_report', 'ai_detection', 'sensor_alert', 'manual_entry'];
-  const severityLevels = ['all', 'low', 'medium', 'high', 'critical', 'emergency'];
-  
-  // Context menu states
-  const [contextMenu, setContextMenu] = useState<{
-    position: { x: number; y: number };
-    latLng: { lat: number; lng: number };
-  } | null>(null);
-  
-  // UI states
-  const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLElement | null>(null);
-  const [showSidebar, setShowSidebar] = useState(false);
-  const [showOverview, setShowOverview] = useState(true);
-  const [selectedCameraDetails, setSelectedCameraDetails] = useState<Camera | null>(null);
-
-  // Fetch cameras, events, and prepare for detections
-  const fetchData = async () => {
-    setLoading(true);
-    try {
-      const [cameras, events] = await Promise.all([
-        fetchCamerasData(),
-        fetchEventsData(),
-      ]);
-      
-      setCameras(cameras);
-      setEvents(events);
-      
-      // Generate mock detections for demonstration (will be replaced with real API)
+import React, { useState, useEffect, useRef } from 'react';
+import {
+  Box,
+  Typography,
+  Card,
+  CardContent,
+  IconButton,
+  Fab,
+  Menu,
+  MenuItem,
+  ListItemIcon,
+  ListItemText,
+  TextField,
+  InputAdornment,
+  FormControl,
+  InputLabel,
+  Select,
+  FormControlLabel,
+  Switch,
+  Chip,
+  Badge,
+  CircularProgress,
+  Alert,
+  Collapse,
+  Tooltip,
+  Button,
+  Drawer,
+  List,
+  ListItem,
+  ListItemButton,
+  Divider,
+  CardActions,
+  Avatar,
+  Grid,
+} from '@mui/material';
+import {
+  Layers as LayersIcon,
+  Search as SearchIcon,
+  FilterList as FilterListIcon,
+  LocationOn as LocationOnIcon,
+  Event as EventIcon,
+  Warning as WarningIcon,
+  Close as CloseIcon,
+  Videocam as VideocamIcon,
+  PlayArrow as PlayArrowIcon,
+  Settings as SettingsIcon,
+  Info as InfoIcon,
+  Fullscreen as FullscreenIcon,
+  ZoomIn as ZoomInIcon,
+  ZoomOut as ZoomOutIcon,
+} from '@mui/icons-material';
+import {
+  MapContainer,
+  TileLayer,
+  Marker,
+  Popup,
+  useMapEvents,
+} from 'react-leaflet';
+import L from 'leaflet';
+import 'leaflet/dist/leaflet.css';
+import { Camera } from '../types/index';
+import { fetchCamerasData, fetchEventsData, SecurityEvent } from '../services/dataService';
+import MapContextMenu from '../components/MapContextMenu';
+import { useNavigate } from 'react-router-dom';
+
+// Fix for default markers in react-leaflet
+delete (L.Icon.Default.prototype as any)._getIconUrl;
+L.Icon.Default.mergeOptions({
+  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
+  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
+  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
+});
+
+// Create custom camera icons based on status
+const createCameraIcon = (status: 'online' | 'offline' | 'maintenance') => {
+  const colors = {
+    online: '#4caf50',
+    offline: '#f44336',
+    maintenance: '#ff9800'
+  };
+
+  const svgIcon = `
+    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
+      <circle cx="20" cy="20" r="18" fill="${colors[status]}" stroke="white" stroke-width="3"/>
+      <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
+    </svg>
+  `;
+
+  return L.divIcon({
+    html: svgIcon,
+    className: 'custom-camera-marker',
+    iconSize: [40, 40],
+    iconAnchor: [20, 20],
+  });
+};
+
+const MapView: React.FC = () => {
+  const navigate = useNavigate();
+  const [loading, setLoading] = useState(true);
+  const [selectedCamera, setSelectedCamera] = useState<Camera | null>(null);
+  const [selectedEvent, setSelectedEvent] = useState<SecurityEvent | null>(null);
+  const [showCameras, setShowCameras] = useState(true);
+  const [showEvents, setShowEvents] = useState(true);
+  const [showDetections, setShowDetections] = useState(true);
+  const [showLayers, setShowLayers] = useState(false);
+  const [cameras, setCameras] = useState<Camera[]>([]);
+  const [events, setEvents] = useState<SecurityEvent[]>([]);
+  const [detections, setDetections] = useState<any[]>([]);
+  const [filteredCameras, setFilteredCameras] = useState<Camera[]>([]);
+  const [filteredEvents, setFilteredEvents] = useState<SecurityEvent[]>([]);
+  const [filteredDetections, setFilteredDetections] = useState<any[]>([]);
+  
+  // Search and filter states
+  const [searchTerm, setSearchTerm] = useState('');
+  const [statusFilter, setStatusFilter] = useState<string>('all');
+  const [eventTypeFilter, setEventTypeFilter] = useState<string>('all');
+  const [severityFilter, setSeverityFilter] = useState<string>('all');
+  const [detectionTypeFilter, setDetectionTypeFilter] = useState<string>('all');
+  const [reportSourceFilter, setReportSourceFilter] = useState<string>('all');
+  const [showUnresolvedOnly, setShowUnresolvedOnly] = useState(false);
+  const [showPendingOnly, setShowPendingOnly] = useState(false);
+  
+  // Live notification states
+  const [liveNotifications, setLiveNotifications] = useState<any[]>([]);
+  const [showLiveNotifications, setShowLiveNotifications] = useState(true);
+  const [autoZoomToNew, setAutoZoomToNew] = useState(true);
+  
+  // Enhanced filtering categories
+  const eventTypes = ['all', 'security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 'user_report', 'system_alert'];
+  const detectionTypes = ['all', 'motion_detected', 'object_detected', 'anomaly_detected', 'user_submitted', 'ai_flagged'];
+  const reportSources = ['all', 'camera_system', 'user_report', 'ai_detection', 'sensor_alert', 'manual_entry'];
+  const severityLevels = ['all', 'low', 'medium', 'high', 'critical', 'emergency'];
+  
+  // Context menu states
+  const [contextMenu, setContextMenu] = useState<{
+    position: { x: number; y: number };
+    latLng: { lat: number; lng: number };
+  } | null>(null);
+  
+  // UI states
+  const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLElement | null>(null);
+  const [showSidebar, setShowSidebar] = useState(false);
+  const [showOverview, setShowOverview] = useState(true);
+  const [selectedCameraDetails, setSelectedCameraDetails] = useState<Camera | null>(null);
+
+  // Fetch cameras, events, and prepare for detections
+  const fetchData = async () => {
+    setLoading(true);
+    try {
+      const [cameras, events] = await Promise.all([
+        fetchCamerasData(),
+        fetchEventsData(),
+      ]);
+      
+      setCameras(cameras);
+      setEvents(events);
+      
       const mockDetections = generateMockDetections(cameras);
-      setDetections(mockDetections);
-    } catch (error) {
-      console.error('Error fetching data:', error);
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  // Generate mock detections for demonstration
-  const generateMockDetections = (cameras: Camera[]) => {
-    const detectionTypes = ['motion_detected', 'object_detected', 'user_submitted', 'ai_flagged'];
-    const sources = ['camera_system', 'user_report', 'ai_detection'];
-    
-    return cameras.slice(0, 8).map((camera, index) => ({
-      _id: `detection_${index}`,
-      type: detectionTypes[index % detectionTypes.length],
-      source: sources[index % sources.length],
-      location: {
-        coordinates: [camera.location.coordinates[0] + (Math.random() - 0.5) * 0.01, camera.location.coordinates[1] + (Math.random() - 0.5) * 0.01]
-      },
-      confidence: Math.random(),
-      status: index % 3 === 0 ? 'pending_review' : index % 3 === 1 ? 'investigating' : 'resolved',
-      timestamp: new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000),
-      description: `Detection reported: ${detectionTypes[index % detectionTypes.length].replace('_', ' ')}`,
-      cameraId: camera._id,
-      severity: index % 4 === 0 ? 'high' : index % 4 === 1 ? 'medium' : 'low',
-      isPromotedToEvent: index % 5 === 0
-    }));
-  };
-
-  // Apply filters
-  const applyFilters = () => {
-    let filteredCams = cameras.filter(camera => {
-      const matchesSearch = searchTerm === '' || 
-        camera.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        camera.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        camera.location.address?.toLowerCase().includes(searchTerm.toLowerCase());
-      
-      const matchesStatus = statusFilter === 'all' || camera.status === statusFilter;
-      
-      return matchesSearch && matchesStatus;
-    });
-
-    let filteredEvts = events.filter(event => {
-      const matchesSearch = searchTerm === '' || 
-        event.cameraName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        event.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        event.type.toLowerCase().includes(searchTerm.toLowerCase());
-      
-      const matchesType = eventTypeFilter === 'all' || event.type === eventTypeFilter;
-      const matchesSeverity = severityFilter === 'all' || event.severity === severityFilter;
-      const matchesResolved = !showUnresolvedOnly || !event.resolved;
-      const matchesSource = reportSourceFilter === 'all' || (event as any).source === reportSourceFilter;
-      
-      return matchesSearch && matchesType && matchesSeverity && matchesResolved && matchesSource;
-    });
-
-    // Filter detections (non-event reports)
-    let filteredDets = detections.filter(detection => {
-      const matchesSearch = searchTerm === '' || 
-        detection.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        detection.type.toLowerCase().includes(searchTerm.toLowerCase());
-      
-      const matchesType = detectionTypeFilter === 'all' || detection.type === detectionTypeFilter;
-      const matchesSource = reportSourceFilter === 'all' || detection.source === reportSourceFilter;
-      const matchesSeverity = severityFilter === 'all' || detection.severity === severityFilter;
-      const matchesPending = !showPendingOnly || detection.status === 'pending_review';
-      const notPromotedToEvent = !detection.isPromotedToEvent; // Only show detections that haven't become events
-      
-      return matchesSearch && matchesType && matchesSource && matchesSeverity && matchesPending && notPromotedToEvent;
-    });
-
-    setFilteredCameras(filteredCams);
-    setFilteredEvents(filteredEvts);
-    setFilteredDetections(filteredDets);
-  };
-
-  useEffect(() => {
-    fetchData();
-  }, []);
-
-  useEffect(() => {
-    applyFilters();
-  }, [cameras, events, detections, searchTerm, statusFilter, eventTypeFilter, severityFilter, detectionTypeFilter, reportSourceFilter, showUnresolvedOnly, showPendingOnly]);
-
-  // Create event markers with severity-based styling
-  const createEventIcon = (severity: string) => {
-    const colors = {
-      low: '#2196f3',
-      medium: '#ff9800',
-      high: '#f44336',
-      critical: '#d32f2f'
-    };
-
-    const svgIcon = `
-      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
-        <circle cx="15" cy="15" r="12" fill="${colors[severity as keyof typeof colors]}" stroke="white" stroke-width="2"/>
-        <path d="M10 8h10v6h-10z M15 14l5-3v8l-5-3z" fill="white"/>
-      </svg>
-    `;
-
-    return L.divIcon({
-      html: svgIcon,
-      className: 'custom-event-marker',
-      iconSize: [30, 30],
-      iconAnchor: [15, 15],
-    });
-  };
-
-  // Create detection marker icon
-  const createDetectionIcon = (detection: any) => {
-    const typeIcons = {
-      motion_detected: 'ğŸš¶',
-      object_detected: 'ğŸ“¦',
-      user_submitted: 'ğŸ‘¤',
-      ai_flagged: 'ğŸ¤–',
-      anomaly_detected: 'âš ï¸'
-    };
-
-    const statusColors = {
-      pending_review: '#ff9800',
-      investigating: '#2196f3',
-      resolved: '#4caf50',
-      dismissed: '#9e9e9e'
-    };
-
-    const size = 25;
-    const icon = typeIcons[detection.type as keyof typeof typeIcons] || 'ğŸ“';
-    const color = statusColors[detection.status as keyof typeof statusColors] || '#ff9800';
-
-    const svgIcon = `
-      <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
-        <circle cx="${size/2}" cy="${size/2}" r="${size/2-2}" 
-                fill="${color}" stroke="white" stroke-width="2" opacity="0.9"/>
-        <text x="${size/2}" y="${size/2+4}" text-anchor="middle" 
-              font-size="10" fill="white">
-          ${icon}
-        </text>
-      </svg>
-    `;
-
-    return L.divIcon({
-      html: svgIcon,
-      className: 'custom-detection-marker',
-      iconSize: [size, size],
-      iconAnchor: [size/2, size/2],
-    });
-  };
-
-  // Context menu handlers
-  const handleMapRightClick = (e: any) => {
-    const { lat, lng } = e.latlng;
-    const { x, y } = e.containerPoint;
-    
-    setContextMenu({
-      position: { x: x + e.target._container.offsetLeft, y: y + e.target._container.offsetTop },
-      latLng: { lat, lng }
-    });
-  };
-
-  const handleAddCamera = (position: { lat: number; lng: number }) => {
-    navigate('/cameras/add', { 
-      state: { 
-        coordinates: { 
-          latitude: position.lat, 
-          longitude: position.lng 
-        } 
-      } 
-    });
-  };
-
-  const handleCreateEvent = (position: { lat: number; lng: number }) => {
-    // TODO: Implement event creation modal
-    console.log('Creating event at:', position);
-  };
-
-  const handleViewCoverage = (position: { lat: number; lng: number }) => {
-    // TODO: Show camera coverage areas
-    console.log('Viewing coverage for:', position);
-  };
-
-  const handleAnalyzeArea = (position: { lat: number; lng: number }) => {
-    // TODO: Open area analysis tools
-    console.log('Analyzing area:', position);
-  };
-
-  const handleSetWaypoint = (position: { lat: number; lng: number }) => {
-    // TODO: Add waypoint functionality
-    console.log('Setting waypoint:', position);
-  };
-
-  const handleMeasureDistance = (position: { lat: number; lng: number }) => {
-    // TODO: Start distance measurement
-    console.log('Measuring distance from:', position);
-  };
-
-  const handleViewTimeline = (position: { lat: number; lng: number }) => {
-    // TODO: Show timeline for location
-    console.log('Viewing timeline for:', position);
-  };
-
-  // Map event handler component
-  const MapEventHandler = () => {
-    const map = useMapEvents({
-      contextmenu: (e) => {
-        const { lat, lng } = e.latlng;
-        const { x, y } = e.containerPoint;
-        
-        setContextMenu({
-          position: { x, y },
-          latLng: { lat, lng }
-        });
-      },
-    });
-    return null;
-  };
-
-  if (loading) {
-    return (
-      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
-        <CircularProgress />
-      </Box>
-    );
-  }
-
-  return (
-    <Box sx={{ height: '100vh', position: 'relative', overflow: 'hidden' }}>
-      {/* Header with Search and Filters */}
-      <Box sx={{ p: 2, bgcolor: 'background.paper', borderBottom: 1, borderColor: 'divider', zIndex: 1000, position: 'relative' }}>
-        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
-          <Typography variant="h5" component="h1">
-            Security Map
-          </Typography>
-          <TextField
-            size="small"
-            placeholder="Search cameras and events..."
-            value={searchTerm}
-            onChange={(e) => setSearchTerm(e.target.value)}
-            InputProps={{
-              startAdornment: (
-                <InputAdornment position="start">
-                  <SearchIcon />
-                </InputAdornment>
-              ),
-            }}
-            sx={{ minWidth: 300 }}
-          />
-          <IconButton onClick={(e) => setFilterAnchorEl(e.currentTarget)}>
-            <FilterListIcon />
-          </IconButton>
-          <IconButton onClick={() => setShowLayers(!showLayers)}>
-            <LayersIcon />
-          </IconButton>
-          <IconButton onClick={() => setShowSidebar(!showSidebar)}>
-            <InfoIcon />
-          </IconButton>
-        </Box>
-
-        {/* Layer Controls */}
-        <Collapse in={showLayers}>
-          <Box sx={{ mt: 2, display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
-            <FormControlLabel
-              control={<Switch checked={showCameras} onChange={(e) => setShowCameras(e.target.checked)} />}
-              label={`Cameras (${filteredCameras.length})`}
-            />
-            <FormControlLabel
-              control={<Switch checked={showEvents} onChange={(e) => setShowEvents(e.target.checked)} />}
-              label={`Events (${filteredEvents.length})`}
-            />
-            <FormControlLabel
-              control={<Switch checked={showDetections} onChange={(e) => setShowDetections(e.target.checked)} />}
-              label={`Detections (${filteredDetections.length})`}
-            />
-            <FormControlLabel
-              control={<Switch checked={showOverview} onChange={(e) => setShowOverview(e.target.checked)} />}
-              label="Overview Panel"
-            />
-          </Box>
-        </Collapse>
-      </Box>
-
-      {/* Side Drawer for Camera Details */}
-      <Drawer
-        anchor="right"
-        open={showSidebar}
-        onClose={() => setShowSidebar(false)}
-        variant="persistent"
-        sx={{
-          width: showSidebar ? 400 : 0,
-          flexShrink: 0,
-          '& .MuiDrawer-paper': {
-            width: 400,
-            boxSizing: 'border-box',
-            top: '120px',
-            height: 'calc(100vh - 120px)',
-          },
-        }}
-      >
-        <Box sx={{ p: 2 }}>
-          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
-            <Typography variant="h6">Camera Details</Typography>
-            <IconButton onClick={() => setShowSidebar(false)}>
-              <CloseIcon />
-            </IconButton>
-          </Box>
-          
-          {selectedCameraDetails ? (
-            <Card>
-              <CardContent>
-                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
-                  <Avatar sx={{ bgcolor: selectedCameraDetails.status === 'online' ? 'success.main' : selectedCameraDetails.status === 'offline' ? 'error.main' : 'warning.main' }}>
-                    <VideocamIcon />
-                  </Avatar>
-                  <Box>
-                    <Typography variant="h6">{selectedCameraDetails.name}</Typography>
-                    <Chip 
-                      label={selectedCameraDetails.status} 
-                      size="small" 
-                      color={selectedCameraDetails.status === 'online' ? 'success' : selectedCameraDetails.status === 'offline' ? 'error' : 'warning'}
-                    />
-                  </Box>
-                </Box>
-                
-                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
-                  {selectedCameraDetails.description}
-                </Typography>
-                
-                <Typography variant="subtitle2" gutterBottom>Location</Typography>
-                <Typography variant="body2" sx={{ mb: 2 }}>
-                  {selectedCameraDetails.location.address}
-                </Typography>
-                
-                <Typography variant="subtitle2" gutterBottom>Settings</Typography>
-                <Box sx={{ mb: 2 }}>
-                  <Typography variant="body2">Resolution: {selectedCameraDetails.settings.resolution}</Typography>
-                  <Typography variant="body2">FPS: {selectedCameraDetails.settings.fps}</Typography>
-                  <Typography variant="body2">Recording: {selectedCameraDetails.settings.recordingEnabled ? 'Enabled' : 'Disabled'}</Typography>
-                </Box>
-              </CardContent>
-              
-              <CardActions sx={{ justifyContent: 'space-between' }}>
-                <Button 
-                  variant="contained" 
-                  startIcon={<PlayArrowIcon />}
-                  disabled={selectedCameraDetails.status !== 'online'}
-                  size="small"
-                >
-                  Live Feed
-                </Button>
-                <Button 
-                  variant="outlined" 
-                  startIcon={<SettingsIcon />}
-                  size="small"
-                >
-                  Settings
-                </Button>
-              </CardActions>
-            </Card>
-          ) : (
-            <Typography variant="body2" color="text.secondary">
-              Click on a camera marker to view details
-            </Typography>
-          )}
-          
-          <Divider sx={{ my: 3 }} />
-          
-          <Typography variant="h6" gutterBottom>All Cameras</Typography>
-          <List>
-            {filteredCameras.map((camera) => (
-              <ListItem key={camera._id} disablePadding>
-                <ListItemButton 
-                  onClick={() => {
-                    setSelectedCameraDetails(camera);
-                    setSelectedCamera(camera);
-                  }}
-                  selected={selectedCameraDetails?._id === camera._id}
-                >
-                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
-                    <Avatar sx={{ 
-                      bgcolor: camera.status === 'online' ? 'success.main' : camera.status === 'offline' ? 'error.main' : 'warning.main',
-                      width: 32,
-                      height: 32
-                    }}>
-                      <VideocamIcon sx={{ fontSize: 16 }} />
-                    </Avatar>
-                    <Box sx={{ flexGrow: 1 }}>
-                      <Typography variant="body2" fontWeight="medium">
-                        {camera.name}
-                      </Typography>
-                      <Typography variant="caption" color="text.secondary">
-                        {camera.location.address}
-                      </Typography>
-                    </Box>
-                    <Chip 
-                      label={camera.status} 
-                      size="small"
-                      variant="outlined"
-                      color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
-                    />
-                  </Box>
-                </ListItemButton>
-              </ListItem>
-            ))}
-          </List>
-        </Box>
-      </Drawer>
-
-      {/* Filter Menu */}
-      <Menu
-        anchorEl={filterAnchorEl}
-        open={Boolean(filterAnchorEl)}
-        onClose={() => setFilterAnchorEl(null)}
-      >
-        <Box sx={{ p: 2, minWidth: 250 }}>
-          <FormControl fullWidth sx={{ mb: 2 }}>
-            <InputLabel>Camera Status</InputLabel>
-            <Select
-              value={statusFilter}
-              label="Camera Status"
-              onChange={(e) => setStatusFilter(e.target.value)}
-            >
-              <MenuItem value="all">All Status</MenuItem>
-              <MenuItem value="online">Online</MenuItem>
-              <MenuItem value="offline">Offline</MenuItem>
-              <MenuItem value="maintenance">Maintenance</MenuItem>
-            </Select>
-          </FormControl>
-
-          <FormControl fullWidth sx={{ mb: 2 }}>
-            <InputLabel>Event Type</InputLabel>
-            <Select
-              value={eventTypeFilter}
-              label="Event Type"
-              onChange={(e) => setEventTypeFilter(e.target.value)}
-            >
-              {eventTypes.map(type => (
-                <MenuItem key={type} value={type}>
-                  {type === 'all' ? 'All Types' : type.replace('_', ' ').toUpperCase()}
-                </MenuItem>
-              ))}
-            </Select>
-          </FormControl>
-
-          <FormControl fullWidth sx={{ mb: 2 }}>
-            <InputLabel>Detection Type</InputLabel>
-            <Select
-              value={detectionTypeFilter}
-              label="Detection Type"
-              onChange={(e) => setDetectionTypeFilter(e.target.value)}
-            >
-              {detectionTypes.map(type => (
-                <MenuItem key={type} value={type}>
-                  {type === 'all' ? 'All Types' : type.replace('_', ' ').toUpperCase()}
-                </MenuItem>
-              ))}
-            </Select>
-          </FormControl>
-
-          <FormControl fullWidth sx={{ mb: 2 }}>
-            <InputLabel>Report Source</InputLabel>
-            <Select
-              value={reportSourceFilter}
-              label="Report Source"
-              onChange={(e) => setReportSourceFilter(e.target.value)}
-            >
-              {reportSources.map(source => (
-                <MenuItem key={source} value={source}>
-                  {source === 'all' ? 'All Sources' : source.replace('_', ' ').toUpperCase()}
-                </MenuItem>
-              ))}
-            </Select>
-          </FormControl>
-
-          <FormControl fullWidth sx={{ mb: 2 }}>
-            <InputLabel>Severity</InputLabel>
-            <Select
-              value={severityFilter}
-              label="Severity"
-              onChange={(e) => setSeverityFilter(e.target.value)}
-            >
-              <MenuItem value="all">All Severities</MenuItem>
-              <MenuItem value="low">Low</MenuItem>
-              <MenuItem value="medium">Medium</MenuItem>
-              <MenuItem value="high">High</MenuItem>
-              <MenuItem value="critical">Critical</MenuItem>
-            </Select>
-          </FormControl>
-
-          <FormControlLabel
-            control={
-              <Switch 
-                checked={showUnresolvedOnly} 
-                onChange={(e) => setShowUnresolvedOnly(e.target.checked)} 
-              />
-            }
-            label="Unresolved Events Only"
-          />
-          
-          <FormControlLabel
-            control={
-              <Switch 
-                checked={showPendingOnly} 
-                onChange={(e) => setShowPendingOnly(e.target.checked)} 
-              />
-            }
-            label="Pending Review Only"
-          />
-          
-          <FormControlLabel
-            control={
-              <Switch 
-                checked={autoZoomToNew} 
-                onChange={(e) => setAutoZoomToNew(e.target.checked)} 
-              />
-            }
-            label="Auto Zoom to New Reports"
-          />
-        </Box>
-      </Menu>
-
-      {/* Map */}
-      <Box 
-        sx={{ height: 'calc(100vh - 120px)', position: 'relative' }}
-        onClick={() => setContextMenu(null)}
-      >
-        <MapContainer
-          center={[40.7831, -73.9712]}
-          zoom={13}
-          style={{ height: '100%', width: showSidebar ? 'calc(100% - 400px)' : '100%' }}
-        >
-          <MapEventHandler />
-          <TileLayer
-            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
-            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
-          />
-
-          {/* Camera Markers */}
-          {showCameras && filteredCameras.map((camera) => (
-            <Marker
-              key={`camera-${camera._id}-${camera.location.coordinates[1]}-${camera.location.coordinates[0]}`}
-              position={[camera.location.coordinates[1], camera.location.coordinates[0]]}
-              icon={createCameraIcon(camera.status)}
-              eventHandlers={{
-                click: () => {
-                  setSelectedCameraDetails(camera);
-                  setSelectedCamera(camera);
-                  setShowSidebar(true);
-                },
-              }}
-            >
-              <Popup>
-                <Box>
-                  <Typography variant="h6">{camera.name}</Typography>
-                  <Typography variant="body2" color="text.secondary">
-                    {camera.description}
-                  </Typography>
-                  <Chip
-                    label={camera.status}
-                    size="small"
-                    color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
-                    sx={{ mt: 1, mb: 2 }}
-                  />
-                  <Box sx={{ display: 'flex', gap: 1, mt: 1 }}>
-                    <Button 
-                      size="small" 
-                      variant="contained" 
-                      startIcon={<PlayArrowIcon />}
-                      disabled={camera.status !== 'online'}
-                      onClick={() => {
-                        setSelectedCameraDetails(camera);
-                        setShowSidebar(true);
-                      }}
-                    >
-                      View Details
-                    </Button>
-                  </Box>
-                </Box>
-              </Popup>
-            </Marker>
-          ))}
-
-          {/* Event Markers - CRITICAL FIX: Using stable coordinate-based keys */}
-          {showEvents && filteredEvents.map((event) => (
-            <Marker
-              key={`event-${event._id}-${event.location.coordinates[1]}-${event.location.coordinates[0]}`}
-              position={[event.location.coordinates[1], event.location.coordinates[0]]}
-              icon={createEventIcon(event.severity)}
-            >
-              <Popup>
-                <Box>
-                  <Typography variant="h6">{event.type.replace('_', ' ')}</Typography>
-                  <Typography variant="body2">{event.description}</Typography>
-                  <Box sx={{ mt: 1, display: 'flex', gap: 1 }}>
-                    <Chip
-                      label={event.severity}
-                      size="small"
-                      color={event.severity === 'critical' ? 'error' : event.severity === 'high' ? 'warning' : 'default'}
-                    />
-                    {!event.resolved && (
-                      <Chip
-                        label="Unresolved"
-                        size="small"
-                        color="error"
-                        variant="outlined"
-                      />
-                    )}
-                  </Box>
-                  <Typography variant="caption" display="block" sx={{ mt: 1 }}>
-                    Camera: {event.cameraName}
-                  </Typography>
-                  <Typography variant="caption" display="block">
-                    {new Date(event.timestamp).toLocaleString()}
-                  </Typography>
-                </Box>
-              </Popup>
-            </Marker>
-          ))}
-
-          {/* Detection Markers (Non-Event Reports) */}
-          {showDetections && filteredDetections.map((detection) => (
-            <Marker
-              key={`detection-${detection._id}`}
-              position={[detection.location.coordinates[1], detection.location.coordinates[0]]}
-              icon={createDetectionIcon(detection)}
-            >
-              <Popup>
-                <Box sx={{ minWidth: '250px' }}>
-                  <Typography variant="subtitle1" gutterBottom>
-                    {detection.type.replace('_', ' ').toUpperCase()}
-                  </Typography>
-                  <Typography variant="body2" color="textSecondary">
-                    {detection.description}
-                  </Typography>
-                  <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
-                    <Chip
-                      label={detection.status.replace('_', ' ')}
-                      size="small"
-                      color={detection.status === 'pending_review' ? 'warning' : 
-                             detection.status === 'investigating' ? 'info' : 'success'}
-                    />
-                    <Chip
-                      label={detection.source.replace('_', ' ')}
-                      size="small"
-                      variant="outlined"
-                    />
-                    <Chip
-                      label={detection.severity}
-                      size="small"
-                      color={detection.severity === 'high' ? 'error' : 
-                             detection.severity === 'medium' ? 'warning' : 'default'}
-                    />
-                  </Box>
-                  <Typography variant="caption" display="block" sx={{ mt: 1 }}>
-                    {new Date(detection.timestamp).toLocaleString()}
-                  </Typography>
-                  {detection.status === 'pending_review' && (
-                    <Box sx={{ mt: 2, display: 'flex', gap: 1 }}>
-                      <Button
-                        size="small"
-                        variant="contained"
-                        color="primary"
-                        onClick={() => {
-                          // TODO: Implement promote to event
-                          console.log('Promoting detection to event:', detection._id);
-                        }}
-                      >
-                        Promote to Event
-                      </Button>
-                      <Button
-                        size="small"
-                        variant="outlined"
-                        onClick={() => {
-                          // TODO: Implement investigation
-                          console.log('Start investigating:', detection._id);
-                        }}
-                      >
-                        Investigate
-                      </Button>
-                    </Box>
-                  )}
-                </Box>
-              </Popup>
-            </Marker>
-          ))}
-        </MapContainer>
-
-        {/* Bottom Left Overview Panel */}
-        <Collapse in={showOverview}>
-          <Card 
-            sx={{ 
-              position: 'absolute', 
-              bottom: 24, 
-              left: 16, 
-              minWidth: 300,
-              maxWidth: 400,
-              maxHeight: 'calc(100vh - 200px)',
-              zIndex: 1000,
-              bgcolor: 'background.paper',
-              boxShadow: 3,
-              overflow: 'auto'
-            }}
-          >
-            <CardContent>
-              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
-                <Typography variant="h6" component="h2">
-                  System Overview
-                </Typography>
-                <IconButton 
-                  size="small" 
-                  onClick={() => setShowOverview(false)}
-                  sx={{ ml: 1 }}
-                >
-                  <CloseIcon fontSize="small" />
-                </IconButton>
-              </Box>
-              
-              <Box sx={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 2, mb: 2 }}>
-                <Box sx={{ textAlign: 'center' }}>
-                  <Typography variant="h4" color="primary.main" fontWeight="bold">
-                    {filteredCameras.length}
-                  </Typography>
-                  <Typography variant="body2" color="text.secondary">
-                    Total Cameras
-                  </Typography>
-                </Box>
-                <Box sx={{ textAlign: 'center' }}>
-                  <Typography variant="h4" color="error.main" fontWeight="bold">
-                    {filteredEvents.filter(e => !e.resolved).length}
-                  </Typography>
-                  <Typography variant="body2" color="text.secondary">
-                    Active Events
-                  </Typography>
-                </Box>
-              </Box>
-
-              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
-                <Typography variant="body2">Online Cameras:</Typography>
-                <Chip 
-                  label={`${filteredCameras.filter(c => c.status === 'online').length}/${filteredCameras.length}`}
-                  size="small"
-                  color="success"
-                  variant="outlined"
-                />
-              </Box>
-              
-              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
-                <Typography variant="body2">Critical Events:</Typography>
-                <Chip 
-                  label={filteredEvents.filter(e => e.severity === 'critical' && !e.resolved).length}
-                  size="small"
-                  color="error"
-                  variant="outlined"
-                />
-              </Box>
-              
-              <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
-                <Typography variant="body2">High Priority:</Typography>
-                <Chip 
-                  label={filteredEvents.filter(e => e.severity === 'high' && !e.resolved).length}
-                  size="small"
-                  color="warning"
-                  variant="outlined"
-                />
-              </Box>
-            </CardContent>
-            
-            <CardActions sx={{ justifyContent: 'space-between' }}>
-              <Button 
-                size="small"
-                onClick={() => setShowSidebar(true)}
-                startIcon={<InfoIcon />}
-              >
-                Camera Details
-              </Button>
-              <Button 
-                size="small" 
-                onClick={() => setShowLayers(!showLayers)}
-                startIcon={<LayersIcon />}
-              >
-                Layers
-              </Button>
-            </CardActions>
-          </Card>
-        </Collapse>
-      </Box>
-
-      {/* Right-click Context Menu */}
-      <MapContextMenu
-        position={contextMenu?.position || null}
-        latLng={contextMenu?.latLng || null}
-        onClose={() => setContextMenu(null)}
-        onAddCamera={handleAddCamera}
-        onCreateEvent={handleCreateEvent}
-        onViewCoverage={handleViewCoverage}
-        onAnalyzeArea={handleAnalyzeArea}
-        onSetWaypoint={handleSetWaypoint}
-        onMeasureDistance={handleMeasureDistance}
-        onViewTimeline={handleViewTimeline}
-        userRole="operator"
-        nearbyData={{
-          cameras: filteredCameras.length,
-          events: filteredEvents.length,
-          detections: filteredDetections.length
-        }}
-      />
-    </Box>
-  );
-};
-
-export default MapView;
\ No newline at end of file
+      setDetections(mockDetections);
+    } catch (error) {
+      console.error('Error fetching data:', error);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Generate mock detections for demonstration
+  const generateMockDetections = (cameras: Camera[]) => {
+    const detectionTypes = ['motion_detected', 'object_detected', 'user_submitted', 'ai_flagged'];
+    const sources = ['camera_system', 'user_report', 'ai_detection'];
+    
+    return cameras.slice(0, 8).map((camera, index) => ({
+      _id: `detection_${index}`,
+      type: detectionTypes[index % detectionTypes.length],
+      source: sources[index % sources.length],
+      location: {
+        coordinates: [camera.location.coordinates[0] + (Math.random() - 0.5) * 0.01, camera.location.coordinates[1] + (Math.random() - 0.5) * 0.01]
+      },
+      confidence: Math.random(),
+      status: index % 3 === 0 ? 'pending_review' : index % 3 === 1 ? 'investigating' : 'resolved',
+      timestamp: new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000),
+      description: `Detection reported: ${detectionTypes[index % detectionTypes.length].replace('_', ' ')}`,
+      cameraId: camera._id,
+      severity: index % 4 === 0 ? 'high' : index % 4 === 1 ? 'medium' : 'low',
+      isPromotedToEvent: index % 5 === 0
+    }));
+  };
+
+  // Apply filters
+  const applyFilters = () => {
+    let filteredCams = cameras.filter(camera => {
+      const matchesSearch = searchTerm === '' || 
+        camera.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        camera.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        camera.location.address?.toLowerCase().includes(searchTerm.toLowerCase());
+      
+      const matchesStatus = statusFilter === 'all' || camera.status === statusFilter;
+      
+      return matchesSearch && matchesStatus;
+    });
+
+    let filteredEvts = events.filter(event => {
+      const matchesSearch = searchTerm === '' || 
+        event.cameraName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        event.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        event.type.toLowerCase().includes(searchTerm.toLowerCase());
+      
+      const matchesType = eventTypeFilter === 'all' || event.type === eventTypeFilter;
+      const matchesSeverity = severityFilter === 'all' || event.severity === severityFilter;
+      const matchesResolved = !showUnresolvedOnly || !event.resolved;
+      const matchesSource = reportSourceFilter === 'all' || (event as any).source === reportSourceFilter;
+      
+      return matchesSearch && matchesType && matchesSeverity && matchesResolved && matchesSource;
+    });
+
+    // Filter detections (non-event reports)
+    let filteredDets = detections.filter(detection => {
+      const matchesSearch = searchTerm === '' || 
+        detection.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        detection.type.toLowerCase().includes(searchTerm.toLowerCase());
+      
+      const matchesType = detectionTypeFilter === 'all' || detection.type === detectionTypeFilter;
+      const matchesSource = reportSourceFilter === 'all' || detection.source === reportSourceFilter;
+      const matchesSeverity = severityFilter === 'all' || detection.severity === severityFilter;
+      const matchesPending = !showPendingOnly || detection.status === 'pending_review';
+      const notPromotedToEvent = !detection.isPromotedToEvent; // Only show detections that haven't become events
+      
+      return matchesSearch && matchesType && matchesSource && matchesSeverity && matchesPending && notPromotedToEvent;
+    });
+
+    setFilteredCameras(filteredCams);
+    setFilteredEvents(filteredEvts);
+    setFilteredDetections(filteredDets);
+  };
+
+  useEffect(() => {
+    fetchData();
+  }, []);
+
+  useEffect(() => {
+    applyFilters();
+  }, [cameras, events, detections, searchTerm, statusFilter, eventTypeFilter, severityFilter, detectionTypeFilter, reportSourceFilter, showUnresolvedOnly, showPendingOnly]);
+
+  // Create event markers with severity-based styling
+  const createEventIcon = (severity: string) => {
+    const colors = {
+      low: '#2196f3',
+      medium: '#ff9800',
+      high: '#f44336',
+      critical: '#d32f2f'
+    };
+
+    const svgIcon = `
+      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
+        <circle cx="15" cy="15" r="12" fill="${colors[severity as keyof typeof colors]}" stroke="white" stroke-width="2"/>
+        <path d="M10 8h10v6h-10z M15 14l5-3v8l-5-3z" fill="white"/>
+      </svg>
+    `;
+
+    return L.divIcon({
+      html: svgIcon,
+      className: 'custom-event-marker',
+      iconSize: [30, 30],
+      iconAnchor: [15, 15],
+    });
+  };
+
+  // Create detection marker icon
+  const createDetectionIcon = (detection: any) => {
+    const typeIcons = {
+      motion_detected: 'ğŸš¶',
+      object_detected: 'ğŸ“¦',
+      user_submitted: 'ğŸ‘¤',
+      ai_flagged: 'ğŸ¤–',
+      anomaly_detected: 'âš ï¸'
+    };
+
+    const statusColors = {
+      pending_review: '#ff9800',
+      investigating: '#2196f3',
+      resolved: '#4caf50',
+      dismissed: '#9e9e9e'
+    };
+
+    const size = 25;
+    const icon = typeIcons[detection.type as keyof typeof typeIcons] || 'ğŸ“';
+    const color = statusColors[detection.status as keyof typeof statusColors] || '#ff9800';
+
+    const svgIcon = `
+      <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
+        <circle cx="${size/2}" cy="${size/2}" r="${size/2-2}" 
+                fill="${color}" stroke="white" stroke-width="2" opacity="0.9"/>
+        <text x="${size/2}" y="${size/2+4}" text-anchor="middle" 
+              font-size="10" fill="white">
+          ${icon}
+        </text>
+      </svg>
+    `;
+
+    return L.divIcon({
+      html: svgIcon,
+      className: 'custom-detection-marker',
+      iconSize: [size, size],
+      iconAnchor: [size/2, size/2],
+    });
+  };
+
+  // Context menu handlers
+  const handleMapRightClick = (e: any) => {
+    const { lat, lng } = e.latlng;
+    const { x, y } = e.containerPoint;
+    
+    setContextMenu({
+      position: { x: x + e.target._container.offsetLeft, y: y + e.target._container.offsetTop },
+      latLng: { lat, lng }
+    });
+  };
+
+  const handleAddCamera = (position: { lat: number; lng: number }) => {
+    navigate('/cameras/add', { 
+      state: { 
+        coordinates: { 
+          latitude: position.lat, 
+          longitude: position.lng 
+        } 
+      } 
+    });
+  };
+
+  const handleCreateEvent = (position: { lat: number; lng: number }) => {
+    // TODO: Implement event creation modal
+    console.log('Creating event at:', position);
+  };
+
+  const handleViewCoverage = (position: { lat: number; lng: number }) => {
+    // TODO: Show camera coverage areas
+    console.log('Viewing coverage for:', position);
+  };
+
+  const handleAnalyzeArea = (position: { lat: number; lng: number }) => {
+    // TODO: Open area analysis tools
+    console.log('Analyzing area:', position);
+  };
+
+  const handleSetWaypoint = (position: { lat: number; lng: number }) => {
+    // TODO: Add waypoint functionality
+    console.log('Setting waypoint:', position);
+  };
+
+  const handleMeasureDistance = (position: { lat: number; lng: number }) => {
+    // TODO: Start distance measurement
+    console.log('Measuring distance from:', position);
+  };
+
+  const handleViewTimeline = (position: { lat: number; lng: number }) => {
+    // TODO: Show timeline for location
+    console.log('Viewing timeline for:', position);
+  };
+
+  // Map event handler component
+  const MapEventHandler = () => {
+    const map = useMapEvents({
+      contextmenu: (e) => {
+        const { lat, lng } = e.latlng;
+        const { x, y } = e.containerPoint;
+        
+        setContextMenu({
+          position: { x, y },
+          latLng: { lat, lng }
+        });
+      },
+    });
+    return null;
+  };
+
+  if (loading) {
+    return (
+      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
+        <CircularProgress />
+      </Box>
+    );
+  }
+
+  return (
+    <Box sx={{ height: '100vh', position: 'relative', overflow: 'hidden' }}>
+      {/* Header with Search and Filters */}
+      <Box sx={{ p: 2, bgcolor: 'background.paper', borderBottom: 1, borderColor: 'divider', zIndex: 1000, position: 'relative' }}>
+        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
+          <Typography variant="h5" component="h1">
+            Security Map
+          </Typography>
+          <TextField
+            size="small"
+            placeholder="Search cameras and events..."
+            value={searchTerm}
+            onChange={(e) => setSearchTerm(e.target.value)}
+            InputProps={{
+              startAdornment: (
+                <InputAdornment position="start">
+                  <SearchIcon />
+                </InputAdornment>
+              ),
+            }}
+            sx={{ minWidth: 300 }}
+          />
+          <IconButton onClick={(e) => setFilterAnchorEl(e.currentTarget)}>
+            <FilterListIcon />
+          </IconButton>
+          <IconButton onClick={() => setShowLayers(!showLayers)}>
+            <LayersIcon />
+          </IconButton>
+          <IconButton onClick={() => setShowSidebar(!showSidebar)}>
+            <InfoIcon />
+          </IconButton>
+        </Box>
+
+        {/* Layer Controls */}
+        <Collapse in={showLayers}>
+          <Box sx={{ mt: 2, display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
+            <FormControlLabel
+              control={<Switch checked={showCameras} onChange={(e) => setShowCameras(e.target.checked)} />}
+              label={`Cameras (${filteredCameras.length})`}
+            />
+            <FormControlLabel
+              control={<Switch checked={showEvents} onChange={(e) => setShowEvents(e.target.checked)} />}
+              label={`Events (${filteredEvents.length})`}
+            />
+            <FormControlLabel
+              control={<Switch checked={showDetections} onChange={(e) => setShowDetections(e.target.checked)} />}
+              label={`Detections (${filteredDetections.length})`}
+            />
+            <FormControlLabel
+              control={<Switch checked={showOverview} onChange={(e) => setShowOverview(e.target.checked)} />}
+              label="Overview Panel"
+            />
+          </Box>
+        </Collapse>
+      </Box>
+
+      {/* Side Drawer for Camera Details */}
+      <Drawer
+        anchor="right"
+        open={showSidebar}
+        onClose={() => setShowSidebar(false)}
+        variant="persistent"
+        sx={{
+          width: showSidebar ? 400 : 0,
+          flexShrink: 0,
+          '& .MuiDrawer-paper': {
+            width: 400,
+            boxSizing: 'border-box',
+            top: '120px',
+            height: 'calc(100vh - 120px)',
+          },
+        }}
+      >
+        <Box sx={{ p: 2 }}>
+          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
+            <Typography variant="h6">Camera Details</Typography>
+            <IconButton onClick={() => setShowSidebar(false)}>
+              <CloseIcon />
+            </IconButton>
+          </Box>
+          
+          {selectedCameraDetails ? (
+            <Card>
+              <CardContent>
+                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
+                  <Avatar sx={{ bgcolor: selectedCameraDetails.status === 'online' ? 'success.main' : selectedCameraDetails.status === 'offline' ? 'error.main' : 'warning.main' }}>
+                    <VideocamIcon />
+                  </Avatar>
+                  <Box>
+                    <Typography variant="h6">{selectedCameraDetails.name}</Typography>
+                    <Chip 
+                      label={selectedCameraDetails.status} 
+                      size="small" 
+                      color={selectedCameraDetails.status === 'online' ? 'success' : selectedCameraDetails.status === 'offline' ? 'error' : 'warning'}
+                    />
+                  </Box>
+                </Box>
+                
+                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
+                  {selectedCameraDetails.description}
+                </Typography>
+                
+                <Typography variant="subtitle2" gutterBottom>Location</Typography>
+                <Typography variant="body2" sx={{ mb: 2 }}>
+                  {selectedCameraDetails.location.address}
+                </Typography>
+                
+                <Typography variant="subtitle2" gutterBottom>Settings</Typography>
+                <Box sx={{ mb: 2 }}>
+                  <Typography variant="body2">Resolution: {selectedCameraDetails.settings.resolution}</Typography>
+                  <Typography variant="body2">FPS: {selectedCameraDetails.settings.fps}</Typography>
+                  <Typography variant="body2">Recording: {selectedCameraDetails.settings.recordingEnabled ? 'Enabled' : 'Disabled'}</Typography>
+                </Box>
+              </CardContent>
+              
+              <CardActions sx={{ justifyContent: 'space-between' }}>
+                <Button 
+                  variant="contained" 
+                  startIcon={<PlayArrowIcon />}
+                  disabled={selectedCameraDetails.status !== 'online'}
+                  size="small"
+                >
+                  Live Feed
+                </Button>
+                <Button 
+                  variant="outlined" 
+                  startIcon={<SettingsIcon />}
+                  size="small"
+                >
+                  Settings
+                </Button>
+              </CardActions>
+            </Card>
+          ) : (
+            <Typography variant="body2" color="text.secondary">
+              Click on a camera marker to view details
+            </Typography>
+          )}
+          
+          <Divider sx={{ my: 3 }} />
+          
+          <Typography variant="h6" gutterBottom>All Cameras</Typography>
+          <List>
+            {filteredCameras.map((camera) => (
+              <ListItem key={camera._id} disablePadding>
+                <ListItemButton 
+                  onClick={() => {
+                    setSelectedCameraDetails(camera);
+                    setSelectedCamera(camera);
+                  }}
+                  selected={selectedCameraDetails?._id === camera._id}
+                >
+                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%' }}>
+                    <Avatar sx={{ 
+                      bgcolor: camera.status === 'online' ? 'success.main' : camera.status === 'offline' ? 'error.main' : 'warning.main',
+                      width: 32,
+                      height: 32
+                    }}>
+                      <VideocamIcon sx={{ fontSize: 16 }} />
+                    </Avatar>
+                    <Box sx={{ flexGrow: 1 }}>
+                      <Typography variant="body2" fontWeight="medium">
+                        {camera.name}
+                      </Typography>
+                      <Typography variant="caption" color="text.secondary">
+                        {camera.location.address}
+                      </Typography>
+                    </Box>
+                    <Chip 
+                      label={camera.status} 
+                      size="small"
+                      variant="outlined"
+                      color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
+                    />
+                  </Box>
+                </ListItemButton>
+              </ListItem>
+            ))}
+          </List>
+        </Box>
+      </Drawer>
+
+      {/* Filter Menu */}
+      <Menu
+        anchorEl={filterAnchorEl}
+        open={Boolean(filterAnchorEl)}
+        onClose={() => setFilterAnchorEl(null)}
+      >
+        <Box sx={{ p: 2, minWidth: 250 }}>
+          <FormControl fullWidth sx={{ mb: 2 }}>
+            <InputLabel>Camera Status</InputLabel>
+            <Select
+              value={statusFilter}
+              label="Camera Status"
+              onChange={(e) => setStatusFilter(e.target.value)}
+            >
+              <MenuItem value="all">All Status</MenuItem>
+              <MenuItem value="online">Online</MenuItem>
+              <MenuItem value="offline">Offline</MenuItem>
+              <MenuItem value="maintenance">Maintenance</MenuItem>
+            </Select>
+          </FormControl>
+
+          <FormControl fullWidth sx={{ mb: 2 }}>
+            <InputLabel>Event Type</InputLabel>
+            <Select
+              value={eventTypeFilter}
+              label="Event Type"
+              onChange={(e) => setEventTypeFilter(e.target.value)}
+            >
+              {eventTypes.map(type => (
+                <MenuItem key={type} value={type}>
+                  {type === 'all' ? 'All Types' : type.replace('_', ' ').toUpperCase()}
+                </MenuItem>
+              ))}
+            </Select>
+          </FormControl>
+
+          <FormControl fullWidth sx={{ mb: 2 }}>
+            <InputLabel>Detection Type</InputLabel>
+            <Select
+              value={detectionTypeFilter}
+              label="Detection Type"
+              onChange={(e) => setDetectionTypeFilter(e.target.value)}
+            >
+              {detectionTypes.map(type => (
+                <MenuItem key={type} value={type}>
+                  {type === 'all' ? 'All Types' : type.replace('_', ' ').toUpperCase()}
+                </MenuItem>
+              ))}
+            </Select>
+          </FormControl>
+
+          <FormControl fullWidth sx={{ mb: 2 }}>
+            <InputLabel>Report Source</InputLabel>
+            <Select
+              value={reportSourceFilter}
+              label="Report Source"
+              onChange={(e) => setReportSourceFilter(e.target.value)}
+            >
+              {reportSources.map(source => (
+                <MenuItem key={source} value={source}>
+                  {source === 'all' ? 'All Sources' : source.replace('_', ' ').toUpperCase()}
+                </MenuItem>
+              ))}
+            </Select>
+          </FormControl>
+
+          <FormControl fullWidth sx={{ mb: 2 }}>
+            <InputLabel>Severity</InputLabel>
+            <Select
+              value={severityFilter}
+              label="Severity"
+              onChange={(e) => setSeverityFilter(e.target.value)}
+            >
+              <MenuItem value="all">All Severities</MenuItem>
+              <MenuItem value="low">Low</MenuItem>
+              <MenuItem value="medium">Medium</MenuItem>
+              <MenuItem value="high">High</MenuItem>
+              <MenuItem value="critical">Critical</MenuItem>
+            </Select>
+          </FormControl>
+
+          <FormControlLabel
+            control={
+              <Switch 
+                checked={showUnresolvedOnly} 
+                onChange={(e) => setShowUnresolvedOnly(e.target.checked)} 
+              />
+            }
+            label="Unresolved Events Only"
+          />
+          
+          <FormControlLabel
+            control={
+              <Switch 
+                checked={showPendingOnly} 
+                onChange={(e) => setShowPendingOnly(e.target.checked)} 
+              />
+            }
+            label="Pending Review Only"
+          />
+          
+          <FormControlLabel
+            control={
+              <Switch 
+                checked={autoZoomToNew} 
+                onChange={(e) => setAutoZoomToNew(e.target.checked)} 
+              />
+            }
+            label="Auto Zoom to New Reports"
+          />
+        </Box>
+      </Menu>
+
+      {/* Map */}
+      <Box 
+        sx={{ height: 'calc(100vh - 120px)', position: 'relative' }}
+        onClick={() => setContextMenu(null)}
+      >
+        <MapContainer
+          center={[40.7831, -73.9712]}
+          zoom={13}
+          style={{ height: '100%', width: showSidebar ? 'calc(100% - 400px)' : '100%' }}
+        >
+          <MapEventHandler />
+          <TileLayer
+            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
+          />
+
+          {/* Camera Markers */}
+          {showCameras && filteredCameras.map((camera) => (
+            <Marker
+              key={`camera-${camera._id}-${camera.location.coordinates[1]}-${camera.location.coordinates[0]}`}
+              position={[camera.location.coordinates[1], camera.location.coordinates[0]]}
+              icon={createCameraIcon(camera.status)}
+              eventHandlers={{
+                click: () => {
+                  setSelectedCameraDetails(camera);
+                  setSelectedCamera(camera);
+                  setShowSidebar(true);
+                },
+              }}
+            >
+              <Popup>
+                <Box>
+                  <Typography variant="h6">{camera.name}</Typography>
+                  <Typography variant="body2" color="text.secondary">
+                    {camera.description}
+                  </Typography>
+                  <Chip
+                    label={camera.status}
+                    size="small"
+                    color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
+                    sx={{ mt: 1, mb: 2 }}
+                  />
+                  <Box sx={{ display: 'flex', gap: 1, mt: 1 }}>
+                    <Button 
+                      size="small" 
+                      variant="contained" 
+                      startIcon={<PlayArrowIcon />}
+                      disabled={camera.status !== 'online'}
+                      onClick={() => {
+                        setSelectedCameraDetails(camera);
+                        setShowSidebar(true);
+                      }}
+                    >
+                      View Details
+                    </Button>
+                  </Box>
+                </Box>
+              </Popup>
+            </Marker>
+          ))}
+
+          {/* Event Markers - CRITICAL FIX: Using stable coordinate-based keys */}
+          {showEvents && filteredEvents.map((event) => (
+            <Marker
+              key={`event-${event._id}-${event.location.coordinates[1]}-${event.location.coordinates[0]}`}
+              position={[event.location.coordinates[1], event.location.coordinates[0]]}
+              icon={createEventIcon(event.severity)}
+            >
+              <Popup>
+                <Box>
+                  <Typography variant="h6">{event.type.replace('_', ' ')}</Typography>
+                  <Typography variant="body2">{event.description}</Typography>
+                  <Box sx={{ mt: 1, display: 'flex', gap: 1 }}>
+                    <Chip
+                      label={event.severity}
+                      size="small"
+                      color={event.severity === 'critical' ? 'error' : event.severity === 'high' ? 'warning' : 'default'}
+                    />
+                    {!event.resolved && (
+                      <Chip
+                        label="Unresolved"
+                        size="small"
+                        color="error"
+                        variant="outlined"
+                      />
+                    )}
+                  </Box>
+                  <Typography variant="caption" display="block" sx={{ mt: 1 }}>
+                    Camera: {event.cameraName}
+                  </Typography>
+                  <Typography variant="caption" display="block">
+                    {new Date(event.timestamp).toLocaleString()}
+                  </Typography>
+                </Box>
+              </Popup>
+            </Marker>
+          ))}
+
+          {/* Detection Markers (Non-Event Reports) */}
+          {showDetections && filteredDetections.map((detection) => (
+            <Marker
+              key={`detection-${detection._id}`}
+              position={[detection.location.coordinates[1], detection.location.coordinates[0]]}
+              icon={createDetectionIcon(detection)}
+            >
+              <Popup>
+                <Box sx={{ minWidth: '250px' }}>
+                  <Typography variant="subtitle1" gutterBottom>
+                    {detection.type.replace('_', ' ').toUpperCase()}
+                  </Typography>
+                  <Typography variant="body2" color="textSecondary">
+                    {detection.description}
+                  </Typography>
+                  <Box sx={{ mt: 1, display: 'flex', gap: 1, flexWrap: 'wrap' }}>
+                    <Chip
+                      label={detection.status.replace('_', ' ')}
+                      size="small"
+                      color={detection.status === 'pending_review' ? 'warning' : 
+                             detection.status === 'investigating' ? 'info' : 'success'}
+                    />
+                    <Chip
+                      label={detection.source.replace('_', ' ')}
+                      size="small"
+                      variant="outlined"
+                    />
+                    <Chip
+                      label={detection.severity}
+                      size="small"
+                      color={detection.severity === 'high' ? 'error' : 
+                             detection.severity === 'medium' ? 'warning' : 'default'}
+                    />
+                  </Box>
+                  <Typography variant="caption" display="block" sx={{ mt: 1 }}>
+                    {new Date(detection.timestamp).toLocaleString()}
+                  </Typography>
+                  {detection.status === 'pending_review' && (
+                    <Box sx={{ mt: 2, display: 'flex', gap: 1 }}>
+                      <Button
+                        size="small"
+                        variant="contained"
+                        color="primary"
+                        onClick={() => {
+                          // TODO: Implement promote to event
+                          console.log('Promoting detection to event:', detection._id);
+                        }}
+                      >
+                        Promote to Event
+                      </Button>
+                      <Button
+                        size="small"
+                        variant="outlined"
+                        onClick={() => {
+                          // TODO: Implement investigation
+                          console.log('Start investigating:', detection._id);
+                        }}
+                      >
+                        Investigate
+                      </Button>
+                    </Box>
+                  )}
+                </Box>
+              </Popup>
+            </Marker>
+          ))}
+        </MapContainer>
+
+        {/* Bottom Left Overview Panel */}
+        <Collapse in={showOverview}>
+          <Card 
+            sx={{ 
+              position: 'absolute', 
+              bottom: 24, 
+              left: 16, 
+              minWidth: 300,
+              maxWidth: 400,
+              maxHeight: 'calc(100vh - 200px)',
+              zIndex: 1000,
+              bgcolor: 'background.paper',
+              boxShadow: 3,
+              overflow: 'auto'
+            }}
+          >
+            <CardContent>
+              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
+                <Typography variant="h6" component="h2">
+                  System Overview
+                </Typography>
+                <IconButton 
+                  size="small" 
+                  onClick={() => setShowOverview(false)}
+                  sx={{ ml: 1 }}
+                >
+                  <CloseIcon fontSize="small" />
+                </IconButton>
+              </Box>
+              
+              <Box sx={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 2, mb: 2 }}>
+                <Box sx={{ textAlign: 'center' }}>
+                  <Typography variant="h4" color="primary.main" fontWeight="bold">
+                    {filteredCameras.length}
+                  </Typography>
+                  <Typography variant="body2" color="text.secondary">
+                    Total Cameras
+                  </Typography>
+                </Box>
+                <Box sx={{ textAlign: 'center' }}>
+                  <Typography variant="h4" color="error.main" fontWeight="bold">
+                    {filteredEvents.filter(e => !e.resolved).length}
+                  </Typography>
+                  <Typography variant="body2" color="text.secondary">
+                    Active Events
+                  </Typography>
+                </Box>
+              </Box>
+
+              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
+                <Typography variant="body2">Online Cameras:</Typography>
+                <Chip 
+                  label={`${filteredCameras.filter(c => c.status === 'online').length}/${filteredCameras.length}`}
+                  size="small"
+                  color="success"
+                  variant="outlined"
+                />
+              </Box>
+              
+              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
+                <Typography variant="body2">Critical Events:</Typography>
+                <Chip 
+                  label={filteredEvents.filter(e => e.severity === 'critical' && !e.resolved).length}
+                  size="small"
+                  color="error"
+                  variant="outlined"
+                />
+              </Box>
+              
+              <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
+                <Typography variant="body2">High Priority:</Typography>
+                <Chip 
+                  label={filteredEvents.filter(e => e.severity === 'high' && !e.resolved).length}
+                  size="small"
+                  color="warning"
+                  variant="outlined"
+                />
+              </Box>
+            </CardContent>
+            
+            <CardActions sx={{ justifyContent: 'space-between' }}>
+              <Button 
+                size="small"
+                onClick={() => setShowSidebar(true)}
+                startIcon={<InfoIcon />}
+              >
+                Camera Details
+              </Button>
+              <Button 
+                size="small" 
+                onClick={() => setShowLayers(!showLayers)}
+                startIcon={<LayersIcon />}
+              >
+                Layers
+              </Button>
+            </CardActions>
+          </Card>
+        </Collapse>
+      </Box>
+
+      {/* Right-click Context Menu */}
+      <MapContextMenu
+        position={contextMenu?.position || null}
+        latLng={contextMenu?.latLng || null}
+        onClose={() => setContextMenu(null)}
+        onAddCamera={handleAddCamera}
+        onCreateEvent={handleCreateEvent}
+        onViewCoverage={handleViewCoverage}
+        onAnalyzeArea={handleAnalyzeArea}
+        onSetWaypoint={handleSetWaypoint}
+        onMeasureDistance={handleMeasureDistance}
+        onViewTimeline={handleViewTimeline}
+        userRole="operator"
+        nearbyData={{
+          cameras: filteredCameras.length,
+          events: filteredEvents.length,
+          detections: filteredDetections.length
+        }}
+      />
+    </Box>
+  );
+};
+
+export default MapView;
diff --git a/event-monitoring-mvp/frontend/src/pages/MapView.tsx.broken b/event-monitoring-mvp/frontend/src/pages/MapView.tsx.broken
index 0b22f12..bf15eef 100644
--- a/event-monitoring-mvp/frontend/src/pages/MapView.tsx.broken
+++ b/event-monitoring-mvp/frontend/src/pages/MapView.tsx.broken
@@ -1,967 +1,967 @@
-import React, { useState, useEffect } from 'react';
-import {
-  Box,
-  Typography,
-  Paper,
-  Chip,
-  Dialog,
-  DialogTitle,
-  DialogContent,
-  DialogActions,
-  Switch,
-  FormControlLabel,
-  Button,
-  CircularProgress,
-  TextField,
-  InputAdornment,
-  Menu,
-  MenuItem,
-  ListItemIcon,
-  ListItemText,
-  Autocomplete,
-  Fab,
-  Card,
-  CardContent,
-  Tooltip,
-  Divider,
-  Badge,
-  Grid,
-} from '@mui/material';
-import {
-  Videocam as VideocamIcon,
-  Refresh as RefreshIcon,
-  Search as SearchIcon,
-  FilterList as FilterIcon,
-  Layers as LayersIcon,
-  Add as AddIcon,
-  MyLocation as MyLocationIcon,
-  Fullscreen as FullscreenIcon,
-  LocationOn as LocationIcon,
-  Event as EventIcon,
-  Warning as WarningIcon,
-  Close as CloseIcon,
-} from '@mui/icons-material';
-import {
-  MapContainer,
-  TileLayer,
-  Marker,
-  Popup,
-} from 'react-leaflet';
-import L from 'leaflet';
-import 'leaflet/dist/leaflet.css';
-
-// Fix for default markers in react-leaflet
-delete (L.Icon.Default.prototype as any)._getIconUrl;
-L.Icon.Default.mergeOptions({
-  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
-  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
-  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
-});
-
-import { Camera } from '../types/index';
-import { fetchCamerasData, fetchEventsData, SecurityEvent } from '../services/dataService';
-
-// Create custom camera icons based on status
-const createCameraIcon = (status: 'online' | 'offline' | 'maintenance') => {
-  const colors = {
-    online: '#4caf50',
-    offline: '#f44336',
-    maintenance: '#ff9800'
-  };
-
-  const svgIcon = `
-    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
-      <circle cx="20" cy="20" r="18" fill="${colors[status]}" stroke="white" stroke-width="3"/>
-      <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
-    </svg>
-  `;
-
-  return L.divIcon({
-    html: svgIcon,
-    className: 'custom-camera-marker',
-    iconSize: [40, 40],
-    iconAnchor: [20, 20],
-  });
-};
-
-/**
- * MapView Component - Interactive map displaying security cameras and events
- * Uses Leaflet with OpenStreetMap (completely free, no API key required)
- */
-const MapView: React.FC = () => {
-  const [loading, setLoading] = useState(true);
-  const [selectedCamera, setSelectedCamera] = useState<Camera | null>(null);
-  const [selectedEvent, setSelectedEvent] = useState<SecurityEvent | null>(null);
-  const [showCameras, setShowCameras] = useState(true);
-  const [showEvents, setShowEvents] = useState(true);
-  const [showLayers, setShowLayers] = useState(false);
-  const [cameras, setCameras] = useState<Camera[]>([]);
-  const [events, setEvents] = useState<SecurityEvent[]>([]);
-  const [filteredCameras, setFilteredCameras] = useState<Camera[]>([]);
-  const [filteredEvents, setFilteredEvents] = useState<SecurityEvent[]>([]);
-  
-  // Search and filter states
-  const [searchTerm, setSearchTerm] = useState('');
-  const [statusFilter, setStatusFilter] = useState<string>('all');
-  const [eventTypeFilter, setEventTypeFilter] = useState<string>('all');
-  const [severityFilter, setSeverityFilter] = useState<string>('all');
-  const [showUnresolvedOnly, setShowUnresolvedOnly] = useState(false);
-  
-  // UI states
-  const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLElement | null>(null);
-
-  // API call to fetch cameras and events from backend
-  const fetchCameras = async () => {
-    try {
-      setLoading(true);
-      
-      // Fetch both cameras and events using shared data service
-      const [cameras, events] = await Promise.all([
-        fetchCamerasData(),
-        fetchEventsData(),
-      ]);
-      
-      setCameras(cameras);
-      setEvents(events);
-    } catch (error) {
-      console.error('Error fetching data:', error);
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  // Filtering and search functions
-  const applyFilters = () => {
-    // Filter cameras
-    let filteredCams = cameras.filter(camera => {
-          isActive: true,
-          createdAt: new Date().toISOString(),
-          updatedAt: new Date().toISOString(),
-        },
-        {
-          _id: '2',
-          name: 'Parking Lot Camera',
-          description: 'Vehicle monitoring area',
-          streamUrl: 'rtsp://192.168.1.101:554/stream',
-          status: 'online',
-          type: 'ip',
-          location: {
-            coordinates: [-74.0070, 40.7138],
-            address: '125 Main St, New York, NY',
-          },
-          settings: {
-            resolution: '1920x1080',
-            fps: 25,
-            recordingEnabled: false,
-          },
-          isActive: true,
-          createdAt: new Date().toISOString(),
-          updatedAt: new Date().toISOString(),
-        },
-        {
-          _id: '3',
-          name: 'Side Entrance Camera',
-          description: 'Secondary access point',
-          streamUrl: 'rtsp://192.168.1.102:554/stream',
-          status: 'offline',
-          type: 'ip',
-          location: {
-            coordinates: [-74.0050, 40.7118],
-            address: '121 Main St, New York, NY',
-          },
-          settings: {
-            resolution: '1280x720',
-            fps: 20,
-            recordingEnabled: true,
-          },
-          isActive: true,
-          createdAt: new Date().toISOString(),
-          updatedAt: new Date().toISOString(),
-        },
-        {
-          _id: '4',
-          name: 'Loading Dock Camera',
-          description: 'Delivery area surveillance',
-          streamUrl: 'rtsp://192.168.1.103:554/stream',
-          status: 'maintenance',
-          type: 'ip',
-          location: {
-            coordinates: [-74.0040, 40.7108],
-            address: '119 Main St, New York, NY',
-          },
-          settings: {
-            resolution: '1920x1080',
-            fps: 30,
-            recordingEnabled: true,
-          },
-          isActive: true,
-          createdAt: new Date().toISOString(),
-          updatedAt: new Date().toISOString(),
-        },
-      ];
-      
-      const mockEvents: SecurityEvent[] = [
-        {
-          _id: 'evt1',
-          type: 'person_detected',
-          severity: 'medium',
-          location: {
-            coordinates: [-74.0062, 40.7130],
-            address: '123 Main St, New York, NY',
-          },
-          camera: '1',
-          cameraName: 'Front Gate Camera',
-          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
-          description: 'Person detected at main entrance',
-          resolved: false,
-          metadata: {
-            confidence: 0.95,
-            duration: 30,
-            objectCount: 1,
-          },
-        },
-        {
-          _id: 'evt2',
-          type: 'unauthorized_access',
-          severity: 'high',
-          location: {
-            coordinates: [-74.0052, 40.7120],
-            address: '121 Main St, New York, NY',
-          },
-          camera: '3',
-          cameraName: 'Side Entrance Camera',
-          timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago
-          description: 'Attempted access to restricted area',
-          resolved: false,
-          metadata: {
-            confidence: 0.88,
-            duration: 45,
-          },
-        },
-        {
-          _id: 'evt3',
-          type: 'vehicle_detected',
-          severity: 'low',
-          location: {
-            coordinates: [-74.0072, 40.7140],
-            address: '125 Main St, New York, NY',
-          },
-          camera: '2',
-          cameraName: 'Parking Lot Camera',
-          timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 minutes ago
-          description: 'Vehicle entered parking area',
-          resolved: true,
-          metadata: {
-            confidence: 0.92,
-            duration: 120,
-            objectCount: 1,
-          },
-        },
-        {
-          _id: 'evt4',
-          type: 'motion',
-          severity: 'critical',
-          location: {
-            coordinates: [-74.0042, 40.7110],
-            address: '119 Main St, New York, NY',
-          },
-          camera: '4',
-          cameraName: 'Loading Dock Camera',
-          timestamp: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // 1 hour ago
-          description: 'Unusual motion detected during off-hours',
-          resolved: false,
-          metadata: {
-            confidence: 0.78,
-            duration: 180,
-          },
-        },
-      ];
-      
-      setCameras(mockCameras);
-      setEvents(mockEvents);
-    } catch (error) {
-      console.error('Error fetching data:', error);
-    } finally {
-      setLoading(false);
-    }
-  };
-
-  // Filtering and search functions
-  const applyFilters = () => {
-    // Filter cameras
-    let filteredCams = cameras.filter(camera => {
-      const matchesSearch = searchTerm === '' || 
-        camera.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        camera.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        camera.location.address?.toLowerCase().includes(searchTerm.toLowerCase());
-      
-      const matchesStatus = statusFilter === 'all' || camera.status === statusFilter;
-      
-      return matchesSearch && matchesStatus;
-    });
-
-    // Filter events
-    let filteredEvts = events.filter(event => {
-      const matchesSearch = searchTerm === '' || 
-        event.cameraName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        event.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
-        event.type.toLowerCase().includes(searchTerm.toLowerCase());
-      
-      const matchesType = eventTypeFilter === 'all' || event.type === eventTypeFilter;
-      const matchesSeverity = severityFilter === 'all' || event.severity === severityFilter;
-      const matchesResolved = !showUnresolvedOnly || !event.resolved;
-      
-      return matchesSearch && matchesType && matchesSeverity && matchesResolved;
-    });
-
-    setFilteredCameras(filteredCams);
-    setFilteredEvents(filteredEvts);
-  };
-
-  // Apply filters when dependencies change
-  useEffect(() => {
-    applyFilters();
-  }, [cameras, events, searchTerm, statusFilter, eventTypeFilter, severityFilter, showUnresolvedOnly]);
-
-  // Create event markers with severity-based styling
-  const createEventIcon = (severity: string) => {
-    const colors = {
-      low: '#2196f3',
-      medium: '#ff9800',
-      high: '#f44336',
-      critical: '#9c27b0'
-    };
-
-    const svgIcon = `
-      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
-        <circle cx="15" cy="15" r="13" fill="${colors[severity as keyof typeof colors]}" stroke="white" stroke-width="2"/>
-        <path d="M15 6l1.5 9h-3l1.5-9zm0 12a1.5 1.5 0 100 3 1.5 1.5 0 000-3z" fill="white"/>
-      </svg>
-    `;
-
-    return L.divIcon({
-      html: svgIcon,
-      className: 'custom-event-marker',
-      iconSize: [30, 30],
-      iconAnchor: [15, 15],
-    });
-  };
-
-  /**
-   * Initialize component - fetch cameras
-   */
-  useEffect(() => {
-    fetchCameras();
-  }, []);
-
-  /**
-   * Refresh camera data
-   */
-  const handleRefresh = () => {
-    fetchCameras();
-  };
-
-  return (
-    <Box sx={{ height: '100%', position: 'relative' }}>
-      {/* Enhanced Header Section with Search and Filters */}
-      <Box sx={{ mb: 2 }}>
-        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
-          <Box>
-            <Typography variant="h4" gutterBottom fontWeight="bold">
-              Interactive Security Map
-            </Typography>
-            <Typography variant="subtitle1" color="text.secondary">
-              {filteredCameras.length} cameras â€¢ {filteredEvents.filter(e => !e.resolved).length} active events
-            </Typography>
-          </Box>
-          
-          <Button
-            variant="outlined"
-            startIcon={<RefreshIcon />}
-            onClick={handleRefresh}
-            disabled={loading}
-            size="small"
-          >
-            Refresh
-          </Button>
-        </Box>
-
-        {/* Search and Filter Bar */}
-        <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', mb: 2, flexWrap: 'wrap' }}>
-          {/* Search Field */}
-          <TextField
-            placeholder="Search cameras, events, locations..."
-            value={searchTerm}
-            onChange={(e) => setSearchTerm(e.target.value)}
-            size="small"
-            sx={{ minWidth: 300 }}
-            InputProps={{
-              startAdornment: (
-                <InputAdornment position="start">
-                  <SearchIcon />
-                </InputAdornment>
-              ),
-            }}
-          />
-
-          {/* Quick Filters */}
-          <FormControlLabel
-            control={
-              <Switch
-                checked={showCameras}
-                onChange={(e) => setShowCameras(e.target.checked)}
-                color="primary"
-              />
-            }
-            label="Cameras"
-          />
-          <FormControlLabel
-            control={
-              <Switch
-                checked={showEvents}
-                onChange={(e) => setShowEvents(e.target.checked)}
-                color="warning"
-              />
-            }
-            label="Events"
-          />
-          <FormControlLabel
-            control={
-              <Switch
-                checked={showUnresolvedOnly}
-                onChange={(e) => setShowUnresolvedOnly(e.target.checked)}
-                color="error"
-              />
-            }
-            label="Unresolved Only"
-          />
-
-          {/* Filter Menu Button */}
-          <Button
-            variant="outlined"
-            startIcon={<FilterIcon />}
-            onClick={(e) => setFilterAnchorEl(e.currentTarget)}
-            size="small"
-          >
-            Filters
-          </Button>
-
-          {/* Layers Button */}
-          <Button
-            variant="outlined"
-            startIcon={<LayersIcon />}
-            onClick={() => setShowLayers(true)}
-            size="small"
-          >
-            Layers
-          </Button>
-        </Box>
-      </Box>
-
-      {/* Enhanced Map Container with Event Markers */}
-      <Paper 
-        elevation={3}
-        sx={{ 
-          position: 'relative',
-          height: 'calc(100vh - 250px)',
-          overflow: 'hidden',
-          borderRadius: 2
-        }}
-      >
-        {loading && (
-          <Box
-            sx={{
-              position: 'absolute',
-              top: 0,
-              left: 0,
-              right: 0,
-              bottom: 0,
-              backgroundColor: 'rgba(255, 255, 255, 0.8)',
-              display: 'flex',
-              alignItems: 'center',
-              justifyContent: 'center',
-              zIndex: 1000,
-            }}
-          >
-            <CircularProgress size={60} />
-            <Typography sx={{ ml: 2 }}>Loading map data...</Typography>
-          </Box>
-        )}
-        
-        <MapContainer
-          center={[40.7128, -74.0060]}
-          zoom={14}
-          style={{ height: '100%', width: '100%' }}
-          zoomControl={true}
-        >
-          <TileLayer
-            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
-            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
-          />
-          
-          {/* Camera Markers */}
-          {showCameras && filteredCameras.map((camera, index) => (
-            <Marker
-              key={`camera-${camera._id}-${index}`}
-              position={[camera.location.coordinates[1], camera.location.coordinates[0]]}
-              icon={createCameraIcon(camera.status)}
-              eventHandlers={{
-                click: () => setSelectedCamera(camera)
-              }}
-            >
-              <Popup>
-                <Box sx={{ minWidth: 250 }}>
-                  <Typography variant="h6" gutterBottom>
-                    <VideocamIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
-                    {camera.name}
-                  </Typography>
-                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
-                    <Typography variant="body2">
-                      <strong>Status:</strong>
-                    </Typography>
-                    <Chip
-                      label={camera.status.toUpperCase()}
-                      color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
-                      size="small"
-                    />
-                  </Box>
-                  {camera.description && (
-                    <Typography variant="body2" color="text.secondary" gutterBottom>
-                      {camera.description}
-                    </Typography>
-                  )}
-                  <Typography variant="caption" display="block" gutterBottom>
-                    <LocationIcon sx={{ fontSize: 12, mr: 0.5 }} />
-                    {camera.location.address || 'No address specified'}
-                  </Typography>
-                  <Typography variant="caption" display="block" gutterBottom>
-                    ğŸ“¹ {camera.settings.resolution} â€¢ {camera.settings.fps} FPS
-                  </Typography>
-                  <Button 
-                    size="small" 
-                    variant="contained"
-                    onClick={() => setSelectedCamera(camera)}
-                    sx={{ mt: 1 }}
-                  >
-                    View Details
-                  </Button>
-                </Box>
-              </Popup>
-            </Marker>
-          ))}
-
-          {/* Event Markers */}
-          {showEvents && filteredEvents.map((event, index) => (
-            <Marker
-              key={`event-${event._id}-${index}-${event.location.coordinates[0]}-${event.location.coordinates[1]}`}
-              position={[event.location.coordinates[1], event.location.coordinates[0]]}
-              icon={createEventIcon(event.severity)}
-              eventHandlers={{
-                click: () => setSelectedEvent(event)
-              }}
-            >
-              <Popup>
-                <Box sx={{ minWidth: 250 }}>
-                  <Typography variant="h6" gutterBottom>
-                    <WarningIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
-                    {event.type.replace('_', ' ').toUpperCase()}
-                  </Typography>
-                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
-                    <Typography variant="body2">
-                      <strong>Severity:</strong>
-                    </Typography>
-                    <Chip
-                      label={event.severity.toUpperCase()}
-                      color={event.severity === 'critical' ? 'error' : event.severity === 'high' ? 'warning' : 'info'}
-                      size="small"
-                    />
-                    <Chip
-                      label={event.resolved ? 'RESOLVED' : 'ACTIVE'}
-                      color={event.resolved ? 'success' : 'error'}
-                      size="small"
-                    />
-                  </Box>
-                  <Typography variant="body2" gutterBottom>
-                    {event.description}
-                  </Typography>
-                  <Typography variant="caption" display="block" gutterBottom>
-                    ğŸ“… {new Date(event.timestamp).toLocaleString()}
-                  </Typography>
-                  <Typography variant="caption" display="block" gutterBottom>
-                    ğŸ“¹ {event.cameraName}
-                  </Typography>
-                  {event.metadata && (
-                    <Typography variant="caption" display="block" gutterBottom>
-                      ğŸ¯ Confidence: {Math.round((event.metadata.confidence || 0) * 100)}%
-                    </Typography>
-                  )}
-                  <Button 
-                    size="small" 
-                    variant="contained"
-                    onClick={() => setSelectedEvent(event)}
-                    sx={{ mt: 1 }}
-                  >
-                    View Details
-                  </Button>
-                </Box>
-              </Popup>
-            </Marker>
-          ))}
-        </MapContainer>
-
-        {/* Map Stats Overlay */}
-        <Card
-          sx={{
-            position: 'absolute',
-            bottom: 16,
-            left: 16,
-            minWidth: 200,
-            bgcolor: 'rgba(255, 255, 255, 0.95)',
-            backdropFilter: 'blur(10px)',
-          }}
-        >
-          <CardContent sx={{ py: 1.5, px: 2, '&:last-child': { pb: 1.5 } }}>
-            <Typography variant="subtitle2" gutterBottom>
-              Map Overview
-            </Typography>
-            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
-              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: '#4caf50' }} />
-                <Typography variant="caption">{filteredCameras.filter(c => c.status === 'online').length} Online</Typography>
-              </Box>
-              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: '#f44336' }} />
-                <Typography variant="caption">{filteredCameras.filter(c => c.status === 'offline').length} Offline</Typography>
-              </Box>
-              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: '#ff9800' }} />
-                <Typography variant="caption">{filteredCameras.filter(c => c.status === 'maintenance').length} Maintenance</Typography>
-              </Box>
-              <Divider sx={{ my: 0.5 }} />
-              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
-                <WarningIcon sx={{ fontSize: 12, color: '#f44336' }} />
-                <Typography variant="caption">{filteredEvents.filter(e => !e.resolved).length} Active Events</Typography>
-              </Box>
-            </Box>
-          </CardContent>
-        </Card>
-      </Paper>
-
-      {/* Camera Details Dialog */}
-      <Dialog
-        open={Boolean(selectedCamera)}
-        onClose={() => setSelectedCamera(null)}
-        maxWidth="md"
-      >
-        {selectedCamera && (
-          <>
-            <DialogTitle>
-              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
-                <VideocamIcon color="primary" />
-                {selectedCamera.name}
-                <Chip
-                  label={selectedCamera.status}
-                  color={selectedCamera.status === 'online' ? 'success' : 'error'}
-                  size="small"
-                />
-              </Box>
-            </DialogTitle>
-            <DialogContent>
-              <Box sx={{ minWidth: 400 }}>
-                <Typography variant="body2" gutterBottom>
-                  <strong>Type:</strong> {selectedCamera.type.toUpperCase()} Camera
-                </Typography>
-                <Typography variant="body2" gutterBottom>
-                  <strong>Resolution:</strong> {selectedCamera.settings.resolution}
-                </Typography>
-                <Typography variant="body2" gutterBottom>
-                  <strong>FPS:</strong> {selectedCamera.settings.fps}
-                </Typography>
-                <Typography variant="body2" gutterBottom>
-                  <strong>Recording:</strong> {selectedCamera.settings.recordingEnabled ? 'Enabled' : 'Disabled'}
-                </Typography>
-                <Typography variant="body2" gutterBottom>
-                  <strong>Location:</strong> {selectedCamera.location.address || 'No address'}
-                </Typography>
-                <Typography variant="body2" gutterBottom>
-                  <strong>Coordinates:</strong> {selectedCamera.location.coordinates[1].toFixed(6)}, {selectedCamera.location.coordinates[0].toFixed(6)}
-                </Typography>
-                <Typography variant="body2" gutterBottom>
-                  <strong>Stream URL:</strong>
-                </Typography>
-                <Typography 
-                  variant="body2" 
-                  sx={{ 
-                    fontFamily: 'monospace', 
-                    fontSize: '0.75rem',
-                    wordBreak: 'break-all',
-                    color: 'text.secondary',
-                    bgcolor: 'grey.100',
-                    p: 1,
-                    borderRadius: 1
-                  }}
-                >
-                  {selectedCamera.streamUrl}
-                </Typography>
-              </Box>
-            </DialogContent>
-            <DialogActions>
-              <Button onClick={() => setSelectedCamera(null)}>Close</Button>
-              <Button variant="contained" color="primary">
-                View Live Stream
-              </Button>
-            </DialogActions>
-          </>
-        )}
-      </Dialog>
-
-      {/* Event Details Dialog */}
-      <Dialog
-        open={Boolean(selectedEvent)}
-        onClose={() => setSelectedEvent(null)}
-        maxWidth="md"
-      >
-        {selectedEvent && (
-          <>
-            <DialogTitle>
-              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
-                <EventIcon color="warning" />
-                {selectedEvent.type.replace('_', ' ').toUpperCase()} Event
-                <Chip
-                  label={selectedEvent.severity.toUpperCase()}
-                  color={selectedEvent.severity === 'critical' ? 'error' : selectedEvent.severity === 'high' ? 'warning' : 'info'}
-                  size="small"
-                />
-                <Chip
-                  label={selectedEvent.resolved ? 'RESOLVED' : 'ACTIVE'}
-                  color={selectedEvent.resolved ? 'success' : 'error'}
-                  size="small"
-                />
-              </Box>
-            </DialogTitle>
-            <DialogContent>
-              <Grid container spacing={2}>
-                <Grid item xs={12} sm={6}>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Event Type:</strong> {selectedEvent.type.replace('_', ' ')}
-                  </Typography>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Severity:</strong> {selectedEvent.severity}
-                  </Typography>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Camera:</strong> {selectedEvent.cameraName}
-                  </Typography>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Timestamp:</strong> {new Date(selectedEvent.timestamp).toLocaleString()}
-                  </Typography>
-                </Grid>
-                <Grid item xs={12} sm={6}>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Location:</strong> {selectedEvent.location.address || 'No address'}
-                  </Typography>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Coordinates:</strong> {selectedEvent.location.coordinates[1].toFixed(6)}, {selectedEvent.location.coordinates[0].toFixed(6)}
-                  </Typography>
-                  {selectedEvent.metadata?.confidence && (
-                    <Typography variant="body2" gutterBottom>
-                      <strong>Confidence:</strong> {Math.round(selectedEvent.metadata.confidence * 100)}%
-                    </Typography>
-                  )}
-                  {selectedEvent.metadata?.duration && (
-                    <Typography variant="body2" gutterBottom>
-                      <strong>Duration:</strong> {selectedEvent.metadata.duration}s
-                    </Typography>
-                  )}
-                </Grid>
-                <Grid item xs={12}>
-                  <Typography variant="body2" gutterBottom>
-                    <strong>Description:</strong>
-                  </Typography>
-                  <Typography variant="body2" sx={{ bgcolor: 'grey.100', p: 1, borderRadius: 1 }}>
-                    {selectedEvent.description}
-                  </Typography>
-                </Grid>
-              </Grid>
-            </DialogContent>
-            <DialogActions>
-              <Button onClick={() => setSelectedEvent(null)}>Close</Button>
-              {!selectedEvent.resolved && (
-                <Button variant="contained" color="primary">
-                  Mark as Resolved
-                </Button>
-              )}
-              <Button variant="outlined">
-                View Recording
-              </Button>
-            </DialogActions>
-          </>
-        )}
-      </Dialog>
-
-      {/* Filter Menu */}
-      <Menu
-        anchorEl={filterAnchorEl}
-        open={Boolean(filterAnchorEl)}
-        onClose={() => setFilterAnchorEl(null)}
-      >
-        <Box sx={{ p: 2, minWidth: 250 }}>
-          <Typography variant="h6" gutterBottom>
-            Advanced Filters
-          </Typography>
-          
-          <Typography variant="subtitle2" gutterBottom>
-            Camera Status
-          </Typography>
-          <Autocomplete
-            options={['all', 'online', 'offline', 'maintenance']}
-            value={statusFilter}
-            onChange={(_, newValue) => setStatusFilter(newValue || 'all')}
-            size="small"
-            sx={{ mb: 2 }}
-            renderInput={(params) => <TextField {...params} label="Status" />}
-          />
-
-          <Typography variant="subtitle2" gutterBottom>
-            Event Type
-          </Typography>
-          <Autocomplete
-            options={['all', 'motion', 'person_detected', 'vehicle_detected', 'unauthorized_access', 'tamper_detected']}
-            value={eventTypeFilter}
-            onChange={(_, newValue) => setEventTypeFilter(newValue || 'all')}
-            size="small"
-            sx={{ mb: 2 }}
-            renderInput={(params) => <TextField {...params} label="Event Type" />}
-          />
-
-          <Typography variant="subtitle2" gutterBottom>
-            Event Severity
-          </Typography>
-          <Autocomplete
-            options={['all', 'low', 'medium', 'high', 'critical']}
-            value={severityFilter}
-            onChange={(_, newValue) => setSeverityFilter(newValue || 'all')}
-            size="small"
-            sx={{ mb: 2 }}
-            renderInput={(params) => <TextField {...params} label="Severity" />}
-          />
-
-          <Button
-            variant="outlined"
-            onClick={() => {
-              setStatusFilter('all');
-              setEventTypeFilter('all');
-              setSeverityFilter('all');
-              setShowUnresolvedOnly(false);
-              setSearchTerm('');
-            }}
-            fullWidth
-          >
-            Reset Filters
-          </Button>
-        </Box>
-      </Menu>
-
-      {/* Layers Dialog */}
-      <Dialog open={showLayers} onClose={() => setShowLayers(false)} maxWidth="sm">
-        <DialogTitle>Map Layers</DialogTitle>
-        <DialogContent>
-          <Box sx={{ minWidth: 300 }}>
-            <Typography variant="h6" gutterBottom>
-              Visibility Controls
-            </Typography>
-            <FormControlLabel
-              control={<Switch checked={showCameras} onChange={(e) => setShowCameras(e.target.checked)} />}
-              label="Security Cameras"
-            />
-            <FormControlLabel
-              control={<Switch checked={showEvents} onChange={(e) => setShowEvents(e.target.checked)} />}
-              label="Security Events"
-            />
-            <Divider sx={{ my: 2 }} />
-            <Typography variant="h6" gutterBottom>
-              Event Filters
-            </Typography>
-            <FormControlLabel
-              control={<Switch checked={showUnresolvedOnly} onChange={(e) => setShowUnresolvedOnly(e.target.checked)} />}
-              label="Show Unresolved Events Only"
-            />
-            <Divider sx={{ my: 2 }} />
-            <Typography variant="h6" gutterBottom>
-              Map Statistics
-            </Typography>
-            <Typography variant="body2">
-              Total Cameras: {cameras.length}
-            </Typography>
-            <Typography variant="body2">
-              Visible Cameras: {filteredCameras.length}
-            </Typography>
-            <Typography variant="body2">
-              Total Events: {events.length}
-            </Typography>
-            <Typography variant="body2">
-              Visible Events: {filteredEvents.length}
-            </Typography>
-            <Typography variant="body2">
-              Active Events: {filteredEvents.filter(e => !e.resolved).length}
-            </Typography>
-          </Box>
-        </DialogContent>
-        <DialogActions>
-          <Button onClick={() => setShowLayers(false)}>Close</Button>
-        </DialogActions>
-      </Dialog>
-
-      {/* Floating Add Camera Button */}
-      <Fab
-        color="primary"
-        aria-label="add camera"
-        sx={{
-          position: 'fixed',
-          bottom: 24,
-          right: 24,
-        }}
-        onClick={() => {
-          // Navigate to AddCamera page
-          window.location.href = '/cameras/add';
-        }}
-      >
-        <AddIcon />
-      </Fab>
-
-      {/* Enhanced CSS for markers and animations */}
-      <style>{`
-        .custom-camera-marker {
-          background: transparent !important;
-          border: none !important;
-        }
-        
-        .custom-camera-marker:hover {
-          transform: scale(1.1);
-          transition: transform 0.2s ease;
-        }
-
-        .custom-event-marker {
-          background: transparent !important;
-          border: none !important;
-          animation: pulse 2s infinite;
-        }
-
-        @keyframes pulse {
-          0% { transform: scale(1); opacity: 1; }
-          50% { transform: scale(1.1); opacity: 0.7; }
-          100% { transform: scale(1); opacity: 1; }
-        }
-
-        .leaflet-popup-content-wrapper {
-          border-radius: 8px !important;
-        }
-        
-        .leaflet-popup-content {
-          margin: 0 !important;
-        }
-      `}</style>
-    </Box>
-  );
-};
-
+import React, { useState, useEffect } from 'react';
+import {
+  Box,
+  Typography,
+  Paper,
+  Chip,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Switch,
+  FormControlLabel,
+  Button,
+  CircularProgress,
+  TextField,
+  InputAdornment,
+  Menu,
+  MenuItem,
+  ListItemIcon,
+  ListItemText,
+  Autocomplete,
+  Fab,
+  Card,
+  CardContent,
+  Tooltip,
+  Divider,
+  Badge,
+  Grid,
+} from '@mui/material';
+import {
+  Videocam as VideocamIcon,
+  Refresh as RefreshIcon,
+  Search as SearchIcon,
+  FilterList as FilterIcon,
+  Layers as LayersIcon,
+  Add as AddIcon,
+  MyLocation as MyLocationIcon,
+  Fullscreen as FullscreenIcon,
+  LocationOn as LocationIcon,
+  Event as EventIcon,
+  Warning as WarningIcon,
+  Close as CloseIcon,
+} from '@mui/icons-material';
+import {
+  MapContainer,
+  TileLayer,
+  Marker,
+  Popup,
+} from 'react-leaflet';
+import L from 'leaflet';
+import 'leaflet/dist/leaflet.css';
+
+// Fix for default markers in react-leaflet
+delete (L.Icon.Default.prototype as any)._getIconUrl;
+L.Icon.Default.mergeOptions({
+  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
+  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
+  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
+});
+
+import { Camera } from '../types/index';
+import { fetchCamerasData, fetchEventsData, SecurityEvent } from '../services/dataService';
+
+// Create custom camera icons based on status
+const createCameraIcon = (status: 'online' | 'offline' | 'maintenance') => {
+  const colors = {
+    online: '#4caf50',
+    offline: '#f44336',
+    maintenance: '#ff9800'
+  };
+
+  const svgIcon = `
+    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
+      <circle cx="20" cy="20" r="18" fill="${colors[status]}" stroke="white" stroke-width="3"/>
+      <path d="M12 14h8v6h-8z M20 17l4-2v6l-4-2z" fill="white"/>
+    </svg>
+  `;
+
+  return L.divIcon({
+    html: svgIcon,
+    className: 'custom-camera-marker',
+    iconSize: [40, 40],
+    iconAnchor: [20, 20],
+  });
+};
+
+/**
+ * MapView Component - Interactive map displaying security cameras and events
+ * Uses Leaflet with OpenStreetMap (completely free, no API key required)
+ */
+const MapView: React.FC = () => {
+  const [loading, setLoading] = useState(true);
+  const [selectedCamera, setSelectedCamera] = useState<Camera | null>(null);
+  const [selectedEvent, setSelectedEvent] = useState<SecurityEvent | null>(null);
+  const [showCameras, setShowCameras] = useState(true);
+  const [showEvents, setShowEvents] = useState(true);
+  const [showLayers, setShowLayers] = useState(false);
+  const [cameras, setCameras] = useState<Camera[]>([]);
+  const [events, setEvents] = useState<SecurityEvent[]>([]);
+  const [filteredCameras, setFilteredCameras] = useState<Camera[]>([]);
+  const [filteredEvents, setFilteredEvents] = useState<SecurityEvent[]>([]);
+  
+  // Search and filter states
+  const [searchTerm, setSearchTerm] = useState('');
+  const [statusFilter, setStatusFilter] = useState<string>('all');
+  const [eventTypeFilter, setEventTypeFilter] = useState<string>('all');
+  const [severityFilter, setSeverityFilter] = useState<string>('all');
+  const [showUnresolvedOnly, setShowUnresolvedOnly] = useState(false);
+  
+  // UI states
+  const [filterAnchorEl, setFilterAnchorEl] = useState<HTMLElement | null>(null);
+
+  // API call to fetch cameras and events from backend
+  const fetchCameras = async () => {
+    try {
+      setLoading(true);
+      
+      // Fetch both cameras and events using shared data service
+      const [cameras, events] = await Promise.all([
+        fetchCamerasData(),
+        fetchEventsData(),
+      ]);
+      
+      setCameras(cameras);
+      setEvents(events);
+    } catch (error) {
+      console.error('Error fetching data:', error);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Filtering and search functions
+  const applyFilters = () => {
+    // Filter cameras
+    let filteredCams = cameras.filter(camera => {
+          isActive: true,
+          createdAt: new Date().toISOString(),
+          updatedAt: new Date().toISOString(),
+        },
+        {
+          _id: '2',
+          name: 'Parking Lot Camera',
+          description: 'Vehicle monitoring area',
+          streamUrl: 'rtsp://192.168.1.101:554/stream',
+          status: 'online',
+          type: 'ip',
+          location: {
+            coordinates: [-74.0070, 40.7138],
+            address: '125 Main St, New York, NY',
+          },
+          settings: {
+            resolution: '1920x1080',
+            fps: 25,
+            recordingEnabled: false,
+          },
+          isActive: true,
+          createdAt: new Date().toISOString(),
+          updatedAt: new Date().toISOString(),
+        },
+        {
+          _id: '3',
+          name: 'Side Entrance Camera',
+          description: 'Secondary access point',
+          streamUrl: 'rtsp://192.168.1.102:554/stream',
+          status: 'offline',
+          type: 'ip',
+          location: {
+            coordinates: [-74.0050, 40.7118],
+            address: '121 Main St, New York, NY',
+          },
+          settings: {
+            resolution: '1280x720',
+            fps: 20,
+            recordingEnabled: true,
+          },
+          isActive: true,
+          createdAt: new Date().toISOString(),
+          updatedAt: new Date().toISOString(),
+        },
+        {
+          _id: '4',
+          name: 'Loading Dock Camera',
+          description: 'Delivery area surveillance',
+          streamUrl: 'rtsp://192.168.1.103:554/stream',
+          status: 'maintenance',
+          type: 'ip',
+          location: {
+            coordinates: [-74.0040, 40.7108],
+            address: '119 Main St, New York, NY',
+          },
+          settings: {
+            resolution: '1920x1080',
+            fps: 30,
+            recordingEnabled: true,
+          },
+          isActive: true,
+          createdAt: new Date().toISOString(),
+          updatedAt: new Date().toISOString(),
+        },
+      ];
+      
+      const mockEvents: SecurityEvent[] = [
+        {
+          _id: 'evt1',
+          type: 'person_detected',
+          severity: 'medium',
+          location: {
+            coordinates: [-74.0062, 40.7130],
+            address: '123 Main St, New York, NY',
+          },
+          camera: '1',
+          cameraName: 'Front Gate Camera',
+          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
+          description: 'Person detected at main entrance',
+          resolved: false,
+          metadata: {
+            confidence: 0.95,
+            duration: 30,
+            objectCount: 1,
+          },
+        },
+        {
+          _id: 'evt2',
+          type: 'unauthorized_access',
+          severity: 'high',
+          location: {
+            coordinates: [-74.0052, 40.7120],
+            address: '121 Main St, New York, NY',
+          },
+          camera: '3',
+          cameraName: 'Side Entrance Camera',
+          timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago
+          description: 'Attempted access to restricted area',
+          resolved: false,
+          metadata: {
+            confidence: 0.88,
+            duration: 45,
+          },
+        },
+        {
+          _id: 'evt3',
+          type: 'vehicle_detected',
+          severity: 'low',
+          location: {
+            coordinates: [-74.0072, 40.7140],
+            address: '125 Main St, New York, NY',
+          },
+          camera: '2',
+          cameraName: 'Parking Lot Camera',
+          timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 minutes ago
+          description: 'Vehicle entered parking area',
+          resolved: true,
+          metadata: {
+            confidence: 0.92,
+            duration: 120,
+            objectCount: 1,
+          },
+        },
+        {
+          _id: 'evt4',
+          type: 'motion',
+          severity: 'critical',
+          location: {
+            coordinates: [-74.0042, 40.7110],
+            address: '119 Main St, New York, NY',
+          },
+          camera: '4',
+          cameraName: 'Loading Dock Camera',
+          timestamp: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // 1 hour ago
+          description: 'Unusual motion detected during off-hours',
+          resolved: false,
+          metadata: {
+            confidence: 0.78,
+            duration: 180,
+          },
+        },
+      ];
+      
+      setCameras(mockCameras);
+      setEvents(mockEvents);
+    } catch (error) {
+      console.error('Error fetching data:', error);
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  // Filtering and search functions
+  const applyFilters = () => {
+    // Filter cameras
+    let filteredCams = cameras.filter(camera => {
+      const matchesSearch = searchTerm === '' || 
+        camera.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        camera.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        camera.location.address?.toLowerCase().includes(searchTerm.toLowerCase());
+      
+      const matchesStatus = statusFilter === 'all' || camera.status === statusFilter;
+      
+      return matchesSearch && matchesStatus;
+    });
+
+    // Filter events
+    let filteredEvts = events.filter(event => {
+      const matchesSearch = searchTerm === '' || 
+        event.cameraName?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        event.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
+        event.type.toLowerCase().includes(searchTerm.toLowerCase());
+      
+      const matchesType = eventTypeFilter === 'all' || event.type === eventTypeFilter;
+      const matchesSeverity = severityFilter === 'all' || event.severity === severityFilter;
+      const matchesResolved = !showUnresolvedOnly || !event.resolved;
+      
+      return matchesSearch && matchesType && matchesSeverity && matchesResolved;
+    });
+
+    setFilteredCameras(filteredCams);
+    setFilteredEvents(filteredEvts);
+  };
+
+  // Apply filters when dependencies change
+  useEffect(() => {
+    applyFilters();
+  }, [cameras, events, searchTerm, statusFilter, eventTypeFilter, severityFilter, showUnresolvedOnly]);
+
+  // Create event markers with severity-based styling
+  const createEventIcon = (severity: string) => {
+    const colors = {
+      low: '#2196f3',
+      medium: '#ff9800',
+      high: '#f44336',
+      critical: '#9c27b0'
+    };
+
+    const svgIcon = `
+      <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
+        <circle cx="15" cy="15" r="13" fill="${colors[severity as keyof typeof colors]}" stroke="white" stroke-width="2"/>
+        <path d="M15 6l1.5 9h-3l1.5-9zm0 12a1.5 1.5 0 100 3 1.5 1.5 0 000-3z" fill="white"/>
+      </svg>
+    `;
+
+    return L.divIcon({
+      html: svgIcon,
+      className: 'custom-event-marker',
+      iconSize: [30, 30],
+      iconAnchor: [15, 15],
+    });
+  };
+
+  /**
+   * Initialize component - fetch cameras
+   */
+  useEffect(() => {
+    fetchCameras();
+  }, []);
+
+  /**
+   * Refresh camera data
+   */
+  const handleRefresh = () => {
+    fetchCameras();
+  };
+
+  return (
+    <Box sx={{ height: '100%', position: 'relative' }}>
+      {/* Enhanced Header Section with Search and Filters */}
+      <Box sx={{ mb: 2 }}>
+        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
+          <Box>
+            <Typography variant="h4" gutterBottom fontWeight="bold">
+              Interactive Security Map
+            </Typography>
+            <Typography variant="subtitle1" color="text.secondary">
+              {filteredCameras.length} cameras â€¢ {filteredEvents.filter(e => !e.resolved).length} active events
+            </Typography>
+          </Box>
+          
+          <Button
+            variant="outlined"
+            startIcon={<RefreshIcon />}
+            onClick={handleRefresh}
+            disabled={loading}
+            size="small"
+          >
+            Refresh
+          </Button>
+        </Box>
+
+        {/* Search and Filter Bar */}
+        <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', mb: 2, flexWrap: 'wrap' }}>
+          {/* Search Field */}
+          <TextField
+            placeholder="Search cameras, events, locations..."
+            value={searchTerm}
+            onChange={(e) => setSearchTerm(e.target.value)}
+            size="small"
+            sx={{ minWidth: 300 }}
+            InputProps={{
+              startAdornment: (
+                <InputAdornment position="start">
+                  <SearchIcon />
+                </InputAdornment>
+              ),
+            }}
+          />
+
+          {/* Quick Filters */}
+          <FormControlLabel
+            control={
+              <Switch
+                checked={showCameras}
+                onChange={(e) => setShowCameras(e.target.checked)}
+                color="primary"
+              />
+            }
+            label="Cameras"
+          />
+          <FormControlLabel
+            control={
+              <Switch
+                checked={showEvents}
+                onChange={(e) => setShowEvents(e.target.checked)}
+                color="warning"
+              />
+            }
+            label="Events"
+          />
+          <FormControlLabel
+            control={
+              <Switch
+                checked={showUnresolvedOnly}
+                onChange={(e) => setShowUnresolvedOnly(e.target.checked)}
+                color="error"
+              />
+            }
+            label="Unresolved Only"
+          />
+
+          {/* Filter Menu Button */}
+          <Button
+            variant="outlined"
+            startIcon={<FilterIcon />}
+            onClick={(e) => setFilterAnchorEl(e.currentTarget)}
+            size="small"
+          >
+            Filters
+          </Button>
+
+          {/* Layers Button */}
+          <Button
+            variant="outlined"
+            startIcon={<LayersIcon />}
+            onClick={() => setShowLayers(true)}
+            size="small"
+          >
+            Layers
+          </Button>
+        </Box>
+      </Box>
+
+      {/* Enhanced Map Container with Event Markers */}
+      <Paper 
+        elevation={3}
+        sx={{ 
+          position: 'relative',
+          height: 'calc(100vh - 250px)',
+          overflow: 'hidden',
+          borderRadius: 2
+        }}
+      >
+        {loading && (
+          <Box
+            sx={{
+              position: 'absolute',
+              top: 0,
+              left: 0,
+              right: 0,
+              bottom: 0,
+              backgroundColor: 'rgba(255, 255, 255, 0.8)',
+              display: 'flex',
+              alignItems: 'center',
+              justifyContent: 'center',
+              zIndex: 1000,
+            }}
+          >
+            <CircularProgress size={60} />
+            <Typography sx={{ ml: 2 }}>Loading map data...</Typography>
+          </Box>
+        )}
+        
+        <MapContainer
+          center={[40.7128, -74.0060]}
+          zoom={14}
+          style={{ height: '100%', width: '100%' }}
+          zoomControl={true}
+        >
+          <TileLayer
+            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
+            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
+          />
+          
+          {/* Camera Markers */}
+          {showCameras && filteredCameras.map((camera, index) => (
+            <Marker
+              key={`camera-${camera._id}-${index}`}
+              position={[camera.location.coordinates[1], camera.location.coordinates[0]]}
+              icon={createCameraIcon(camera.status)}
+              eventHandlers={{
+                click: () => setSelectedCamera(camera)
+              }}
+            >
+              <Popup>
+                <Box sx={{ minWidth: 250 }}>
+                  <Typography variant="h6" gutterBottom>
+                    <VideocamIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
+                    {camera.name}
+                  </Typography>
+                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
+                    <Typography variant="body2">
+                      <strong>Status:</strong>
+                    </Typography>
+                    <Chip
+                      label={camera.status.toUpperCase()}
+                      color={camera.status === 'online' ? 'success' : camera.status === 'offline' ? 'error' : 'warning'}
+                      size="small"
+                    />
+                  </Box>
+                  {camera.description && (
+                    <Typography variant="body2" color="text.secondary" gutterBottom>
+                      {camera.description}
+                    </Typography>
+                  )}
+                  <Typography variant="caption" display="block" gutterBottom>
+                    <LocationIcon sx={{ fontSize: 12, mr: 0.5 }} />
+                    {camera.location.address || 'No address specified'}
+                  </Typography>
+                  <Typography variant="caption" display="block" gutterBottom>
+                    ğŸ“¹ {camera.settings.resolution} â€¢ {camera.settings.fps} FPS
+                  </Typography>
+                  <Button 
+                    size="small" 
+                    variant="contained"
+                    onClick={() => setSelectedCamera(camera)}
+                    sx={{ mt: 1 }}
+                  >
+                    View Details
+                  </Button>
+                </Box>
+              </Popup>
+            </Marker>
+          ))}
+
+          {/* Event Markers */}
+          {showEvents && filteredEvents.map((event, index) => (
+            <Marker
+              key={`event-${event._id}-${index}-${event.location.coordinates[0]}-${event.location.coordinates[1]}`}
+              position={[event.location.coordinates[1], event.location.coordinates[0]]}
+              icon={createEventIcon(event.severity)}
+              eventHandlers={{
+                click: () => setSelectedEvent(event)
+              }}
+            >
+              <Popup>
+                <Box sx={{ minWidth: 250 }}>
+                  <Typography variant="h6" gutterBottom>
+                    <WarningIcon sx={{ fontSize: 20, mr: 1, verticalAlign: 'middle' }} />
+                    {event.type.replace('_', ' ').toUpperCase()}
+                  </Typography>
+                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
+                    <Typography variant="body2">
+                      <strong>Severity:</strong>
+                    </Typography>
+                    <Chip
+                      label={event.severity.toUpperCase()}
+                      color={event.severity === 'critical' ? 'error' : event.severity === 'high' ? 'warning' : 'info'}
+                      size="small"
+                    />
+                    <Chip
+                      label={event.resolved ? 'RESOLVED' : 'ACTIVE'}
+                      color={event.resolved ? 'success' : 'error'}
+                      size="small"
+                    />
+                  </Box>
+                  <Typography variant="body2" gutterBottom>
+                    {event.description}
+                  </Typography>
+                  <Typography variant="caption" display="block" gutterBottom>
+                    ğŸ“… {new Date(event.timestamp).toLocaleString()}
+                  </Typography>
+                  <Typography variant="caption" display="block" gutterBottom>
+                    ğŸ“¹ {event.cameraName}
+                  </Typography>
+                  {event.metadata && (
+                    <Typography variant="caption" display="block" gutterBottom>
+                      ğŸ¯ Confidence: {Math.round((event.metadata.confidence || 0) * 100)}%
+                    </Typography>
+                  )}
+                  <Button 
+                    size="small" 
+                    variant="contained"
+                    onClick={() => setSelectedEvent(event)}
+                    sx={{ mt: 1 }}
+                  >
+                    View Details
+                  </Button>
+                </Box>
+              </Popup>
+            </Marker>
+          ))}
+        </MapContainer>
+
+        {/* Map Stats Overlay */}
+        <Card
+          sx={{
+            position: 'absolute',
+            bottom: 16,
+            left: 16,
+            minWidth: 200,
+            bgcolor: 'rgba(255, 255, 255, 0.95)',
+            backdropFilter: 'blur(10px)',
+          }}
+        >
+          <CardContent sx={{ py: 1.5, px: 2, '&:last-child': { pb: 1.5 } }}>
+            <Typography variant="subtitle2" gutterBottom>
+              Map Overview
+            </Typography>
+            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
+              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: '#4caf50' }} />
+                <Typography variant="caption">{filteredCameras.filter(c => c.status === 'online').length} Online</Typography>
+              </Box>
+              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: '#f44336' }} />
+                <Typography variant="caption">{filteredCameras.filter(c => c.status === 'offline').length} Offline</Typography>
+              </Box>
+              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                <Box sx={{ width: 12, height: 12, borderRadius: '50%', bgcolor: '#ff9800' }} />
+                <Typography variant="caption">{filteredCameras.filter(c => c.status === 'maintenance').length} Maintenance</Typography>
+              </Box>
+              <Divider sx={{ my: 0.5 }} />
+              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                <WarningIcon sx={{ fontSize: 12, color: '#f44336' }} />
+                <Typography variant="caption">{filteredEvents.filter(e => !e.resolved).length} Active Events</Typography>
+              </Box>
+            </Box>
+          </CardContent>
+        </Card>
+      </Paper>
+
+      {/* Camera Details Dialog */}
+      <Dialog
+        open={Boolean(selectedCamera)}
+        onClose={() => setSelectedCamera(null)}
+        maxWidth="md"
+      >
+        {selectedCamera && (
+          <>
+            <DialogTitle>
+              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
+                <VideocamIcon color="primary" />
+                {selectedCamera.name}
+                <Chip
+                  label={selectedCamera.status}
+                  color={selectedCamera.status === 'online' ? 'success' : 'error'}
+                  size="small"
+                />
+              </Box>
+            </DialogTitle>
+            <DialogContent>
+              <Box sx={{ minWidth: 400 }}>
+                <Typography variant="body2" gutterBottom>
+                  <strong>Type:</strong> {selectedCamera.type.toUpperCase()} Camera
+                </Typography>
+                <Typography variant="body2" gutterBottom>
+                  <strong>Resolution:</strong> {selectedCamera.settings.resolution}
+                </Typography>
+                <Typography variant="body2" gutterBottom>
+                  <strong>FPS:</strong> {selectedCamera.settings.fps}
+                </Typography>
+                <Typography variant="body2" gutterBottom>
+                  <strong>Recording:</strong> {selectedCamera.settings.recordingEnabled ? 'Enabled' : 'Disabled'}
+                </Typography>
+                <Typography variant="body2" gutterBottom>
+                  <strong>Location:</strong> {selectedCamera.location.address || 'No address'}
+                </Typography>
+                <Typography variant="body2" gutterBottom>
+                  <strong>Coordinates:</strong> {selectedCamera.location.coordinates[1].toFixed(6)}, {selectedCamera.location.coordinates[0].toFixed(6)}
+                </Typography>
+                <Typography variant="body2" gutterBottom>
+                  <strong>Stream URL:</strong>
+                </Typography>
+                <Typography 
+                  variant="body2" 
+                  sx={{ 
+                    fontFamily: 'monospace', 
+                    fontSize: '0.75rem',
+                    wordBreak: 'break-all',
+                    color: 'text.secondary',
+                    bgcolor: 'grey.100',
+                    p: 1,
+                    borderRadius: 1
+                  }}
+                >
+                  {selectedCamera.streamUrl}
+                </Typography>
+              </Box>
+            </DialogContent>
+            <DialogActions>
+              <Button onClick={() => setSelectedCamera(null)}>Close</Button>
+              <Button variant="contained" color="primary">
+                View Live Stream
+              </Button>
+            </DialogActions>
+          </>
+        )}
+      </Dialog>
+
+      {/* Event Details Dialog */}
+      <Dialog
+        open={Boolean(selectedEvent)}
+        onClose={() => setSelectedEvent(null)}
+        maxWidth="md"
+      >
+        {selectedEvent && (
+          <>
+            <DialogTitle>
+              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
+                <EventIcon color="warning" />
+                {selectedEvent.type.replace('_', ' ').toUpperCase()} Event
+                <Chip
+                  label={selectedEvent.severity.toUpperCase()}
+                  color={selectedEvent.severity === 'critical' ? 'error' : selectedEvent.severity === 'high' ? 'warning' : 'info'}
+                  size="small"
+                />
+                <Chip
+                  label={selectedEvent.resolved ? 'RESOLVED' : 'ACTIVE'}
+                  color={selectedEvent.resolved ? 'success' : 'error'}
+                  size="small"
+                />
+              </Box>
+            </DialogTitle>
+            <DialogContent>
+              <Grid container spacing={2}>
+                <Grid item xs={12} sm={6}>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Event Type:</strong> {selectedEvent.type.replace('_', ' ')}
+                  </Typography>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Severity:</strong> {selectedEvent.severity}
+                  </Typography>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Camera:</strong> {selectedEvent.cameraName}
+                  </Typography>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Timestamp:</strong> {new Date(selectedEvent.timestamp).toLocaleString()}
+                  </Typography>
+                </Grid>
+                <Grid item xs={12} sm={6}>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Location:</strong> {selectedEvent.location.address || 'No address'}
+                  </Typography>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Coordinates:</strong> {selectedEvent.location.coordinates[1].toFixed(6)}, {selectedEvent.location.coordinates[0].toFixed(6)}
+                  </Typography>
+                  {selectedEvent.metadata?.confidence && (
+                    <Typography variant="body2" gutterBottom>
+                      <strong>Confidence:</strong> {Math.round(selectedEvent.metadata.confidence * 100)}%
+                    </Typography>
+                  )}
+                  {selectedEvent.metadata?.duration && (
+                    <Typography variant="body2" gutterBottom>
+                      <strong>Duration:</strong> {selectedEvent.metadata.duration}s
+                    </Typography>
+                  )}
+                </Grid>
+                <Grid item xs={12}>
+                  <Typography variant="body2" gutterBottom>
+                    <strong>Description:</strong>
+                  </Typography>
+                  <Typography variant="body2" sx={{ bgcolor: 'grey.100', p: 1, borderRadius: 1 }}>
+                    {selectedEvent.description}
+                  </Typography>
+                </Grid>
+              </Grid>
+            </DialogContent>
+            <DialogActions>
+              <Button onClick={() => setSelectedEvent(null)}>Close</Button>
+              {!selectedEvent.resolved && (
+                <Button variant="contained" color="primary">
+                  Mark as Resolved
+                </Button>
+              )}
+              <Button variant="outlined">
+                View Recording
+              </Button>
+            </DialogActions>
+          </>
+        )}
+      </Dialog>
+
+      {/* Filter Menu */}
+      <Menu
+        anchorEl={filterAnchorEl}
+        open={Boolean(filterAnchorEl)}
+        onClose={() => setFilterAnchorEl(null)}
+      >
+        <Box sx={{ p: 2, minWidth: 250 }}>
+          <Typography variant="h6" gutterBottom>
+            Advanced Filters
+          </Typography>
+          
+          <Typography variant="subtitle2" gutterBottom>
+            Camera Status
+          </Typography>
+          <Autocomplete
+            options={['all', 'online', 'offline', 'maintenance']}
+            value={statusFilter}
+            onChange={(_, newValue) => setStatusFilter(newValue || 'all')}
+            size="small"
+            sx={{ mb: 2 }}
+            renderInput={(params) => <TextField {...params} label="Status" />}
+          />
+
+          <Typography variant="subtitle2" gutterBottom>
+            Event Type
+          </Typography>
+          <Autocomplete
+            options={['all', 'motion', 'person_detected', 'vehicle_detected', 'unauthorized_access', 'tamper_detected']}
+            value={eventTypeFilter}
+            onChange={(_, newValue) => setEventTypeFilter(newValue || 'all')}
+            size="small"
+            sx={{ mb: 2 }}
+            renderInput={(params) => <TextField {...params} label="Event Type" />}
+          />
+
+          <Typography variant="subtitle2" gutterBottom>
+            Event Severity
+          </Typography>
+          <Autocomplete
+            options={['all', 'low', 'medium', 'high', 'critical']}
+            value={severityFilter}
+            onChange={(_, newValue) => setSeverityFilter(newValue || 'all')}
+            size="small"
+            sx={{ mb: 2 }}
+            renderInput={(params) => <TextField {...params} label="Severity" />}
+          />
+
+          <Button
+            variant="outlined"
+            onClick={() => {
+              setStatusFilter('all');
+              setEventTypeFilter('all');
+              setSeverityFilter('all');
+              setShowUnresolvedOnly(false);
+              setSearchTerm('');
+            }}
+            fullWidth
+          >
+            Reset Filters
+          </Button>
+        </Box>
+      </Menu>
+
+      {/* Layers Dialog */}
+      <Dialog open={showLayers} onClose={() => setShowLayers(false)} maxWidth="sm">
+        <DialogTitle>Map Layers</DialogTitle>
+        <DialogContent>
+          <Box sx={{ minWidth: 300 }}>
+            <Typography variant="h6" gutterBottom>
+              Visibility Controls
+            </Typography>
+            <FormControlLabel
+              control={<Switch checked={showCameras} onChange={(e) => setShowCameras(e.target.checked)} />}
+              label="Security Cameras"
+            />
+            <FormControlLabel
+              control={<Switch checked={showEvents} onChange={(e) => setShowEvents(e.target.checked)} />}
+              label="Security Events"
+            />
+            <Divider sx={{ my: 2 }} />
+            <Typography variant="h6" gutterBottom>
+              Event Filters
+            </Typography>
+            <FormControlLabel
+              control={<Switch checked={showUnresolvedOnly} onChange={(e) => setShowUnresolvedOnly(e.target.checked)} />}
+              label="Show Unresolved Events Only"
+            />
+            <Divider sx={{ my: 2 }} />
+            <Typography variant="h6" gutterBottom>
+              Map Statistics
+            </Typography>
+            <Typography variant="body2">
+              Total Cameras: {cameras.length}
+            </Typography>
+            <Typography variant="body2">
+              Visible Cameras: {filteredCameras.length}
+            </Typography>
+            <Typography variant="body2">
+              Total Events: {events.length}
+            </Typography>
+            <Typography variant="body2">
+              Visible Events: {filteredEvents.length}
+            </Typography>
+            <Typography variant="body2">
+              Active Events: {filteredEvents.filter(e => !e.resolved).length}
+            </Typography>
+          </Box>
+        </DialogContent>
+        <DialogActions>
+          <Button onClick={() => setShowLayers(false)}>Close</Button>
+        </DialogActions>
+      </Dialog>
+
+      {/* Floating Add Camera Button */}
+      <Fab
+        color="primary"
+        aria-label="add camera"
+        sx={{
+          position: 'fixed',
+          bottom: 24,
+          right: 24,
+        }}
+        onClick={() => {
+          // Navigate to AddCamera page
+          window.location.href = '/cameras/add';
+        }}
+      >
+        <AddIcon />
+      </Fab>
+
+      {/* Enhanced CSS for markers and animations */}
+      <style>{`
+        .custom-camera-marker {
+          background: transparent !important;
+          border: none !important;
+        }
+        
+        .custom-camera-marker:hover {
+          transform: scale(1.1);
+          transition: transform 0.2s ease;
+        }
+
+        .custom-event-marker {
+          background: transparent !important;
+          border: none !important;
+          animation: pulse 2s infinite;
+        }
+
+        @keyframes pulse {
+          0% { transform: scale(1); opacity: 1; }
+          50% { transform: scale(1.1); opacity: 0.7; }
+          100% { transform: scale(1); opacity: 1; }
+        }
+
+        .leaflet-popup-content-wrapper {
+          border-radius: 8px !important;
+        }
+        
+        .leaflet-popup-content {
+          margin: 0 !important;
+        }
+      `}</style>
+    </Box>
+  );
+};
+
 export default MapView;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/pages/Profile.tsx b/event-monitoring-mvp/frontend/src/pages/Profile.tsx
index 4b2f944..95a3382 100644
--- a/event-monitoring-mvp/frontend/src/pages/Profile.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/Profile.tsx
@@ -1,352 +1,352 @@
-import React, { useState } from 'react';
-import {
-  Box,
-  Typography,
-  Paper,
-  Grid,
-  Card,
-  CardContent,
-  Avatar,
-  Button,
-  TextField,
-  Divider,
-  List,
-  ListItem,
-  ListItemText,
-  ListItemIcon,
-  Chip,
-  Dialog,
-  DialogTitle,
-  DialogContent,
-  DialogActions,
-} from '@mui/material';
-import {
-  Edit as EditIcon,
-  Security as SecurityIcon,
-  History as HistoryIcon,
-  Notifications as NotificationsIcon,
-  Save as SaveIcon,
-  Cancel as CancelIcon,
-} from '@mui/icons-material';
-import { useSelector } from 'react-redux';
-import { RootState } from '../store/store';
-
-/**
- * Profile Component - User profile management page
- * Features:
- * - View and edit user account information
- * - Display performance statistics
- * - Show recent activity history
- * - Profile picture with initials
- */
-const Profile: React.FC = () => {
-  const { user } = useSelector((state: RootState) => state.auth);
-  const [editDialogOpen, setEditDialogOpen] = useState(false);
-  const [editData, setEditData] = useState({
-    username: user?.username || '',
-    email: user?.email || '',
-    phone: '+1 (555) 123-4567',
-    department: 'Security Operations',
-  });
-
-  // Mock recent activity data - replace with API call
-  const recentActivity = [
-    {
-      id: 1,
-      action: 'Acknowledged event #EV-2024-001',
-      timestamp: '2 hours ago',
-      type: 'event',
-    },
-    {
-      id: 2,
-      action: 'Updated camera settings - Front Gate',
-      timestamp: '5 hours ago',
-      type: 'camera',
-    },
-    {
-      id: 3,
-      action: 'Resolved security incident',
-      timestamp: '1 day ago',
-      type: 'incident',
-    },
-    {
-      id: 4,
-      action: 'Login from new device',
-      timestamp: '2 days ago',
-      type: 'security',
-    },
-  ];
-
-  // Mock performance statistics - replace with API call
-  const stats = [
-    { label: 'Events Handled', value: '142', color: 'primary' },
-    { label: 'Active Cameras', value: '8', color: 'success' },
-    { label: 'Hours Online', value: '24.5', color: 'info' },
-    { label: 'Incidents Resolved', value: '23', color: 'warning' },
-  ];
-
-  /**
-   * Handle profile save action
-   * TODO: Implement API call to update user profile
-   */
-  const handleSaveProfile = () => {
-    // API call to save profile changes would go here
-    console.log('Saving profile:', editData);
-    setEditDialogOpen(false);
-  };
-
-  /**
-   * Get appropriate icon for activity type
-   * @param type - The type of activity
-   * @returns JSX element with the corresponding icon
-   */
-  const getActivityIcon = (type: string) => {
-    switch (type) {
-      case 'event':
-        return <NotificationsIcon fontSize="small" color="primary" />;
-      case 'camera':
-        return <SecurityIcon fontSize="small" color="info" />;
-      case 'incident':
-        return <SecurityIcon fontSize="small" color="error" />;
-      case 'security':
-        return <SecurityIcon fontSize="small" color="warning" />;
-      default:
-        return <HistoryIcon fontSize="small" />;
-    }
-  };
-
-  return (
-    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
-      {/* Page Header */}
-      <Typography variant="h4" gutterBottom fontWeight="bold">
-        User Profile
-      </Typography>
-      <Typography variant="subtitle1" color="text.secondary" gutterBottom>
-        Manage your account settings and view your activity.
-      </Typography>
-
-      <Grid container spacing={3} sx={{ mt: 2 }}>
-        {/* Profile Card */}
-        <Grid item xs={12} md={4}>
-          <Paper sx={{ p: 3, textAlign: 'center' }}>
-            <Avatar
-              sx={{
-                width: 120,
-                height: 120,
-                mx: 'auto',
-                mb: 2,
-                bgcolor: 'primary.main',
-                fontSize: '3rem',
-              }}
-            >
-              {user?.username?.charAt(0).toUpperCase() || 'U'}
-            </Avatar>
-            
-            <Typography variant="h5" gutterBottom>
-              {user?.username || 'User Name'}
-            </Typography>
-            
-            <Chip
-              label={user?.role?.toUpperCase() || 'OPERATOR'}
-              color="primary"
-              sx={{ mb: 2 }}
-            />
-            
-            <Typography variant="body2" color="text.secondary" gutterBottom>
-              Security Operations Team
-            </Typography>
-            
-            <Button
-              variant="contained"
-              startIcon={<EditIcon />}
-              onClick={() => setEditDialogOpen(true)}
-              sx={{ mt: 2 }}
-              fullWidth
-            >
-              Edit Profile
-            </Button>
-          </Paper>
-        </Grid>
-
-        {/* Account Information and Statistics */}
-        <Grid item xs={12} md={8}>
-          {/* Account Information */}
-          <Paper sx={{ p: 3, mb: 3 }}>
-            <Typography variant="h6" gutterBottom>
-              Account Information
-            </Typography>
-            
-            <Grid container spacing={3}>
-              <Grid item xs={12} sm={6}>
-                <Typography variant="body2" color="text.secondary">
-                  Username
-                </Typography>
-                <Typography variant="body1" sx={{ mb: 2 }}>
-                  {user?.username || 'Not set'}
-                </Typography>
-              </Grid>
-              
-              <Grid item xs={12} sm={6}>
-                <Typography variant="body2" color="text.secondary">
-                  Email
-                </Typography>
-                <Typography variant="body1" sx={{ mb: 2 }}>
-                  {user?.email || 'Not set'}
-                </Typography>
-              </Grid>
-              
-              <Grid item xs={12} sm={6}>
-                <Typography variant="body2" color="text.secondary">
-                  Phone
-                </Typography>
-                <Typography variant="body1" sx={{ mb: 2 }}>
-                  +1 (555) 123-4567
-                </Typography>
-              </Grid>
-              
-              <Grid item xs={12} sm={6}>
-                <Typography variant="body2" color="text.secondary">
-                  Department
-                </Typography>
-                <Typography variant="body1" sx={{ mb: 2 }}>
-                  Security Operations
-                </Typography>
-              </Grid>
-              
-              <Grid item xs={12} sm={6}>
-                <Typography variant="body2" color="text.secondary">
-                  Role
-                </Typography>
-                <Typography variant="body1" sx={{ mb: 2 }}>
-                  {user?.role || 'Operator'}
-                </Typography>
-              </Grid>
-              
-              <Grid item xs={12} sm={6}>
-                <Typography variant="body2" color="text.secondary">
-                  Last Login
-                </Typography>
-                <Typography variant="body1" sx={{ mb: 2 }}>
-                  {user?.lastLogin ? new Date(user.lastLogin).toLocaleString() : 'Never'}
-                </Typography>
-              </Grid>
-            </Grid>
-          </Paper>
-
-          {/* Performance Statistics */}
-          <Paper sx={{ p: 3 }}>
-            <Typography variant="h6" gutterBottom>
-              Performance Statistics
-            </Typography>
-            
-            <Grid container spacing={3}>
-              {stats.map((stat, index) => (
-                <Grid item xs={6} sm={3} key={index}>
-                  <Card variant="outlined">
-                    <CardContent sx={{ textAlign: 'center', py: 2 }}>
-                      <Typography 
-                        variant="h4" 
-                        color={`${stat.color}.main`}
-                        fontWeight="bold"
-                      >
-                        {stat.value}
-                      </Typography>
-                      <Typography variant="body2" color="text.secondary">
-                        {stat.label}
-                      </Typography>
-                    </CardContent>
-                  </Card>
-                </Grid>
-              ))}
-            </Grid>
-          </Paper>
-        </Grid>
-
-        {/* Recent Activity */}
-        <Grid item xs={12}>
-          <Paper sx={{ p: 3 }}>
-            <Typography variant="h6" gutterBottom>
-              Recent Activity
-            </Typography>
-            
-            <List>
-              {recentActivity.map((activity, index) => (
-                <React.Fragment key={activity.id}>
-                  <ListItem>
-                    <ListItemIcon>
-                      {getActivityIcon(activity.type)}
-                    </ListItemIcon>
-                    <ListItemText
-                      primary={activity.action}
-                      secondary={activity.timestamp}
-                    />
-                  </ListItem>
-                  {index < recentActivity.length - 1 && <Divider />}
-                </React.Fragment>
-              ))}
-            </List>
-          </Paper>
-        </Grid>
-      </Grid>
-
-      {/* Edit Profile Dialog */}
-      <Dialog open={editDialogOpen} onClose={() => setEditDialogOpen(false)} maxWidth="sm" fullWidth>
-        <DialogTitle>Edit Profile</DialogTitle>
-        <DialogContent>
-          <Grid container spacing={3} sx={{ mt: 1 }}>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Username"
-                value={editData.username}
-                onChange={(e) => setEditData({ ...editData, username: e.target.value })}
-              />
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Email"
-                type="email"
-                value={editData.email}
-                onChange={(e) => setEditData({ ...editData, email: e.target.value })}
-              />
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Phone"
-                value={editData.phone}
-                onChange={(e) => setEditData({ ...editData, phone: e.target.value })}
-              />
-            </Grid>
-            <Grid item xs={12}>
-              <TextField
-                fullWidth
-                label="Department"
-                value={editData.department}
-                onChange={(e) => setEditData({ ...editData, department: e.target.value })}
-              />
-            </Grid>
-          </Grid>
-        </DialogContent>
-        <DialogActions>
-          <Button
-            onClick={() => setEditDialogOpen(false)}
-            startIcon={<CancelIcon />}
-          >
-            Cancel
-          </Button>
-          <Button
-            onClick={handleSaveProfile}
-            variant="contained"
-            startIcon={<SaveIcon />}
-          >
-            Save Changes
-          </Button>
-        </DialogActions>
-      </Dialog>
-    </Box>
-  );
-};
-
+import React, { useState } from 'react';
+import {
+  Box,
+  Typography,
+  Paper,
+  Grid,
+  Card,
+  CardContent,
+  Avatar,
+  Button,
+  TextField,
+  Divider,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemIcon,
+  Chip,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+} from '@mui/material';
+import {
+  Edit as EditIcon,
+  Security as SecurityIcon,
+  History as HistoryIcon,
+  Notifications as NotificationsIcon,
+  Save as SaveIcon,
+  Cancel as CancelIcon,
+} from '@mui/icons-material';
+import { useSelector } from 'react-redux';
+import { RootState } from '../store/store';
+
+/**
+ * Profile Component - User profile management page
+ * Features:
+ * - View and edit user account information
+ * - Display performance statistics
+ * - Show recent activity history
+ * - Profile picture with initials
+ */
+const Profile: React.FC = () => {
+  const { user } = useSelector((state: RootState) => state.auth);
+  const [editDialogOpen, setEditDialogOpen] = useState(false);
+  const [editData, setEditData] = useState({
+    username: user?.username || '',
+    email: user?.email || '',
+    phone: '+1 (555) 123-4567',
+    department: 'Security Operations',
+  });
+
+  // Mock recent activity data - replace with API call
+  const recentActivity = [
+    {
+      id: 1,
+      action: 'Acknowledged event #EV-2024-001',
+      timestamp: '2 hours ago',
+      type: 'event',
+    },
+    {
+      id: 2,
+      action: 'Updated camera settings - Front Gate',
+      timestamp: '5 hours ago',
+      type: 'camera',
+    },
+    {
+      id: 3,
+      action: 'Resolved security incident',
+      timestamp: '1 day ago',
+      type: 'incident',
+    },
+    {
+      id: 4,
+      action: 'Login from new device',
+      timestamp: '2 days ago',
+      type: 'security',
+    },
+  ];
+
+  // Mock performance statistics - replace with API call
+  const stats = [
+    { label: 'Events Handled', value: '142', color: 'primary' },
+    { label: 'Active Cameras', value: '8', color: 'success' },
+    { label: 'Hours Online', value: '24.5', color: 'info' },
+    { label: 'Incidents Resolved', value: '23', color: 'warning' },
+  ];
+
+  /**
+   * Handle profile save action
+   * TODO: Implement API call to update user profile
+   */
+  const handleSaveProfile = () => {
+    // API call to save profile changes would go here
+    console.log('Saving profile:', editData);
+    setEditDialogOpen(false);
+  };
+
+  /**
+   * Get appropriate icon for activity type
+   * @param type - The type of activity
+   * @returns JSX element with the corresponding icon
+   */
+  const getActivityIcon = (type: string) => {
+    switch (type) {
+      case 'event':
+        return <NotificationsIcon fontSize="small" color="primary" />;
+      case 'camera':
+        return <SecurityIcon fontSize="small" color="info" />;
+      case 'incident':
+        return <SecurityIcon fontSize="small" color="error" />;
+      case 'security':
+        return <SecurityIcon fontSize="small" color="warning" />;
+      default:
+        return <HistoryIcon fontSize="small" />;
+    }
+  };
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
+      {/* Page Header */}
+      <Typography variant="h4" gutterBottom fontWeight="bold">
+        User Profile
+      </Typography>
+      <Typography variant="subtitle1" color="text.secondary" gutterBottom>
+        Manage your account settings and view your activity.
+      </Typography>
+
+      <Grid container spacing={3} sx={{ mt: 2 }}>
+        {/* Profile Card */}
+        <Grid item xs={12} md={4}>
+          <Paper sx={{ p: 3, textAlign: 'center' }}>
+            <Avatar
+              sx={{
+                width: 120,
+                height: 120,
+                mx: 'auto',
+                mb: 2,
+                bgcolor: 'primary.main',
+                fontSize: '3rem',
+              }}
+            >
+              {user?.username?.charAt(0).toUpperCase() || 'U'}
+            </Avatar>
+            
+            <Typography variant="h5" gutterBottom>
+              {user?.username || 'User Name'}
+            </Typography>
+            
+            <Chip
+              label={user?.role?.toUpperCase() || 'OPERATOR'}
+              color="primary"
+              sx={{ mb: 2 }}
+            />
+            
+            <Typography variant="body2" color="text.secondary" gutterBottom>
+              Security Operations Team
+            </Typography>
+            
+            <Button
+              variant="contained"
+              startIcon={<EditIcon />}
+              onClick={() => setEditDialogOpen(true)}
+              sx={{ mt: 2 }}
+              fullWidth
+            >
+              Edit Profile
+            </Button>
+          </Paper>
+        </Grid>
+
+        {/* Account Information and Statistics */}
+        <Grid item xs={12} md={8}>
+          {/* Account Information */}
+          <Paper sx={{ p: 3, mb: 3 }}>
+            <Typography variant="h6" gutterBottom>
+              Account Information
+            </Typography>
+            
+            <Grid container spacing={3}>
+              <Grid item xs={12} sm={6}>
+                <Typography variant="body2" color="text.secondary">
+                  Username
+                </Typography>
+                <Typography variant="body1" sx={{ mb: 2 }}>
+                  {user?.username || 'Not set'}
+                </Typography>
+              </Grid>
+              
+              <Grid item xs={12} sm={6}>
+                <Typography variant="body2" color="text.secondary">
+                  Email
+                </Typography>
+                <Typography variant="body1" sx={{ mb: 2 }}>
+                  {user?.email || 'Not set'}
+                </Typography>
+              </Grid>
+              
+              <Grid item xs={12} sm={6}>
+                <Typography variant="body2" color="text.secondary">
+                  Phone
+                </Typography>
+                <Typography variant="body1" sx={{ mb: 2 }}>
+                  +1 (555) 123-4567
+                </Typography>
+              </Grid>
+              
+              <Grid item xs={12} sm={6}>
+                <Typography variant="body2" color="text.secondary">
+                  Department
+                </Typography>
+                <Typography variant="body1" sx={{ mb: 2 }}>
+                  Security Operations
+                </Typography>
+              </Grid>
+              
+              <Grid item xs={12} sm={6}>
+                <Typography variant="body2" color="text.secondary">
+                  Role
+                </Typography>
+                <Typography variant="body1" sx={{ mb: 2 }}>
+                  {user?.role || 'Operator'}
+                </Typography>
+              </Grid>
+              
+              <Grid item xs={12} sm={6}>
+                <Typography variant="body2" color="text.secondary">
+                  Last Login
+                </Typography>
+                <Typography variant="body1" sx={{ mb: 2 }}>
+                  {user?.lastLogin ? new Date(user.lastLogin).toLocaleString() : 'Never'}
+                </Typography>
+              </Grid>
+            </Grid>
+          </Paper>
+
+          {/* Performance Statistics */}
+          <Paper sx={{ p: 3 }}>
+            <Typography variant="h6" gutterBottom>
+              Performance Statistics
+            </Typography>
+            
+            <Grid container spacing={3}>
+              {stats.map((stat, index) => (
+                <Grid item xs={6} sm={3} key={index}>
+                  <Card variant="outlined">
+                    <CardContent sx={{ textAlign: 'center', py: 2 }}>
+                      <Typography 
+                        variant="h4" 
+                        color={`${stat.color}.main`}
+                        fontWeight="bold"
+                      >
+                        {stat.value}
+                      </Typography>
+                      <Typography variant="body2" color="text.secondary">
+                        {stat.label}
+                      </Typography>
+                    </CardContent>
+                  </Card>
+                </Grid>
+              ))}
+            </Grid>
+          </Paper>
+        </Grid>
+
+        {/* Recent Activity */}
+        <Grid item xs={12}>
+          <Paper sx={{ p: 3 }}>
+            <Typography variant="h6" gutterBottom>
+              Recent Activity
+            </Typography>
+            
+            <List>
+              {recentActivity.map((activity, index) => (
+                <React.Fragment key={activity.id}>
+                  <ListItem>
+                    <ListItemIcon>
+                      {getActivityIcon(activity.type)}
+                    </ListItemIcon>
+                    <ListItemText
+                      primary={activity.action}
+                      secondary={activity.timestamp}
+                    />
+                  </ListItem>
+                  {index < recentActivity.length - 1 && <Divider />}
+                </React.Fragment>
+              ))}
+            </List>
+          </Paper>
+        </Grid>
+      </Grid>
+
+      {/* Edit Profile Dialog */}
+      <Dialog open={editDialogOpen} onClose={() => setEditDialogOpen(false)} maxWidth="sm" fullWidth>
+        <DialogTitle>Edit Profile</DialogTitle>
+        <DialogContent>
+          <Grid container spacing={3} sx={{ mt: 1 }}>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Username"
+                value={editData.username}
+                onChange={(e) => setEditData({ ...editData, username: e.target.value })}
+              />
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Email"
+                type="email"
+                value={editData.email}
+                onChange={(e) => setEditData({ ...editData, email: e.target.value })}
+              />
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Phone"
+                value={editData.phone}
+                onChange={(e) => setEditData({ ...editData, phone: e.target.value })}
+              />
+            </Grid>
+            <Grid item xs={12}>
+              <TextField
+                fullWidth
+                label="Department"
+                value={editData.department}
+                onChange={(e) => setEditData({ ...editData, department: e.target.value })}
+              />
+            </Grid>
+          </Grid>
+        </DialogContent>
+        <DialogActions>
+          <Button
+            onClick={() => setEditDialogOpen(false)}
+            startIcon={<CancelIcon />}
+          >
+            Cancel
+          </Button>
+          <Button
+            onClick={handleSaveProfile}
+            variant="contained"
+            startIcon={<SaveIcon />}
+          >
+            Save Changes
+          </Button>
+        </DialogActions>
+      </Dialog>
+    </Box>
+  );
+};
+
 export default Profile;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/pages/Settings.tsx b/event-monitoring-mvp/frontend/src/pages/Settings.tsx
index c2aedc6..c48017c 100644
--- a/event-monitoring-mvp/frontend/src/pages/Settings.tsx
+++ b/event-monitoring-mvp/frontend/src/pages/Settings.tsx
@@ -1,538 +1,538 @@
-import React, { useState } from 'react';
-import {
-  Box,
-  Typography,
-  Paper,
-  Grid,
-  Switch,
-  TextField,
-  Button,
-  List,
-  ListItem,
-  ListItemText,
-  ListItemSecondaryAction,
-  Dialog,
-  DialogTitle,
-  DialogContent,
-  DialogActions,
-  Slider,
-  MenuItem,
-} from '@mui/material';
-import {
-  Notifications as NotificationsIcon,
-  Security as SecurityIcon,
-  Palette as PaletteIcon,
-  VolumeUp as VolumeIcon,
-  Save as SaveIcon,
-  Restore as RestoreIcon,
-  Lock as LockIcon,
-} from '@mui/icons-material';
-
-/**
- * Settings Component - System configuration and user preferences
- * Features:
- * - Notification preferences (email, push, SMS)
- * - Display settings (theme, language, timezone)
- * - Audio configuration (volume, sound alerts)
- * - Security settings (2FA, session timeout)
- * - System preferences (auto-refresh, caching)
- * - Password change functionality
- */
-const Settings: React.FC = () => {
-  // Settings state with all configuration categories
-  const [settings, setSettings] = useState({
-    notifications: {
-      emailAlerts: true,
-      pushNotifications: true,
-      smsAlerts: false,
-      eventNotifications: true,
-      systemAlerts: true,
-      maintenanceNotifications: false,
-    },
-    display: {
-      darkMode: false,
-      compactView: false,
-      showGrid: true,
-      animationsEnabled: true,
-      language: 'en',
-      timezone: 'America/New_York',
-    },
-    audio: {
-      alertSounds: true,
-      notificationVolume: 70,
-      eventSounds: true,
-      systemSounds: false,
-    },
-    security: {
-      twoFactorAuth: false,
-      sessionTimeout: 30,
-      autoLogout: true,
-      passwordExpiry: 90,
-    },
-    system: {
-      autoRefresh: true,
-      refreshInterval: 5,
-      cacheEnabled: true,
-      debugMode: false,
-    },
-  });
-
-  const [changePasswordDialog, setChangePasswordDialog] = useState(false);
-  const [passwordData, setPasswordData] = useState({
-    currentPassword: '',
-    newPassword: '',
-    confirmPassword: '',
-  });
-
-  /**
-   * Handle changes to individual settings
-   * @param category - Settings category (notifications, display, etc.)
-   * @param setting - Specific setting name
-   * @param value - New value for the setting
-   */
-  const handleSettingChange = (category: string, setting: string, value: any) => {
-    setSettings(prev => ({
-      ...prev,
-      [category]: {
-        ...prev[category as keyof typeof prev],
-        [setting]: value,
-      },
-    }));
-  };
-
-  /**
-   * Save all settings to backend
-   * TODO: Implement API call to persist settings
-   */
-  const handleSaveSettings = () => {
-    console.log('Saving settings:', settings);
-    // API call would go here
-  };
-
-  /**
-   * Reset all settings to default values
-   * TODO: Implement reset functionality
-   */
-  const handleResetSettings = () => {
-    console.log('Resetting settings to defaults');
-    // Reset logic would go here
-  };
-
-  /**
-   * Handle password change request
-   * TODO: Implement password change API call
-   */
-  const handleChangePassword = () => {
-    if (passwordData.newPassword !== passwordData.confirmPassword) {
-      alert('Passwords do not match');
-      return;
-    }
-    console.log('Changing password');
-    setChangePasswordDialog(false);
-    setPasswordData({ currentPassword: '', newPassword: '', confirmPassword: '' });
-  };
-
-  /**
-   * Reusable settings section component
-   */
-  const SettingsSection: React.FC<{
-    title: string;
-    icon: React.ReactNode;
-    children: React.ReactNode;
-  }> = ({ title, icon, children }) => (
-    <Paper sx={{ p: 3, mb: 3 }}>
-      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
-        {icon}
-        <Typography variant="h6" sx={{ ml: 1 }}>
-          {title}
-        </Typography>
-      </Box>
-      {children}
-    </Paper>
-  );
-
-  return (
-    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
-      {/* Page Header */}
-      <Typography variant="h4" gutterBottom fontWeight="bold">
-        System Settings
-      </Typography>
-      <Typography variant="subtitle1" color="text.secondary" gutterBottom>
-        Configure your preferences and system behavior.
-      </Typography>
-
-      <Grid container spacing={3} sx={{ mt: 2 }}>
-        {/* Notification Settings */}
-        <Grid item xs={12} md={6}>
-          <SettingsSection
-            title="Notifications"
-            icon={<NotificationsIcon color="primary" />}
-          >
-            <List>
-              <ListItem>
-                <ListItemText
-                  primary="Email Alerts"
-                  secondary="Receive alerts via email"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.notifications.emailAlerts}
-                    onChange={(e) => handleSettingChange('notifications', 'emailAlerts', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="Push Notifications"
-                  secondary="Browser push notifications"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.notifications.pushNotifications}
-                    onChange={(e) => handleSettingChange('notifications', 'pushNotifications', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="SMS Alerts"
-                  secondary="Critical alerts via SMS"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.notifications.smsAlerts}
-                    onChange={(e) => handleSettingChange('notifications', 'smsAlerts', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="Event Notifications"
-                  secondary="Alerts for new security events"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.notifications.eventNotifications}
-                    onChange={(e) => handleSettingChange('notifications', 'eventNotifications', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-            </List>
-          </SettingsSection>
-        </Grid>
-
-        {/* Display Settings */}
-        <Grid item xs={12} md={6}>
-          <SettingsSection
-            title="Display"
-            icon={<PaletteIcon color="primary" />}
-          >
-            <List>
-              <ListItem>
-                <ListItemText
-                  primary="Dark Mode"
-                  secondary="Use dark theme"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.display.darkMode}
-                    onChange={(e) => handleSettingChange('display', 'darkMode', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="Compact View"
-                  secondary="Reduce spacing and padding"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.display.compactView}
-                    onChange={(e) => handleSettingChange('display', 'compactView', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="Show Grid Lines"
-                  secondary="Display grid lines in tables"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.display.showGrid}
-                    onChange={(e) => handleSettingChange('display', 'showGrid', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-            </List>
-            
-            <Box sx={{ mt: 2 }}>
-              <TextField
-                select
-                fullWidth
-                label="Language"
-                value={settings.display.language}
-                onChange={(e) => handleSettingChange('display', 'language', e.target.value)}
-                sx={{ mb: 2 }}
-              >
-                <MenuItem value="en">English</MenuItem>
-                <MenuItem value="es">Spanish</MenuItem>
-                <MenuItem value="fr">French</MenuItem>
-                <MenuItem value="de">German</MenuItem>
-              </TextField>
-              
-              <TextField
-                select
-                fullWidth
-                label="Timezone"
-                value={settings.display.timezone}
-                onChange={(e) => handleSettingChange('display', 'timezone', e.target.value)}
-              >
-                <MenuItem value="America/New_York">Eastern Time</MenuItem>
-                <MenuItem value="America/Chicago">Central Time</MenuItem>
-                <MenuItem value="America/Denver">Mountain Time</MenuItem>
-                <MenuItem value="America/Los_Angeles">Pacific Time</MenuItem>
-              </TextField>
-            </Box>
-          </SettingsSection>
-        </Grid>
-
-        {/* Audio Settings */}
-        <Grid item xs={12} md={6}>
-          <SettingsSection
-            title="Audio"
-            icon={<VolumeIcon color="primary" />}
-          >
-            <List>
-              <ListItem>
-                <ListItemText
-                  primary="Alert Sounds"
-                  secondary="Play sounds for alerts"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.audio.alertSounds}
-                    onChange={(e) => handleSettingChange('audio', 'alertSounds', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="Event Sounds"
-                  secondary="Play sounds for new events"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.audio.eventSounds}
-                    onChange={(e) => handleSettingChange('audio', 'eventSounds', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-            </List>
-            
-            <Box sx={{ mt: 2, px: 2 }}>
-              <Typography gutterBottom>
-                Notification Volume: {settings.audio.notificationVolume}%
-              </Typography>
-              <Slider
-                value={settings.audio.notificationVolume}
-                onChange={(_, value) => handleSettingChange('audio', 'notificationVolume', value)}
-                min={0}
-                max={100}
-                step={10}
-                marks
-                valueLabelDisplay="auto"
-              />
-            </Box>
-          </SettingsSection>
-        </Grid>
-
-        {/* Security Settings */}
-        <Grid item xs={12} md={6}>
-          <SettingsSection
-            title="Security"
-            icon={<SecurityIcon color="primary" />}
-          >
-            <List>
-              <ListItem>
-                <ListItemText
-                  primary="Two-Factor Authentication"
-                  secondary="Add an extra layer of security"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.security.twoFactorAuth}
-                    onChange={(e) => handleSettingChange('security', 'twoFactorAuth', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-              
-              <ListItem>
-                <ListItemText
-                  primary="Auto Logout"
-                  secondary="Automatically logout on inactivity"
-                />
-                <ListItemSecondaryAction>
-                  <Switch
-                    checked={settings.security.autoLogout}
-                    onChange={(e) => handleSettingChange('security', 'autoLogout', e.target.checked)}
-                  />
-                </ListItemSecondaryAction>
-              </ListItem>
-            </List>
-            
-            <Box sx={{ mt: 2 }}>
-              <TextField
-                fullWidth
-                type="number"
-                label="Session Timeout (minutes)"
-                value={settings.security.sessionTimeout}
-                onChange={(e) => handleSettingChange('security', 'sessionTimeout', parseInt(e.target.value))}
-                sx={{ mb: 2 }}
-              />
-              
-              <Button
-                variant="outlined"
-                startIcon={<LockIcon />}
-                onClick={() => setChangePasswordDialog(true)}
-                fullWidth
-              >
-                Change Password
-              </Button>
-            </Box>
-          </SettingsSection>
-        </Grid>
-
-        {/* System Settings */}
-        <Grid item xs={12}>
-          <SettingsSection
-            title="System"
-            icon={<SecurityIcon color="primary" />}
-          >
-            <Grid container spacing={3}>
-              <Grid item xs={12} md={6}>
-                <List>
-                  <ListItem>
-                    <ListItemText
-                      primary="Auto Refresh"
-                      secondary="Automatically refresh data"
-                    />
-                    <ListItemSecondaryAction>
-                      <Switch
-                        checked={settings.system.autoRefresh}
-                        onChange={(e) => handleSettingChange('system', 'autoRefresh', e.target.checked)}
-                      />
-                    </ListItemSecondaryAction>
-                  </ListItem>
-                  
-                  <ListItem>
-                    <ListItemText
-                      primary="Cache Enabled"
-                      secondary="Cache data for better performance"
-                    />
-                    <ListItemSecondaryAction>
-                      <Switch
-                        checked={settings.system.cacheEnabled}
-                        onChange={(e) => handleSettingChange('system', 'cacheEnabled', e.target.checked)}
-                      />
-                    </ListItemSecondaryAction>
-                  </ListItem>
-                </List>
-              </Grid>
-              
-              <Grid item xs={12} md={6}>
-                <TextField
-                  fullWidth
-                  type="number"
-                  label="Refresh Interval (seconds)"
-                  value={settings.system.refreshInterval}
-                  onChange={(e) => handleSettingChange('system', 'refreshInterval', parseInt(e.target.value))}
-                  sx={{ mb: 2 }}
-                  disabled={!settings.system.autoRefresh}
-                />
-              </Grid>
-            </Grid>
-          </SettingsSection>
-        </Grid>
-      </Grid>
-
-      {/* Action Buttons */}
-      <Paper sx={{ p: 3, mt: 3 }}>
-        <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
-          <Button
-            variant="outlined"
-            startIcon={<RestoreIcon />}
-            onClick={handleResetSettings}
-          >
-            Reset to Defaults
-          </Button>
-          
-          <Button
-            variant="contained"
-            startIcon={<SaveIcon />}
-            onClick={handleSaveSettings}
-          >
-            Save Settings
-          </Button>
-        </Box>
-      </Paper>
-
-      {/* Change Password Dialog */}
-      <Dialog
-        open={changePasswordDialog}
-        onClose={() => setChangePasswordDialog(false)}
-        maxWidth="sm"
-        fullWidth
-      >
-        <DialogTitle>Change Password</DialogTitle>
-        <DialogContent>
-          <TextField
-            fullWidth
-            type="password"
-            label="Current Password"
-            value={passwordData.currentPassword}
-            onChange={(e) => setPasswordData({ ...passwordData, currentPassword: e.target.value })}
-            sx={{ mb: 2, mt: 1 }}
-          />
-          
-          <TextField
-            fullWidth
-            type="password"
-            label="New Password"
-            value={passwordData.newPassword}
-            onChange={(e) => setPasswordData({ ...passwordData, newPassword: e.target.value })}
-            sx={{ mb: 2 }}
-          />
-          
-          <TextField
-            fullWidth
-            type="password"
-            label="Confirm New Password"
-            value={passwordData.confirmPassword}
-            onChange={(e) => setPasswordData({ ...passwordData, confirmPassword: e.target.value })}
-          />
-        </DialogContent>
-        
-        <DialogActions>
-          <Button onClick={() => setChangePasswordDialog(false)}>
-            Cancel
-          </Button>
-          <Button
-            onClick={handleChangePassword}
-            variant="contained"
-          >
-            Change Password
-          </Button>
-        </DialogActions>
-      </Dialog>
-    </Box>
-  );
-};
-
+import React, { useState } from 'react';
+import {
+  Box,
+  Typography,
+  Paper,
+  Grid,
+  Switch,
+  TextField,
+  Button,
+  List,
+  ListItem,
+  ListItemText,
+  ListItemSecondaryAction,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  Slider,
+  MenuItem,
+} from '@mui/material';
+import {
+  Notifications as NotificationsIcon,
+  Security as SecurityIcon,
+  Palette as PaletteIcon,
+  VolumeUp as VolumeIcon,
+  Save as SaveIcon,
+  Restore as RestoreIcon,
+  Lock as LockIcon,
+} from '@mui/icons-material';
+
+/**
+ * Settings Component - System configuration and user preferences
+ * Features:
+ * - Notification preferences (email, push, SMS)
+ * - Display settings (theme, language, timezone)
+ * - Audio configuration (volume, sound alerts)
+ * - Security settings (2FA, session timeout)
+ * - System preferences (auto-refresh, caching)
+ * - Password change functionality
+ */
+const Settings: React.FC = () => {
+  // Settings state with all configuration categories
+  const [settings, setSettings] = useState({
+    notifications: {
+      emailAlerts: true,
+      pushNotifications: true,
+      smsAlerts: false,
+      eventNotifications: true,
+      systemAlerts: true,
+      maintenanceNotifications: false,
+    },
+    display: {
+      darkMode: false,
+      compactView: false,
+      showGrid: true,
+      animationsEnabled: true,
+      language: 'en',
+      timezone: 'America/New_York',
+    },
+    audio: {
+      alertSounds: true,
+      notificationVolume: 70,
+      eventSounds: true,
+      systemSounds: false,
+    },
+    security: {
+      twoFactorAuth: false,
+      sessionTimeout: 30,
+      autoLogout: true,
+      passwordExpiry: 90,
+    },
+    system: {
+      autoRefresh: true,
+      refreshInterval: 5,
+      cacheEnabled: true,
+      debugMode: false,
+    },
+  });
+
+  const [changePasswordDialog, setChangePasswordDialog] = useState(false);
+  const [passwordData, setPasswordData] = useState({
+    currentPassword: '',
+    newPassword: '',
+    confirmPassword: '',
+  });
+
+  /**
+   * Handle changes to individual settings
+   * @param category - Settings category (notifications, display, etc.)
+   * @param setting - Specific setting name
+   * @param value - New value for the setting
+   */
+  const handleSettingChange = (category: string, setting: string, value: any) => {
+    setSettings(prev => ({
+      ...prev,
+      [category]: {
+        ...prev[category as keyof typeof prev],
+        [setting]: value,
+      },
+    }));
+  };
+
+  /**
+   * Save all settings to backend
+   * TODO: Implement API call to persist settings
+   */
+  const handleSaveSettings = () => {
+    console.log('Saving settings:', settings);
+    // API call would go here
+  };
+
+  /**
+   * Reset all settings to default values
+   * TODO: Implement reset functionality
+   */
+  const handleResetSettings = () => {
+    console.log('Resetting settings to defaults');
+    // Reset logic would go here
+  };
+
+  /**
+   * Handle password change request
+   * TODO: Implement password change API call
+   */
+  const handleChangePassword = () => {
+    if (passwordData.newPassword !== passwordData.confirmPassword) {
+      alert('Passwords do not match');
+      return;
+    }
+    console.log('Changing password');
+    setChangePasswordDialog(false);
+    setPasswordData({ currentPassword: '', newPassword: '', confirmPassword: '' });
+  };
+
+  /**
+   * Reusable settings section component
+   */
+  const SettingsSection: React.FC<{
+    title: string;
+    icon: React.ReactNode;
+    children: React.ReactNode;
+  }> = ({ title, icon, children }) => (
+    <Paper sx={{ p: 3, mb: 3 }}>
+      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
+        {icon}
+        <Typography variant="h6" sx={{ ml: 1 }}>
+          {title}
+        </Typography>
+      </Box>
+      {children}
+    </Paper>
+  );
+
+  return (
+    <Box sx={{ height: 'calc(100vh - 112px)', overflow: 'auto' }}>
+      {/* Page Header */}
+      <Typography variant="h4" gutterBottom fontWeight="bold">
+        System Settings
+      </Typography>
+      <Typography variant="subtitle1" color="text.secondary" gutterBottom>
+        Configure your preferences and system behavior.
+      </Typography>
+
+      <Grid container spacing={3} sx={{ mt: 2 }}>
+        {/* Notification Settings */}
+        <Grid item xs={12} md={6}>
+          <SettingsSection
+            title="Notifications"
+            icon={<NotificationsIcon color="primary" />}
+          >
+            <List>
+              <ListItem>
+                <ListItemText
+                  primary="Email Alerts"
+                  secondary="Receive alerts via email"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.notifications.emailAlerts}
+                    onChange={(e) => handleSettingChange('notifications', 'emailAlerts', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="Push Notifications"
+                  secondary="Browser push notifications"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.notifications.pushNotifications}
+                    onChange={(e) => handleSettingChange('notifications', 'pushNotifications', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="SMS Alerts"
+                  secondary="Critical alerts via SMS"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.notifications.smsAlerts}
+                    onChange={(e) => handleSettingChange('notifications', 'smsAlerts', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="Event Notifications"
+                  secondary="Alerts for new security events"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.notifications.eventNotifications}
+                    onChange={(e) => handleSettingChange('notifications', 'eventNotifications', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+            </List>
+          </SettingsSection>
+        </Grid>
+
+        {/* Display Settings */}
+        <Grid item xs={12} md={6}>
+          <SettingsSection
+            title="Display"
+            icon={<PaletteIcon color="primary" />}
+          >
+            <List>
+              <ListItem>
+                <ListItemText
+                  primary="Dark Mode"
+                  secondary="Use dark theme"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.display.darkMode}
+                    onChange={(e) => handleSettingChange('display', 'darkMode', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="Compact View"
+                  secondary="Reduce spacing and padding"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.display.compactView}
+                    onChange={(e) => handleSettingChange('display', 'compactView', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="Show Grid Lines"
+                  secondary="Display grid lines in tables"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.display.showGrid}
+                    onChange={(e) => handleSettingChange('display', 'showGrid', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+            </List>
+            
+            <Box sx={{ mt: 2 }}>
+              <TextField
+                select
+                fullWidth
+                label="Language"
+                value={settings.display.language}
+                onChange={(e) => handleSettingChange('display', 'language', e.target.value)}
+                sx={{ mb: 2 }}
+              >
+                <MenuItem value="en">English</MenuItem>
+                <MenuItem value="es">Spanish</MenuItem>
+                <MenuItem value="fr">French</MenuItem>
+                <MenuItem value="de">German</MenuItem>
+              </TextField>
+              
+              <TextField
+                select
+                fullWidth
+                label="Timezone"
+                value={settings.display.timezone}
+                onChange={(e) => handleSettingChange('display', 'timezone', e.target.value)}
+              >
+                <MenuItem value="America/New_York">Eastern Time</MenuItem>
+                <MenuItem value="America/Chicago">Central Time</MenuItem>
+                <MenuItem value="America/Denver">Mountain Time</MenuItem>
+                <MenuItem value="America/Los_Angeles">Pacific Time</MenuItem>
+              </TextField>
+            </Box>
+          </SettingsSection>
+        </Grid>
+
+        {/* Audio Settings */}
+        <Grid item xs={12} md={6}>
+          <SettingsSection
+            title="Audio"
+            icon={<VolumeIcon color="primary" />}
+          >
+            <List>
+              <ListItem>
+                <ListItemText
+                  primary="Alert Sounds"
+                  secondary="Play sounds for alerts"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.audio.alertSounds}
+                    onChange={(e) => handleSettingChange('audio', 'alertSounds', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="Event Sounds"
+                  secondary="Play sounds for new events"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.audio.eventSounds}
+                    onChange={(e) => handleSettingChange('audio', 'eventSounds', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+            </List>
+            
+            <Box sx={{ mt: 2, px: 2 }}>
+              <Typography gutterBottom>
+                Notification Volume: {settings.audio.notificationVolume}%
+              </Typography>
+              <Slider
+                value={settings.audio.notificationVolume}
+                onChange={(_, value) => handleSettingChange('audio', 'notificationVolume', value)}
+                min={0}
+                max={100}
+                step={10}
+                marks
+                valueLabelDisplay="auto"
+              />
+            </Box>
+          </SettingsSection>
+        </Grid>
+
+        {/* Security Settings */}
+        <Grid item xs={12} md={6}>
+          <SettingsSection
+            title="Security"
+            icon={<SecurityIcon color="primary" />}
+          >
+            <List>
+              <ListItem>
+                <ListItemText
+                  primary="Two-Factor Authentication"
+                  secondary="Add an extra layer of security"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.security.twoFactorAuth}
+                    onChange={(e) => handleSettingChange('security', 'twoFactorAuth', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+              
+              <ListItem>
+                <ListItemText
+                  primary="Auto Logout"
+                  secondary="Automatically logout on inactivity"
+                />
+                <ListItemSecondaryAction>
+                  <Switch
+                    checked={settings.security.autoLogout}
+                    onChange={(e) => handleSettingChange('security', 'autoLogout', e.target.checked)}
+                  />
+                </ListItemSecondaryAction>
+              </ListItem>
+            </List>
+            
+            <Box sx={{ mt: 2 }}>
+              <TextField
+                fullWidth
+                type="number"
+                label="Session Timeout (minutes)"
+                value={settings.security.sessionTimeout}
+                onChange={(e) => handleSettingChange('security', 'sessionTimeout', parseInt(e.target.value))}
+                sx={{ mb: 2 }}
+              />
+              
+              <Button
+                variant="outlined"
+                startIcon={<LockIcon />}
+                onClick={() => setChangePasswordDialog(true)}
+                fullWidth
+              >
+                Change Password
+              </Button>
+            </Box>
+          </SettingsSection>
+        </Grid>
+
+        {/* System Settings */}
+        <Grid item xs={12}>
+          <SettingsSection
+            title="System"
+            icon={<SecurityIcon color="primary" />}
+          >
+            <Grid container spacing={3}>
+              <Grid item xs={12} md={6}>
+                <List>
+                  <ListItem>
+                    <ListItemText
+                      primary="Auto Refresh"
+                      secondary="Automatically refresh data"
+                    />
+                    <ListItemSecondaryAction>
+                      <Switch
+                        checked={settings.system.autoRefresh}
+                        onChange={(e) => handleSettingChange('system', 'autoRefresh', e.target.checked)}
+                      />
+                    </ListItemSecondaryAction>
+                  </ListItem>
+                  
+                  <ListItem>
+                    <ListItemText
+                      primary="Cache Enabled"
+                      secondary="Cache data for better performance"
+                    />
+                    <ListItemSecondaryAction>
+                      <Switch
+                        checked={settings.system.cacheEnabled}
+                        onChange={(e) => handleSettingChange('system', 'cacheEnabled', e.target.checked)}
+                      />
+                    </ListItemSecondaryAction>
+                  </ListItem>
+                </List>
+              </Grid>
+              
+              <Grid item xs={12} md={6}>
+                <TextField
+                  fullWidth
+                  type="number"
+                  label="Refresh Interval (seconds)"
+                  value={settings.system.refreshInterval}
+                  onChange={(e) => handleSettingChange('system', 'refreshInterval', parseInt(e.target.value))}
+                  sx={{ mb: 2 }}
+                  disabled={!settings.system.autoRefresh}
+                />
+              </Grid>
+            </Grid>
+          </SettingsSection>
+        </Grid>
+      </Grid>
+
+      {/* Action Buttons */}
+      <Paper sx={{ p: 3, mt: 3 }}>
+        <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
+          <Button
+            variant="outlined"
+            startIcon={<RestoreIcon />}
+            onClick={handleResetSettings}
+          >
+            Reset to Defaults
+          </Button>
+          
+          <Button
+            variant="contained"
+            startIcon={<SaveIcon />}
+            onClick={handleSaveSettings}
+          >
+            Save Settings
+          </Button>
+        </Box>
+      </Paper>
+
+      {/* Change Password Dialog */}
+      <Dialog
+        open={changePasswordDialog}
+        onClose={() => setChangePasswordDialog(false)}
+        maxWidth="sm"
+        fullWidth
+      >
+        <DialogTitle>Change Password</DialogTitle>
+        <DialogContent>
+          <TextField
+            fullWidth
+            type="password"
+            label="Current Password"
+            value={passwordData.currentPassword}
+            onChange={(e) => setPasswordData({ ...passwordData, currentPassword: e.target.value })}
+            sx={{ mb: 2, mt: 1 }}
+          />
+          
+          <TextField
+            fullWidth
+            type="password"
+            label="New Password"
+            value={passwordData.newPassword}
+            onChange={(e) => setPasswordData({ ...passwordData, newPassword: e.target.value })}
+            sx={{ mb: 2 }}
+          />
+          
+          <TextField
+            fullWidth
+            type="password"
+            label="Confirm New Password"
+            value={passwordData.confirmPassword}
+            onChange={(e) => setPasswordData({ ...passwordData, confirmPassword: e.target.value })}
+          />
+        </DialogContent>
+        
+        <DialogActions>
+          <Button onClick={() => setChangePasswordDialog(false)}>
+            Cancel
+          </Button>
+          <Button
+            onClick={handleChangePassword}
+            variant="contained"
+          >
+            Change Password
+          </Button>
+        </DialogActions>
+      </Dialog>
+    </Box>
+  );
+};
+
 export default Settings;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/services/aiDetectionService.ts b/event-monitoring-mvp/frontend/src/services/aiDetectionService.ts
index 7c218d8..84f9b7e 100644
--- a/event-monitoring-mvp/frontend/src/services/aiDetectionService.ts
+++ b/event-monitoring-mvp/frontend/src/services/aiDetectionService.ts
@@ -1,400 +1,400 @@
-// AI Detection service for frontend integration
-
-export interface AIDetection {
-  _id: string;
-  cameraId: {
-    _id: string;
-    name: string;
-    location: {
-      coordinates: [number, number];
-      address?: string;
-    };
-  };
-  detectionId: string;
-  timestamp: string;
-  type: 'person' | 'vehicle' | 'unknown_object' | 'motion';
-  confidence: number;
-  boundingBox: {
-    x: number;
-    y: number;
-    width: number;
-    height: number;
-  };
-  location: {
-    coordinates: [number, number];
-    estimatedPosition?: [number, number];
-    address?: string;
-  };
-  metadata: {
-    aiModel: string;
-    processingTime: number;
-    frameNumber: number;
-    objectProperties?: {
-      color?: string;
-      size?: string;
-      direction?: string;
-      speed?: number;
-    };
-  };
-  status: 'pending_review' | 'dismissed' | 'promoted_to_event';
-  reviewedBy?: {
-    _id: string;
-    username: string;
-  };
-  reviewedAt?: string;
-  promotedEventId?: string;
-  snapshots: {
-    fullFrame: string;
-    croppedObject: string;
-    thumbnail: string;
-  };
-  createdAt: string;
-  updatedAt: string;
-}
-
-export interface DetectionFilters {
-  status?: string;
-  type?: string;
-  cameraId?: string;
-  minConfidence?: number;
-  maxConfidence?: number;
-  startDate?: string;
-  endDate?: string;
-  page?: number;
-  limit?: number;
-}
-
-export interface DetectionStats {
-  statusDistribution: Array<{
-    _id: string;
-    count: number;
-    avgConfidence: number;
-  }>;
-  typeDistribution: Array<{
-    _id: string;
-    count: number;
-    avgConfidence: number;
-  }>;
-  confidenceDistribution: Array<{
-    _id: string | number;
-    count: number;
-    types: string[];
-  }>;
-  timeline: Array<{
-    _id: string;
-    count: number;
-    types: string[];
-  }>;
-}
-
-class AIDetectionService {
-  private baseUrl = '/api/detections';
-
-  // Fetch all detections with filtering
-  async fetchDetections(filters: DetectionFilters = {}): Promise<{
-    success: boolean;
-    data: AIDetection[];
-    pagination?: {
-      current: number;
-      pages: number;
-      total: number;
-      limit: number;
-    };
-    error?: string;
-  }> {
-    try {
-      const queryParams = new URLSearchParams();
-      
-      Object.entries(filters).forEach(([key, value]) => {
-        if (value !== undefined && value !== null && value !== '') {
-          queryParams.append(key, value.toString());
-        }
-      });
-
-      const response = await fetch(`${this.baseUrl}?${queryParams.toString()}`, {
-        method: 'GET',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${localStorage.getItem('token')}`
-        }
-      });
-
-      const result = await response.json();
-      
-      if (!response.ok) {
-        throw new Error(result.message || 'Failed to fetch detections');
-      }
-
-      return result;
-    } catch (error: any) {
-      console.error('Error fetching detections:', error);
-      return {
-        success: false,
-        data: [],
-        error: error.message
-      };
-    }
-  }
-
-  // Fetch detections within radius
-  async fetchDetectionsInRadius(
-    lat: number, 
-    lng: number, 
-    radius: number = 1000,
-    filters: Partial<DetectionFilters> = {}
-  ): Promise<{
-    success: boolean;
-    data: AIDetection[];
-    center: { lat: number; lng: number };
-    radius: number;
-    error?: string;
-  }> {
-    try {
-      const queryParams = new URLSearchParams({
-        lat: lat.toString(),
-        lng: lng.toString(),
-        radius: radius.toString(),
-        ...Object.fromEntries(
-          Object.entries(filters).filter(([_, value]) => value !== undefined && value !== '')
-        )
-      });
-
-      const response = await fetch(`${this.baseUrl}/radius?${queryParams.toString()}`, {
-        method: 'GET',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${localStorage.getItem('token')}`
-        }
-      });
-
-      const result = await response.json();
-      
-      if (!response.ok) {
-        throw new Error(result.message || 'Failed to fetch detections in radius');
-      }
-
-      return result;
-    } catch (error: any) {
-      console.error('Error fetching detections in radius:', error);
-      return {
-        success: false,
-        data: [],
-        center: { lat, lng },
-        radius,
-        error: error.message
-      };
-    }
-  }
-
-  // Fetch single detection
-  async fetchDetection(id: string): Promise<{
-    success: boolean;
-    data?: AIDetection;
-    error?: string;
-  }> {
-    try {
-      const response = await fetch(`${this.baseUrl}/${id}`, {
-        method: 'GET',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${localStorage.getItem('token')}`
-        }
-      });
-
-      const result = await response.json();
-      
-      if (!response.ok) {
-        throw new Error(result.message || 'Failed to fetch detection');
-      }
-
-      return result;
-    } catch (error: any) {
-      console.error('Error fetching detection:', error);
-      return {
-        success: false,
-        error: error.message
-      };
-    }
-  }
-
-  // Promote detection to event
-  async promoteToEvent(
-    detectionId: string, 
-    eventData?: {
-      type?: string;
-      severity?: string;
-      description?: string;
-      metadata?: any;
-    }
-  ): Promise<{
-    success: boolean;
-    data?: { detection: AIDetection; event: any };
-    message?: string;
-    error?: string;
-  }> {
-    try {
-      const response = await fetch(`${this.baseUrl}/${detectionId}/promote`, {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${localStorage.getItem('token')}`
-        },
-        body: JSON.stringify({ eventData })
-      });
-
-      const result = await response.json();
-      
-      if (!response.ok) {
-        throw new Error(result.message || 'Failed to promote detection');
-      }
-
-      return result;
-    } catch (error: any) {
-      console.error('Error promoting detection:', error);
-      return {
-        success: false,
-        error: error.message
-      };
-    }
-  }
-
-  // Dismiss detection
-  async dismissDetection(
-    detectionId: string, 
-    reason?: string
-  ): Promise<{
-    success: boolean;
-    data?: AIDetection;
-    message?: string;
-    error?: string;
-  }> {
-    try {
-      const response = await fetch(`${this.baseUrl}/${detectionId}/dismiss`, {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${localStorage.getItem('token')}`
-        },
-        body: JSON.stringify({ reason })
-      });
-
-      const result = await response.json();
-      
-      if (!response.ok) {
-        throw new Error(result.message || 'Failed to dismiss detection');
-      }
-
-      return result;
-    } catch (error: any) {
-      console.error('Error dismissing detection:', error);
-      return {
-        success: false,
-        error: error.message
-      };
-    }
-  }
-
-  // Fetch detection statistics
-  async fetchDetectionStats(
-    startDate?: string,
-    endDate?: string,
-    cameraId?: string
-  ): Promise<{
-    success: boolean;
-    data?: DetectionStats;
-    error?: string;
-  }> {
-    try {
-      const queryParams = new URLSearchParams();
-      
-      if (startDate) queryParams.append('startDate', startDate);
-      if (endDate) queryParams.append('endDate', endDate);
-      if (cameraId) queryParams.append('cameraId', cameraId);
-
-      const response = await fetch(`${this.baseUrl}/stats?${queryParams.toString()}`, {
-        method: 'GET',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${localStorage.getItem('token')}`
-        }
-      });
-
-      const result = await response.json();
-      
-      if (!response.ok) {
-        throw new Error(result.message || 'Failed to fetch detection statistics');
-      }
-
-      return result;
-    } catch (error: any) {
-      console.error('Error fetching detection statistics:', error);
-      return {
-        success: false,
-        error: error.message
-      };
-    }
-  }
-
+// AI Detection service for frontend integration
+
+export interface AIDetection {
+  _id: string;
+  cameraId: {
+    _id: string;
+    name: string;
+    location: {
+      coordinates: [number, number];
+      address?: string;
+    };
+  };
+  detectionId: string;
+  timestamp: string;
+  type: 'person' | 'vehicle' | 'unknown_object' | 'motion';
+  confidence: number;
+  boundingBox: {
+    x: number;
+    y: number;
+    width: number;
+    height: number;
+  };
+  location: {
+    coordinates: [number, number];
+    estimatedPosition?: [number, number];
+    address?: string;
+  };
+  metadata: {
+    aiModel: string;
+    processingTime: number;
+    frameNumber: number;
+    objectProperties?: {
+      color?: string;
+      size?: string;
+      direction?: string;
+      speed?: number;
+    };
+  };
+  status: 'pending_review' | 'dismissed' | 'promoted_to_event';
+  reviewedBy?: {
+    _id: string;
+    username: string;
+  };
+  reviewedAt?: string;
+  promotedEventId?: string;
+  snapshots: {
+    fullFrame: string;
+    croppedObject: string;
+    thumbnail: string;
+  };
+  createdAt: string;
+  updatedAt: string;
+}
+
+export interface DetectionFilters {
+  status?: string;
+  type?: string;
+  cameraId?: string;
+  minConfidence?: number;
+  maxConfidence?: number;
+  startDate?: string;
+  endDate?: string;
+  page?: number;
+  limit?: number;
+}
+
+export interface DetectionStats {
+  statusDistribution: Array<{
+    _id: string;
+    count: number;
+    avgConfidence: number;
+  }>;
+  typeDistribution: Array<{
+    _id: string;
+    count: number;
+    avgConfidence: number;
+  }>;
+  confidenceDistribution: Array<{
+    _id: string | number;
+    count: number;
+    types: string[];
+  }>;
+  timeline: Array<{
+    _id: string;
+    count: number;
+    types: string[];
+  }>;
+}
+
+class AIDetectionService {
+  private baseUrl = '/api/detections';
+
+  // Fetch all detections with filtering
+  async fetchDetections(filters: DetectionFilters = {}): Promise<{
+    success: boolean;
+    data: AIDetection[];
+    pagination?: {
+      current: number;
+      pages: number;
+      total: number;
+      limit: number;
+    };
+    error?: string;
+  }> {
+    try {
+      const queryParams = new URLSearchParams();
+      
+      Object.entries(filters).forEach(([key, value]) => {
+        if (value !== undefined && value !== null && value !== '') {
+          queryParams.append(key, value.toString());
+        }
+      });
+
+      const response = await fetch(`${this.baseUrl}?${queryParams.toString()}`, {
+        method: 'GET',
+        headers: {
+          'Content-Type': 'application/json',
+          'Authorization': `Bearer ${localStorage.getItem('token')}`
+        }
+      });
+
+      const result = await response.json();
+      
+      if (!response.ok) {
+        throw new Error(result.message || 'Failed to fetch detections');
+      }
+
+      return result;
+    } catch (error: any) {
+      console.error('Error fetching detections:', error);
+      return {
+        success: false,
+        data: [],
+        error: error.message
+      };
+    }
+  }
+
+  // Fetch detections within radius
+  async fetchDetectionsInRadius(
+    lat: number, 
+    lng: number, 
+    radius: number = 1000,
+    filters: Partial<DetectionFilters> = {}
+  ): Promise<{
+    success: boolean;
+    data: AIDetection[];
+    center: { lat: number; lng: number };
+    radius: number;
+    error?: string;
+  }> {
+    try {
+      const queryParams = new URLSearchParams({
+        lat: lat.toString(),
+        lng: lng.toString(),
+        radius: radius.toString(),
+        ...Object.fromEntries(
+          Object.entries(filters).filter(([_, value]) => value !== undefined && value !== '')
+        )
+      });
+
+      const response = await fetch(`${this.baseUrl}/radius?${queryParams.toString()}`, {
+        method: 'GET',
+        headers: {
+          'Content-Type': 'application/json',
+          'Authorization': `Bearer ${localStorage.getItem('token')}`
+        }
+      });
+
+      const result = await response.json();
+      
+      if (!response.ok) {
+        throw new Error(result.message || 'Failed to fetch detections in radius');
+      }
+
+      return result;
+    } catch (error: any) {
+      console.error('Error fetching detections in radius:', error);
+      return {
+        success: false,
+        data: [],
+        center: { lat, lng },
+        radius,
+        error: error.message
+      };
+    }
+  }
+
+  // Fetch single detection
+  async fetchDetection(id: string): Promise<{
+    success: boolean;
+    data?: AIDetection;
+    error?: string;
+  }> {
+    try {
+      const response = await fetch(`${this.baseUrl}/${id}`, {
+        method: 'GET',
+        headers: {
+          'Content-Type': 'application/json',
+          'Authorization': `Bearer ${localStorage.getItem('token')}`
+        }
+      });
+
+      const result = await response.json();
+      
+      if (!response.ok) {
+        throw new Error(result.message || 'Failed to fetch detection');
+      }
+
+      return result;
+    } catch (error: any) {
+      console.error('Error fetching detection:', error);
+      return {
+        success: false,
+        error: error.message
+      };
+    }
+  }
+
+  // Promote detection to event
+  async promoteToEvent(
+    detectionId: string, 
+    eventData?: {
+      type?: string;
+      severity?: string;
+      description?: string;
+      metadata?: any;
+    }
+  ): Promise<{
+    success: boolean;
+    data?: { detection: AIDetection; event: any };
+    message?: string;
+    error?: string;
+  }> {
+    try {
+      const response = await fetch(`${this.baseUrl}/${detectionId}/promote`, {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+          'Authorization': `Bearer ${localStorage.getItem('token')}`
+        },
+        body: JSON.stringify({ eventData })
+      });
+
+      const result = await response.json();
+      
+      if (!response.ok) {
+        throw new Error(result.message || 'Failed to promote detection');
+      }
+
+      return result;
+    } catch (error: any) {
+      console.error('Error promoting detection:', error);
+      return {
+        success: false,
+        error: error.message
+      };
+    }
+  }
+
+  // Dismiss detection
+  async dismissDetection(
+    detectionId: string, 
+    reason?: string
+  ): Promise<{
+    success: boolean;
+    data?: AIDetection;
+    message?: string;
+    error?: string;
+  }> {
+    try {
+      const response = await fetch(`${this.baseUrl}/${detectionId}/dismiss`, {
+        method: 'POST',
+        headers: {
+          'Content-Type': 'application/json',
+          'Authorization': `Bearer ${localStorage.getItem('token')}`
+        },
+        body: JSON.stringify({ reason })
+      });
+
+      const result = await response.json();
+      
+      if (!response.ok) {
+        throw new Error(result.message || 'Failed to dismiss detection');
+      }
+
+      return result;
+    } catch (error: any) {
+      console.error('Error dismissing detection:', error);
+      return {
+        success: false,
+        error: error.message
+      };
+    }
+  }
+
+  // Fetch detection statistics
+  async fetchDetectionStats(
+    startDate?: string,
+    endDate?: string,
+    cameraId?: string
+  ): Promise<{
+    success: boolean;
+    data?: DetectionStats;
+    error?: string;
+  }> {
+    try {
+      const queryParams = new URLSearchParams();
+      
+      if (startDate) queryParams.append('startDate', startDate);
+      if (endDate) queryParams.append('endDate', endDate);
+      if (cameraId) queryParams.append('cameraId', cameraId);
+
+      const response = await fetch(`${this.baseUrl}/stats?${queryParams.toString()}`, {
+        method: 'GET',
+        headers: {
+          'Content-Type': 'application/json',
+          'Authorization': `Bearer ${localStorage.getItem('token')}`
+        }
+      });
+
+      const result = await response.json();
+      
+      if (!response.ok) {
+        throw new Error(result.message || 'Failed to fetch detection statistics');
+      }
+
+      return result;
+    } catch (error: any) {
+      console.error('Error fetching detection statistics:', error);
+      return {
+        success: false,
+        error: error.message
+      };
+    }
+  }
+
   // Create mock detection data for development
   generateMockDetections(cameras: any[]): AIDetection[] {
-    const mockDetections: AIDetection[] = [];
-    
-    cameras.forEach((camera, index) => {
-      // Create 2-3 detections per camera
-      for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) {
-        const types = ['person', 'vehicle', 'motion', 'unknown_object'] as const;
-        const statuses = ['pending_review', 'dismissed', 'promoted_to_event'] as const;
-        
-        mockDetections.push({
-          _id: `detection_${camera._id}_${i}`,
-          cameraId: {
-            _id: camera._id,
-            name: camera.name,
-            location: camera.location
-          },
-          detectionId: `AI_${Date.now()}_${index}_${i}`,
-          timestamp: new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000).toISOString(),
-          type: types[Math.floor(Math.random() * types.length)],
-          confidence: Math.random() * 0.4 + 0.6, // 60-100% confidence
-          boundingBox: {
-            x: Math.random() * 100,
-            y: Math.random() * 100,
-            width: Math.random() * 200 + 50,
-            height: Math.random() * 300 + 100
-          },
-          location: {
-            coordinates: [
-              camera.location.coordinates[0] + (Math.random() - 0.5) * 0.001,
-              camera.location.coordinates[1] + (Math.random() - 0.5) * 0.001
-            ],
-            address: camera.location.address
-          },
-          metadata: {
-            aiModel: ['YOLO-v8', 'ResNet-50', 'MobileNet-v3'][Math.floor(Math.random() * 3)],
-            processingTime: Math.random() * 100 + 50,
-            frameNumber: Math.floor(Math.random() * 10000),
-            objectProperties: {
-              color: ['red', 'blue', 'white', 'black', 'gray'][Math.floor(Math.random() * 5)],
-              size: ['small', 'medium', 'large'][Math.floor(Math.random() * 3)]
-            }
-          },
-          status: statuses[Math.floor(Math.random() * statuses.length)],
-          snapshots: {
-            fullFrame: `https://picsum.photos/800/600?random=${index}_${i}_1`,
-            croppedObject: `https://picsum.photos/200/200?random=${index}_${i}_2`,
-            thumbnail: `https://picsum.photos/100/100?random=${index}_${i}_3`
-          },
-          createdAt: new Date(Date.now() - Math.random() * 48 * 60 * 60 * 1000).toISOString(),
-          updatedAt: new Date().toISOString()
-        });
-      }
-    });
-    
-    return mockDetections.sort((a, b) => 
-      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
-    );
-  }
-}
-
-export const aiDetectionService = new AIDetectionService();
-export default aiDetectionService;
\ No newline at end of file
+    const mockDetections: AIDetection[] = [];
+    
+    cameras.forEach((camera, index) => {
+      // Create 2-3 detections per camera
+      for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) {
+        const types = ['person', 'vehicle', 'motion', 'unknown_object'] as const;
+        const statuses = ['pending_review', 'dismissed', 'promoted_to_event'] as const;
+        
+        mockDetections.push({
+          _id: `detection_${camera._id}_${i}`,
+          cameraId: {
+            _id: camera._id,
+            name: camera.name,
+            location: camera.location
+          },
+          detectionId: `AI_${Date.now()}_${index}_${i}`,
+          timestamp: new Date(Date.now() - Math.random() * 24 * 60 * 60 * 1000).toISOString(),
+          type: types[Math.floor(Math.random() * types.length)],
+          confidence: Math.random() * 0.4 + 0.6, // 60-100% confidence
+          boundingBox: {
+            x: Math.random() * 100,
+            y: Math.random() * 100,
+            width: Math.random() * 200 + 50,
+            height: Math.random() * 300 + 100
+          },
+          location: {
+            coordinates: [
+              camera.location.coordinates[0] + (Math.random() - 0.5) * 0.001,
+              camera.location.coordinates[1] + (Math.random() - 0.5) * 0.001
+            ],
+            address: camera.location.address
+          },
+          metadata: {
+            aiModel: ['YOLO-v8', 'ResNet-50', 'MobileNet-v3'][Math.floor(Math.random() * 3)],
+            processingTime: Math.random() * 100 + 50,
+            frameNumber: Math.floor(Math.random() * 10000),
+            objectProperties: {
+              color: ['red', 'blue', 'white', 'black', 'gray'][Math.floor(Math.random() * 5)],
+              size: ['small', 'medium', 'large'][Math.floor(Math.random() * 3)]
+            }
+          },
+          status: statuses[Math.floor(Math.random() * statuses.length)],
+          snapshots: {
+            fullFrame: `https://picsum.photos/800/600?random=${index}_${i}_1`,
+            croppedObject: `https://picsum.photos/200/200?random=${index}_${i}_2`,
+            thumbnail: `https://picsum.photos/100/100?random=${index}_${i}_3`
+          },
+          createdAt: new Date(Date.now() - Math.random() * 48 * 60 * 60 * 1000).toISOString(),
+          updatedAt: new Date().toISOString()
+        });
+      }
+    });
+    
+    return mockDetections.sort((a, b) => 
+      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
+    );
+  }
+}
+
+export const aiDetectionService = new AIDetectionService();
+export default aiDetectionService;
diff --git a/event-monitoring-mvp/frontend/src/services/authService.ts b/event-monitoring-mvp/frontend/src/services/authService.ts
index c770103..632ca0b 100644
--- a/event-monitoring-mvp/frontend/src/services/authService.ts
+++ b/event-monitoring-mvp/frontend/src/services/authService.ts
@@ -1,80 +1,82 @@
-const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
-
-export interface LoginRequest {
-  email: string;
-  password: string;
-}
-
-export interface RegisterRequest {
-  username: string;
-  email: string;
-  password: string;
-}
-
-export interface AuthResponse {
-  success: boolean;
-  data: {
-    token: string;
-    user: {
-      _id: string;
-      username: string;
-      email: string;
-      role: 'admin' | 'operator';
-      isActive: boolean;
-      createdAt: string;
-      updatedAt: string;
-    };
-  };
-}
-
-export const authService = {
-  async login(credentials: LoginRequest): Promise<AuthResponse> {
-    const response = await fetch(`${API_URL}/auth/login`, {
-      method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-      },
-      body: JSON.stringify(credentials),
-    });
-
-    if (!response.ok) {
-      const error = await response.json();
-      throw new Error(error.message || 'Login failed');
-    }
-
-    return response.json();
-  },
-
-  async register(userData: RegisterRequest): Promise<AuthResponse> {
-    const response = await fetch(`${API_URL}/auth/register`, {
-      method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-      },
-      body: JSON.stringify(userData),
-    });
-
-    if (!response.ok) {
-      const error = await response.json();
-      throw new Error(error.message || 'Registration failed');
-    }
-
-    return response.json();
-  },
-
-  // Helper function to get stored token
-  getToken(): string | null {
-    return localStorage.getItem('token');
-  },
-
-  // Helper function to remove token (for logout)
-  removeToken(): void {
-    localStorage.removeItem('token');
-  },
-
-  // Helper function to check if user is authenticated
-  isAuthenticated(): boolean {
-    const token = this.getToken();
-    return !!token;
-  },
+const API_URL = process.env.REACT_APP_API_BASE_URL || process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
+
+
+
+export interface LoginRequest {
+  email: string;
+  password: string;
+}
+
+export interface RegisterRequest {
+  username: string;
+  email: string;
+  password: string;
+}
+
+export interface AuthResponse {
+  success: boolean;
+  data: {
+    token: string;
+    user: {
+      _id: string;
+      username: string;
+      email: string;
+      role: 'admin' | 'operator';
+      isActive: boolean;
+      createdAt: string;
+      updatedAt: string;
+    };
+  };
+}
+
+export const authService = {
+  async login(credentials: LoginRequest): Promise<AuthResponse> {
+    const response = await fetch(`${API_URL}/auth/login`, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+      },
+      body: JSON.stringify(credentials),
+    });
+
+    if (!response.ok) {
+      const error = await response.json();
+      throw new Error(error.message || 'Login failed');
+    }
+
+    return response.json();
+  },
+
+  async register(userData: RegisterRequest): Promise<AuthResponse> {
+    const response = await fetch(`${API_URL}/auth/register`, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+      },
+      body: JSON.stringify(userData),
+    });
+
+    if (!response.ok) {
+      const error = await response.json();
+      throw new Error(error.message || 'Registration failed');
+    }
+
+    return response.json();
+  },
+
+  // Helper function to get stored token
+  getToken(): string | null {
+    return localStorage.getItem('token');
+  },
+
+  // Helper function to remove token (for logout)
+  removeToken(): void {
+    localStorage.removeItem('token');
+  },
+
+  // Helper function to check if user is authenticated
+  isAuthenticated(): boolean {
+    const token = this.getToken();
+    return !!token;
+  },
 };
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/services/cameraService.ts b/event-monitoring-mvp/frontend/src/services/cameraService.ts
new file mode 100644
index 0000000..448b845
--- /dev/null
+++ b/event-monitoring-mvp/frontend/src/services/cameraService.ts
@@ -0,0 +1,544 @@
+/**
+ * Camera Service
+ * Handles all API communication regarding cameras.
+ *
+ * FILE: frontend/src/services/cameraService.ts
+ */
+
+/**
+ * Backend base URL
+ * Uses env var when available (Docker / deployed), falls back to localhost.
+ */
+const API_URL = process.env.REACT_APP_API_BASE_URL || process.env.REACT_APP_API_URL || 'http://localhost:5000/api';
+
+  function clearAuthStorage() {
+  // Token is stored in localStorage and auth state is persisted by redux-persist.
+  // If backend rejects the token (401), force a clean re-login.
+  localStorage.removeItem('token');
+  localStorage.removeItem('persist:root');
+}
+
+
+
+/**
+ * Helper function to retrieve JWT token from localStorage
+ * and attach it to Authorization headers.
+ */
+const getAuthHeader = (): Record<string, string> => {
+  const token = localStorage.getItem('token');
+  return token ? { 'Authorization': `Bearer ${token}` } : {};
+};
+
+
+/**
+ * Interface for Camera creation data
+ * Must match backend camera validation schema
+ */
+export interface CreateCameraData {
+  name: string;
+  description?: string;
+  type: 'ip' | 'analog' | 'usb';
+  streamUrl: string;
+  location: {
+    coordinates: [number, number]; // [longitude, latitude]
+    address?: string;
+  };
+  settings?: {
+    resolution: string;
+    fps: number;
+    recordingEnabled: boolean;
+  };
+}
+
+/**
+ * Sends a POST request to create a new camera
+ * @param cameraData - Camera object to store in DB
+ */
+export const addCamera = async (cameraData: CreateCameraData) => {
+  const response = await fetch(`${API_URL}/cameras`, {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(), // Attach auth token
+    },
+    body: JSON.stringify(cameraData),
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await response.json();
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to add camera');
+  }
+
+  return data;
+};
+
+/**
+ * Fetches all cameras from the backend
+ */
+export const getCameras = async () => {
+  const response = await fetch(`${API_URL}/cameras`, {
+    method: 'GET',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await response.json();
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to fetch cameras');
+  }
+
+  // Backend returns: { success: true, data: [...] }
+  return data.data;
+};
+
+
+/**
+ * Updates camera status (online/offline/maintenance)
+ * Backend: PATCH /api/cameras/:id/status
+ */
+export const setCameraStatus = async (
+  cameraId: string,
+  status: 'online' | 'offline' | 'maintenance'
+) => {
+  const response = await fetch(`${API_URL}/cameras/${cameraId}/status`, {
+    method: 'PATCH',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+    body: JSON.stringify({ status }),
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+  const data = await response.json().catch(() => ({}));
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to update camera status');
+  }
+
+  // backend returns { success: true, data: camera }
+  return data.data;
+};
+
+/**
+ * Deletes a camera (soft delete in backend)
+ * Backend: DELETE /api/cameras/:id
+ */
+export const deleteCamera = async (cameraId: string): Promise<void> => {
+  const response = await fetch(`${API_URL}/cameras/${cameraId}`, {
+    method: 'DELETE',
+    headers: {
+    'Content-Type': 'application/json',
+    ...getAuthHeader(),
+    }, 
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await response.json().catch(() => ({}));
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to delete camera');
+  }
+};
+
+// -----------------------------
+// VMS Integration (Frontend API)
+// -----------------------------
+
+/**
+ * VMS provider values must match the backend VmsServer model enum.
+ */
+export type VmsProvider = 'shinobi' | 'zoneminder' | 'agentdvr' | 'other';
+
+export interface VmsServer {
+  _id: string;
+  name: string;
+  provider: VmsProvider;
+  baseUrl: string;
+  isActive: boolean;
+  createdAt: string;
+  updatedAt: string;
+}
+
+export interface CreateVmsServerData {
+  name: string;
+  provider: VmsProvider;
+  baseUrl: string;
+  auth?: {
+    /**
+     * Shinobi needs BOTH:
+     * - apiKey
+     * - groupKey
+     * These are stored in MongoDB and are never serialized back to the frontend
+     * because VmsServer.ts strips `auth` in toJSON/toObject.
+     */
+    apiKey?: string;
+    groupKey?: string;
+
+    // Other providers may use username/password instead
+    username?: string;
+    password?: string;
+  };
+}
+
+export interface VmsMonitor {
+  mid?: string;
+  id?: string;
+  name?: string;
+  title?: string;
+  details?: string;
+}
+
+export interface UpdateVmsServerData {
+  name?: string;
+  provider?: VmsProvider;
+  baseUrl?: string;
+  auth?: {
+    apiKey?: string;
+    groupKey?: string;
+    username?: string;
+    password?: string;
+  };
+  isActive?: boolean;
+}
+
+
+/**
+ * Small helper to parse JSON safely.
+ * Why: backend always returns JSON, but if a proxy/error returns empty body
+ * we don't want parsing to crash the UI.
+ */
+const safeJson = async (response: Response) => {
+  try {
+    return await response.json();
+  } catch {
+    return {};
+  }
+};
+
+/**
+ * GET /api/vms/servers
+ * Fetch list of active VMS servers.
+ * Admin-only on backend (requires admin/super_admin JWT).
+ */
+export const getVmsServers = async (): Promise<VmsServer[]> => {
+  const response = await fetch(`${API_URL}/vms/servers`, {
+    method: 'GET',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to fetch VMS servers');
+  }
+
+  return data.data;
+};
+
+/**
+ * POST /api/vms/servers
+ * Create/register a VMS server record in our DB.
+ * Admin-only on backend (requires admin/super_admin JWT).
+ */
+export const createVmsServer = async (payload: CreateVmsServerData): Promise<VmsServer> => {
+  const response = await fetch(`${API_URL}/vms/servers`, {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+    body: JSON.stringify(payload),
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to create VMS server');
+  }
+
+  return data.data;
+};
+
+/**
+ * PATCH /api/vms/servers/:id
+ * Update VMS server details (including auth for providers like Shinobi).
+ */
+export const updateVmsServer = async (
+  serverId: string,
+  payload: UpdateVmsServerData
+): Promise<VmsServer> => {
+  const response = await fetch(`${API_URL}/vms/servers/${serverId}`, {
+    method: 'PATCH',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+    body: JSON.stringify(payload),
+  });
+
+  if (response.status === 401) {
+    clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to update VMS server');
+  }
+
+  return data.data;
+};
+
+/**
+ * GET /api/vms/servers/:id/monitors
+ * Fetch monitors from a VMS server (Shinobi).
+ */
+export const getVmsMonitors = async (serverId: string): Promise<VmsMonitor[]> => {
+  const response = await fetch(`${API_URL}/vms/servers/${serverId}/monitors`, {
+    method: 'GET',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+    clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to fetch VMS monitors');
+  }
+
+  return data.data;
+};
+
+/**
+ * POST /api/vms/servers/:id/monitors/import
+ * Batch-import monitors into cameras.
+ */
+export const importVmsMonitors = async (
+  serverId: string,
+  payload: {
+    monitorIds?: string[];
+    defaultLocation?: { coordinates: [number, number]; address?: string };
+    source?: string;
+  }
+) => {
+  const response = await fetch(`${API_URL}/vms/servers/${serverId}/monitors/import`, {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+    body: JSON.stringify(payload),
+  });
+
+  if (response.status === 401) {
+    clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to import VMS monitors');
+  }
+
+  return data.data;
+};
+
+/**
+ * DELETE /api/vms/servers/:id
+ * Soft-removes a VMS server by marking it inactive.
+ */
+export const deleteVmsServer = async (serverId: string): Promise<void> => {
+  const response = await fetch(`${API_URL}/vms/servers/${serverId}`, {
+    method: 'DELETE',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+    clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to delete VMS server');
+  }
+};
+
+/**
+ * POST /api/cameras/:id/vms/connect
+ * Connect a camera record to a chosen VMS server (mapping only for now).
+ * Admin-only on backend (requires admin/super_admin JWT).
+ */
+export const connectCameraToVms = async (
+  cameraId: string,
+  payload: { serverId: string; monitorId?: string }
+) => {
+  const response = await fetch(`${API_URL}/cameras/${cameraId}/vms/connect`, {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+    body: JSON.stringify(payload),
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to connect camera to VMS');
+  }
+
+  return data.data;
+};
+
+/**
+ * POST /api/cameras/:id/vms/disconnect
+ * Clears camera.vms mapping.
+ * Admin-only on backend (requires admin/super_admin JWT).
+ */
+export const disconnectCameraFromVms = async (cameraId: string) => {
+  const response = await fetch(`${API_URL}/cameras/${cameraId}/vms/disconnect`, {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to disconnect camera from VMS');
+  }
+
+  return data.data;
+};
+
+/**
+ * GET /api/cameras/:id/vms/streams
+ * Returns RTSP + VMS mapping + placeholders for live/playback URLs.
+ * Auth-only on backend.
+ */
+export const getCameraVmsStreams = async (cameraId: string) => {
+  const response = await fetch(`${API_URL}/cameras/${cameraId}/vms/streams`, {
+    method: 'GET',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+  clearAuthStorage();
+  }
+  
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to fetch camera stream info');
+  }
+
+  return data.data;
+};
+
+/**
+ * POST /api/cameras/test-connection
+ * Server-side reachability check for RTSP/HTTP stream URLs.
+ */
+export const testCameraConnection = async (payload: {
+  streamUrl: string;
+  mode?: 'rtsp' | 'vms';
+  vmsServerId?: string;
+  monitorId?: string;
+}): Promise<{ ok: boolean; message: string }> => {
+  const response = await fetch(`${API_URL}/cameras/test-connection`, {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+    body: JSON.stringify(payload),
+  });
+
+  if (response.status === 401) {
+    clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to test stream URL');
+  }
+
+  return data;
+};
+
+/**
+ * DELETE /api/cameras/source/:source
+ * Bulk delete cameras by metadata.source.
+ */
+export const deleteCamerasBySource = async (source: string): Promise<void> => {
+  const response = await fetch(`${API_URL}/cameras/source/${source}`, {
+    method: 'DELETE',
+    headers: {
+      'Content-Type': 'application/json',
+      ...getAuthHeader(),
+    },
+  });
+
+  if (response.status === 401) {
+    clearAuthStorage();
+  }
+
+  const data = await safeJson(response);
+
+  if (!response.ok) {
+    throw new Error(data.message || 'Failed to delete cameras');
+  }
+};
diff --git a/event-monitoring-mvp/frontend/src/services/dataService.ts b/event-monitoring-mvp/frontend/src/services/dataService.ts
index cd05cf4..e9e2a2c 100644
--- a/event-monitoring-mvp/frontend/src/services/dataService.ts
+++ b/event-monitoring-mvp/frontend/src/services/dataService.ts
@@ -1,200 +1,200 @@
 // Shared data service for consistent mock data across components
-// This ensures all components see the same cameras until real API integration is complete
-
-import { Camera } from '../types/index';
-
-export interface SecurityEvent {
-  _id: string;
-  type: string;
-  severity: 'low' | 'medium' | 'high' | 'critical';
-  location: {
-    coordinates: [number, number]; // [longitude, latitude]
-    address?: string;
-  };
-  camera: string;
-  cameraName?: string;
-  timestamp: string;
-  description: string;
-  resolved: boolean;
-  metadata?: {
-    confidence?: number;
-    duration?: number;
-    objectCount?: number;
-  };
-}
-
-// Shared mock cameras data - used by ALL components
-export const MOCK_CAMERAS: Camera[] = [
-  {
-    _id: '1',
-    name: 'Front Gate Camera',
-    description: 'Main entrance monitoring',
-    streamUrl: 'rtsp://192.168.1.100:554/stream',
-    status: 'online',
-    type: 'ip',
-    location: {
-      coordinates: [-74.0060, 40.7128], // NYC coordinates
-      address: '123 Main St, New York, NY',
-    },
-    settings: {
-      resolution: '1920x1080',
-      fps: 30,
-      recordingEnabled: true,
-    },
-    isActive: true,
-    createdBy: 'admin',
-    createdAt: new Date().toISOString(),
-    updatedAt: new Date().toISOString(),
-  },
-  {
-    _id: '2',
-    name: 'Parking Lot Camera',
-    description: 'Vehicle monitoring area',
-    streamUrl: 'rtsp://192.168.1.101:554/stream',
-    status: 'online',
-    type: 'ip',
-    location: {
-      coordinates: [-74.0070, 40.7138],
-      address: '125 Main St, New York, NY',
-    },
-    settings: {
-      resolution: '1920x1080',
-      fps: 25,
-      recordingEnabled: false,
-    },
-    isActive: true,
-    createdBy: 'admin',
-    createdAt: new Date().toISOString(),
-    updatedAt: new Date().toISOString(),
-  },
-  {
-    _id: '3',
-    name: 'Side Entrance Camera',
-    description: 'Secondary access point',
-    streamUrl: 'rtsp://192.168.1.102:554/stream',
-    status: 'offline',
-    type: 'ip',
-    location: {
-      coordinates: [-74.0050, 40.7118],
-      address: '121 Main St, New York, NY',
-    },
-    settings: {
-      resolution: '1280x720',
-      fps: 20,
-      recordingEnabled: true,
-    },
-    isActive: true,
-    createdBy: 'admin',
-    createdAt: new Date().toISOString(),
-    updatedAt: new Date().toISOString(),
-  },
-];
-
-// Shared mock events data - tied to the exact camera coordinates above
-export const MOCK_EVENTS: SecurityEvent[] = [
-  {
-    _id: 'evt1',
-    type: 'person_detected',
-    severity: 'medium',
-    location: {
-      coordinates: [-74.0060, 40.7128], // EXACTLY same as Front Gate Camera
-      address: '123 Main St, New York, NY',
-    },
-    camera: '1',
-    cameraName: 'Front Gate Camera',
-    timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
-    description: 'Person detected at main entrance',
-    resolved: false,
-    metadata: {
-      confidence: 0.95,
-      duration: 30,
-      objectCount: 1,
-    },
-  },
-  {
-    _id: 'evt2',
-    type: 'motion',
-    severity: 'low',
-    location: {
-      coordinates: [-74.0070, 40.7138], // EXACTLY same as Parking Lot Camera
-      address: '125 Main St, New York, NY',
-    },
-    camera: '2',
-    cameraName: 'Parking Lot Camera',
-    timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago
-    description: 'Vehicle movement in parking area',
-    resolved: true,
-    metadata: {
-      confidence: 0.87,
-      duration: 45,
-    },
-  },
-  {
-    _id: 'evt3',
-    type: 'intrusion',
-    severity: 'high',
-    location: {
-      coordinates: [-74.0050, 40.7118], // EXACTLY same as Side Entrance Camera
-      address: '121 Main St, New York, NY',
-    },
-    camera: '3',
-    cameraName: 'Side Entrance Camera',
-    timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // 2 hours ago
-    description: 'Unauthorized access attempt detected',
-    resolved: false,
-    metadata: {
-      confidence: 0.92,
-      duration: 120,
-      objectCount: 1,
-    },
-  },
-];
-
-// API service function that tries real API first, falls back to consistent mock data
-export const fetchCamerasData = async (): Promise<Camera[]> => {
-  try {
-    const response = await fetch('/api/cameras', {
-      method: 'GET',
-      headers: {
-        'Content-Type': 'application/json',
-      },
-    });
-    
-    if (response.ok) {
-      const result = await response.json();
-      if (result.success && result.data) {
-        console.log('Using real camera data from API');
-        return result.data;
-      }
-    }
-  } catch (apiError) {
-    console.log('API not available, using consistent mock data:', apiError);
-  }
-  
-  console.log('Using shared mock camera data');
-  return MOCK_CAMERAS;
+// This ensures all components see the same cameras until real API integration is complete
+
+import { Camera } from '../types/index';
+
+export interface SecurityEvent {
+  _id: string;
+  type: string;
+  severity: 'low' | 'medium' | 'high' | 'critical';
+  location: {
+    coordinates: [number, number]; // [longitude, latitude]
+    address?: string;
+  };
+  camera: string;
+  cameraName?: string;
+  timestamp: string;
+  description: string;
+  resolved: boolean;
+  metadata?: {
+    confidence?: number;
+    duration?: number;
+    objectCount?: number;
+  };
+}
+
+// Shared mock cameras data - used by ALL components
+export const MOCK_CAMERAS: Camera[] = [
+  {
+    _id: '1',
+    name: 'Front Gate Camera',
+    description: 'Main entrance monitoring',
+    streamUrl: 'rtsp://192.168.1.100:554/stream',
+    status: 'online',
+    type: 'ip',
+    location: {
+      coordinates: [-74.0060, 40.7128], // NYC coordinates
+      address: '123 Main St, New York, NY',
+    },
+    settings: {
+      resolution: '1920x1080',
+      fps: 30,
+      recordingEnabled: true,
+    },
+    isActive: true,
+    createdBy: 'admin',
+    createdAt: new Date().toISOString(),
+    updatedAt: new Date().toISOString(),
+  },
+  {
+    _id: '2',
+    name: 'Parking Lot Camera',
+    description: 'Vehicle monitoring area',
+    streamUrl: 'rtsp://192.168.1.101:554/stream',
+    status: 'online',
+    type: 'ip',
+    location: {
+      coordinates: [-74.0070, 40.7138],
+      address: '125 Main St, New York, NY',
+    },
+    settings: {
+      resolution: '1920x1080',
+      fps: 25,
+      recordingEnabled: false,
+    },
+    isActive: true,
+    createdBy: 'admin',
+    createdAt: new Date().toISOString(),
+    updatedAt: new Date().toISOString(),
+  },
+  {
+    _id: '3',
+    name: 'Side Entrance Camera',
+    description: 'Secondary access point',
+    streamUrl: 'rtsp://192.168.1.102:554/stream',
+    status: 'offline',
+    type: 'ip',
+    location: {
+      coordinates: [-74.0050, 40.7118],
+      address: '121 Main St, New York, NY',
+    },
+    settings: {
+      resolution: '1280x720',
+      fps: 20,
+      recordingEnabled: true,
+    },
+    isActive: true,
+    createdBy: 'admin',
+    createdAt: new Date().toISOString(),
+    updatedAt: new Date().toISOString(),
+  },
+];
+
+// Shared mock events data - tied to the exact camera coordinates above
+export const MOCK_EVENTS: SecurityEvent[] = [
+  {
+    _id: 'evt1',
+    type: 'person_detected',
+    severity: 'medium',
+    location: {
+      coordinates: [-74.0060, 40.7128], // EXACTLY same as Front Gate Camera
+      address: '123 Main St, New York, NY',
+    },
+    camera: '1',
+    cameraName: 'Front Gate Camera',
+    timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 minutes ago
+    description: 'Person detected at main entrance',
+    resolved: false,
+    metadata: {
+      confidence: 0.95,
+      duration: 30,
+      objectCount: 1,
+    },
+  },
+  {
+    _id: 'evt2',
+    type: 'motion',
+    severity: 'low',
+    location: {
+      coordinates: [-74.0070, 40.7138], // EXACTLY same as Parking Lot Camera
+      address: '125 Main St, New York, NY',
+    },
+    camera: '2',
+    cameraName: 'Parking Lot Camera',
+    timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 minutes ago
+    description: 'Vehicle movement in parking area',
+    resolved: true,
+    metadata: {
+      confidence: 0.87,
+      duration: 45,
+    },
+  },
+  {
+    _id: 'evt3',
+    type: 'intrusion',
+    severity: 'high',
+    location: {
+      coordinates: [-74.0050, 40.7118], // EXACTLY same as Side Entrance Camera
+      address: '121 Main St, New York, NY',
+    },
+    camera: '3',
+    cameraName: 'Side Entrance Camera',
+    timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(), // 2 hours ago
+    description: 'Unauthorized access attempt detected',
+    resolved: false,
+    metadata: {
+      confidence: 0.92,
+      duration: 120,
+      objectCount: 1,
+    },
+  },
+];
+
+// API service function that tries real API first, falls back to consistent mock data
+export const fetchCamerasData = async (): Promise<Camera[]> => {
+  try {
+    const response = await fetch('/api/cameras', {
+      method: 'GET',
+      headers: {
+        'Content-Type': 'application/json',
+      },
+    });
+    
+    if (response.ok) {
+      const result = await response.json();
+      if (result.success && result.data) {
+        console.log('Using real camera data from API');
+        return result.data;
+      }
+    }
+  } catch (apiError) {
+    console.log('API not available, using consistent mock data:', apiError);
+  }
+  
+  console.log('Using shared mock camera data');
+  return MOCK_CAMERAS;
+};
+
+export const fetchEventsData = async (): Promise<SecurityEvent[]> => {
+  try {
+    const response = await fetch('/api/events', {
+      method: 'GET',
+      headers: {
+        'Content-Type': 'application/json',
+      },
+    });
+    
+    if (response.ok) {
+      const result = await response.json();
+      if (result.success && result.data) {
+        console.log('Using real event data from API');
+        return result.data;
+      }
+    }
+  } catch (apiError) {
+    console.log('API not available, using consistent mock events:', apiError);
+  }
+  
+  console.log('Using shared mock event data');
+  return MOCK_EVENTS;
 };
-
-export const fetchEventsData = async (): Promise<SecurityEvent[]> => {
-  try {
-    const response = await fetch('/api/events', {
-      method: 'GET',
-      headers: {
-        'Content-Type': 'application/json',
-      },
-    });
-    
-    if (response.ok) {
-      const result = await response.json();
-      if (result.success && result.data) {
-        console.log('Using real event data from API');
-        return result.data;
-      }
-    }
-  } catch (apiError) {
-    console.log('API not available, using consistent mock events:', apiError);
-  }
-  
-  console.log('Using shared mock event data');
-  return MOCK_EVENTS;
-};
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/store/store.ts b/event-monitoring-mvp/frontend/src/store/store.ts
index 66a4f53..1a56389 100644
--- a/event-monitoring-mvp/frontend/src/store/store.ts
+++ b/event-monitoring-mvp/frontend/src/store/store.ts
@@ -1,231 +1,231 @@
-import { configureStore } from '@reduxjs/toolkit';
-import { persistStore, persistReducer } from 'redux-persist';
-import storage from 'redux-persist/lib/storage';
-import { combineReducers } from '@reduxjs/toolkit';
-
-// Auth slice
-import { createSlice, PayloadAction } from '@reduxjs/toolkit';
-import { User } from '../types';
-
-/**
- * Authentication State Interface
- * Defines the structure of authentication-related state
- */
-interface AuthState {
-  user: User | null;           // Current authenticated user data
-  token: string | null;        // JWT authentication token
-  isAuthenticated: boolean;    // Authentication status flag
-  loading: boolean;            // Loading state for auth operations
-}
-
-/**
- * Initial Authentication State
- * Default values when the app starts
- */
-const initialAuthState: AuthState = {
-  user: null,
-  token: null,
-  isAuthenticated: false,
-  loading: false,
-};
-
-/**
- * Authentication Redux Slice
- * Manages user authentication state and actions
- * 
- * Actions:
- * - loginStart: Sets loading state when login begins
- * - loginSuccess: Stores user data and token on successful login
- * - loginFailure: Clears auth data on login failure
- * - logout: Clears all authentication data
- * - updateUser: Updates current user information
- */
-const authSlice = createSlice({
-  name: 'auth',
-  initialState: initialAuthState,
-  reducers: {
-    // Set loading state when login process starts
-    loginStart: (state) => {
-      state.loading = true;
-    },
-    // Handle successful login - store user data and token
-    loginSuccess: (state, action: PayloadAction<{ user: User; token: string }>) => {
-      state.loading = false;
-      state.user = action.payload.user;
-      state.token = action.payload.token;
-      state.isAuthenticated = true;
-    },
-    // Handle login failure - clear authentication data
-    loginFailure: (state) => {
-      state.loading = false;
-      state.user = null;
-      state.token = null;
-      state.isAuthenticated = false;
-    },
-    // Handle logout - reset to initial state
-    logout: (state) => {
-      state.user = null;
-      state.token = null;
-      state.isAuthenticated = false;
-      state.loading = false;
-    },
-    // Update user profile information
-    updateUser: (state, action: PayloadAction<User>) => {
-      state.user = action.payload;
-    },
-  },
-});
-
-/**
- * User Interface State Interface
- * Defines the structure of UI-related state
- */
-interface UIState {
-  sidebarOpen: boolean;        // Sidebar visibility state
-  theme: 'light' | 'dark';    // Application theme preference
-  notifications: Array<{      // In-app notification system
-    id: string;               // Unique notification identifier
-    type: 'success' | 'error' | 'warning' | 'info'; // Notification type
-    message: string;          // Notification content
-    timestamp: string;        // When notification was created
-  }>;
-}
-
-/**
- * Initial UI State
- * Default values for user interface components
- */
-const initialUIState: UIState = {
-  sidebarOpen: true,
-  theme: 'light',
-  notifications: [],
-};
-
-/**
- * User Interface Redux Slice
- * Manages application UI state and user preferences
- * 
- * Actions:
- * - toggleSidebar: Toggle sidebar visibility
- * - setSidebarOpen: Explicitly set sidebar open/closed state
- * - setTheme: Switch between light/dark themes
- * - addNotification: Add new notification to the queue
- * - removeNotification: Remove notification by ID
- */
-const uiSlice = createSlice({
-  name: 'ui',
-  initialState: initialUIState,
-  reducers: {
-    // Toggle sidebar open/closed state
-    toggleSidebar: (state) => {
-      state.sidebarOpen = !state.sidebarOpen;
-    },
-    // Explicitly set sidebar visibility
-    setSidebarOpen: (state, action: PayloadAction<boolean>) => {
-      state.sidebarOpen = action.payload;
-    },
-    // Set application theme (light/dark mode)
-    setTheme: (state, action: PayloadAction<'light' | 'dark'>) => {
-      state.theme = action.payload;
-    },
-    // Add new notification to the notification queue
-    addNotification: (state, action: PayloadAction<Omit<UIState['notifications'][0], 'id' | 'timestamp'>>) => {
-      const notification = {
-        ...action.payload,
-        id: Math.random().toString(36).substr(2, 9), // Generate unique ID
-        timestamp: new Date().toISOString(),
-      };
-      state.notifications.push(notification);
-    },
-    // Remove notification from queue by ID
-    removeNotification: (state, action: PayloadAction<string>) => {
-      state.notifications = state.notifications.filter(n => n.id !== action.payload);
-    },
-    // Clear all notifications from the queue
-    clearNotifications: (state) => {
-      state.notifications = [];
-    },
-  },
-});
-
-/**
- * Root Reducer Configuration
- * Combines all individual slice reducers into a single root reducer
- * This allows multiple slices to work together in the Redux store
- */
-const rootReducer = combineReducers({
-  auth: authSlice.reducer,  // Authentication state management
-  ui: uiSlice.reducer,      // User interface state management
-});
-
-/**
- * Redux Persist Configuration
- * Configures which parts of the Redux state should be persisted
- * to localStorage between browser sessions
- */
-const persistConfig = {
-  key: 'root',                    // Storage key in localStorage
-  storage,                        // Storage engine (localStorage)
-  whitelist: ['auth'],           // Only persist auth state (UI state resets on refresh)
-};
-
-// Create persisted reducer with the configuration
-const persistedReducer = persistReducer(persistConfig, rootReducer);
-
-/**
- * Redux Store Configuration
- * Creates the main Redux store with middleware and persistence
- * 
- * Features:
- * - Redux Toolkit for modern Redux patterns
- * - Redux Persist for state persistence
- * - Custom middleware configuration for serialization
- */
-export const store = configureStore({
-  reducer: persistedReducer,
-  middleware: (getDefaultMiddleware) =>
-    getDefaultMiddleware({
-      serializableCheck: {
-        // Ignore redux-persist actions that contain non-serializable values
-        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
-      },
-    }),
-});
-
-/**
- * Redux Persistor
- * Creates the persistor instance for managing state persistence
- */
-export const persistor = persistStore(store);
-
-/**
- * TypeScript Types for Redux Store
- * These types enable proper type checking throughout the application
- */
-export type RootState = ReturnType<typeof store.getState>;  // Type for the entire Redux state
-export type AppDispatch = typeof store.dispatch;           // Type for the dispatch function
-
-/**
- * Authentication Actions Export
- * These actions can be dispatched from components to manage auth state
- */
-export const {
-  loginStart,      // Start login process (set loading)
-  loginSuccess,    // Complete successful login
-  loginFailure,    // Handle login failure
-  logout,          // Clear authentication data
-  updateUser,      // Update user profile information
-} = authSlice.actions;
-
-/**
- * UI Actions Export
- * These actions can be dispatched from components to manage UI state
- */
-export const {
-  toggleSidebar,      // Toggle sidebar visibility
-  setSidebarOpen,     // Set sidebar open/closed state
-  setTheme,           // Switch application theme
-  addNotification,    // Add notification to queue
-  removeNotification, // Remove specific notification
-  clearNotifications, // Clear all notifications
+import { configureStore } from '@reduxjs/toolkit';
+import { persistStore, persistReducer } from 'redux-persist';
+import storage from 'redux-persist/lib/storage';
+import { combineReducers } from '@reduxjs/toolkit';
+
+// Auth slice
+import { createSlice, PayloadAction } from '@reduxjs/toolkit';
+import { User } from '../types';
+
+/**
+ * Authentication State Interface
+ * Defines the structure of authentication-related state
+ */
+interface AuthState {
+  user: User | null;           // Current authenticated user data
+  token: string | null;        // JWT authentication token
+  isAuthenticated: boolean;    // Authentication status flag
+  loading: boolean;            // Loading state for auth operations
+}
+
+/**
+ * Initial Authentication State
+ * Default values when the app starts
+ */
+const initialAuthState: AuthState = {
+  user: null,
+  token: null,
+  isAuthenticated: false,
+  loading: false,
+};
+
+/**
+ * Authentication Redux Slice
+ * Manages user authentication state and actions
+ * 
+ * Actions:
+ * - loginStart: Sets loading state when login begins
+ * - loginSuccess: Stores user data and token on successful login
+ * - loginFailure: Clears auth data on login failure
+ * - logout: Clears all authentication data
+ * - updateUser: Updates current user information
+ */
+const authSlice = createSlice({
+  name: 'auth',
+  initialState: initialAuthState,
+  reducers: {
+    // Set loading state when login process starts
+    loginStart: (state) => {
+      state.loading = true;
+    },
+    // Handle successful login - store user data and token
+    loginSuccess: (state, action: PayloadAction<{ user: User; token: string }>) => {
+      state.loading = false;
+      state.user = action.payload.user;
+      state.token = action.payload.token;
+      state.isAuthenticated = true;
+    },
+    // Handle login failure - clear authentication data
+    loginFailure: (state) => {
+      state.loading = false;
+      state.user = null;
+      state.token = null;
+      state.isAuthenticated = false;
+    },
+    // Handle logout - reset to initial state
+    logout: (state) => {
+      state.user = null;
+      state.token = null;
+      state.isAuthenticated = false;
+      state.loading = false;
+    },
+    // Update user profile information
+    updateUser: (state, action: PayloadAction<User>) => {
+      state.user = action.payload;
+    },
+  },
+});
+
+/**
+ * User Interface State Interface
+ * Defines the structure of UI-related state
+ */
+interface UIState {
+  sidebarOpen: boolean;        // Sidebar visibility state
+  theme: 'light' | 'dark';    // Application theme preference
+  notifications: Array<{      // In-app notification system
+    id: string;               // Unique notification identifier
+    type: 'success' | 'error' | 'warning' | 'info'; // Notification type
+    message: string;          // Notification content
+    timestamp: string;        // When notification was created
+  }>;
+}
+
+/**
+ * Initial UI State
+ * Default values for user interface components
+ */
+const initialUIState: UIState = {
+  sidebarOpen: true,
+  theme: 'light',
+  notifications: [],
+};
+
+/**
+ * User Interface Redux Slice
+ * Manages application UI state and user preferences
+ * 
+ * Actions:
+ * - toggleSidebar: Toggle sidebar visibility
+ * - setSidebarOpen: Explicitly set sidebar open/closed state
+ * - setTheme: Switch between light/dark themes
+ * - addNotification: Add new notification to the queue
+ * - removeNotification: Remove notification by ID
+ */
+const uiSlice = createSlice({
+  name: 'ui',
+  initialState: initialUIState,
+  reducers: {
+    // Toggle sidebar open/closed state
+    toggleSidebar: (state) => {
+      state.sidebarOpen = !state.sidebarOpen;
+    },
+    // Explicitly set sidebar visibility
+    setSidebarOpen: (state, action: PayloadAction<boolean>) => {
+      state.sidebarOpen = action.payload;
+    },
+    // Set application theme (light/dark mode)
+    setTheme: (state, action: PayloadAction<'light' | 'dark'>) => {
+      state.theme = action.payload;
+    },
+    // Add new notification to the notification queue
+    addNotification: (state, action: PayloadAction<Omit<UIState['notifications'][0], 'id' | 'timestamp'>>) => {
+      const notification = {
+        ...action.payload,
+        id: Math.random().toString(36).substr(2, 9), // Generate unique ID
+        timestamp: new Date().toISOString(),
+      };
+      state.notifications.push(notification);
+    },
+    // Remove notification from queue by ID
+    removeNotification: (state, action: PayloadAction<string>) => {
+      state.notifications = state.notifications.filter(n => n.id !== action.payload);
+    },
+    // Clear all notifications from the queue
+    clearNotifications: (state) => {
+      state.notifications = [];
+    },
+  },
+});
+
+/**
+ * Root Reducer Configuration
+ * Combines all individual slice reducers into a single root reducer
+ * This allows multiple slices to work together in the Redux store
+ */
+const rootReducer = combineReducers({
+  auth: authSlice.reducer,  // Authentication state management
+  ui: uiSlice.reducer,      // User interface state management
+});
+
+/**
+ * Redux Persist Configuration
+ * Configures which parts of the Redux state should be persisted
+ * to localStorage between browser sessions
+ */
+const persistConfig = {
+  key: 'root',                    // Storage key in localStorage
+  storage,                        // Storage engine (localStorage)
+  whitelist: ['auth'],           // Only persist auth state (UI state resets on refresh)
+};
+
+// Create persisted reducer with the configuration
+const persistedReducer = persistReducer(persistConfig, rootReducer);
+
+/**
+ * Redux Store Configuration
+ * Creates the main Redux store with middleware and persistence
+ * 
+ * Features:
+ * - Redux Toolkit for modern Redux patterns
+ * - Redux Persist for state persistence
+ * - Custom middleware configuration for serialization
+ */
+export const store = configureStore({
+  reducer: persistedReducer,
+  middleware: (getDefaultMiddleware) =>
+    getDefaultMiddleware({
+      serializableCheck: {
+        // Ignore redux-persist actions that contain non-serializable values
+        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],
+      },
+    }),
+});
+
+/**
+ * Redux Persistor
+ * Creates the persistor instance for managing state persistence
+ */
+export const persistor = persistStore(store);
+
+/**
+ * TypeScript Types for Redux Store
+ * These types enable proper type checking throughout the application
+ */
+export type RootState = ReturnType<typeof store.getState>;  // Type for the entire Redux state
+export type AppDispatch = typeof store.dispatch;           // Type for the dispatch function
+
+/**
+ * Authentication Actions Export
+ * These actions can be dispatched from components to manage auth state
+ */
+export const {
+  loginStart,      // Start login process (set loading)
+  loginSuccess,    // Complete successful login
+  loginFailure,    // Handle login failure
+  logout,          // Clear authentication data
+  updateUser,      // Update user profile information
+} = authSlice.actions;
+
+/**
+ * UI Actions Export
+ * These actions can be dispatched from components to manage UI state
+ */
+export const {
+  toggleSidebar,      // Toggle sidebar visibility
+  setSidebarOpen,     // Set sidebar open/closed state
+  setTheme,           // Switch application theme
+  addNotification,    // Add notification to queue
+  removeNotification, // Remove specific notification
+  clearNotifications, // Clear all notifications
 } = uiSlice.actions;
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/src/types/index.ts b/event-monitoring-mvp/frontend/src/types/index.ts
index 4f3a24a..424eab6 100644
--- a/event-monitoring-mvp/frontend/src/types/index.ts
+++ b/event-monitoring-mvp/frontend/src/types/index.ts
@@ -1,324 +1,324 @@
-/**
- * Event Monitoring System - TypeScript Type Definitions
- * 
- * This file contains all the TypeScript interfaces and types used throughout
- * the Event Monitoring MVP application. These types ensure type safety and
- * provide clear contracts for data structures across frontend components.
- */
-
-/**
- * User Interface Type
- * Represents a system user with authentication and role-based access
- * 
- * @interface User
- * @property {string} _id - Unique MongoDB ObjectId for the user
- * @property {string} username - Unique username for login
- * @property {string} email - User's email address
- * @property {string} role - User's role determining permissions ('admin' | 'operator')
- * @property {boolean} isActive - Whether the user account is active
- * @property {string} [lastLogin] - ISO timestamp of last successful login (optional)
- * @property {string} createdAt - ISO timestamp when user was created
- * @property {string} updatedAt - ISO timestamp when user was last modified
- */
-export interface User {
-  _id: string;
-  username: string;
-  email: string;
-  role: 'admin' | 'operator';
-  isActive: boolean;
-  lastLogin?: string;
-  createdAt: string;
-  updatedAt: string;
-}
-
-/**
- * Camera Interface Type
- * Represents a camera device in the monitoring system
- * 
- * @interface Camera
- * @property {string} _id - Unique MongoDB ObjectId for the camera
- * @property {string} name - Human-readable name for the camera
- * @property {string} [description] - Optional description of camera placement/purpose
- * @property {string} streamUrl - URL for accessing the camera's video stream
- * @property {Object} location - Geographic location data
- * @property {[number, number]} location.coordinates - [longitude, latitude] coordinates
- * @property {string} [location.address] - Human-readable address (optional)
- * @property {string} status - Current operational status of the camera
- * @property {string} type - Type of camera hardware connection
- * @property {Object} settings - Camera configuration settings
- * @property {string} settings.resolution - Video resolution (e.g., "1920x1080")
- * @property {number} settings.fps - Frames per second for video capture
- * @property {boolean} settings.recordingEnabled - Whether continuous recording is enabled
- * @property {boolean} isActive - Whether the camera is active in the system
- * @property {string} createdBy - User ID who created this camera entry
- * @property {string} createdAt - ISO timestamp when camera was added
- * @property {string} updatedAt - ISO timestamp when camera was last modified
- */
-export interface Camera {
-  _id: string;
-  name: string;
-  description?: string;
-  streamUrl: string;
-  location: {
-    coordinates: [number, number]; // [longitude, latitude]
-    address?: string;
-  };
-  status: 'online' | 'offline' | 'maintenance';
-  type: 'ip' | 'analog' | 'usb';
-  settings: {
-    resolution: string;
-    fps: number;
-    recordingEnabled: boolean;
-  };
-  isActive: boolean;
-  createdBy: string;
-  createdAt: string;
-  updatedAt: string;
-}
-
-/**
- * Event Interface Type
- * Represents a security event detected by the AI monitoring system
- * 
- * @interface Event
- * @property {string} _id - Unique MongoDB ObjectId for the event
- * @property {string} title - Brief title describing the event
- * @property {string} [description] - Optional detailed description
- * @property {string} type - Category of event detected by AI
- * @property {string} severity - Priority level for response planning
- * @property {string} status - Current investigation/response status
- * @property {string} cameraId - ID of camera that captured this event
- * @property {Object} location - Geographic location where event occurred
- * @property {[number, number]} location.coordinates - [longitude, latitude] coordinates
- * @property {string} [location.address] - Human-readable address (optional)
- * @property {Object} detectionData - AI detection metadata
- * @property {number} detectionData.confidence - AI confidence score (0-1)
- */
-export interface Event {
-  _id: string;
-  title: string;
-  description?: string;
-  type: 'person_detected' | 'vehicle_detected' | 'motion_detected' | 'unauthorized_access' | 'other';
-  severity: 'low' | 'medium' | 'high' | 'critical';
-  status: 'open' | 'acknowledged' | 'investigating' | 'resolved' | 'closed';
-  cameraId: string;
-  location: {
-    coordinates: [number, number];
-    address?: string;
-  };
-  detectionData: {
-    confidence: number;               // AI confidence score (0.0 to 1.0)
-    boundingBox?: {                  // Object detection bounding box (optional)
-      x: number;                     // X coordinate of top-left corner
-      y: number;                     // Y coordinate of top-left corner  
-      width: number;                 // Width of bounding box
-      height: number;                // Height of bounding box
-    };
-    objectCount?: number;            // Number of objects detected (optional)
-    aiModel?: string;                // AI model used for detection (optional)
-  };
-  media?: {                          // Associated media files (optional)
-    imageUrl?: string;               // URL to captured image
-    videoUrl?: string;               // URL to captured video clip
-    thumbnailUrl?: string;           // URL to thumbnail image
-  };
-  assignedTo?: string;               // User ID assigned to handle this event (optional)
-  acknowledgedBy?: string;           // User ID who acknowledged the event (optional)
-  acknowledgedAt?: string;           // ISO timestamp when event was acknowledged (optional)
-  resolvedBy?: string;               // User ID who resolved the event (optional)
-  resolvedAt?: string;               // ISO timestamp when event was resolved (optional)
-  notes: Array<{                     // Investigation notes array
-    content: string;                 // Note content
-    createdBy: string;               // User ID who created the note
-    createdAt: string;               // ISO timestamp when note was created
-  }>;
-  tags: string[];                    // Array of tags for categorization
-  createdAt: string;                 // ISO timestamp when event was created
-  updatedAt: string;                 // ISO timestamp when event was last updated
-}
-
-/**
- * API Response Types
- * Standard response formats for all API endpoints
- */
-
-/**
- * Generic API Response
- * Standard wrapper for all API responses
- * 
- * @interface ApiResponse
- * @template T - Type of data being returned
- * @property {boolean} success - Whether the operation was successful
- * @property {string} [message] - Optional human-readable message
- * @property {T} [data] - Response data (optional, type varies)
- * @property {string} [error] - Error message if operation failed (optional)
- */
-export interface ApiResponse<T = any> {
-  success: boolean;
-  message?: string;
-  data?: T;
-  error?: string;
-}
-
-/**
- * Paginated API Response
- * For endpoints that return paginated results
- * 
- * @interface PaginatedResponse
- * @template T - Type of items in the paginated array
- * @extends ApiResponse<T[]>
- * @property {Object} pagination - Pagination metadata
- * @property {number} pagination.page - Current page number (1-based)
- * @property {number} pagination.limit - Items per page
- * @property {number} pagination.total - Total number of items
- * @property {number} pagination.pages - Total number of pages
- */
-export interface PaginatedResponse<T> extends ApiResponse<T[]> {
-  pagination: {
-    page: number;
-    limit: number;
-    total: number;
-    pages: number;
-  };
-}
-
-/**
- * Authentication Types
- * Types related to user authentication and registration
- */
-
-/**
- * Login Request
- * Data structure for user login requests
- * 
- * @interface LoginRequest
- * @property {string} email - User's email address
- * @property {string} password - User's password
- */
-export interface LoginRequest {
-  email: string;
-  password: string;
-}
-
-/**
- * Registration Request
- * Data structure for new user registration
- * 
- * @interface RegisterRequest
- * @property {string} username - Desired username
- * @property {string} email - User's email address
- * @property {string} password - User's password
- * @property {string} [role] - Optional role assignment (defaults to 'operator')
- */
-export interface RegisterRequest {
-  username: string;
-  email: string;
-  password: string;
-  role?: 'admin' | 'operator';
-}
-
-/**
- * Authentication Response
- * Response data after successful login/registration
- * 
- * @interface AuthResponse
- * @property {string} token - JWT authentication token
- * @property {User} user - Complete user data object
- */
-export interface AuthResponse {
-  token: string;
-  user: User;
-}
-
-/**
- * Form Types
- * Types for form data structures used in the UI
- */
-
-/**
- * Camera Form Data
- * Form structure for creating/editing cameras
- * 
- * @interface CameraForm
- * @property {string} name - Camera name
- * @property {string} [description] - Optional description
- * @property {string} streamUrl - Video stream URL
- * @property {Object} location - Geographic location
- */
-export interface CameraForm {
-  name: string;
-  description?: string;
-  streamUrl: string;
-  location: {
-    coordinates: [number, number];   // [longitude, latitude]
-    address?: string;                // Optional human-readable address
-  };
-  type: 'ip' | 'analog' | 'usb';    // Camera connection type
-  settings: {
-    resolution: string;              // Video resolution (e.g., "1920x1080")
-    fps: number;                     // Frames per second
-    recordingEnabled: boolean;       // Whether continuous recording is enabled
-  };
-}
-
-/**
- * Event Filters
- * Filter criteria for querying events
- * 
- * @interface EventFilters
- * @property {string} [status] - Filter by event status (optional)
- * @property {string} [type] - Filter by event type (optional)
- * @property {string} [severity] - Filter by severity level (optional)
- * @property {string} [cameraId] - Filter by specific camera (optional)
- * @property {string} [startDate] - Filter events from this date (optional, ISO string)
- * @property {string} [endDate] - Filter events until this date (optional, ISO string)
- * @property {number} [page] - Page number for pagination (optional)
- * @property {number} [limit] - Items per page for pagination (optional)
- */
-export interface EventFilters {
-  status?: string;
-  type?: string;
-  severity?: string;
-  cameraId?: string;
-  startDate?: string;
-  endDate?: string;
-  page?: number;
-  limit?: number;
-}
-
-/**
- * Map and Geographic Types
- * Types related to map visualization and geographic data
- */
-
-/**
- * Map Viewport Configuration
- * Defines the current view state of the map
- * 
- * @interface MapViewport
- * @property {number} latitude - Center latitude of the map view
- * @property {number} longitude - Center longitude of the map view
- * @property {number} zoom - Zoom level of the map (higher = more zoomed in)
- */
-export interface MapViewport {
-  latitude: number;
-  longitude: number;
-  zoom: number;
-}
-
-/**
- * Map Marker Data
- * Represents a marker (camera or event) displayed on the map
- * 
- * @interface MarkerData
- * @property {string} id - Unique identifier for the marker
- * @property {[number, number]} coordinates - [longitude, latitude] position
- * @property {string} type - Type of marker ('camera' for cameras, 'event' for events)
- * @property {Camera | Event} data - Associated data object (Camera or Event)
- */
-export interface MarkerData {
-  id: string;
-  coordinates: [number, number];
-  type: 'camera' | 'event';
-  data: Camera | Event;
+/**
+ * Event Monitoring System - TypeScript Type Definitions
+ * 
+ * This file contains all the TypeScript interfaces and types used throughout
+ * the Event Monitoring MVP application. These types ensure type safety and
+ * provide clear contracts for data structures across frontend components.
+ */
+
+/**
+ * User Interface Type
+ * Represents a system user with authentication and role-based access
+ * 
+ * @interface User
+ * @property {string} _id - Unique MongoDB ObjectId for the user
+ * @property {string} username - Unique username for login
+ * @property {string} email - User's email address
+ * @property {string} role - User's role determining permissions ('admin' | 'operator')
+ * @property {boolean} isActive - Whether the user account is active
+ * @property {string} [lastLogin] - ISO timestamp of last successful login (optional)
+ * @property {string} createdAt - ISO timestamp when user was created
+ * @property {string} updatedAt - ISO timestamp when user was last modified
+ */
+export interface User {
+  _id: string;
+  username: string;
+  email: string;
+  role: 'admin' | 'operator';
+  isActive: boolean;
+  lastLogin?: string;
+  createdAt: string;
+  updatedAt: string;
+}
+
+/**
+ * Camera Interface Type
+ * Represents a camera device in the monitoring system
+ * 
+ * @interface Camera
+ * @property {string} _id - Unique MongoDB ObjectId for the camera
+ * @property {string} name - Human-readable name for the camera
+ * @property {string} [description] - Optional description of camera placement/purpose
+ * @property {string} streamUrl - URL for accessing the camera's video stream
+ * @property {Object} location - Geographic location data
+ * @property {[number, number]} location.coordinates - [longitude, latitude] coordinates
+ * @property {string} [location.address] - Human-readable address (optional)
+ * @property {string} status - Current operational status of the camera
+ * @property {string} type - Type of camera hardware connection
+ * @property {Object} settings - Camera configuration settings
+ * @property {string} settings.resolution - Video resolution (e.g., "1920x1080")
+ * @property {number} settings.fps - Frames per second for video capture
+ * @property {boolean} settings.recordingEnabled - Whether continuous recording is enabled
+ * @property {boolean} isActive - Whether the camera is active in the system
+ * @property {string} createdBy - User ID who created this camera entry
+ * @property {string} createdAt - ISO timestamp when camera was added
+ * @property {string} updatedAt - ISO timestamp when camera was last modified
+ */
+export interface Camera {
+  _id: string;
+  name: string;
+  description?: string;
+  streamUrl: string;
+  location: {
+    coordinates: [number, number]; // [longitude, latitude]
+    address?: string;
+  };
+  status: 'online' | 'offline' | 'maintenance';
+  type: 'ip' | 'analog' | 'usb';
+  settings: {
+    resolution: string;
+    fps: number;
+    recordingEnabled: boolean;
+  };
+  isActive: boolean;
+  createdBy: string;
+  createdAt: string;
+  updatedAt: string;
+}
+
+/**
+ * Event Interface Type
+ * Represents a security event detected by the AI monitoring system
+ * 
+ * @interface Event
+ * @property {string} _id - Unique MongoDB ObjectId for the event
+ * @property {string} title - Brief title describing the event
+ * @property {string} [description] - Optional detailed description
+ * @property {string} type - Category of event detected by AI
+ * @property {string} severity - Priority level for response planning
+ * @property {string} status - Current investigation/response status
+ * @property {string} cameraId - ID of camera that captured this event
+ * @property {Object} location - Geographic location where event occurred
+ * @property {[number, number]} location.coordinates - [longitude, latitude] coordinates
+ * @property {string} [location.address] - Human-readable address (optional)
+ * @property {Object} detectionData - AI detection metadata
+ * @property {number} detectionData.confidence - AI confidence score (0-1)
+ */
+export interface Event {
+  _id: string;
+  title: string;
+  description?: string;
+  type: 'person_detected' | 'vehicle_detected' | 'motion_detected' | 'unauthorized_access' | 'other';
+  severity: 'low' | 'medium' | 'high' | 'critical';
+  status: 'open' | 'acknowledged' | 'investigating' | 'resolved' | 'closed';
+  cameraId: string;
+  location: {
+    coordinates: [number, number];
+    address?: string;
+  };
+  detectionData: {
+    confidence: number;               // AI confidence score (0.0 to 1.0)
+    boundingBox?: {                  // Object detection bounding box (optional)
+      x: number;                     // X coordinate of top-left corner
+      y: number;                     // Y coordinate of top-left corner  
+      width: number;                 // Width of bounding box
+      height: number;                // Height of bounding box
+    };
+    objectCount?: number;            // Number of objects detected (optional)
+    aiModel?: string;                // AI model used for detection (optional)
+  };
+  media?: {                          // Associated media files (optional)
+    imageUrl?: string;               // URL to captured image
+    videoUrl?: string;               // URL to captured video clip
+    thumbnailUrl?: string;           // URL to thumbnail image
+  };
+  assignedTo?: string;               // User ID assigned to handle this event (optional)
+  acknowledgedBy?: string;           // User ID who acknowledged the event (optional)
+  acknowledgedAt?: string;           // ISO timestamp when event was acknowledged (optional)
+  resolvedBy?: string;               // User ID who resolved the event (optional)
+  resolvedAt?: string;               // ISO timestamp when event was resolved (optional)
+  notes: Array<{                     // Investigation notes array
+    content: string;                 // Note content
+    createdBy: string;               // User ID who created the note
+    createdAt: string;               // ISO timestamp when note was created
+  }>;
+  tags: string[];                    // Array of tags for categorization
+  createdAt: string;                 // ISO timestamp when event was created
+  updatedAt: string;                 // ISO timestamp when event was last updated
+}
+
+/**
+ * API Response Types
+ * Standard response formats for all API endpoints
+ */
+
+/**
+ * Generic API Response
+ * Standard wrapper for all API responses
+ * 
+ * @interface ApiResponse
+ * @template T - Type of data being returned
+ * @property {boolean} success - Whether the operation was successful
+ * @property {string} [message] - Optional human-readable message
+ * @property {T} [data] - Response data (optional, type varies)
+ * @property {string} [error] - Error message if operation failed (optional)
+ */
+export interface ApiResponse<T = any> {
+  success: boolean;
+  message?: string;
+  data?: T;
+  error?: string;
+}
+
+/**
+ * Paginated API Response
+ * For endpoints that return paginated results
+ * 
+ * @interface PaginatedResponse
+ * @template T - Type of items in the paginated array
+ * @extends ApiResponse<T[]>
+ * @property {Object} pagination - Pagination metadata
+ * @property {number} pagination.page - Current page number (1-based)
+ * @property {number} pagination.limit - Items per page
+ * @property {number} pagination.total - Total number of items
+ * @property {number} pagination.pages - Total number of pages
+ */
+export interface PaginatedResponse<T> extends ApiResponse<T[]> {
+  pagination: {
+    page: number;
+    limit: number;
+    total: number;
+    pages: number;
+  };
+}
+
+/**
+ * Authentication Types
+ * Types related to user authentication and registration
+ */
+
+/**
+ * Login Request
+ * Data structure for user login requests
+ * 
+ * @interface LoginRequest
+ * @property {string} email - User's email address
+ * @property {string} password - User's password
+ */
+export interface LoginRequest {
+  email: string;
+  password: string;
+}
+
+/**
+ * Registration Request
+ * Data structure for new user registration
+ * 
+ * @interface RegisterRequest
+ * @property {string} username - Desired username
+ * @property {string} email - User's email address
+ * @property {string} password - User's password
+ * @property {string} [role] - Optional role assignment (defaults to 'operator')
+ */
+export interface RegisterRequest {
+  username: string;
+  email: string;
+  password: string;
+  role?: 'admin' | 'operator';
+}
+
+/**
+ * Authentication Response
+ * Response data after successful login/registration
+ * 
+ * @interface AuthResponse
+ * @property {string} token - JWT authentication token
+ * @property {User} user - Complete user data object
+ */
+export interface AuthResponse {
+  token: string;
+  user: User;
+}
+
+/**
+ * Form Types
+ * Types for form data structures used in the UI
+ */
+
+/**
+ * Camera Form Data
+ * Form structure for creating/editing cameras
+ * 
+ * @interface CameraForm
+ * @property {string} name - Camera name
+ * @property {string} [description] - Optional description
+ * @property {string} streamUrl - Video stream URL
+ * @property {Object} location - Geographic location
+ */
+export interface CameraForm {
+  name: string;
+  description?: string;
+  streamUrl: string;
+  location: {
+    coordinates: [number, number];   // [longitude, latitude]
+    address?: string;                // Optional human-readable address
+  };
+  type: 'ip' | 'analog' | 'usb';    // Camera connection type
+  settings: {
+    resolution: string;              // Video resolution (e.g., "1920x1080")
+    fps: number;                     // Frames per second
+    recordingEnabled: boolean;       // Whether continuous recording is enabled
+  };
+}
+
+/**
+ * Event Filters
+ * Filter criteria for querying events
+ * 
+ * @interface EventFilters
+ * @property {string} [status] - Filter by event status (optional)
+ * @property {string} [type] - Filter by event type (optional)
+ * @property {string} [severity] - Filter by severity level (optional)
+ * @property {string} [cameraId] - Filter by specific camera (optional)
+ * @property {string} [startDate] - Filter events from this date (optional, ISO string)
+ * @property {string} [endDate] - Filter events until this date (optional, ISO string)
+ * @property {number} [page] - Page number for pagination (optional)
+ * @property {number} [limit] - Items per page for pagination (optional)
+ */
+export interface EventFilters {
+  status?: string;
+  type?: string;
+  severity?: string;
+  cameraId?: string;
+  startDate?: string;
+  endDate?: string;
+  page?: number;
+  limit?: number;
+}
+
+/**
+ * Map and Geographic Types
+ * Types related to map visualization and geographic data
+ */
+
+/**
+ * Map Viewport Configuration
+ * Defines the current view state of the map
+ * 
+ * @interface MapViewport
+ * @property {number} latitude - Center latitude of the map view
+ * @property {number} longitude - Center longitude of the map view
+ * @property {number} zoom - Zoom level of the map (higher = more zoomed in)
+ */
+export interface MapViewport {
+  latitude: number;
+  longitude: number;
+  zoom: number;
+}
+
+/**
+ * Map Marker Data
+ * Represents a marker (camera or event) displayed on the map
+ * 
+ * @interface MarkerData
+ * @property {string} id - Unique identifier for the marker
+ * @property {[number, number]} coordinates - [longitude, latitude] position
+ * @property {string} type - Type of marker ('camera' for cameras, 'event' for events)
+ * @property {Camera | Event} data - Associated data object (Camera or Event)
+ */
+export interface MarkerData {
+  id: string;
+  coordinates: [number, number];
+  type: 'camera' | 'event';
+  data: Camera | Event;
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp/frontend/tsconfig.json b/event-monitoring-mvp/frontend/tsconfig.json
index 570171e..d461f18 100644
--- a/event-monitoring-mvp/frontend/tsconfig.json
+++ b/event-monitoring-mvp/frontend/tsconfig.json
@@ -1,30 +1,30 @@
-{
-  "compilerOptions": {
-    "target": "ES2020",
-    "lib": [
-      "dom",
-      "dom.iterable",
-      "ES6"
-    ],
-    "allowJs": true,
-    "skipLibCheck": true,
-    "esModuleInterop": true,
-    "allowSyntheticDefaultImports": true,
-    "strict": true,
-    "forceConsistentCasingInFileNames": true,
-    "noFallthroughCasesInSwitch": true,
-    "module": "esnext",
-    "moduleResolution": "node",
-    "resolveJsonModule": true,
-    "isolatedModules": true,
-    "noEmit": true,
-    "jsx": "react-jsx"
-  },
-  "include": [
-    "src"
-  ],
-  "exclude": [
-    "node_modules",
-    "build"
-  ]
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "lib": [
+      "dom",
+      "dom.iterable",
+      "ES6"
+    ],
+    "allowJs": true,
+    "skipLibCheck": true,
+    "esModuleInterop": true,
+    "allowSyntheticDefaultImports": true,
+    "strict": true,
+    "forceConsistentCasingInFileNames": true,
+    "noFallthroughCasesInSwitch": true,
+    "module": "esnext",
+    "moduleResolution": "node",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "noEmit": true,
+    "jsx": "react-jsx"
+  },
+  "include": [
+    "src"
+  ],
+  "exclude": [
+    "node_modules",
+    "build"
+  ]
 }
\ No newline at end of file
diff --git a/event-monitoring-mvp/scripts/README.md b/event-monitoring-mvp/scripts/README.md
index 5315a7c..43d4704 100644
--- a/event-monitoring-mvp/scripts/README.md
+++ b/event-monitoring-mvp/scripts/README.md
@@ -1,41 +1,141 @@
-# Database Scripts
-
-This directory contains utility scripts for database management and seeding.
-
-## Available Scripts
-
-### `seed-database.sh`
-Populates the database with default users, sample cameras, and events for development.
-
-**Usage:**
-```bash
-# Make script executable
-chmod +x scripts/seed-database.sh
-
-# Run seeding
-./scripts/seed-database.sh
-```
-
-**What it creates:**
-- Admin user: `admin@example.com` / `password123`
-- Operator user: `operator@example.com` / `password123`
-- 2 sample cameras (Front Entrance, Parking Lot)
-- 2 sample events (Motion Detection, Vehicle Intrusion)
-
-### Quick MongoDB Commands
-
-```bash
-# Connect to database
-docker exec -it event-monitoring-mongodb mongosh --username admin --password password123 --authenticationDatabase admin
-
-# Check collections
-use event_monitoring
-show collections
-db.users.find().pretty()
-db.cameras.find().pretty()
-db.events.find().pretty()
-
-# Reset database (DANGER!)
-use event_monitoring
-db.dropDatabase()
-```
\ No newline at end of file
+# Database Scripts
+
+This directory contains all database management scripts for the Event Monitoring MVP.
+ 
+## ğŸš€ Quick Setup
+
+```bash
+# Complete database setup (recommended)
+node scripts/setup-database.js
+```
+
+This single script handles:
+- âœ… Database initialization and indexes
+- âœ… Default EventTypes for mobile integration
+- âœ… Default permissions
+- âœ… Web application users (operators/admins)
+
+**Note**: Mobile users authenticate through their own app - not stored in this database.
+
+## ğŸ“‹ Available Scripts
+
+### `setup-database.js` (Main Script)
+**Purpose**: Complete database setup and user creation  
+**When to use**: Initial setup or reset
+
+```bash
+# Prerequisites: Backend must be running
+cd backend && npm run dev
+
+# In another terminal:
+node scripts/setup-database.js
+```
+
+**What it creates**:
+- Collections: `users`, `cameras`, `events`, `eventtypes`, `permissions`
+- Indexes for optimal performance
+- Default EventTypes for mobile team
+- Web users: admin, operator1, mobile_admin
+
+### `migrate-to-new-schema.js`
+**Purpose**: Migrate existing data to new schema  
+**When to use**: Upgrading from old version
+
+```bash
+node scripts/migrate-to-new-schema.js
+```
+
+## ğŸ—‚ï¸ Manual Database Operations
+
+### Connect to MongoDB
+```bash
+# Local MongoDB
+mongosh mongodb://localhost:27017/event_monitoring
+
+# Docker MongoDB (if using docker-compose)
+docker exec -it mongodb mongosh -u admin -p password123
+```
+
+### Check Data
+```javascript
+// Switch to database
+use event_monitoring
+
+// View collections
+show collections
+
+// Check users
+db.users.find().pretty()
+
+// Check EventTypes
+db.eventtypes.find().pretty()
+
+// Check recent events
+db.events.find().sort({createdAt: -1}).limit(5).pretty()
+```
+
+### Reset Database (âš ï¸ DANGER)
+```javascript
+// This will delete ALL data!
+use event_monitoring
+db.dropDatabase()
+```
+
+## ğŸ”§ Troubleshooting
+
+### "Backend not running" error
+```bash
+# Start backend first
+cd backend
+npm run dev
+
+# Wait for "Server running on port 5000"
+# Then run database setup
+node scripts/setup-database.js
+```
+
+### "User already exists" warnings
+This is normal - the script detects existing users and skips them.
+
+### MongoDB connection issues
+```bash
+# Check MongoDB status
+sudo systemctl status mongod
+
+# Start MongoDB if stopped
+sudo systemctl start mongod
+
+# Check if port 27017 is in use
+sudo netstat -tlnp | grep :27017
+```
+
+## ğŸ“± Mobile Team Integration
+
+The database setup creates EventTypes that mobile team can use:
+
+```bash
+# Get available EventTypes for mobile app
+curl http://localhost:5000/api/mobile/events/types
+
+# Mobile admin can manage EventTypes via:
+# POST /api/event-types (create)
+# PUT /api/event-types/:id (update) 
+# GET /api/event-types (list)
+```
+
+## ğŸ—ï¸ Database Schema Overview
+
+```
+event_monitoring/
+â”œâ”€â”€ users/          # Web app users (operators, admins)
+â”œâ”€â”€ cameras/        # Security cameras
+â”œâ”€â”€ events/         # Events from mobile + cameras
+â”œâ”€â”€ eventtypes/     # Dynamic event categories
+â””â”€â”€ permissions/    # Granular access control
+```
+
+**Mobile Integration**: 
+- Mobile users authenticate in their own app
+- Mobile app gets EventTypes from `/api/mobile/events/types`
+- Mobile app submits events to `/api/mobile/events`
+- Your system only stores the events, not mobile user credentials
\ No newline at end of file
diff --git a/event-monitoring-mvp/scripts/migrate-to-new-schema.js b/event-monitoring-mvp/scripts/migrate-to-new-schema.js
new file mode 100644
index 0000000..8f45da6
--- /dev/null
+++ b/event-monitoring-mvp/scripts/migrate-to-new-schema.js
@@ -0,0 +1,261 @@
+#!/usr/bin/env node
+ 
+const { MongoClient, ObjectId } = require('mongodb');
+const bcrypt = require('bcrypt');
+
+const MONGO_URL = process.env.MONGO_URL || 'mongodb://localhost:27017';
+const DB_NAME = 'event_monitoring';
+
+async function runMigration() {
+  const client = new MongoClient(MONGO_URL);
+  
+  try {
+    console.log('ğŸ”„ Connecting to MongoDB...');
+    await client.connect();
+    const db = client.db(DB_NAME);
+    
+    console.log('ğŸ“Š Starting database migration to new schema...\n');
+
+    // 1. Migrate Users Collection
+    console.log('ğŸ‘¤ Migrating users...');
+    const users = db.collection('users');
+    const userDocs = await users.find({}).toArray();
+    
+    for (const user of userDocs) {
+      const updates = {};
+      
+      // Convert old role field to roles array
+      if (user.role && !user.roles) {
+        updates.roles = [user.role];
+        updates.$unset = { role: 1 };
+      }
+      
+      // Add default authMethod if missing
+      if (!user.authMethod) {
+        updates.authMethod = user.email ? 'email' : 'phone';
+      }
+      
+      // Add default profile if missing
+      if (!user.profile) {
+        updates.profile = {
+          firstName: user.firstName || user.username || 'User',
+          lastName: user.lastName || ''
+        };
+      }
+      
+      // Add default permissions based on role
+      if (!user.permissions && user.role) {
+        updates.permissions = getDefaultPermissions(user.role);
+      }
+      
+      // Add missing boolean fields
+      if (user.isEmailVerified === undefined) {
+        updates.isEmailVerified = !!user.email;
+      }
+      if (user.isPhoneVerified === undefined) {
+        updates.isPhoneVerified = !!user.phone;
+      }
+      if (user.isActive === undefined) {
+        updates.isActive = true;
+      }
+      
+      // Apply updates if any
+      if (Object.keys(updates).length > 0) {
+        await users.updateOne({ _id: user._id }, { $set: updates, ...(updates.$unset ? { $unset: updates.$unset } : {}) });
+        console.log(`  âœ… Updated user: ${user.email || user.username || user.phone}`);
+      }
+    }
+    
+    // 2. Create EventTypes Collection
+    console.log('\nğŸ·ï¸  Creating default EventTypes...');
+    const eventTypes = db.collection('eventtypes');
+    const existingEventTypes = await eventTypes.countDocuments();
+    
+    if (existingEventTypes === 0) {
+      const defaultEventTypes = [
+        {
+          _id: new ObjectId(),
+          name: 'Security Incidents',
+          category: 'security',
+          description: 'Security-related events and incidents',
+          isPublic: true,
+          isActive: true,
+          order: 1,
+          allowedRoles: ['citizen', 'operator', 'admin'],
+          fields: [
+            { name: 'severity', type: 'select', options: ['low', 'medium', 'high', 'critical'], required: true },
+            { name: 'description', type: 'textarea', required: true }
+          ],
+          createdAt: new Date(),
+          updatedAt: new Date()
+        },
+        {
+          _id: new ObjectId(),
+          name: 'Infrastructure Issues',
+          category: 'infrastructure',
+          description: 'Infrastructure and maintenance issues',
+          isPublic: true,
+          isActive: true,
+          order: 2,
+          allowedRoles: ['citizen', 'operator', 'admin'],
+          fields: [
+            { name: 'urgency', type: 'select', options: ['low', 'medium', 'high'], required: true },
+            { name: 'location', type: 'text', required: true }
+          ],
+          createdAt: new Date(),
+          updatedAt: new Date()
+        }
+      ];
+      
+      await eventTypes.insertMany(defaultEventTypes);
+      console.log(`  âœ… Created ${defaultEventTypes.length} default EventTypes`);
+    }
+    
+    // 3. Migrate Events Collection
+    console.log('\nğŸ“… Migrating events...');
+    const events = db.collection('events');
+    const eventDocs = await events.find({}).toArray();
+    
+    // Get EventTypes for mapping
+    const eventTypesMap = {};
+    const eventTypesList = await eventTypes.find({}).toArray();
+    eventTypesList.forEach(et => {
+      eventTypesMap[et.name.toLowerCase()] = et._id;
+      eventTypesMap[et.category] = et._id;
+    });
+    
+    for (const event of eventDocs) {
+      const updates = {};
+      
+      // Map legacy type field to eventType reference
+      if (event.type && !event.eventType) {
+        const typeKey = event.type.toLowerCase();
+        const mappedEventType = eventTypesMap[typeKey] || eventTypesMap['security incidents'];
+        
+        if (mappedEventType) {
+          updates.eventType = mappedEventType;
+          // Cache EventType details for performance
+          const eventTypeDoc = eventTypesList.find(et => et._id.equals(mappedEventType));
+          if (eventTypeDoc) {
+            updates.eventTypeName = eventTypeDoc.name;
+            updates.eventTypeCategory = eventTypeDoc.category;
+          }
+        }
+      }
+      
+      // Add missing fields
+      if (!event.isAnonymous) {
+        updates.isAnonymous = false;
+      }
+      
+      // Ensure submittedBy exists for non-anonymous events
+      if (!event.submittedBy && !event.isAnonymous && event.createdBy) {
+        updates.submittedBy = event.createdBy;
+      }
+      
+      // Apply updates if any
+      if (Object.keys(updates).length > 0) {
+        await events.updateOne({ _id: event._id }, { $set: updates });
+        console.log(`  âœ… Updated event: ${event._id}`);
+      }
+    }
+    
+    // 4. Create Permissions Collection
+    console.log('\nğŸ” Creating default permissions...');
+    const permissions = db.collection('permissions');
+    const existingPermissions = await permissions.countDocuments();
+    
+    if (existingPermissions === 0) {
+      const defaultPermissions = [
+        { resource: '*', action: '*', description: 'Full system access', createdAt: new Date() },
+        { resource: 'events', action: 'read', description: 'View events', createdAt: new Date() },
+        { resource: 'events', action: 'create', description: 'Submit events', createdAt: new Date() },
+        { resource: 'events', action: 'update', description: 'Update event status', createdAt: new Date() },
+        { resource: 'cameras', action: 'read', description: 'View cameras', createdAt: new Date() },
+        { resource: 'cameras', action: 'manage', description: 'Manage cameras', createdAt: new Date() },
+        { resource: 'event-types', action: 'manage', description: 'Manage event types', createdAt: new Date() },
+        { resource: 'users', action: 'read', description: 'View users', createdAt: new Date() },
+        { resource: 'users', action: 'manage', description: 'Manage users', createdAt: new Date() }
+      ];
+      
+      await permissions.insertMany(defaultPermissions);
+      console.log(`  âœ… Created ${defaultPermissions.length} default permissions`);
+    }
+    
+    // 5. Create Indexes
+    console.log('\nğŸ“‡ Creating indexes...');
+    
+    // User indexes (enhanced)
+    await users.createIndex({ "email": 1 }, { unique: true, sparse: true });
+    await users.createIndex({ "phone": 1 }, { unique: true, sparse: true });
+    await users.createIndex({ "username": 1 }, { unique: true, sparse: true });
+    await users.createIndex({ "roles": 1 });
+    
+    // EventType indexes
+    await eventTypes.createIndex({ "name": 1, "isActive": 1 });
+    await eventTypes.createIndex({ "category": 1 });
+    
+    // Enhanced Event indexes
+    await events.createIndex({ "eventType": 1 });
+    await events.createIndex({ "submittedBy": 1 });
+    await events.createIndex({ "isAnonymous": 1 });
+    
+    // Permission indexes
+    await permissions.createIndex({ "resource": 1, "action": 1 });
+    
+    console.log('  âœ… Indexes created');
+    
+    console.log('\nğŸ‰ Migration completed successfully!');
+    console.log('\nğŸ“Š Summary:');
+    console.log(`   Users: ${userDocs.length} migrated`);
+    console.log(`   Events: ${eventDocs.length} migrated`);
+    console.log(`   EventTypes: ${eventTypesList.length} available`);
+    console.log(`   Permissions: ${(await permissions.countDocuments())} available`);
+    
+    console.log('\nğŸ”§ Next steps:');
+    console.log('   1. Test authentication with existing users');
+    console.log('   2. Verify events are properly linked to EventTypes');
+    console.log('   3. Run: node setup_default_users.js to create test accounts');
+    
+  } catch (error) {
+    console.error('âŒ Migration failed:', error);
+    process.exit(1);
+  } finally {
+    await client.close();
+  }
+}
+
+function getDefaultPermissions(role) {
+  const rolePermissions = {
+    admin: [
+      { resource: '*', action: '*', granted: true }
+    ],
+    super_admin: [
+      { resource: '*', action: '*', granted: true }
+    ],
+    operator: [
+      { resource: 'events', action: 'read', granted: true },
+      { resource: 'events', action: 'update', granted: true },
+      { resource: 'cameras', action: 'read', granted: true },
+      { resource: 'cameras', action: 'manage', granted: true }
+    ],
+    mobile_admin: [
+      { resource: 'event-types', action: 'manage', granted: true },
+      { resource: 'mobile-users', action: 'read', granted: true },
+      { resource: 'events', action: 'read', granted: true }
+    ],
+    citizen: [
+      { resource: 'events', action: 'create', granted: true },
+      { resource: 'events', action: 'read', granted: true, conditions: { ownOnly: true } }
+    ]
+  };
+  
+  return rolePermissions[role] || rolePermissions.citizen;
+}
+
+// Run migration if called directly
+if (require.main === module) {
+  runMigration().catch(console.error);
+}
+
+module.exports = { runMigration };
\ No newline at end of file
diff --git a/event-monitoring-mvp/scripts/seed-database.sh b/event-monitoring-mvp/scripts/seed-database.sh
deleted file mode 100644
index 2da20cf..0000000
--- a/event-monitoring-mvp/scripts/seed-database.sh
+++ /dev/null
@@ -1,153 +0,0 @@
-#!/bin/bash
-
-# Event Monitoring MVP - Database Seed Script
-# This script creates default data for development and testing
-
-echo "ğŸŒ± Starting database seeding process..."
-
-# Check if MongoDB container is running
-if ! docker ps | grep -q event-monitoring-mongodb; then
-    echo "âŒ MongoDB container is not running. Starting it..."
-    docker-compose up -d mongodb
-    echo "â³ Waiting for MongoDB to start..."
-    sleep 10
-fi
-
-# MongoDB connection details
-MONGO_USER="admin"
-MONGO_PASS="password123"
-MONGO_AUTH_DB="admin"
-MONGO_DB="event_monitoring"
-CONTAINER_NAME="event-monitoring-mongodb"
-
-echo "ğŸ”Œ Testing MongoDB connection..."
-if ! docker exec $CONTAINER_NAME mongosh --username $MONGO_USER --password $MONGO_PASS --authenticationDatabase $MONGO_AUTH_DB --eval "db.adminCommand('ping')" >/dev/null 2>&1; then
-    echo "âŒ Failed to connect to MongoDB. Check container status."
-    exit 1
-fi
-
-echo "âœ… MongoDB connection successful"
-
-# Function to execute MongoDB commands
-mongo_exec() {
-    docker exec $CONTAINER_NAME mongosh --username $MONGO_USER --password $MONGO_PASS --authenticationDatabase $MONGO_AUTH_DB --eval "use $MONGO_DB; $1"
-}
-
-echo "ğŸ—‘ï¸  Cleaning existing data..."
-mongo_exec "db.users.deleteMany({}); db.cameras.deleteMany({}); db.events.deleteMany({}); db.aidetections.deleteMany({});"
-
-echo "ğŸ‘¤ Creating default admin user..."
-mongo_exec "db.users.insertOne({
-    username: 'admin',
-    email: 'admin@example.com',
-    password: '\$2a\$12\$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj0HIMU.Gsva',
-    role: 'admin',
-    isActive: true,
-    createdAt: new Date(),
-    updatedAt: new Date()
-});"
-
-echo "ğŸ‘¥ Creating operator user..."
-mongo_exec "db.users.insertOne({
-    username: 'operator',
-    email: 'operator@example.com',
-    password: '\$2a\$12\$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj0HIMU.Gsva',
-    role: 'operator',
-    isActive: true,
-    createdAt: new Date(),
-    updatedAt: new Date()
-});"
-
-echo "ğŸ“¹ Creating sample cameras..."
-mongo_exec "db.cameras.insertMany([
-    {
-        name: 'Front Entrance',
-        description: 'Main building entrance camera',
-        location: {
-            type: 'Point',
-            coordinates: [-74.006, 40.7128]
-        },
-        address: '123 Main St, New York, NY',
-        rtspUrl: 'rtsp://camera1.example.com:554/stream',
-        resolution: '1920x1080',
-        fps: 30,
-        status: 'active',
-        isActive: true,
-        createdBy: ObjectId(),
-        createdAt: new Date(),
-        updatedAt: new Date()
-    },
-    {
-        name: 'Parking Lot',
-        description: 'Employee parking area surveillance',
-        location: {
-            type: 'Point',
-            coordinates: [-74.007, 40.7130]
-        },
-        address: '123 Main St Parking, New York, NY',
-        rtspUrl: 'rtsp://camera2.example.com:554/stream',
-        resolution: '1280x720',
-        fps: 25,
-        status: 'active',
-        isActive: true,
-        createdBy: ObjectId(),
-        createdAt: new Date(),
-        updatedAt: new Date()
-    }
-]);"
-
-echo "ğŸš¨ Creating sample events..."
-mongo_exec "db.events.insertMany([
-    {
-        title: 'Motion Detected - Front Entrance',
-        description: 'Unusual motion detected at main entrance during off hours',
-        type: 'motion_detection',
-        severity: 'medium',
-        status: 'active',
-        location: {
-            type: 'Point',
-            coordinates: [-74.006, 40.7128]
-        },
-        cameraId: ObjectId(),
-        detectedObjects: ['person'],
-        confidence: 0.85,
-        createdAt: new Date(Date.now() - 3600000),
-        updatedAt: new Date(Date.now() - 3600000)
-    },
-    {
-        title: 'Vehicle Intrusion Alert',
-        description: 'Unauthorized vehicle detected in restricted area',
-        type: 'intrusion',
-        severity: 'high',
-        status: 'investigating',
-        location: {
-            type: 'Point',
-            coordinates: [-74.007, 40.7130]
-        },
-        cameraId: ObjectId(),
-        detectedObjects: ['car'],
-        confidence: 0.92,
-        assignedTo: ObjectId(),
-        createdAt: new Date(Date.now() - 1800000),
-        updatedAt: new Date(Date.now() - 1800000)
-    }
-]);"
-
-echo "ğŸ” Verifying seed data..."
-USER_COUNT=$(mongo_exec "db.users.countDocuments()" | tail -n1)
-CAMERA_COUNT=$(mongo_exec "db.cameras.countDocuments()" | tail -n1)
-EVENT_COUNT=$(mongo_exec "db.events.countDocuments()" | tail -n1)
-
-echo "ğŸ“Š Seed Summary:"
-echo "   ğŸ‘¥ Users created: $USER_COUNT"
-echo "   ğŸ“¹ Cameras created: $CAMERA_COUNT"
-echo "   ğŸš¨ Events created: $EVENT_COUNT"
-
-echo ""
-echo "ğŸ” Default Login Credentials:"
-echo "   ğŸ“§ Admin: admin@example.com / password123"
-echo "   ğŸ‘¤ Operator: operator@example.com / password123"
-
-echo ""
-echo "âœ… Database seeding completed successfully!"
-echo "ğŸš€ You can now start the application and login with the credentials above."
\ No newline at end of file
diff --git a/event-monitoring-mvp/scripts/setup-database.js b/event-monitoring-mvp/scripts/setup-database.js
new file mode 100644
index 0000000..5a896cd
--- /dev/null
+++ b/event-monitoring-mvp/scripts/setup-database.js
@@ -0,0 +1,293 @@
+#!/usr/bin/env node
+
+/**
+ * Database Setup and Initialization Script
+ * 
+ * This script consolidates all database setup tasks:
+ * - Creates collections and indexes
+ * - Seeds initial EventTypes and permissions  
+ * - Creates default web users (operators/admins)
+ * 
+ * Note: Mobile users authenticate through their own app - not stored here
+ */
+
+const http = require('http');
+const { MongoClient } = require('mongodb');
+
+// Database connection
+const MONGO_URL = process.env.MONGODB_URI || 'mongodb://localhost:27017';
+const DB_NAME = 'event_monitoring';
+
+// Default web users (mobile users authenticate separately)
+const defaultUsers = [
+  {
+    username: 'admin',
+    email: 'admin@example.com',
+    password: 'password123',
+    roles: ['super_admin'],
+    authMethod: 'email',
+    profile: {
+      firstName: 'System',
+      lastName: 'Administrator'
+    }
+  },
+  {
+    username: 'operator1', 
+    email: 'operator1@example.com',
+    password: 'password123',
+    roles: ['operator'],
+    authMethod: 'email',
+    profile: {
+      firstName: 'John',
+      lastName: 'Operator'
+    }
+  },
+  {
+    username: 'mobile_admin',
+    email: 'mobile@example.com',
+    password: 'password123',
+    roles: ['mobile_admin'],
+    authMethod: 'email',
+    profile: {
+      firstName: 'Mobile',
+      lastName: 'Administrator'
+    }
+  }
+];
+
+// Default EventTypes for mobile team integration
+const defaultEventTypes = [
+  {
+    name: 'Security Incidents',
+    category: 'security',
+    description: 'Security-related events and incidents',
+    isPublic: true,
+    isActive: true,
+    order: 1,
+    allowedRoles: ['operator', 'admin'],
+    fields: [
+      { name: 'severity', type: 'select', options: ['low', 'medium', 'high', 'critical'], required: true },
+      { name: 'description', type: 'textarea', required: true }
+    ]
+  },
+  {
+    name: 'Theft',
+    category: 'security', 
+    description: 'Theft and robbery incidents',
+    parentType: 'Security Incidents',
+    isPublic: true,
+    isActive: true,
+    order: 1
+  },
+  {
+    name: 'Infrastructure Issues',
+    category: 'infrastructure',
+    description: 'Infrastructure and maintenance issues',
+    isPublic: true,
+    isActive: true,
+    order: 2,
+    fields: [
+      { name: 'urgency', type: 'select', options: ['low', 'medium', 'high'], required: true }
+    ]
+  }
+];
+
+// Default permissions
+const defaultPermissions = [
+  { resource: '*', action: '*', description: 'Full system access' },
+  { resource: 'events', action: 'read', description: 'View events' },
+  { resource: 'events', action: 'update', description: 'Update event status' },
+  { resource: 'cameras', action: 'read', description: 'View cameras' },
+  { resource: 'cameras', action: 'manage', description: 'Manage cameras' },
+  { resource: 'event-types', action: 'manage', description: 'Manage event types' }
+]; 
+
+async function initializeDatabase() {
+  console.log('ğŸ—„ï¸ Initializing MongoDB database...');
+  
+  try {
+    const client = new MongoClient(MONGO_URL);
+    await client.connect();
+    const db = client.db(DB_NAME);
+
+    // Create collections
+    console.log('ğŸ“‚ Creating collections...');
+    const collections = ['users', 'cameras', 'events', 'eventtypes', 'permissions'];
+    for (const collection of collections) {
+      try {
+        await db.createCollection(collection);
+        console.log(`   âœ… Created ${collection}`);
+      } catch (err) {
+        if (err.code === 48) { // Collection already exists
+          console.log(`   â„¹ï¸  ${collection} already exists`);
+        } else {
+          throw err;
+        }
+      }
+    }
+
+    // Create indexes
+    console.log('ğŸ—‚ï¸ Creating indexes...');
+    
+    // Users indexes (web users only)
+    await db.collection('users').createIndex({ "email": 1 }, { unique: true });
+    await db.collection('users').createIndex({ "username": 1 }, { unique: true, sparse: true });
+    await db.collection('users').createIndex({ "isActive": 1 });
+    await db.collection('users').createIndex({ "roles": 1 });
+    
+    // EventType indexes
+    await db.collection('eventtypes').createIndex({ "name": 1, "isActive": 1 });
+    await db.collection('eventtypes').createIndex({ "category": 1 });
+    await db.collection('eventtypes').createIndex({ "isPublic": 1 });
+    
+    // Events indexes
+    await db.collection('events').createIndex({ "eventType": 1 });
+    await db.collection('events').createIndex({ "status": 1 });
+    await db.collection('events').createIndex({ "createdAt": -1 });
+    await db.collection('events').createIndex({ "location": "2dsphere" });
+    
+    // Permission indexes  
+    await db.collection('permissions').createIndex({ "resource": 1, "action": 1 });
+    
+    console.log('   âœ… Indexes created');
+
+    // Insert default data
+    console.log('ğŸŒ± Seeding default data...');
+    
+    // Insert EventTypes
+    const eventTypesResult = await db.collection('eventtypes').insertMany(
+      defaultEventTypes.map(et => ({
+        ...et,
+        createdAt: new Date(),
+        updatedAt: new Date()
+      }))
+    );
+    console.log(`   âœ… Created ${eventTypesResult.insertedCount} EventTypes`);
+    
+    // Insert permissions
+    const permissionsResult = await db.collection('permissions').insertMany(
+      defaultPermissions.map(p => ({
+        ...p,
+        createdAt: new Date(),
+        updatedAt: new Date()
+      }))
+    );
+    console.log(`   âœ… Created ${permissionsResult.insertedCount} permissions`);
+
+    await client.close();
+    console.log('âœ… Database initialization complete!');
+    
+  } catch (error) {
+    console.error('âŒ Database initialization failed:', error);
+    process.exit(1);
+  }
+}
+
+async function createWebUsers() {
+  console.log('\nğŸ‘¥ Creating web application users...');
+  
+  // Check if backend is running
+  const backendRunning = await checkBackend();
+  if (!backendRunning) {
+    console.log('âŒ Backend not running on http://localhost:5000');
+    console.log('ğŸ’¡ Please start the backend first: cd backend && npm run dev');
+    process.exit(1);
+  }
+
+  console.log('âœ… Backend is running');
+  
+  const results = await Promise.all(defaultUsers.map(makeUserRequest));
+
+  results.forEach(result => {
+    if (result.success) {
+      console.log(`âœ… Created user: ${result.user}`);
+    } else {
+      const errorMsg = JSON.parse(result.error || '{}').message || result.error;
+      if (errorMsg.includes('already exists') || errorMsg.includes('duplicate')) {
+        console.log(`â„¹ï¸  User ${result.user} already exists`);
+      } else {
+        console.log(`âŒ Failed to create ${result.user}: ${errorMsg}`);
+      }
+    }
+  });
+}
+
+function makeUserRequest(user) {
+  return new Promise((resolve) => {
+    const data = JSON.stringify(user);
+    
+    const options = {
+      hostname: 'localhost',
+      port: 5000,
+      path: '/api/auth/register',
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        'Content-Length': Buffer.byteLength(data)
+      }
+    };
+
+    const req = http.request(options, (res) => {
+      let body = '';
+      res.on('data', (chunk) => body += chunk);
+      res.on('end', () => {
+        resolve({ 
+          user: user.username || user.email, 
+          success: res.statusCode >= 200 && res.statusCode < 300, 
+          error: res.statusCode >= 400 ? body : null
+        });
+      });
+    });
+
+    req.on('error', (err) => {
+      resolve({ user: user.username || user.email, success: false, error: err.message });
+    });
+
+    req.write(data);
+    req.end();
+  });
+}
+
+function checkBackend() {
+  return new Promise((resolve) => {
+    const req = http.request({
+      hostname: 'localhost',
+      port: 5000,
+      path: '/health',
+      method: 'GET',
+      timeout: 2000
+    }, (res) => resolve(res.statusCode === 200));
+    
+    req.on('error', () => resolve(false));
+    req.on('timeout', () => resolve(false));
+    req.end();
+  });
+}
+
+async function main() {
+  console.log('ğŸš€ Event Monitoring MVP - Database Setup');
+  console.log('=====================================\n');
+  
+  await initializeDatabase();
+  await createWebUsers();
+  
+  console.log('\nğŸ‰ Setup complete!');
+  console.log('\nğŸ“§ Web Login Credentials:');
+  console.log('   Super Admin: admin@example.com / password123');
+  console.log('   Operator: operator1@example.com / password123');
+  console.log('   Mobile Admin: mobile@example.com / password123');
+  console.log('\nğŸ“± Mobile Integration:');
+  console.log('   â€¢ Mobile users authenticate through their own app');
+  console.log('   â€¢ EventTypes available at: GET /api/mobile/events/types');
+  console.log('   â€¢ Mobile events submitted to: POST /api/mobile/events');
+  console.log('\nğŸŒ Access:');
+  console.log('   Frontend: http://localhost:3000');
+  console.log('   API: http://localhost:5000/api');
+}
+
+// Run if called directly
+if (require.main === module) {
+  main().catch(console.error);
+}
+
+module.exports = { initializeDatabase, createWebUsers };
\ No newline at end of file
diff --git a/event-monitoring-mvp/setup-database.js b/event-monitoring-mvp/setup-database.js
new file mode 100644
index 0000000..adb7510
--- /dev/null
+++ b/event-monitoring-mvp/setup-database.js
@@ -0,0 +1,165 @@
+#!/usr/bin/env node
+
+/**
+ * CENTRALIZED DATABASE SETUP SCRIPT
+ * 
+ * This is the ONLY script you need to run for complete database setup.
+ * It handles everything:
+ * - MongoDB initialization
+ * - Creating default users for web app
+ * - No duplicate files, no confusion
+ * 
+ * Usage: node setup-database.js
+ */
+
+const http = require('http');
+
+// Default users for web application (mobile users authenticate separately)
+const webUsers = [
+  {
+    username: 'admin',
+    email: 'admin@example.com',
+    password: 'password123',
+    roles: ['super_admin'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'System',
+      lastName: 'Administrator'
+    }
+  },
+  {
+    username: 'operator1',
+    email: 'operator1@example.com',
+    password: 'password123',
+    roles: ['operator'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'John',
+      lastName: 'Operator'
+    }
+  },
+  {
+    username: 'mobile_admin',
+    email: 'mobile@example.com',
+    password: 'password123',
+    roles: ['mobile_admin'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'Mobile',
+      lastName: 'Administrator'
+    }
+  }
+];
+
+function makeUserRequest(user) {
+  return new Promise((resolve, reject) => {
+    const data = JSON.stringify(user);
+    
+    const options = {
+      hostname: 'localhost',
+      port: 5000,
+      path: '/api/auth/register',
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        'Content-Length': Buffer.byteLength(data)
+      }
+    };
+
+    const req = http.request(options, (res) => {
+      let responseData = '';
+      
+      res.on('data', (chunk) => {
+        responseData += chunk;
+      });
+      
+      res.on('end', () => {
+        if (res.statusCode === 201) {
+          resolve({ success: true, user: user.username, email: user.email });
+        } else if (res.statusCode === 400 && responseData.includes('already exists')) {
+          resolve({ success: false, user: user.username, email: user.email, reason: 'already_exists' });
+        } else {
+          resolve({ success: false, user: user.username, email: user.email, error: responseData });
+        }
+      });
+    });
+
+    req.on('error', (err) => {
+      reject({ success: false, user: user.username, email: user.email, error: err.message });
+    });
+
+    req.write(data);
+    req.end();
+  });
+}
+
+function checkBackend() {
+  return new Promise((resolve) => {
+    const req = http.request({ hostname: 'localhost', port: 5000, path: '/health' }, (res) => {
+      resolve(true);
+    });
+    
+    req.on('error', () => resolve(false));
+    req.setTimeout(3000, () => {
+      req.destroy();
+      resolve(false);
+    });
+    
+    req.end();
+  });
+}
+
+async function main() {
+  console.log('ğŸš€ CENTRALIZED DATABASE SETUP');
+  console.log('===============================\n');
+  
+  // Check backend
+  console.log('ğŸ” Checking if backend is running...');
+  const backendRunning = await checkBackend();
+  
+  if (!backendRunning) {
+    console.log('âŒ Backend is not running!');
+    console.log('\nğŸ’¡ Start the backend first:');
+    console.log('   cd backend && npm run dev');
+    console.log('\n   Then run this script again.');
+    process.exit(1);
+  }
+  
+  console.log('âœ… Backend is running\n');
+  
+  // Create users
+  console.log('ğŸ‘¥ Creating web application users...');
+  console.log('ğŸ“± Note: Mobile users authenticate separately through their own app\n');
+  
+  const results = await Promise.all(webUsers.map(makeUserRequest));
+  
+  results.forEach(result => {
+    if (result.success) {
+      console.log(`âœ… Created: ${result.user} (${result.email})`);
+    } else if (result.reason === 'already_exists') {
+      console.log(`â„¹ï¸  Exists: ${result.user} (${result.email})`);
+    } else {
+      console.log(`âŒ Failed: ${result.user} - ${result.error}`);
+    }
+  });
+  
+  console.log('\nğŸ‰ Database setup complete!');
+  console.log('\nğŸ“§ Login credentials:');
+  console.log('   Super Admin: admin@example.com / password123');
+  console.log('   Operator: operator1@example.com / password123');
+  console.log('   Mobile Admin: mobile@example.com / password123');
+  console.log('\nğŸŒ Access:');
+  console.log('   Frontend: http://localhost:3000');
+  console.log('   Backend: http://localhost:5000');
+  console.log('\nğŸ“± Mobile Integration:');
+  console.log('   â€¢ Mobile users authenticate in their own app');
+  console.log('   â€¢ Events are submitted to /api/events endpoint');
+  console.log('   â€¢ Use mobile_admin account to coordinate with mobile team');
+}
+
+// Run if called directly
+if (require.main === module) {
+  main().catch(console.error);
+}
+
+module.exports = { main };
\ No newline at end of file
diff --git a/event-monitoring-mvp/setup_default_users.js b/event-monitoring-mvp/setup_default_users.js
index c21e4b0..0088851 100644
--- a/event-monitoring-mvp/setup_default_users.js
+++ b/event-monitoring-mvp/setup_default_users.js
@@ -1,119 +1,167 @@
-#!/usr/bin/env node
-
-const http = require('http');
-
-const users = [
-  {
-    username: 'admin',
-    email: 'admin@example.com',
-    password: 'password123',
-    role: 'admin'
-  },
-  {
-    username: 'operator1', 
-    email: 'operator1@example.com',
-    password: 'password123',
-    role: 'operator'
-  },
-  {
-    username: 'operator2',
-    email: 'operator2@example.com', 
-    password: 'password123',
-    role: 'operator'
-  }
-];
-
-function makeRequest(user) {
-  return new Promise((resolve, reject) => {
-    const data = JSON.stringify(user);
-    
-    const options = {
-      hostname: 'localhost',
-      port: 5000,
-      path: '/api/auth/register',
-      method: 'POST',
-      headers: {
-        'Content-Type': 'application/json',
-        'Content-Length': Buffer.byteLength(data)
-      }
-    };
-
-    const req = http.request(options, (res) => {
-      let body = '';
-      res.on('data', (chunk) => {
-        body += chunk;
-      });
-      
-      res.on('end', () => {
-        if (res.statusCode >= 200 && res.statusCode < 300) {
-          resolve({ user: user.username, success: true, data: body });
-        } else {
-          resolve({ user: user.username, success: false, error: body });
-        }
-      });
-    });
-
-    req.on('error', (err) => {
-      resolve({ user: user.username, success: false, error: err.message });
-    });
-
-    req.write(data);
-    req.end();
-  });
-}
-
-async function checkBackend() {
-  return new Promise((resolve) => {
-    const req = http.request({
-      hostname: 'localhost',
-      port: 5000,
-      path: '/health',
-      method: 'GET',
-      timeout: 2000
-    }, (res) => {
-      resolve(res.statusCode === 200);
-    });
-    
-    req.on('error', () => resolve(false));
-    req.on('timeout', () => resolve(false));
-    req.end();
-  });
-}
-
-async function createUsers() {
-  console.log('ğŸ” Checking if backend is running...');
-  
-  const backendRunning = await checkBackend();
-  if (!backendRunning) {
-    console.log('âŒ Backend not running on http://localhost:5000');
-    console.log('ğŸ’¡ Please start the backend first:');
-    console.log('   cd backend && npm run dev');
-    process.exit(1);
-  }
-
-  console.log('âœ… Backend is running');
-  console.log('ğŸ‘¥ Creating default users...\n');
-
-  const results = await Promise.all(users.map(makeRequest));
-
-  results.forEach(result => {
-    if (result.success) {
-      console.log(`âœ… Created user: ${result.user}`);
-    } else {
-      const errorMsg = JSON.parse(result.error || '{}').message || result.error;
-      if (errorMsg.includes('already exists') || errorMsg.includes('duplicate')) {
-        console.log(`â„¹ï¸  User ${result.user} already exists`);
-      } else {
-        console.log(`âŒ Failed to create ${result.user}: ${errorMsg}`);
-      }
-    }
-  });
-
-  console.log('\nğŸ‰ Default users setup complete!');
-  console.log('\nğŸ“§ Login credentials:');
-  console.log('   Email: admin@example.com');
-  console.log('   Password: password123');
-  console.log('\nğŸŒ Frontend: http://localhost:3000');
-}
-
+#!/usr/bin/env node
+
+const http = require('http');
+
+// Web application users only - mobile users authenticate through their own app
+const users = [
+  {
+    username: 'admin',
+    email: 'admin@example.com',
+    password: 'password123',
+    roles: ['super_admin'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'System',
+      lastName: 'Administrator'
+    }
+  },
+  {
+    username: 'operator1', 
+    email: 'operator1@example.com',
+    password: 'password123',
+    role: ['operator'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'John',
+      lastName: 'Operator'
+    }
+  },
+  {
+    username: 'operator2',
+    email: 'operator2@example.com', 
+    password: 'password123',
+    role: ['operator'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'Jane',
+      lastName: 'Monitor'
+    }
+  },
+  {
+    username: 'mobile_admin',
+    email: 'mobile@example.com',
+    password: 'password123',
+    role: ['mobile_admin'],
+    authMethod: 'email_password',
+    profile: {
+      firstName: 'Mobile',
+      lastName: 'Administrator'
+    }
+  }
+  // Note: Citizens authenticate through mobile app - not stored in web database
+];
+
+function makeRequest(user) {
+  return new Promise((resolve, reject) => {
+    const data = JSON.stringify(user);
+    
+    const options = {
+      hostname: 'localhost',
+      port: 5000,
+      path: '/api/auth/register',
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        'Content-Length': Buffer.byteLength(data)
+      }
+    };
+
+    const req = http.request(options, (res) => {
+      let body = '';
+      res.on('data', (chunk) => {
+        body += chunk;
+      });
+      
+      res.on('end', () => {
+        if (res.statusCode >= 200 && res.statusCode < 300) {
+          resolve({ 
+            user: user.username || user.email || user.phone, 
+            success: true, 
+            data: body 
+          });
+        } else {
+          resolve({ 
+            user: user.username || user.email || user.phone, 
+            success: false, 
+            error: body 
+          });
+        }
+      });
+    });
+
+    req.on('error', (err) => {
+      resolve({ 
+        user: user.username || user.email || user.phone, 
+        success: false, 
+        error: err.message 
+      });
+    });
+
+    req.write(data);
+    req.end();
+  });
+}
+
+async function checkBackend() {
+  return new Promise((resolve) => {
+    const req = http.request({
+      hostname: 'localhost',
+      port: 5000,
+      path: '/health',
+      method: 'GET',
+      timeout: 2000
+    }, (res) => {
+      resolve(res.statusCode === 200);
+    });
+    
+    req.on('error', () => resolve(false));
+    req.on('timeout', () => resolve(false));
+    req.end();
+  });
+}
+
+async function createUsers() {
+  console.log('ğŸ” Checking if backend is running...');
+  
+  const backendRunning = await checkBackend();
+  if (!backendRunning) {
+    console.log('âŒ Backend not running on http://localhost:5000');
+    console.log('ğŸ’¡ Please start the backend first:');
+    console.log('   cd backend && npm run dev');
+    process.exit(1);
+  }
+
+  console.log('âœ… Backend is running');
+  console.log('ğŸ‘¥ Creating default users...\n');
+
+  const results = await Promise.all(users.map(makeRequest));
+
+  results.forEach(result => {
+    if (result.success) {
+      const userData = JSON.parse(result.data);
+      console.log(`âœ… Created user: ${result.user} (roles: ${userData.user?.roles?.join(', ') || 'N/A'})`);
+    } else {
+      const errorMsg = JSON.parse(result.error || '{}').message || result.error;
+      if (errorMsg.includes('already exists') || errorMsg.includes('duplicate')) {
+        console.log(`â„¹ï¸  User ${result.user} already exists`);
+      } else {
+        console.log(`âŒ Failed to create ${result.user}: ${errorMsg}`);
+      }
+    }
+  });
+
+  console.log('\nğŸ‰ Default users setup complete!');
+  console.log('\nğŸ“§ Login credentials:');
+  console.log('   Super Admin: admin@example.com / password123');
+  console.log('   Operator: operator1@example.com / password123');  
+  console.log('   Mobile Admin: mobile@example.com / password123');
+  console.log('\nğŸ“± Mobile Integration:');
+  console.log('   â€¢ Citizens authenticate through mobile app (not stored here)');
+  console.log('   â€¢ Mobile app submits events to /api/mobile/events endpoint');
+  console.log('   â€¢ Use mobile admin account to manage EventTypes for mobile team');
+  console.log('\nğŸŒ Access:');
+  console.log('   Frontend: http://localhost:3000');
+  console.log('   API: http://localhost:5000/api');
+} 
+
 createUsers();
\ No newline at end of file
diff --git a/mobile-integration-workplan.md b/mobile-integration-workplan.md
new file mode 100644
index 0000000..13dadb1
--- /dev/null
+++ b/mobile-integration-workplan.md
@@ -0,0 +1,469 @@
+# Mobile Integration Work Plan
+## Multi-Tenant Standalone Mobile App Implementation
+
+### ğŸ“‹ Executive Summary
+
+Based on discussions with mobile team lead, we're implementing a **multi-tenant standalone mobile app** with the following key changes:
+
+1. **API Key-Based Multi-Tenancy**: Companies get unique API keys for isolated data access
+2. **First Responder Users**: New user type managed by web team, used by mobile app
+3. **Dynamic Event Types**: Flexible type/subtype system with auto-generation capability
+4. **Live Location Tracking**: Real-time first responder tracking on map
+
+---
+
+## ğŸ—ï¸ Core Architecture Changes
+
+### 1. Multi-Tenancy System
+```
+â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+â”‚   Company A     â”‚â”€â”€â”€â”€â”‚  API Gateway     â”‚â”€â”€â”€â”€â”‚  Web Dashboard  â”‚
+â”‚   Mobile App    â”‚    â”‚  (API Key Auth)  â”‚    â”‚  (Multi-Tenant) â”‚
+â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+         â”‚                       â”‚                       â”‚
+         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
+         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Database       â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+                         â”‚  (Company       â”‚
+                         â”‚   Isolated)     â”‚
+                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+```
+
+**Implementation:**
+- Each company gets unique API key
+- All API requests include `X-API-Key` header
+- Data filtering by `companyId` in all queries
+- Company-specific event types and settings
+
+### 2. New User Types & Authentication Flow
+```
+Web Users:           Mobile Users:
+- super_admin       - first_responder (phone + password)
+- admin             - citizen (various auth methods)
+- operator          - anonymous (company context only)
+- company_admin     
+- mobile_admin      
+```
+
+### 3. Dynamic Event Type System
+```
+Current: Fixed enum types
+New:     Database-driven types with auto-creation
+
+Mobile App â†’ "Traffic Incident" â†’ API checks EventTypes table
+                                 â†’ If not found, auto-create pending approval
+                                 â†’ Store event with type string
+```
+
+---
+
+## ğŸš§ Implementation Plan
+
+### Phase 1: Foundation (Week 1-2)
+#### Database Schema Updates
+- [ ] **Add Company Model** with API key management
+- [ ] **Enhance User Model** for first responder role
+- [ ] **Update Event Model** with companyId and dynamic types
+- [ ] **Create EventType Model** for flexible type management
+- [ ] **Add Location Tracking Model** for first responder pings
+
+#### API Infrastructure
+- [ ] **API Key Middleware** for request validation and company context
+- [ ] **Multi-tenant Data Filtering** in all database queries
+- [ ] **Company Management Endpoints** for admin operations
+- [ ] **Enhanced Authentication** for first responders
+
+#### Database Migration
+```sql
+-- Add company reference to events
+ALTER TABLE events ADD COLUMN companyId ObjectId;
+ALTER TABLE events ADD COLUMN type String; -- Dynamic type field
+ALTER TABLE events ADD COLUMN subType String; -- Dynamic subtype
+ALTER TABLE events ADD INDEX company_type (companyId, type);
+
+-- Create company collection with indexes
+CREATE INDEX companies.apiKey;
+CREATE INDEX companies.status;
+```
+
+### Phase 2: Mobile Integration (Week 3-4)
+#### Mobile-Specific Endpoints
+- [ ] **First Responder Authentication** (`POST /api/mobile/auth/first-responder`)
+- [ ] **Company-Filtered Event Submission** (`POST /api/mobile/events`)
+- [ ] **Dynamic Event Type Retrieval** (`GET /api/mobile/event-types`)
+- [ ] **Location Ping Endpoint** (`POST /api/mobile/location/ping`)
+
+#### Real-Time Updates
+- [ ] **Company-Scoped WebSocket Channels** (`/ws/company/:companyId`)
+- [ ] **First Responder Location Broadcasting** for live tracking
+- [ ] **Event Assignment Notifications** for first responders
+
+#### Event Type Management
+- [ ] **Auto-Generation Logic** for unknown types from mobile
+- [ ] **Approval Workflow** for new types
+- [ ] **Company-Specific Type Customization**
+
+### Phase 3: Advanced Features (Week 5-6)
+#### Live Tracking & Assignment
+- [ ] **First Responder Map Integration** showing live locations
+- [ ] **Proximity-Based Assignment** logic
+- [ ] **ETA Calculation** and tracking
+- [ ] **Status Management** (available, busy, en-route, on-scene)
+
+#### Company Administration
+- [ ] **Company Onboarding Portal** for new clients
+- [ ] **Usage Analytics Dashboard** per company
+- [ ] **API Key Rotation** and security management
+- [ ] **Billing Integration** based on usage metrics
+
+---
+
+## ğŸ”§ Technical Implementation Details
+
+### API Key Authentication Flow
+```javascript
+// API Key Middleware
+async function validateApiKey(req, res, next) {
+  const apiKey = req.headers['x-api-key'];
+  
+  if (!apiKey) {
+    return res.status(401).json({ error: 'API key required' });
+  }
+  
+  const company = await Company.findOne({ 
+    apiKey: apiKey, 
+    status: 'active' 
+  });
+  
+  if (!company) {
+    return res.status(403).json({ error: 'Invalid API key' });
+  }
+  
+  // Add company context to request
+  req.company = company;
+  req.companyId = company._id;
+  
+  // Check API limits
+  if (company.apiUsage.currentMonthCalls >= company.subscription.limits.apiCallsLimit) {
+    return res.status(429).json({ error: 'API limit exceeded' });
+  }
+  
+  // Update usage counter
+  await Company.updateOne(
+    { _id: company._id },
+    { $inc: { 'apiUsage.currentMonthCalls': 1 } }
+  );
+  
+  next();
+}
+```
+
+### Dynamic Event Type Creation
+```javascript
+// Mobile Event Submission
+async function submitEvent(req, res) {
+  const { type, subType, ...eventData } = req.body;
+  const companyId = req.companyId;
+  
+  // Find or create event type
+  let eventType = await EventType.findOne({ 
+    name: type, 
+    $or: [
+      { companyId: companyId },
+      { isGlobal: true }
+    ]
+  });
+  
+  if (!eventType) {
+    // Auto-create new event type
+    eventType = await EventType.create({
+      name: type,
+      companyId: companyId,
+      isAutoGenerated: true,
+      approvalStatus: 'pending',
+      createdBy: req.user?.id,
+      subTypes: subType ? [{ name: subType }] : []
+    });
+    
+    // Notify admins of new type
+    notifyNewEventType(eventType);
+  }
+  
+  // Create event with type reference
+  const event = await Event.create({
+    ...eventData,
+    companyId,
+    eventTypeId: eventType._id,
+    type: type,
+    subType: subType
+  });
+  
+  // Broadcast real-time update to company channel
+  io.to(`company-${companyId}`).emit('new-event', event);
+  
+  res.status(201).json(event);
+}
+```
+
+### First Responder Location Tracking
+```javascript
+// Location Ping Handler
+async function updateResponderLocation(req, res) {
+  const { latitude, longitude, accuracy, status } = req.body;
+  const userId = req.user.id;
+  const companyId = req.companyId;
+  
+  // Save location ping
+  const locationPing = await LocationPing.create({
+    userId,
+    companyId,
+    location: {
+      type: 'Point',
+      coordinates: [longitude, latitude]
+    },
+    accuracy,
+    status,
+    timestamp: new Date()
+  });
+  
+  // Update user's current location
+  await User.updateOne(
+    { _id: userId },
+    { 
+      'firstResponderProfile.currentLocation': {
+        type: 'Point',
+        coordinates: [longitude, latitude],
+        accuracy,
+        lastPing: new Date()
+      },
+      'firstResponderProfile.currentStatus': status
+    }
+  );
+  
+  // Broadcast to company's live tracking channel
+  io.to(`tracking-${companyId}`).emit('responder-location-update', {
+    userId,
+    location: { latitude, longitude },
+    status,
+    accuracy,
+    timestamp: new Date()
+  });
+  
+  res.json({ success: true });
+}
+```
+
+---
+
+## ğŸ“Š Database Schema Changes
+
+### New Collections
+
+#### 1. Companies Collection
+```javascript
+{
+  _id: ObjectId,
+  name: "Acme Security Corp",
+  apiKey: "ask_1234567890abcdef", // Prefix: ask_ (API Secret Key)
+  apiSecret: "hashed_secret",
+  status: "active",
+  subscription: {
+    plan: "professional",
+    limits: {
+      maxUsers: 50,
+      maxEvents: 1000,
+      apiCallsLimit: 10000
+    }
+  },
+  settings: {
+    allowAnonymousReporting: true,
+    enableFirstResponderTracking: true,
+    locationTrackingInterval: 30 // seconds
+  }
+}
+```
+
+#### 2. Enhanced EventTypes Collection
+```javascript
+{
+  _id: ObjectId,
+  name: "Traffic Incident",
+  companyId: ObjectId, // null for global types
+  isGlobal: false,
+  isAutoGenerated: true,
+  approvalStatus: "pending",
+  subTypes: [
+    { name: "Vehicle Accident", isActive: true },
+    { name: "Traffic Jam", isActive: true }
+  ],
+  usage: {
+    totalEvents: 42,
+    lastUsed: ISODate,
+    averageResolutionTime: 35 // minutes
+  }
+}
+```
+
+#### 3. Location Tracking Collection
+```javascript
+{
+  _id: ObjectId,
+  userId: ObjectId, // first responder
+  companyId: ObjectId,
+  location: {
+    type: "Point",
+    coordinates: [-74.006, 40.7128] // [lng, lat]
+  },
+  accuracy: 5.0, // meters
+  status: "available", // available, busy, en_route, on_scene
+  eventId: ObjectId, // if responding to specific event
+  timestamp: ISODate,
+  battery: 85 // device battery %
+}
+```
+
+### Updated Collections
+
+#### Enhanced Events Collection
+```javascript
+{
+  _id: ObjectId,
+  companyId: ObjectId, // REQUIRED - links to company
+  eventTypeId: ObjectId, // reference to EventType
+  type: "Traffic Incident", // dynamic string
+  subType: "Vehicle Accident", // dynamic string
+  firstResponder: {
+    assignedResponder: ObjectId,
+    dispatchedAt: ISODate,
+    status: "en_route",
+    eta: ISODate,
+    currentLocation: {
+      type: "Point", 
+      coordinates: [-74.006, 40.7128],
+      lastPing: ISODate
+    }
+  },
+  // ... existing fields
+}
+```
+
+#### Enhanced Users Collection
+```javascript
+{
+  _id: ObjectId,
+  companyId: ObjectId, // for first_responder, citizen
+  role: "first_responder", // new role
+  authMethod: "phone_password", // new method
+  phone: "+1234567890", // username for first responders
+  firstResponderProfile: {
+    badgeNumber: "FR-001",
+    specializations: ["medical", "fire"],
+    currentStatus: "available",
+    currentLocation: {
+      type: "Point",
+      coordinates: [-74.006, 40.7128],
+      lastPing: ISODate,
+      isTracking: true
+    },
+    shiftSchedule: {
+      startTime: "08:00",
+      endTime: "20:00",
+      daysOfWeek: [1,2,3,4,5] // Mon-Fri
+    }
+  }
+}
+```
+
+---
+
+## ğŸš€ API Endpoints Summary
+
+### Company Management
+- `GET /api/companies` - List companies (super admin)
+- `POST /api/companies` - Create company (super admin)
+- `GET /api/company/profile` - Get own company (company admin)
+- `POST /api/company/users` - Create first responder
+
+### Enhanced Mobile APIs (Require API Key)
+- `POST /api/mobile/auth/first-responder` - First responder login
+- `POST /api/mobile/events` - Submit event (company context)
+- `GET /api/mobile/event-types` - Get available types
+- `POST /api/mobile/location/ping` - Location update
+- `GET /api/mobile/responders/nearby` - Find nearby responders
+
+### Real-Time Channels
+- `WebSocket: /ws/company/:companyId` - Company-specific events
+- `WebSocket: /ws/tracking/:companyId` - Live responder tracking
+- `WebSocket: /ws/responder/:userId` - Individual responder channel
+
+---
+
+## âœ… Success Metrics
+
+### Technical Milestones
+- [ ] API key authentication working for all mobile endpoints
+- [ ] Company data isolation verified (no cross-company data leaks)
+- [ ] First responder location tracking with <5 second update latency
+- [ ] Dynamic event type creation and approval workflow
+- [ ] Real-time updates delivered to correct company channels
+
+### User Experience Goals  
+- [ ] First responder login time <10 seconds
+- [ ] Event submission with auto-type creation <30 seconds
+- [ ] Live location tracking accuracy within 10 meters
+- [ ] Company admin can see only their organization's data
+- [ ] New event types auto-approved within 1 hour (configurable)
+
+### Performance Targets
+- [ ] API key validation <50ms
+- [ ] Company-filtered queries <200ms
+- [ ] Location ping processing <100ms
+- [ ] WebSocket message delivery <2 seconds
+- [ ] Support for 100+ concurrent first responders per company
+
+---
+
+## ğŸ”’ Security Considerations
+
+### API Key Security
+- **Rotation**: Automated monthly rotation with grace period
+- **Rate Limiting**: Per-company API call limits
+- **Encryption**: All API keys encrypted at rest
+- **Audit Logging**: All API key usage tracked
+
+### Data Isolation
+- **Query Filtering**: Automatic companyId filtering in all database queries
+- **Index Strategy**: Compound indexes starting with companyId
+- **Backup Isolation**: Company data backed up separately
+- **GDPR Compliance**: Company-specific data deletion capabilities
+
+### First Responder Privacy
+- **Location Consent**: Explicit opt-in for location tracking
+- **Shift-Based Tracking**: Only track during active shifts
+- **Data Retention**: Location data auto-deleted after 30 days
+- **Access Control**: Location data only visible to authorized personnel
+
+---
+
+## ğŸ“ Next Steps & Action Items
+
+### Immediate (This Week)
+1. **Review and approve** this work plan with both teams
+2. **Create company model** and API key generation logic
+3. **Set up development environment** with multi-tenancy
+4. **Update authentication middleware** for API keys
+5. **Design database migration strategy** for existing data
+
+### Week 1 Goals
+1. Complete company onboarding and API key system
+2. Implement first responder authentication
+3. Add companyId to all existing collections
+4. Create dynamic event type system
+5. Set up company-scoped WebSocket channels
+
+### Communication Schedule
+- **Monday**: Joint team review of multi-tenant implementation
+- **Wednesday**: Mobile integration testing and API validation  
+- **Friday**: First responder workflow testing
+- **Daily**: API changes and company isolation verification
+
+This work plan provides a clear roadmap for implementing the standalone mobile app with multi-tenancy while maintaining your existing web dashboard functionality.
\ No newline at end of file
diff --git a/team-coordination-protocol.md b/team-coordination-protocol.md
new file mode 100644
index 0000000..1cad676
--- /dev/null
+++ b/team-coordination-protocol.md
@@ -0,0 +1,1270 @@
+# SHOB Web - Team Coordination Protocol
+## Real-Time Event Monitoring System Development Guide
+
+### Document Purpose
+This document provides comprehensive recommendations and protocols for coordinating development between the Web Team and Mobile Team to ensure seamless integration, data consistency, and avoid mismatches in the real-time event monitoring system.
+
+---
+
+## 1. PROJECT OVERVIEW & SCOPE
+
+### System Architecture Overview
+- **Web Team**: Building the main dashboard, operator interface, backend services, and **multi-tenant API management**
+- **Mobile Team**: Building **standalone mobile app** for multiple companies with field users, citizens, and first responders
+- **Shared Components**: Multi-tenant Backend API, Database with company isolation, AI Analysis Engine, Real-time communication with live tracking
+- **Multi-Tenancy**: API key-based company separation with isolated data access
+
+### Key Integration Points
+1. **Multi-Tenant Event Data Management**: Company-isolated event creation, updates, and viewing via API keys
+2. **Real-time Communication**: WebSocket connections for live updates + **first responder location tracking**
+3. **Multi-Level User Management**: Citizens, first responders, operators, company admins with API key authorization
+4. **Video & Media Handling**: Company-isolated streaming and file management
+5. **GIS & Location Services**: Map integration with **live first responder tracking** and geofencing
+6. **API Key Management**: Company onboarding, key rotation, and access control
+
+---
+
+## 2. STANDARDIZED DATA MODELS
+
+### 2.1 Company Data Structure (New)
+```json
+{
+  "_id": "ObjectId",
+  "name": "string: required, company name",
+  "displayName": "string: optional, public display name",
+  "apiKey": "string: unique, auto-generated API key",
+  "apiSecret": "string: hashed secret for key validation",
+  "status": "enum: ['active', 'suspended', 'trial', 'expired']",
+  "subscription": {
+    "plan": "enum: ['basic', 'professional', 'enterprise', 'custom']",
+    "features": ["array of enabled features"],
+    "limits": {
+      "maxUsers": "number: max first responders",
+      "maxEvents": "number: monthly event limit",
+      "storageLimit": "number: file storage in MB",
+      "apiCallsLimit": "number: daily API calls"
+    },
+    "expiresAt": "Date: subscription expiry"
+  },
+  "contact": {
+    "adminName": "string: primary contact",
+    "adminEmail": "string: admin email",
+    "adminPhone": "string: admin phone",
+    "address": "string: company address"
+  },
+  "settings": {
+    "allowAnonymousReporting": "boolean: default true",
+    "requireEventApproval": "boolean: default false",
+    "enableFirstResponderTracking": "boolean: default false",
+    "locationTrackingInterval": "number: seconds between pings",
+    "dataRetentionDays": "number: days to keep data",
+    "allowedEventTypes": ["array of allowed event type IDs"],
+    "customEventTypes": ["array of company-specific event types"]
+  },
+  "apiUsage": {
+    "currentMonthCalls": "number",
+    "currentMonthEvents": "number",
+    "lastApiCall": "Date",
+    "quotaResetDate": "Date"
+  },
+  "createdAt": "Date: auto-generated",
+  "updatedAt": "Date: auto-generated"
+}
+```
+
+### 2.2 Enhanced Event Data Structure
+```json
+{
+  "_id": "ObjectId",
+  "companyId": "ObjectId: required, links to company for multi-tenancy",
+  "title": "string: required, 3-200 characters",
+  "description": "string: optional, max 2000 characters",
+  "eventTypeId": "ObjectId: optional, reference to EventType document",
+  "type": "string: dynamic type name (legacy and new)",
+  "subType": "string: optional, dynamic subtype name",
+  "severity": "enum: ['low', 'medium', 'high', 'critical', 'emergency']",
+  "priority": "number: 1-5 (1=highest, 5=lowest)",
+  "status": "enum: ['pending', 'acknowledged', 'investigating', 'resolved', 'closed', 'dismissed']",
+  "cameraId": "ObjectId: optional (not required for user reports)",
+  "detectionId": "ObjectId: optional (link to original AI detection)",
+  "location": {
+    "type": "Point",
+    "coordinates": "[longitude, latitude]",
+    "address": "string: optional",
+    "accuracy": "number: GPS accuracy in meters"
+  },
+  "detectionData": {
+    "confidence": "number: 0-1",
+    "boundingBox": "object: detection coordinates",
+    "detectedObjects": ["array of detected objects"],
+    "aiModel": "string: model used for detection",
+    "detectionTimestamp": "Date"
+  },
+  "media": {
+    "images": ["array of image URLs"],
+    "videos": ["array of video URLs"],
+    "thumbnails": ["array of thumbnail URLs"],
+    "attachments": [{
+      "fileName": "string",
+      "fileUrl": "string",
+      "fileType": "string",
+      "fileSize": "number",
+      "uploadedAt": "Date"
+    }]
+  },
+  "reporter": {
+    "userId": "ObjectId: optional (for registered users)",
+    "name": "string: optional (for anonymous reports)",
+    "email": "string: optional",
+    "phone": "string: optional",
+    "isAnonymous": "boolean: default false"
+  },
+  "assignedTo": "ObjectId: optional",
+  "firstResponder": {
+    "assignedResponder": "ObjectId: optional, first responder user ID",
+    "dispatchedAt": "Date: optional",
+    "arrivedAt": "Date: optional",
+    "completedAt": "Date: optional",
+    "currentLocation": {
+      "type": "Point",
+      "coordinates": "[longitude, latitude]",
+      "accuracy": "number: GPS accuracy in meters",
+      "lastPing": "Date: last location update"
+    },
+    "status": "enum: ['dispatched', 'en_route', 'on_scene', 'completed']",
+    "eta": "Date: estimated arrival time"
+  },
+  "escalatedTo": "ObjectId: optional",
+  "acknowledgedAt": "Date: optional",
+  "resolvedAt": "Date: optional",
+  "estimatedResolutionTime": "Date: optional",
+  "actualResolutionTime": "Date: optional",
+  "notes": [{
+    "content": "string",
+    "author": "ObjectId",
+    "timestamp": "Date",
+    "noteType": "enum: ['general', 'investigation', 'resolution', 'escalation']",
+    "isInternal": "boolean"
+  }],
+  "tags": ["string array"],
+  "customFields": "Map<string, any>: flexible custom data",
+  "source": "enum: ['camera_system', 'user_report', 'ai_detection', 'sensor_alert', 'manual_entry', 'mobile_app']",
+  "verified": "boolean: operator verification status",
+  "publiclyVisible": "boolean: visible in public feeds",
+  "resolution": {
+    "summary": "string: optional",
+    "actions": ["array of resolution actions"],
+    "preventiveMeasures": ["array of preventive measures"],
+    "followUpRequired": "boolean",
+    "satisfactionRating": "number: 1-5 (if applicable)"
+  },
+  "workflow": [{
+    "status": "string",
+    "timestamp": "Date",
+    "userId": "ObjectId",
+    "notes": "string: optional"
+  }],
+  "createdAt": "Date: auto-generated",
+  "updatedAt": "Date: auto-generated"
+}
+```
+
+### 2.3 Enhanced User Data Structure
+```json
+{
+  "_id": "ObjectId",
+  "companyId": "ObjectId: required for first_responder, citizen users",
+  "username": "string: unique, required",
+  "email": "string: unique, required for email auth",
+  "passwordHash": "string: required for email/phone auth",
+  "phone": "string: required for first_responder and phone auth",
+  "fullName": "string: required",
+  "role": "enum: ['citizen', 'first_responder', 'operator', 'admin', 'company_admin', 'mobile_admin', 'super_admin']",
+  "authMethod": "enum: ['email_password', 'phone_password', 'phone_otp', 'api_key']",
+  "permissions": {
+    "granted": ["ObjectId array: individual permissions"],
+    "inherited": ["ObjectId array: role-based permissions"]
+  },
+  "firstResponderProfile": {
+    "badgeNumber": "string: optional",
+    "department": "string: optional",
+    "specializations": ["array: medical, fire, police, security, maintenance"],
+    "certifications": ["array of certifications"],
+    "currentStatus": "enum: ['available', 'on_duty', 'busy', 'off_duty']",
+    "currentLocation": {
+      "type": "Point",
+      "coordinates": "[longitude, latitude]",
+      "accuracy": "number",
+      "lastPing": "Date",
+      "isTracking": "boolean: location sharing enabled"
+    },
+    "shiftSchedule": {
+      "startTime": "string: HH:MM",
+      "endTime": "string: HH:MM",
+      "daysOfWeek": ["array: 0-6 (Sunday-Saturday)"]
+    }
+  },
+  "companySettings": {
+    "canReceiveAssignments": "boolean: default true",
+    "maxTravelDistance": "number: km radius for assignments",
+    "notificationPreferences": {
+      "newEvents": "boolean",
+      "assignments": "boolean",
+      "emergencies": "boolean",
+      "shiftReminders": "boolean"
+    }
+  },
+  "mobileSettings": {
+    "deviceTokens": ["array of push notification tokens"],
+    "notificationPreferences": {
+      "pushEnabled": "boolean",
+      "emailEnabled": "boolean",
+      "smsEnabled": "boolean",
+      "eventTypes": ["array of event types to receive notifications for"]
+    },
+    "locationSharing": "boolean"
+  },
+  "verification": {
+    "isVerified": "boolean",
+    "verificationMethod": "enum: ['email', 'phone', 'manual']",
+    "verifiedAt": "Date: optional",
+    "verifiedBy": "ObjectId: optional"
+  },
+  "isActive": "boolean: default true",
+  "lastLogin": "Date: optional",
+  "loginAttempts": "number: failed login tracking",
+  "lockedUntil": "Date: optional account lock",
+  "createdAt": "Date: auto-generated",
+  "updatedAt": "Date: auto-generated"
+}
+```
+
+### 2.4 Dynamic EventType Data Structure
+```json
+{
+  "_id": "ObjectId",
+  "name": "string: unique per company, required",
+  "displayName": "string: user-friendly name",
+  "category": "string: flexible category (not enum)",
+  "subTypes": [{
+    "name": "string: subtype name",
+    "displayName": "string: user-friendly subtype name",
+    "isActive": "boolean: default true"
+  }],
+  "companyId": "ObjectId: optional, null for global types",
+  "isGlobal": "boolean: available to all companies",
+  "isPublic": "boolean: available for citizen reporters",
+  "isAutoGenerated": "boolean: created from mobile app submission",
+  "allowedRoles": ["array of roles that can use this type"],
+  "defaultSeverity": "enum: ['low', 'medium', 'high', 'critical', 'emergency']",
+  "defaultPriority": "number: 1-5",
+  "requiredFields": ["array of required field names"],
+  "customFields": [{
+    "name": "string",
+    "type": "enum: ['text', 'number', 'select', 'multiselect', 'boolean', 'date']",
+    "options": ["array: for select/multiselect"],
+    "required": "boolean",
+    "defaultValue": "any"
+  }],
+  "autoAssignmentRules": {
+    "byLocation": {
+      "enabled": "boolean",
+      "radiusKm": "number",
+      "assignToNearest": "boolean"
+    },
+    "bySpecialization": {
+      "enabled": "boolean",
+      "requiredSpecializations": ["array"]
+    },
+    "byWorkload": {
+      "enabled": "boolean",
+      "maxActiveEvents": "number"
+    }
+  },
+  "usage": {
+    "totalEvents": "number: count of events using this type",
+    "lastUsed": "Date",
+    "averageResolutionTime": "number: minutes"
+  },
+  "approvalStatus": "enum: ['pending', 'approved', 'rejected']",
+  "createdBy": "ObjectId: user who created/auto-generated",
+  "isActive": "boolean: default true",
+  "createdAt": "Date: auto-generated",
+  "updatedAt": "Date: auto-generated"
+}
+```
+
+### 2.5 First Responder Location Tracking
+```json
+{
+  "_id": "ObjectId",
+  "userId": "ObjectId: first responder user ID",
+  "companyId": "ObjectId: company association",
+  "location": {
+    "type": "Point",
+    "coordinates": "[longitude, latitude]"
+  },
+  "accuracy": "number: GPS accuracy in meters",
+  "speed": "number: m/s",
+  "heading": "number: degrees",
+  "altitude": "number: meters",
+  "battery": "number: device battery percentage",
+  "status": "enum: ['on_duty', 'available', 'busy', 'emergency']",
+  "eventId": "ObjectId: optional, if responding to specific event",
+  "timestamp": "Date: ping time",
+  "deviceInfo": {
+    "platform": "string: iOS/Android",
+    "appVersion": "string",
+    "deviceId": "string: unique device identifier"
+  }
+}
+```
+
+### 2.4 Camera Data Structure
+```json
+{
+  "_id": "ObjectId",
+  "name": "string: required",
+  "type": "enum: ['IP', 'VMS', 'IoT', 'Mobile']",
+  "streamUrl": "string: required",
+  "location": {
+    "latitude": "number: required",
+    "longitude": "number: required",
+    "address": "string: optional"
+  },
+  "status": "enum: ['active', 'inactive', 'maintenance']",
+  "capabilities": {
+    "hasAudio": "boolean",
+    "resolution": "string",
+    "nightVision": "boolean",
+    "ptzControl": "boolean"
+  },
+  "createdAt": "Date: auto-generated"
+}
+```
+
+---
+
+## 3. API SPECIFICATION & ENDPOINTS
+
+### 3.1 Authentication Endpoints
+```
+# Web Dashboard Authentication
+POST /api/auth/login              # Email/password login (operators, admins)
+POST /api/auth/logout             # Standard logout
+POST /api/auth/refresh            # Refresh JWT token
+GET  /api/auth/profile            # Get user profile
+PUT  /api/auth/profile            # Update user profile
+POST /api/auth/change-password    # Change password
+
+# Mobile App Authentication (Company-Specific)
+POST /api/mobile/auth/first-responder    # Phone + password for first responders
+POST /api/mobile/auth/citizen           # Citizen authentication
+POST /api/mobile/auth/anonymous         # Anonymous session with company context
+POST /api/mobile/auth/refresh           # Refresh mobile tokens
+
+# API Key Validation
+POST /api/auth/validate-api-key         # Validate API key and get company context
+GET  /api/auth/api-key-info             # Get API key usage and limits
+```
+
+### 3.2 Company Management Endpoints (New)
+```
+# Company Administration (Super Admin Only)
+GET    /api/companies                   # List all companies
+POST   /api/companies                   # Create new company
+GET    /api/companies/:id               # Get company details
+PUT    /api/companies/:id               # Update company
+DELETE /api/companies/:id               # Deactivate company
+POST   /api/companies/:id/api-key/rotate # Rotate API key
+GET    /api/companies/:id/usage         # Get API usage statistics
+
+# Company Self-Management (Company Admin)
+GET    /api/company/profile             # Get own company profile
+PUT    /api/company/profile             # Update own company profile
+GET    /api/company/users               # List company users
+POST   /api/company/users               # Create company user (first responder)
+PUT    /api/company/users/:id           # Update company user
+GET    /api/company/event-types         # Get company event types
+POST   /api/company/event-types         # Create company event type
+GET    /api/company/analytics           # Company-specific analytics
+```
+
+### 3.3 Enhanced Event Management Endpoints
+```
+# Standard Event Operations
+GET    /api/events                    # Get events with filters
+POST   /api/events                    # Create new event (with validation)
+GET    /api/events/:id                # Get specific event
+PUT    /api/events/:id                # Update event
+DELETE /api/events/:id                # Delete event
+POST   /api/events/:id/comments       # Add comment/note to event
+PUT    /api/events/:id/status         # Update event status
+POST   /api/events/:id/assign         # Assign event to user
+POST   /api/events/:id/escalate       # Escalate event
+GET    /api/events/:id/timeline       # Get event workflow timeline
+POST   /api/events/:id/attachments    # Upload media attachments
+GET    /api/events/:id/attachments    # Get event attachments
+POST   /api/events/:id/verify         # Verify/approve event
+
+# Mobile Event Operations  
+GET    /api/mobile/events/my          # User's submitted events
+POST   /api/mobile/events             # Citizen event reporting
+GET    /api/mobile/events/nearby      # Events near user location
+POST   /api/mobile/events/:id/follow  # Follow event updates
+```
+
+### 3.3 EventType Management Endpoints
+```
+GET    /api/event-types               # Get all event types
+POST   /api/event-types               # Create new event type (admin)
+GET    /api/event-types/:id           # Get specific event type
+PUT    /api/event-types/:id           # Update event type
+DELETE /api/event-types/:id           # Delete event type
+GET    /api/event-types/public        # Public event types for citizens
+GET    /api/event-types/hierarchy     # Get type hierarchy
+
+# Mobile EventType Operations
+GET    /api/mobile/event-types        # Public event types for mobile
+GET    /api/mobile/event-types/:id    # Get mobile-optimized type details
+```
+
+### 3.3 Real-time Communication Endpoints
+```
+WebSocket: /ws/events                 # Real-time event updates
+WebSocket: /ws/notifications          # User notifications
+WebSocket: /ws/video-stream/:cameraId # Live video stream
+```
+
+### 3.4 Media & File Management
+```
+POST /api/media/upload               # Upload files
+GET  /api/media/:id                  # Get file
+DELETE /api/media/:id                # Delete file
+POST /api/media/bulk-upload          # Bulk upload
+```
+
+### 3.5 Camera & Video Endpoints
+```
+GET /api/cameras                     # Get available cameras
+GET /api/cameras/:id                 # Get camera details
+GET /api/cameras/:id/stream          # Get live stream
+GET /api/cameras/:id/recordings      # Get historical recordings
+```
+
+---
+
+## 4. REAL-TIME COMMUNICATION PROTOCOLS
+
+### 4.1 WebSocket Event Types
+```javascript
+// Event Updates
+{
+  "type": "EVENT_CREATED",
+  "payload": {
+    "event": { /* enhanced event object */ },
+    "source": "mobile_app | web_dashboard | ai_system",
+    "requiresApproval": "boolean"
+  }
+}
+
+{
+  "type": "EVENT_UPDATED", 
+  "payload": { 
+    "eventId": "string",
+    "changes": { /* changed fields with old/new values */ },
+    "updatedBy": "ObjectId",
+    "timestamp": "Date"
+  }
+}
+
+{
+  "type": "EVENT_STATUS_CHANGED",
+  "payload": {
+    "eventId": "string",
+    "oldStatus": "string",
+    "newStatus": "string",
+    "changedBy": "ObjectId",
+    "workflowStep": "object",
+    "estimatedResolution": "Date: optional"
+  }
+}
+
+{
+  "type": "EVENT_ASSIGNED",
+  "payload": {
+    "eventId": "string",
+    "assignedTo": "ObjectId",
+    "assignedBy": "ObjectId",
+    "priority": "number",
+    "dueDate": "Date: optional"
+  }
+}
+
+{
+  "type": "EVENT_ESCALATED",
+  "payload": {
+    "eventId": "string",
+    "escalatedTo": "ObjectId",
+    "escalatedBy": "ObjectId",
+    "reason": "string",
+    "urgencyLevel": "string"
+  }
+}
+
+// Mobile-specific events
+{
+  "type": "MOBILE_EVENT_SUBMITTED",
+  "payload": {
+    "event": { /* event object */ },
+    "reporter": { /* reporter info */ },
+    "requiresVerification": "boolean",
+    "submissionMethod": "online | offline_sync"
+  }
+}
+
+// Notifications
+{
+  "type": "NOTIFICATION",
+  "payload": {
+    "severity": "enum: ['info', 'warning', 'error', 'critical', 'emergency']",
+    "message": "string",
+    "title": "string",
+    "eventId": "string: optional",
+    "actionRequired": "boolean",
+    "targetRoles": ["array of roles to notify"],
+    "channels": ["array: ['push', 'email', 'sms', 'dashboard']"],
+    "timestamp": "Date"
+  }
+}
+
+// AI Detection Events
+{
+  "type": "AI_DETECTION",
+  "payload": {
+    "detectionId": "string",
+    "cameraId": "string",
+    "confidence": "number",
+    "detectedObjects": ["array"],
+    "shouldCreateEvent": "boolean",
+    "suggestedEventType": "string"
+  }
+}
+```
+
+### 4.2 Connection Management
+- **Authentication**: JWT token required for WebSocket connections
+- **Reconnection Logic**: Implement exponential backoff
+- **Heartbeat**: Ping/pong every 30 seconds
+- **Message Queuing**: Store missed messages for offline users
+
+---
+
+## 5. DEVELOPMENT WORKFLOW RECOMMENDATIONS
+
+### 5.1 Phase 1: Foundation Setup (Week 1-2)
+**Both Teams:**
+1. Set up shared development environment and Git workflow
+2. Create and seed EventType collection with initial types
+3. Implement enhanced User model with multiple auth methods
+4. Set up enhanced Event model with validation
+5. Create API documentation with Swagger/OpenAPI
+6. Establish CI/CD pipeline with mobile integration
+7. Set up shared testing database with realistic seed data
+
+**Web Team Focus:**
+- Backend API structure with mobile endpoints (`/api/mobile/*`)
+- EventType management system and admin interface
+- Enhanced authentication middleware (JWT + phone verification)
+- Database migrations for new schema
+- Event validation system with custom rules
+- WebSocket infrastructure for real-time updates
+
+**Mobile Team Focus:**
+- Project setup with offline-first architecture
+- API client with retry logic and offline queuing
+- Phone-based authentication flow implementation
+- Anonymous reporting capability
+- Location services integration with permissions
+- Media upload with compression and validation
+- Push notification setup
+
+**Shared Deliverables:**
+- EventType seeded database with public/private types
+- Authentication working for both web and mobile
+- Basic event CRUD operations
+- Location-based event filtering
+- File upload/download functionality
+
+### 5.2 Phase 2: Core Event Management (Week 3-4)
+**Both Teams:**
+1. Implement enhanced event CRUD operations with validation
+2. Set up real-time communication with mobile support
+3. Event status management and workflow system
+4. Basic event filtering and search functionality
+5. Media handling with mobile optimization
+
+**Web Team Focus:**
+- Event assignment and escalation system
+- Admin interface for EventType management
+- Operator dashboard with real-time updates
+- Event verification and approval workflow
+- Advanced filtering and search capabilities
+- User management with role-based permissions
+
+**Mobile Team Focus:**
+- Citizen event reporting with step-by-step wizard
+- Photo/video capture with automatic compression
+- GPS location integration with manual override
+- Offline event storage and sync
+- Push notifications for event status updates
+- "My Events" tracking and follow-up
+- Anonymous reporting with session management
+
+**Shared Responsibilities:**
+- Mobile-optimized API responses
+- Real-time event updates via WebSocket
+- File upload progress tracking
+- Location-based event discovery
+- Cross-platform data synchronization testing
+
+**Integration Points:**
+- Mobile event submission â†’ Web operator review
+- Real-time notifications web â†” mobile
+- Shared event status workflow
+- Consistent media handling and storage
+
+### 5.3 Phase 3: Advanced Features (Week 5-6)
+**Web Team:**
+- Comprehensive dashboard with analytics and KPIs
+- Video streaming integration with event correlation
+- Interactive map visualization with event clustering
+- Admin panel with system configuration
+- Advanced reporting and export functionality
+- Event analytics and trend analysis
+- Automated event assignment based on location/type
+- Integration with external emergency services (CAD systems)
+
+**Mobile Team:**
+- Enhanced event reporting with context-aware suggestions
+- Location-based event discovery and nearby incidents
+- Push notification management and preferences
+- Social features (event following, community reporting)
+- Offline capability with intelligent sync strategies
+- Biometric authentication (Face ID, Touch ID)
+- AR-based incident reporting and visualization
+- Community verification and crowdsourced validation
+
+**Shared Advanced Features:**
+- AI-powered event classification suggestions
+- Automated duplicate event detection
+- Smart notification routing based on user preferences
+- Advanced search with natural language processing
+- Event impact assessment and priority scoring
+- Integration with IoT sensors and external data sources
+
+### 5.4 Phase 4: Integration & Testing (Week 7-8)
+**Both Teams:**
+- End-to-end testing
+- Performance optimization
+- Real-time synchronization testing
+- User acceptance testing
+
+---
+
+## 6. COMMUNICATION PROTOCOLS
+
+### 6.1 Daily Coordination
+- **Daily Standup**: Joint 15-min meeting at 9:00 AM
+- **API Changes**: 24-hour notice before breaking changes
+- **Database Migrations**: Coordinate before deployment
+- **Shared Documentation**: Update API docs immediately after changes
+
+### 6.2 Code Review Process
+1. **Cross-team Reviews**: Each team reviews API changes from the other
+2. **Breaking Changes**: Require approval from both team leads
+3. **Documentation**: Update API docs with every PR
+4. **Testing**: Include integration tests for shared endpoints
+
+### 6.3 Issue Tracking
+- **Shared Project Board**: Use GitHub Projects or Jira
+- **Label System**:
+  - `api-change`: API modifications
+  - `breaking-change`: Breaking changes
+  - `mobile-impact`: Changes affecting mobile
+  - `web-impact`: Changes affecting web
+  - `real-time`: Real-time communication issues
+
+---
+
+## 7. DATA VALIDATION & CONSTRAINTS
+
+### 7.1 Event Validation Rules
+```javascript
+const eventValidation = {
+  title: {
+    required: true,
+    minLength: 3,
+    maxLength: 200,
+    pattern: /^[a-zA-Z0-9\s\-_.!?]+$/
+  },
+  description: {
+    maxLength: 2000,
+    sanitize: true // Remove harmful HTML/scripts
+  },
+  type: {
+    required: true,
+    enum: ['security_incident', 'traffic_violation', 'emergency', 'maintenance_needed', 'user_report', 'system_alert', 'motion_detected', 'person_detected', 'vehicle_detected', 'unauthorized_access', 'suspicious_activity', 'other']
+  },
+  severity: {
+    required: true,
+    enum: ['low', 'medium', 'high', 'critical', 'emergency']
+  },
+  priority: {
+    required: true,
+    min: 1,
+    max: 5,
+    default: 3
+  },
+  location: {
+    coordinates: {
+      required: true,
+      validate: {
+        longitude: { min: -180, max: 180 },
+        latitude: { min: -90, max: 90 }
+      }
+    },
+    accuracy: {
+      min: 0,
+      max: 10000 // Maximum 10km accuracy
+    },
+    address: {
+      maxLength: 500
+    }
+  },
+  reporter: {
+    isAnonymous: {
+      type: "boolean",
+      default: false
+    },
+    name: {
+      maxLength: 100,
+      required: function() { return this.isAnonymous; }
+    },
+    email: {
+      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
+      required: false
+    },
+    phone: {
+      pattern: /^\+?[1-9]\d{1,14}$/,
+      required: false
+    }
+  },
+  media: {
+    images: {
+      maxFiles: 10,
+      maxFileSize: "5MB",
+      allowedTypes: ["image/jpeg", "image/png", "image/webp"]
+    },
+    videos: {
+      maxFiles: 5,
+      maxFileSize: "50MB",
+      allowedTypes: ["video/mp4", "video/webm", "video/quicktime"]
+    },
+    attachments: {
+      maxFiles: 15,
+      maxFileSize: "10MB",
+      allowedTypes: ["application/pdf", "text/plain", "application/msword"]
+    }
+  },
+  tags: {
+    maxItems: 10,
+    itemMaxLength: 50,
+    pattern: /^[a-zA-Z0-9_-]+$/
+  },
+  customFields: {
+    maxFields: 20,
+    keyMaxLength: 50,
+    valueMaxLength: 1000
+  },
+  // Mobile-specific validation
+  mobileSubmission: {
+    networkType: {
+      enum: ['wifi', 'cellular', 'unknown']
+    },
+    submittedOffline: {
+      type: "boolean",
+      default: false
+    }
+  }
+}
+```
+
+### 7.2 Error Handling Standards
+```javascript
+// Standard Error Response Format
+{
+  "success": false,
+  "error": {
+    "code": "ERROR_CODE",
+    "message": "Human-readable error message",
+    "details": {
+      "field": "fieldName",
+      "issue": "Specific validation issue",
+      "value": "Invalid value provided"
+    },
+    "suggestions": ["Array of suggested fixes"]
+  },
+  "timestamp": "2025-12-22T10:00:00Z",
+  // Mobile-specific fields
+  "retryable": "boolean: whether operation can be retried",
+  "offlineSupported": "boolean: whether action can be queued offline"
+}
+
+// Common Error Codes
+const ErrorCodes = {
+  // Validation Errors
+  VALIDATION_ERROR: "Validation failed",
+  INVALID_EVENT_TYPE: "Event type not allowed for user role",
+  LOCATION_REQUIRED: "Location is required for this event type",
+  MEDIA_TOO_LARGE: "Uploaded file exceeds size limit",
+  INVALID_COORDINATES: "GPS coordinates are invalid",
+  
+  // Authentication Errors
+  AUTH_REQUIRED: "Authentication required",
+  INVALID_TOKEN: "Invalid or expired token",
+  PHONE_VERIFICATION_FAILED: "Phone verification failed",
+  ANONYMOUS_NOT_ALLOWED: "Anonymous reporting not allowed for this event type",
+  
+  // Permission Errors
+  INSUFFICIENT_PERMISSIONS: "Insufficient permissions for this operation",
+  EVENT_TYPE_NOT_PUBLIC: "Event type not available for public reporting",
+  ROLE_RESTRICTED: "Action restricted to specific roles",
+  
+  // Resource Errors
+  EVENT_NOT_FOUND: "Event not found",
+  USER_NOT_FOUND: "User not found",
+  CAMERA_OFFLINE: "Camera is currently offline",
+  
+  // System Errors
+  DATABASE_ERROR: "Database operation failed",
+  EXTERNAL_SERVICE_ERROR: "External service unavailable",
+  FILE_UPLOAD_ERROR: "File upload failed",
+  
+  // Mobile-specific Errors
+  OFFLINE_SYNC_FAILED: "Failed to sync offline data",
+  LOCATION_PERMISSION_DENIED: "Location access denied",
+  NETWORK_ERROR: "Network connection error",
+  APP_VERSION_OUTDATED: "App version no longer supported"
+}
+```
+
+---
+
+## 8. TESTING STRATEGIES
+
+### 8.1 Integration Testing
+- **API Testing**: Shared Postman collection
+- **Real-time Testing**: WebSocket connection tests
+- **Database Testing**: Shared test database
+- **End-to-end Testing**: User journey tests
+
+### 8.2 Mock Data Standards
+```javascript
+// Shared test data structure
+const mockEventTypes = {
+  publicSecurity: {
+    _id: "eventtype_001",
+    name: "Public Safety Incident",
+    category: "security",
+    isPublic: true,
+    allowedRoles: ["citizen", "operator", "admin"],
+    defaultSeverity: "medium",
+    requiredFields: ["title", "location"]
+  },
+  emergency: {
+    _id: "eventtype_002", 
+    name: "Emergency Situation",
+    category: "emergency",
+    isPublic: true,
+    allowedRoles: ["citizen", "operator", "admin"],
+    defaultSeverity: "critical",
+    requiredFields: ["title", "location", "description"]
+  },
+  maintenance: {
+    _id: "eventtype_003",
+    name: "Infrastructure Issue",
+    category: "maintenance", 
+    isPublic: true,
+    allowedRoles: ["citizen", "operator"],
+    defaultSeverity: "low",
+    requiredFields: ["title", "location"]
+  }
+};
+
+const mockEvents = {
+  citizenReport: {
+    title: "Broken Street Light",
+    type: "maintenance_needed",
+    severity: "low",
+    priority: 3,
+    status: "pending",
+    location: {
+      type: "Point",
+      coordinates: [34.7818, 32.0853], // [lng, lat]
+      address: "Main Street, Tel Aviv"
+    },
+    reporter: {
+      isAnonymous: true,
+      name: "Anonymous Citizen",
+      email: "citizen@example.com"
+    },
+    source: "mobile_app",
+    publiclyVisible: true
+  },
+  emergencyAlert: {
+    title: "Medical Emergency",
+    type: "emergency",
+    severity: "critical",
+    priority: 1,
+    status: "acknowledged",
+    location: {
+      type: "Point", 
+      coordinates: [34.7818, 32.0853]
+    },
+    reporter: {
+      userId: "user_001",
+      isAnonymous: false
+    },
+    source: "mobile_app",
+    requiresApproval: false
+  },
+  aiDetection: {
+    title: "Suspicious Activity Detected",
+    type: "suspicious_activity",
+    severity: "medium",
+    priority: 2,
+    cameraId: "camera_001",
+    detectionData: {
+      confidence: 0.85,
+      aiModel: "YOLOv8",
+      detectedObjects: ["person", "bag"]
+    },
+    source: "ai_detection",
+    verified: false
+  }
+};
+
+const mockUsers = {
+  citizen: {
+    username: "citizen_user",
+    email: "citizen@example.com",
+    role: "citizen",
+    authMethod: "phone_otp",
+    phone: "+1234567890",
+    verification: { isVerified: true },
+    mobileSettings: {
+      deviceTokens: ["token_123"],
+      notificationPreferences: {
+        pushEnabled: true,
+        eventTypes: ["emergency", "security_incident"]
+      }
+    }
+  },
+  operator: {
+    username: "operator_1",
+    email: "operator@example.com",
+    role: "operator",
+    authMethod: "email_password",
+    permissions: {
+      inherited: ["view_events", "update_events", "assign_events"]
+    }
+  }
+};
+```
+
+---
+
+## 16. MOBILE-SPECIFIC CONSIDERATIONS
+
+### 16.1 Mobile App Architecture Requirements
+- **Offline-First Design**: All critical functions must work offline
+- **Progressive Sync**: Intelligent data synchronization when connection available
+- **Battery Optimization**: Efficient location tracking and background processing
+- **Storage Management**: Local SQLite for offline data with cleanup policies
+- **Network Awareness**: Adapt behavior based on connection quality
+
+### 16.2 Mobile API Optimizations
+```javascript
+// Mobile-optimized response format
+{
+  "success": true,
+  "data": {
+    "events": [/* condensed event objects */],
+    "pagination": {
+      "hasMore": true,
+      "nextCursor": "cursor_token"
+    }
+  },
+  "meta": {
+    "serverTime": "2025-12-22T10:00:00Z",
+    "version": "1.2.0",
+    "cacheExpiry": 300 // seconds
+  },
+  "offline": {
+    "supportedActions": ["create_event", "upload_media"],
+    "syncRequired": false
+  }
+}
+```
+
+### 16.3 Location Services Integration
+```javascript
+// Location data structure for mobile
+const locationData = {
+  coordinates: [longitude, latitude],
+  accuracy: 5.0, // meters
+  altitude: 100.5,
+  altitudeAccuracy: 10.0,
+  heading: 45.0, // degrees
+  speed: 2.5, // m/s
+  timestamp: "2025-12-22T10:00:00Z",
+  source: "gps | network | passive",
+  address: {
+    street: "123 Main Street",
+    city: "Tel Aviv",
+    region: "Tel Aviv District", 
+    country: "Israel",
+    postalCode: "12345"
+  }
+};
+```
+
+### 16.4 Push Notification Strategy
+```javascript
+// Push notification payload structure
+{
+  "notification": {
+    "title": "Event Update",
+    "body": "Your reported incident has been acknowledged",
+    "badge": 3,
+    "sound": "default",
+    "icon": "notification_icon"
+  },
+  "data": {
+    "eventId": "event_123",
+    "type": "status_update",
+    "action": "open_event",
+    "priority": "medium",
+    "timestamp": "2025-12-22T10:00:00Z"
+  },
+  "target": {
+    "userIds": ["user_123"],
+    "roles": ["citizen"],
+    "location": {
+      "radius": 1000, // meters
+      "center": [34.7818, 32.0853]
+    }
+  }
+}
+```
+
+### 16.5 Media Upload Optimization
+- **Client-side Compression**: Reduce file sizes before upload
+- **Progressive Upload**: Resume interrupted uploads
+- **Thumbnail Generation**: Create thumbnails for faster loading
+- **Format Conversion**: Standardize media formats
+- **Background Upload**: Continue uploads when app is backgrounded
+
+### 16.6 Security Considerations for Mobile
+- **Certificate Pinning**: Prevent man-in-the-middle attacks
+- **Biometric Authentication**: Face ID, Touch ID, fingerprint
+- **Secure Storage**: Encrypt sensitive data in local storage
+- **App Transport Security**: Enforce HTTPS connections
+- **Jailbreak/Root Detection**: Enhanced security for compromised devices
+
+---
+
+## 17. BACKWARD COMPATIBILITY
+
+### 17.1 Legacy API Support
+Maintain backward compatibility for existing integrations:
+```javascript
+// Legacy event type mapping
+const legacyTypeMapping = {
+  "motion": "motion_detected",
+  "face": "person_detected", 
+  "lpr": "vehicle_detected",
+  "object": "suspicious_activity",
+  "manual": "user_report",
+  "geofence": "security_incident",
+  "emergency": "emergency"
+};
+
+// API versioning strategy
+// v1: /api/events (legacy)
+// v2: /api/v2/events (enhanced)
+// Mobile: /api/mobile/events (mobile-optimized)
+```
+
+### 17.2 Database Migration Strategy
+1. **Gradual Migration**: Migrate data in batches during off-peak hours
+2. **Dual Write**: Write to both old and new schemas during transition
+3. **Validation**: Verify data integrity after migration
+4. **Rollback Plan**: Ability to revert to previous schema if needed
+
+---
+
+## 9. DEPLOYMENT & ENVIRONMENT MANAGEMENT
+
+### 9.1 Environment Strategy
+- **Development**: Shared staging server
+- **Testing**: Isolated testing environment 
+- **Production**: Coordinated deployment schedule
+
+### 9.2 Environment Configuration
+```yaml
+# Shared environment variables
+DATABASE_URL: "mongodb://localhost:27017/shob_web"
+JWT_SECRET: "shared_secret_key"
+WEBSOCKET_PORT: 3001
+API_BASE_URL: "http://localhost:3000/api"
+MEDIA_UPLOAD_PATH: "/uploads"
+MAX_FILE_SIZE: "10MB"
+```
+
+---
+
+## 10. SECURITY CONSIDERATIONS
+
+### 10.1 Authentication & Authorization
+- **JWT Tokens**: 24-hour expiration with refresh tokens
+- **Role-Based Access**: Consistent permission checking
+- **API Rate Limiting**: Prevent abuse
+- **File Upload Security**: Virus scanning and type validation
+
+### 10.2 Data Security
+- **Input Sanitization**: XSS and SQL injection prevention
+- **HTTPS Only**: All communication encrypted
+- **Media Security**: Secure file storage with access controls
+- **Audit Logging**: Track all data modifications
+
+---
+
+## 11. PERFORMANCE OPTIMIZATION
+
+### 11.1 Database Optimization
+```javascript
+// Recommended indexes
+db.events.createIndex({ "location": "2dsphere" })
+db.events.createIndex({ "createdAt": -1 })
+db.events.createIndex({ "status": 1, "severity": -1 })
+db.events.createIndex({ "assignedTo": 1 })
+```
+
+### 11.2 Real-time Performance
+- **Connection Pooling**: Limit WebSocket connections
+- **Message Throttling**: Rate limit real-time updates
+- **Data Pagination**: Limit API response sizes
+- **Caching Strategy**: Redis for frequently accessed data
+
+---
+
+## 12. MONITORING & LOGGING
+
+### 12.1 Application Monitoring
+- **API Response Times**: Track endpoint performance
+- **Error Rates**: Monitor and alert on failures
+- **WebSocket Health**: Connection stability metrics
+- **Database Performance**: Query execution times
+
+### 12.2 Business Metrics
+- **Event Creation Rate**: Monitor system usage
+- **Response Times**: Track operator efficiency
+- **User Activity**: Monitor engagement patterns
+
+---
+
+## 13. EMERGENCY PROCEDURES
+
+### 13.1 Critical Issues Response
+1. **Immediate Communication**: Slack/Teams emergency channel
+2. **Rollback Procedures**: Automated rollback capability
+3. **Data Recovery**: Backup and restore procedures
+4. **Escalation Path**: Clear responsibility hierarchy
+
+### 13.2 System Maintenance
+- **Maintenance Windows**: Coordinated downtime
+- **Database Updates**: Staged migration process
+- **API Versioning**: Backward compatibility strategy
+
+---
+
+## 14. SUCCESS METRICS & MILESTONES
+
+### 14.1 Technical Milestones
+- [ ] Authentication system integration complete
+- [ ] Real-time event synchronization working
+- [ ] File upload/download functioning
+- [ ] WebSocket stability achieved (99% uptime)
+- [ ] API response times under 200ms
+
+### 14.2 User Experience Metrics
+- [ ] Event creation time under 30 seconds (mobile and web)
+- [ ] Real-time updates delivered within 2 seconds
+- [ ] Cross-platform data consistency achieved
+- [ ] Zero data loss during offline/online synchronization
+- [ ] Mobile app supports offline event reporting
+- [ ] Anonymous reporting working seamlessly
+- [ ] Push notifications delivered within 5 seconds
+- [ ] Photo/video upload completes in under 60 seconds
+- [ ] Location accuracy within 10 meters for mobile reports
+
+---
+
+## 15. NEXT STEPS & ACTION ITEMS
+
+### Immediate Actions (This Week)
+1. **Both Teams**: Review and approve updated protocol document
+2. **Web Team**: Implement EventType management system
+3. **Mobile Team**: Set up offline-first architecture foundation
+4. **Both Teams**: Create mobile-optimized API endpoints (`/api/mobile/*`)
+5. **Both Teams**: Set up enhanced shared communication channels
+6. **Web Team**: Implement phone-based authentication backend
+7. **Mobile Team**: Implement anonymous reporting capability
+
+### Week 1 Goals
+1. Complete EventType system integration
+2. Implement enhanced event CRUD with validation
+3. Set up mobile authentication (phone + anonymous)
+4. Establish real-time communication with mobile support
+5. Create mobile-optimized testing procedures
+
+### Week 2 Goals  
+1. Mobile event submission with media upload
+2. Offline event storage and sync
+3. Push notification infrastructure
+4. Location-based event discovery
+5. Cross-platform integration testing
+
+### Communication Schedule
+- **Monday**: Joint planning meeting (1 hour) + mobile-specific sync (30 min)
+- **Wednesday**: Technical sync meeting (45 minutes) + API review
+- **Friday**: Progress review and integration testing (45 minutes)
+- **Daily**: Quick standups via shared Slack channel
+- **Ad-hoc**: Emergency communication and blocker resolution
+
+### Code Review Requirements
+- **Mobile API Changes**: Must be reviewed by mobile team lead
+- **Database Schema Changes**: Must be approved by both teams
+- **Authentication Changes**: Cross-platform testing required
+- **Real-time Features**: Performance testing on mobile devices
+
+---
+
+**Document Version**: 2.0  
+**Last Updated**: December 22, 2025  
+**Updated for**: Enhanced Event Model, Mobile Integration, EventType System  
+**Next Review**: Weekly during development, with mobile-specific reviews bi-weekly
+
+This protocol has been updated to reflect your current implementation with enhanced data models, mobile citizen reporting, and flexible authentication. The document now includes specific mobile considerations and maintains backward compatibility with your existing system.
\ No newline at end of file
